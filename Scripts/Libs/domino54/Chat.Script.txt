// -------------------------------------- //
//  LIBRARY CHAT by domino54              //
//  script version: 2017-11-26            //
// -------------------------------------- //

/**
 *	Replace default chat with a custom one. Allows to send commands
 *	directly to the game mode script. Automatically formats links
 *	and allows to send longer messages.
 */

#Const Version		"2017-11-26"
#Const ScriptName	"Libs/domino54/Chat.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/domino54/Bindings.Script.txt" as Bindings
#Include "Libs/domino54/MultiClans.Script.txt" as Clans
#Include "Libs/domino54/ServerManager.Script.txt" as ServerManager
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_LibChat_InterfaceLayerId	"LibChat:Chat"
#Const C_LibChat_MessageMaxLength	64		///< Max. characters in one message before it's split.
#Const C_LibChat_MaxNbMessagesSmall	7		///< Max. messages shown at one in small chat.
#Const C_LibChat_MaxNbMessagesLarge	32		///< Max. messages shown at one in large chat.
#Const C_LibChat_MaxCachedCommands	10		///< Amount of cached chat commands.
#Const C_LibChat_ChatTextSize		1.5		///< Size of the chat message text.
#Const C_LibChat_ChatLineHeight		4.		///< Height of the chat line.

// Messages formatting
#Const C_LibChat_MessageFormat_Error	"$F00%1"
#Const C_LibChat_MessageFormat_Global	"$FF0[$<%1$>] %2"
#Const C_LibChat_MessageFormat_Global2	"$FF0%2"
#Const C_LibChat_MessageFormat_Team		"$FF0<$<%1$>> %2"
#Const C_LibChat_MessageFormat_MeCmd	"$6BF$<%1$> %2"
#Const C_LibChat_MessageFormat_Incoming	"$6BF[➘ $<%1$>] %2"
#Const C_LibChat_MessageFormat_Outgoing	"$6BF[➚ $<%1$>] %2"

// Premade quick chat messages
#Const C_LibChat_PremadeMessages [
	"hi" => "Hello", "bb" => "Bye", "re" => "Returned", "wb" => "Welcome back",
	"afk" => "Away from keyboard", "gtg" => "Got to go", "brb" => "Be right back",
	"gg" => "Good game", "gga" => "Good game all", "gj" => "Good job",
	"n1" => "Nice one", "ns" => "Nice shoot", "nt" => "Nice time", "ty" => "Thank you",
	"gl" => "Good luck", "hf" => "Have fun", "glhf" => "Goold luck and have fun",
	"wp" => "Well played", "ggwp" => "Good game, well played",
	"gr8" => "Great", "w8" => "Wait", "lol" => "Loo0ool", "lool" => "Looo00oool",
	"gu" => "Guerried", "grt" => "Guerritos", "flo" => "Florenziusted",
	"nu" => "Nurpsen", "owz" => "Owzom", "wow" => "WOOW"
]
#Const C_LibChat_PremadeWithRecipient [
	"hi", "bb", "wb", "flo", "gg", "gj", "n1", "ns", "nt", "ty", "lol", "lool",
	"gl", "hf", "glhf", "wp", "ggwp", "gu", "gr8", "w8", "owz", "wow"
]

// Badwords to filter
#Const C_LibChat_ForbiddenWords [
	"fuck", "shit", "bitch", "slut", "twat", "prick", "sucker", "cock", "whore", "faggot", "asshole", "dick",
	"merde", "putain", "salope", "kurw", "kurv" 
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Text G_LibChat_InterfaceFont;
declare Integer G_LibChat_LastCommandId;
declare Integer[] G_LibChat_PendingCommands;
declare Text[Integer] G_LibChat_CommandSender;
declare Text[Integer] G_LibChat_CommandName;
declare Text[][Integer] G_LibChat_CommandParams;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for the chat library.
 *
 *	@return		The chat manialink.
 */
Text Private_CreateManialinkChat() {
	declare ChatMessagesLabels = "";
	for (I, 0, C_LibChat_MaxNbMessagesLarge+1)
		ChatMessagesLabels ^= "<label pos='0 "^I*C_LibChat_ChatLineHeight^"' size='140' class='Message' id='Label_ChatMessage#"^I^"' />";

	declare Font = TL::MLEncode(G_LibChat_InterfaceFont);
	return """
<manialink version="3" name="{{{C_LibChat_InterfaceLayerId}}}">
<stylesheet>
	<style class="Message" valign="center2" textsize="{{{C_LibChat_ChatTextSize}}}" textemboss="1" textcolor="FFF" textfont="{{{Font}}}" />
	<style id="Entry_ChatInput" valign="center2" textsize="{{{C_LibChat_ChatTextSize}}}" textemboss="1" textcolor="FFF" textfont="{{{Font}}}" />
	<style id="Label_ChatKeyHint" style="TextButtonNav" valign="center2" textsize=".375" textcolor="FFF" opacity=".5" />
</stylesheet>

<frame id="Frame_ChatWindow" pos="-160 -90" z-index="10">
	<frame pos="1 {{{C_LibChat_ChatLineHeight*2-1.5}}}">
		<frame id="Frame_LabelsAnim">{{{ChatMessagesLabels}}}</frame>
	</frame>
	<frame pos="1 {{{C_LibChat_ChatLineHeight/2+.5}}}" z-index="1">
		<entry size="100 {{{C_LibChat_ChatLineHeight-.5}}}" focusareacolor1="0004" focusareacolor2="0007" id="Entry_ChatInput" ScriptEvents="1" hidden="1" />
		<label id="Label_ChatKeyHint" textfont="Eurostile_Bold" />
	</frame>
</frame>
<script><!--
/**
 *	{{{C_LibChat_InterfaceLayerId}}}
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ChatWindow <=> (Page.GetFirstChild("Frame_ChatWindow") as CMlFrame);
declare Frame_LabelsAnim <=> (Page.GetFirstChild("Frame_LabelsAnim") as CMlFrame);
declare Entry_ChatInput <=> (Page.GetFirstChild("Entry_ChatInput") as CMlEntry);
declare Label_ChatKeyHint <=> (Page.GetFirstChild("Label_ChatKeyHint") as CMlLabel);

declare CMlLabel[] Label_ChatMessages;
for (I, 0, {{{C_LibChat_MaxNbMessagesLarge+1}}})
	Label_ChatMessages.add((Page.GetFirstChild("Label_ChatMessage#"^I) as CMlLabel));

// ---------------------------------- //
// Persistent settings
declare persistent Text[] Persistent_LibServerManager_PrivateMutedUsers for LocalUser;
declare persistent Integer Persistent_LibServerManager_PrivateMuteUpdate for LocalUser;

// ---------------------------------- //
// Net variables
declare netread Boolean Net_LibChat_UseCustomChat for Teams[0];
declare netread Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
declare netread Text[Integer] Net_LibChat_GlobalChatSenders for Teams[0];
declare netread Text[Integer] Net_LibChat_UserChatMessages for InputPlayer;
declare netread Text[Integer] Net_LibChat_UserChatSenders for InputPlayer;
declare netread Integer Net_LibChat_GlobalLastMessage for Teams[0];
declare netread Integer Net_LibChat_UserLastMessage for InputPlayer;

// ---------------------------------- //
// Variables
declare UpdateMessagesList = True;
declare MaxNbMessagesDisplayed = 7;
declare SlideNewMessage = False;
declare IsFirstLaunch = True;
declare UpdateTooltip = True;
declare PrevMessageKey = -1;
declare FormatLabels = True;

// Update
declare PrevGlobalLastMessage = -1;
declare PrevUserLastMessage = -1;
declare PrevMaxNbMessagesDisplayed = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
Frame_ChatWindow.Visible = Net_LibChat_UseCustomChat;
ClientUI.OverlayHideChat = Frame_ChatWindow.Visible;

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Entry submit
	if (Event.Type == CMlEvent::Type::EntrySubmit) {
		if (Event.Control == Entry_ChatInput) {
			Entry_ChatInput.Hide();
			SendCustomEvent("LibChat_MessageSent", [Entry_ChatInput.Value]);
			Entry_ChatInput.Value = "";
		}
	}
}

// ---------------------------------- //
// Start typing a message
if (Bindings_Listener("LibChat_BeginTyping", "T")) {
	Entry_ChatInput.Visible = True;
	Entry_ChatInput.StartEdition();
	UpdateTooltip = True;
}

// ---------------------------------- //
// Start typing a team message
if (Bindings_Listener("LibChat_TeamMessage", "Y")) {
	Entry_ChatInput.Visible = True;
	Entry_ChatInput.Value = "/t ";
	Entry_ChatInput.StartEdition();
}

// ---------------------------------- //
// Toggle expand chat
if (Bindings_Listener("LibChat_ToggleChat", "C")) {
	if (MaxNbMessagesDisplayed == {{{C_LibChat_MaxNbMessagesSmall}}}) MaxNbMessagesDisplayed = {{{C_LibChat_MaxNbMessagesLarge}}};
	else MaxNbMessagesDisplayed = {{{C_LibChat_MaxNbMessagesSmall}}};
}

Label_ChatKeyHint.Visible = !Entry_ChatInput.Visible;

// ---------------------------------- //
// Update messages on global messages update
if (PrevGlobalLastMessage != Net_LibChat_GlobalLastMessage) {
	PrevGlobalLastMessage = Net_LibChat_GlobalLastMessage;
	UpdateMessagesList = True;
}

// ---------------------------------- //
// Update messages on local user update
if (PrevUserLastMessage != Net_LibChat_UserLastMessage) {
	PrevUserLastMessage = Net_LibChat_UserLastMessage;
	UpdateMessagesList = True;
}

// ---------------------------------- //
// Update messages on chat height change
if (PrevMaxNbMessagesDisplayed != MaxNbMessagesDisplayed) {
	PrevMaxNbMessagesDisplayed = MaxNbMessagesDisplayed;
	UpdateMessagesList = True;
}

// ---------------------------------- //
// Update the chat messages list
if (UpdateMessagesList) {
	UpdateMessagesList = False;

	// ---------------------------------- //
	// Get messages to display
	declare Text[] DisplayedChatMessages;
	declare Text[Integer] ChatMessages;
	declare MessageKey = PrevMessageKey;

	foreach (Key => Message in Net_LibChat_GlobalChatMessages) ChatMessages[Key] = Message;
	foreach (Key => Message in Net_LibChat_UserChatMessages) ChatMessages[Key] = Message;
	ChatMessages = ChatMessages.sortkey();

	foreach (Key => Message in ChatMessages) {
		declare MessageSender = "";
		if (Net_LibChat_GlobalChatSenders.existskey(Key)) MessageSender = Net_LibChat_GlobalChatSenders[Key];
		else if (Net_LibChat_UserChatSenders.existskey(Key)) MessageSender = Net_LibChat_UserChatSenders[Key];
		if (MessageSender != "" && Persistent_LibServerManager_PrivateMutedUsers.exists(MessageSender)) continue;

		DisplayedChatMessages.add(Message);
		MessageKey = Key;
	}

	// Trigger animation for new messages
	if (PrevMessageKey != MessageKey) {
		PrevMessageKey = MessageKey;
		if (!IsFirstLaunch) SlideNewMessage = True;
	}

	// ---------------------------------- //
	// Format labels
	foreach (I => Label in Label_ChatMessages) {
		declare MessageId = DisplayedChatMessages.count - I - 1;
		if (DisplayedChatMessages.existskey(MessageId)) Label.Value = DisplayedChatMessages[MessageId];

		if (I <= MaxNbMessagesDisplayed) {
			Label.Visible = True;
			Label.Opacity = 1.;
		}

		// ---------------------------------- //
		// Do new message animation
		if (SlideNewMessage) {
			if (I == 0) {
				Label.Opacity = .125;
				Frame_LabelsAnim.RelativePosition_V3.Y -= {{{C_LibChat_ChatLineHeight}}};

				AnimMgr.Add(Label, "<label opacity='1' />", 250, CAnimManager::EAnimManagerEasing::SineOut);
				AnimMgr.Add(Frame_LabelsAnim, "<frame pos='0 0' />", 250, CAnimManager::EAnimManagerEasing::SineOut);
			}

			if (I == MaxNbMessagesDisplayed) {
				Label.Opacity = 1.;
				AnimMgr.Add(Label, "<label opacity='0' />", 125, CAnimManager::EAnimManagerEasing::Linear);
			}
		}
	}

	SlideNewMessage = False;
	IsFirstLaunch = False;
}

// Update tooltip text
if (UpdateTooltip) {
	UpdateTooltip = False;
	Label_ChatKeyHint.Value = Translate(["Press '%1' to chat", Bindings_GetKey("LibChat_BeginTyping", "T")]);
}

// ---------------------------------- //
// Hide transparent messages
foreach (I => Label in Label_ChatMessages) {
	if (!Label.Visible) continue;
	if (Label.Opacity <= 0) Label.Visible = False;
	if (I > MaxNbMessagesDisplayed) Label.Visible = False;
}
***

{{{Translations::InjectInManialink(["Press '%1' to chat"])}}}
{{{Bindings::Functions()}}}

main() {
	wait(InputPlayer != Null);
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void Private_SendMessage(Text _Message, CPlayer _Sender) {
	if (_Message == "") return;
	declare netwrite Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
	declare netwrite Text[Integer] Net_LibChat_GlobalChatSenders for Teams[0];
	declare netwrite Integer Net_LibChat_GlobalLastMessage for Teams[0];
	Net_LibChat_GlobalLastMessage = Now;
	
	declare Key = Now;
	while (Net_LibChat_GlobalChatMessages.existskey(Key)) Key += 1;
	Net_LibChat_GlobalChatMessages[Key] = _Message;

	if (_Sender != Null)
		Net_LibChat_GlobalChatSenders[Key] = _Sender.User.Login;
	else
		Net_LibChat_GlobalChatSenders[Key] = "";
	
	while (Net_LibChat_GlobalChatMessages.count > C_LibChat_MaxNbMessagesLarge+1) {
		declare KeyToRemove = 0;
		foreach (Key => Message in Net_LibChat_GlobalChatMessages) { KeyToRemove = Key; break; }

		declare Boolean Removed;
		Removed = Net_LibChat_GlobalChatMessages.removekey(KeyToRemove);
		Removed = Net_LibChat_GlobalChatSenders.removekey(KeyToRemove);
	}
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void Private_SendMessage(CPlayer _Player, Text _Message, CPlayer _Sender) {
	if (_Player == Null || _Message == "") return;
	declare netwrite Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
	declare netwrite Text[Integer] Net_LibChat_UserChatMessages for _Player;
	declare netwrite Integer Net_LibChat_UserLastMessage for _Player;
	Net_LibChat_UserLastMessage = Now;

	declare Key = Now;
	while (Net_LibChat_GlobalChatMessages.existskey(Key)) Key += 1;
	while (Net_LibChat_UserChatMessages.existskey(Key)) Key += 1;
	Net_LibChat_UserChatMessages[Key] = _Message;

	while (Net_LibChat_UserChatMessages.count > C_LibChat_MaxNbMessagesLarge+1) {
		declare KeyToRemove = 0;
		foreach (Key => Message in Net_LibChat_UserChatMessages) { KeyToRemove = Key; break; }
		declare Removed = Net_LibChat_UserChatMessages.removekey(KeyToRemove);
	}
}

// ---------------------------------- //
/** Get a player by their UI.
 *
 *	@param	_UI		UI of the player to get.
 *
 *	@return		Target player.
 */
CPlayer Private_GetPlayer(CUIConfig _UI) {
	if (_UI == Null) return Null;
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null && UI == _UI) return Player;
	}
	return Null;
}

// ---------------------------------- //
/** Get a player by their login.
 *
 *	@param	_Login	Login of the player to get.
 *
 *	@return		Target player.
 */
CPlayer Private_GetPlayer(Text _Login) {
	foreach (Player in AllPlayers) if (Player.User.Login == _Login) return Player;
	return Null;
}

// ---------------------------------- //
/** Register a new chat command.
 *
 *	@param	_Sender		Login of the player who sent the command.
 *	@param	_Name		Name of the command.
 *	@param	_Params		Command parameters.
 */
Void Private_RegisterCommand(Text _Sender, Text _Name, Text[] _Params) {
	if (_Sender == "" || _Name == "") return;

	G_LibChat_LastCommandId += 1;
	G_LibChat_PendingCommands.add(G_LibChat_LastCommandId);
	G_LibChat_CommandSender	[G_LibChat_LastCommandId] = _Sender;
	G_LibChat_CommandName	[G_LibChat_LastCommandId] = _Name;
	G_LibChat_CommandParams	[G_LibChat_LastCommandId] = _Params;

	while (G_LibChat_CommandSender.count > C_LibChat_MaxCachedCommands) {
		declare Boolean Removed;
		foreach (CommandId => CommandSender in G_LibChat_CommandSender) {
			Removed = G_LibChat_CommandSender	.removekey(CommandId);
			Removed = G_LibChat_CommandName		.removekey(CommandId);
			Removed = G_LibChat_CommandParams	.removekey(CommandId);
		}
	}
}

// ---------------------------------- //
/** Get the clan number of a player.
 *
 *	@param	_Player		The player to get their clan.
 *
 *	@return		Clan of the player.
 */
Integer Private_GetClan(CPlayer _Player) {
	if (_Player == Null) return 0;

	declare CustomClan = Clans::GetPlayerClan(_Player);
	if (CustomClan > 0) return CustomClan;

	switchtype (_Player) {
		case CTmPlayer : return cast(CTmPlayer, _Player).CurrentClan;
		case CSmPlayer : return cast(CSmPlayer, _Player).CurrentClan;
	}
	return 0;
}

// ---------------------------------- //
/** Parse links in a message.
 *
 *	@param	_Segments	Segments of the message to format.
 *
 *	@return		All segments with formatted links in them.
 */
Text[] Private_ParseLinks(Text[] _Segments) {
	declare Text[] OutputSegments;
	if (_Segments.count <= 0) return OutputSegments;
	declare RemoveLinks = ServerManager::RemoveLinks();

	foreach (_Segment in _Segments) {
		declare Segment = TL::StripFormatting(_Segment);

		// ---------------------------------- //
		// External links (http, https, www)
		if (
			TL::SubString(Segment, 0, 7) == "http://" ||
			TL::SubString(Segment, 0, 8) == "https://" ||
			TL::SubString(Segment, 0, 4) == "www."
		) {
			if (!RemoveLinks) OutputSegments.add("$<$FA3$l"^Segment^"$>");
			continue;
		}

		// ---------------------------------- //
		// Internal links (maniaplanet, hashcodes)
		if (
			TL::SubString(Segment, 0, 14) == "maniaplanet://" ||
			TL::SubString(Segment, 0, 1) == "#"
		) {
			Segment = TL::Replace(Segment, "maniaplanet:///:", "");
			Segment = TL::Replace(Segment, "maniaplanet://", "");
			if (!RemoveLinks) OutputSegments.add("$<$6BF$h"^Segment^"$>");
			continue;
		}

		// Normal segments
		OutputSegments.add(_Segment);
	}
	
	return OutputSegments;
}

// ---------------------------------- //
/** Parse badwords in a message.
 *
 *	@param	_Segments	Segments of the message to format.
 *
 *	@return		All segments with formatted badwords in them.
 */
Text[] Private_ParseBadWords(Text[] _Segments) {
	declare Text[] OutputSegments;
	if (_Segments.count <= 0) return OutputSegments;

	foreach (_Segment in _Segments) {
		declare Segment = TL::StripFormatting(_Segment);
		declare FoundBadWords = False;

		foreach (BadWord in C_LibChat_ForbiddenWords) {
			if (!TL::Find(BadWord, Segment, False, False)) continue;
			FoundBadWords = True;
			break;
		}

		if (!FoundBadWords) {
			OutputSegments.add(_Segment);
			continue;
		}

		declare Stars = "";
		for (I, 1, TL::Length(Segment)) Stars ^= "*";
		OutputSegments.add(Stars);
	}

	return OutputSegments;
}

// ---------------------------------- //
/** Parse the chat message.
 *
 *	@param	_Message	The message to format.
 *
 *	@return		The formatted message.
 */
Text Private_ParseMessage(Text _Message) {
	if (TL::Length(_Message) <= 1) return _Message;
	declare Message = TL::Replace(_Message, "\n", " "); // Line breaking removal
	declare SplitMessage = TL::Split(" ", Message);

	if (ServerManager::ParseBadwords())	SplitMessage = Private_ParseBadWords(SplitMessage);	// Parse badwords
	if (ServerManager::ParseLinks())	SplitMessage = Private_ParseLinks(SplitMessage);	// Parse links

	return TL::Join(" ", SplitMessage); // Remove spaces
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Set the custom chat visibility.
 *
 *	@param	_Visible	Whether the chat is visible or not.
 */
Void SetVisibility(Boolean _Visible) {
	declare netwrite Boolean Net_LibChat_UseCustomChat for Teams[0];
	Net_LibChat_UseCustomChat = _Visible;
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	Layers::Detach(C_LibChat_InterfaceLayerId);
	Layers::Destroy(C_LibChat_InterfaceLayerId);
}

// ---------------------------------- //
/** Load the library.
 *
 *	@param	_FontName	Name of the font used in chat.
 */
Void Load(Text _FontName) {
	Unload();
	SetVisibility(True);
	G_LibChat_InterfaceFont = _FontName;
	Layers::Create(C_LibChat_InterfaceLayerId, Private_CreateManialinkChat());
	Layers::Attach(C_LibChat_InterfaceLayerId);
}

// ---------------------------------- //
/// Load the library.
Void Load() {
	Load("");
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 */
Void SendMessage(Text _Message) {
	Private_SendMessage(_Message, Null);
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 */
Void SendMessage(CPlayer _Player, Text _Message) {
	if (_Player == Null) return;
	Private_SendMessage(_Player, _Message, Null);
}

// ---------------------------------- //
/** Send a message to a team.
 *
 *	@param	_Clan		Clan to send the message.
 *	@param	_Message	Message to send.
 */
Void SendMessage(Integer _Clan, Text _Message) {
	foreach (Player in Players) if (Private_GetClan(Player) == _Clan) SendMessage(Player, _Message);
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(Text _Message, CPlayer _Sender) {
	Private_SendMessage(_Message, _Sender);
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(CPlayer _Player, Text _Message, CPlayer _Sender) {
	if (_Player == Null) return;
	Private_SendMessage(_Player, _Message, _Sender);
}

// ---------------------------------- //
/** Send a message to a team.
 *
 *	@param	_Clan		Clan to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(Integer _Clan, Text _Message, CPlayer _Sender) {
	foreach (Player in Players) if (Private_GetClan(Player) == _Clan) SendMessage(Player, _Message, _Sender);
}

Void SendTranslated(CPlayer _Player, Text[] _Message) {
	if (_Player == Null || _Player.User.IsFakeUser || !_Message.existskey(0) || _Message[0] == "") return;
	declare Translated = Translations::Translate(_Player.User.Language, _Message);
	SendMessage(_Player, Translated);
}

Void SendTranslated(Text[] _Message) {
	if (!_Message.existskey(0) || _Message[0] == "") return;
	foreach (Player in AllPlayers) SendTranslated(Player, _Message);
}

// ---------------------------------- //
/** Get the pending chat commands.
 *
 *	@return		Pending commands.
 */
Integer[] PendingCommands() {
	return G_LibChat_PendingCommands;
}

// ---------------------------------- //
/** Get the command sender login.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command sender login.
 */
Text GetCommandSender(Integer _CommandId) {
	if (!G_LibChat_CommandSender.existskey(_CommandId)) return "";
	return G_LibChat_CommandSender[_CommandId];
}

// ---------------------------------- //
/** Get the command player.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command player.
 */
CPlayer GetCommandPlayer(Integer _CommandId) {
	declare CommandSender = GetCommandSender(_CommandId);
	if (CommandSender == "") return Null;
	foreach (Player in AllPlayers) if (Player.User.Login == CommandSender) return Player;
	return Null;
}

// ---------------------------------- //
/** Get the command name.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command name.
 */
Text GetCommandName(Integer _CommandId) {
	if (!G_LibChat_CommandName.existskey(_CommandId)) return "";
	return G_LibChat_CommandName[_CommandId];
}

// ---------------------------------- //
/** Get the command parameters.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command parameters.
 */
Text[] GetCommandParams(Integer _CommandId) {
	if (!G_LibChat_CommandParams.existskey(_CommandId)) return Text[];
	return G_LibChat_CommandParams[_CommandId];
}

// ---------------------------------- //
/** Library loop.
 *
 *	@param	_UseCustomChat	Whether the chat is used or not.
 */
Void Loop(Boolean _UseCustomChat) {
	SetVisibility(_UseCustomChat);
	if (!_UseCustomChat) return;
	if (G_LibChat_PendingCommands.count > 0) G_LibChat_PendingCommands.clear();

	// ---------------------------------- //
	// Manage events
	foreach (Event in UIManager.PendingEvents) {
		if (Event.Type == CUIConfigEvent::EType::OnLayerCustomEvent) {
			// ---------------------------------- //
			// User sends a message
			if (Event.CustomEventType == "LibChat_MessageSent" && Event.CustomEventData.existskey(0)) {
				declare Message = Event.CustomEventData[0];
				declare Sender = Private_GetPlayer(Event.UI);
				if (Sender == Null || Message == "") continue; 
				
				// Check if message is a command
				declare IsCommand = TL::SubString(Message, 0, 1) == "/";
				
				// ---------------------------------- //
				// Handle commands
				if (IsCommand) {
					declare SplitCommand = TL::Split(" ", Message);
					if (!SplitCommand.existskey(0)) continue;

					declare CommandSender = Sender.User.Login;
					declare CommandName = SplitCommand[0];
					declare CommandParams = SplitCommand;
					declare Removed = CommandParams.remove(CommandName);
					CommandName = TL::Replace(CommandName, "/", "");

					Private_RegisterCommand(CommandSender, CommandName, CommandParams);
				}
				
				// ---------------------------------- //
				// Send global message
				else if (!ServerManager::IsMuted(Sender.User.Login)) {
					declare SplitMessage = TL::Split(" ", Message);
					declare PremadeMsgCode = SplitMessage[0];

					// ---------------------------------- //
					// Premade short answers
					if (SplitMessage.count <= 2 && C_LibChat_PremadeMessages.existskey(PremadeMsgCode)) {
						Message = "$i"^C_LibChat_PremadeMessages[PremadeMsgCode];
						if (SplitMessage.existskey(1) && C_LibChat_PremadeWithRecipient.exists(PremadeMsgCode)) {
							declare TargetName = ServerManager::GetNameByLogin(SplitMessage[1]);
							Message ^= " $<"^TargetName^"$>";
						}
						Message ^= "!";
					}

					else Message = TL::Join(" ", SplitMessage); // Spaces removal
					if (Message == "") continue;
					Message = Private_ParseMessage(Message);
					declare Messages = Text[];

					// ---------------------------------- //
					// Split too long text message
					if (TL::Length(Message) > C_LibChat_MessageMaxLength) {
						SplitMessage = TL::Split(" ", Message);
						declare CurrentPart = Text[];
						declare CurrentLength = 0;

						foreach (I => Segment in SplitMessage) {
							CurrentPart.add(Segment);
							CurrentLength += TL::Length(Segment) + 1;
							if (CurrentLength < C_LibChat_MessageMaxLength && I != SplitMessage.count - 1) continue;
							Messages.add(TL::Join(" ", CurrentPart));
							CurrentPart.clear();
							CurrentLength = 0;
						}
					}

					// Message wasn't split
					if (Messages.count <= 0) Messages = [Message];

					// ---------------------------------- //
					// Send chat message
					foreach (I => Segment in Messages) {
						declare TargetMessage = C_LibChat_MessageFormat_Global;
						if (I > 0) TargetMessage = C_LibChat_MessageFormat_Global2;
						TargetMessage = TL::Replace(TargetMessage, "%1", Sender.User.Name);
						TargetMessage = TL::Replace(TargetMessage, "%2", Segment);
						SendMessage(TargetMessage, Sender);
					}
				}
			}
		}
	}

	// ---------------------------------- //
	// Manage some of the commands
	foreach (CommandId in PendingCommands()) {
		declare CommandPlayer	<=> GetCommandPlayer(CommandId);
		declare CommandName		= GetCommandName(CommandId);
		declare CommandParams	= GetCommandParams(CommandId);
		if (CommandPlayer == Null || CommandName == "") continue;

		switch (CommandName) {
			// ---------------------------------- //
			// Send team message
			case "t" : {
				declare PlayerClan = Private_GetClan(CommandPlayer);
				if (!CommandParams.existskey(0)) continue;

				declare Message = C_LibChat_MessageFormat_Global;
				if (PlayerClan > 0) Message = C_LibChat_MessageFormat_Team;

				Message = TL::Replace(Message, "%1", CommandPlayer.User.Name);
				Message = TL::Replace(Message, "%2", TL::Join(" ", CommandParams));
				
				if (PlayerClan > 0) SendMessage(PlayerClan, Message, CommandPlayer);
				else SendMessage(Message, CommandPlayer);
			}
			// ---------------------------------- //
			// Me command
			case "me" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;
				if (!CommandParams.existskey(0)) continue;

				declare Message = C_LibChat_MessageFormat_MeCmd;
				Message = TL::Replace(Message, "%1", CommandPlayer.User.Name);
				Message = TL::Replace(Message, "%2", TL::Join(" ", CommandParams));
				Message = Private_ParseMessage(Message);
				SendMessage(Message);
			}
			// ---------------------------------- //
			// Private message
			case "pm" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;

				// Recipient or message missing
				if (CommandParams.count < 2) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Usage: /pm <recipient> <message>");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare Recipient <=> Private_GetPlayer(CommandParams[0]);

				// Recipient not found
				if (Recipient == Null) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: Recipient not found!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				// Sending message to self
				if (Recipient == CommandPlayer) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: Cannot send private message to self!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare Removed = CommandParams.removekey(0);
				declare MessageBody = TL::Join(" ", CommandParams);

				// Sender message
				declare SenderMessage = C_LibChat_MessageFormat_Outgoing;
				SenderMessage = TL::Replace(SenderMessage, "%1", Recipient.User.Name);
				SenderMessage = TL::Replace(SenderMessage, "%2", MessageBody);
				SendMessage(CommandPlayer, SenderMessage);

				// Recipient message
				declare RecipientMessage = C_LibChat_MessageFormat_Incoming;
				RecipientMessage = TL::Replace(RecipientMessage, "%1", CommandPlayer.User.Name);
				RecipientMessage = TL::Replace(RecipientMessage, "%2", MessageBody);
				SendMessage(Recipient, RecipientMessage);

				// Save latest conversation
				declare Text LastPrivateMessageLogin as SenderRecipientLogin for CommandPlayer;
				declare Text LastPrivateMessageLogin as RecipientSenderLogin for Recipient;
				SenderRecipientLogin = Recipient.User.Login;
				RecipientSenderLogin = CommandPlayer.User.Login;
			}
			// ---------------------------------- //
			// Private message reply
			case "pmr" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;

				// Message missing
				if (CommandParams.count < 1) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Usage: /pmr <message>");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				// No active conversation yet
				declare Text LastPrivateMessageLogin for CommandPlayer;
				if (LastPrivateMessageLogin == "") {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: You don't have an active conversation yet!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare NewCommandParams = [LastPrivateMessageLogin];
				foreach (Param in CommandParams) NewCommandParams.add(Param);
				Private_RegisterCommand(CommandPlayer.User.Login, "pm", NewCommandParams);
			}
			

			default : {
				ServerManager::OnChatCommand(CommandPlayer, CommandName, CommandParams);
			}
		}
	}

	// ---------------------------------- //
	// Server manager custom messages
	while (ServerManager::PendingChatMessages()) {
		foreach (RecipientId => MessageBody in ServerManager::PendingMessage()) {
			if (!MessageBody.existskey(0) || MessageBody[0] == "") break;
			declare CPlayer Recipient;

			if (RecipientId != NullId) {
				if (!AllPlayers.existskey(RecipientId)) break;
				Recipient = AllPlayers[RecipientId];
			}

			if (Recipient != Null) SendTranslated(Recipient, MessageBody);
			else SendTranslated(MessageBody);
		}
	}
}

// ---------------------------------- //
/// Library loop.
Void Loop() {
	Loop(True);
}