// -------------------------------------- //
//  LIBRARY CHAT by domino54              //
//  script version: 2018-03-29            //
// -------------------------------------- //

/**
 *	Replace default chat with a custom one. Allows to send commands
 *	directly to the game mode script. Automatically formats links
 *	and allows to send longer messages.
 */

#Const Version		"2018-03-29"
#Const ScriptName	"Libs/domino54/Chat.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "TimeLib" as Time
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/domino54/Bindings.Script.txt" as Bindings
#Include "Libs/domino54/DiscordWebhooks.Script.txt" as Discord
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/MultiClans.Script.txt" as Clans
#Include "Libs/domino54/ServerManager.Script.txt" as ServerManager
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_LibChat_InterfaceLayerId	"LibChat:Chat"
#Const C_LibChat_MessageMaxLength	64		///< Max. characters in one message before it's split.
#Const C_LibChat_MaxNbMessagesSmall	7		///< Max. messages shown at one in small chat.
#Const C_LibChat_MaxNbMessagesLarge	32		///< Max. messages shown at one in large chat.
#Const C_LibChat_MaxCachedCommands	10		///< Amount of cached chat commands.
#Const C_LibChat_ChatTextSize		1.5		///< Size of the chat message text.
#Const C_LibChat_ChatLineHeight		4.		///< Height of the chat line.
#Const C_LibChat_EmojisSpacing		0.		///< Space between emoji and text.

// Messages formatting
#Const C_LibChat_ChatLineColor_Default	<1., 1., 1.>
#Const C_LibChat_ChatLineColor_FromUser	<1., 1., 0.>
#Const C_LibChat_MessageFormat_Error	"$F00%1"
#Const C_LibChat_MessageFormat_Global	"$FF0[$<%1$>] %2"
#Const C_LibChat_MessageFormat_Global2	"$FF0%2"
#Const C_LibChat_MessageFormat_Team		"$FF0<$<%1$>> %2"
#Const C_LibChat_MessageFormat_MeCmd	"$6BF$<%1$> %2"
#Const C_LibChat_MessageFormat_Incoming	"$6BF[➘ $<%1$>] %2"
#Const C_LibChat_MessageFormat_Outgoing	"$6BF[➚ $<%1$>] %2"

// Premade quick chat messages
#Const C_LibChat_PremadeMessages [
	"hi" => "Hello", "bb" => "Bye", "re" => "Returned", "wb" => "Welcome back",
	"afk" => "Away from keyboard", "gtg" => "Got to go", "brb" => "Be right back",
	"gg" => "Good game", "gga" => "Good game all", "gj" => "Good job",
	"n1" => "Nice one", "ns" => "Nice shoot", "nt" => "Nice time", "ty" => "Thank you",
	"gl" => "Good luck", "hf" => "Have fun", "glhf" => "Goold luck and have fun",
	"wp" => "Well played", "ggwp" => "Good game, well played",
	"gr8" => "Great", "w8" => "Wait", "flo" => "Florenziusted"
]
#Const C_LibChat_PremadeWithRecipient [
	"hi", "bb", "wb", "flo", "gg", "gj", "n1", "ns", "nt", "ty", "lol", "lool",
	"gl", "hf", "glhf", "wp", "ggwp", "gr8", "w8", "flo"
]

// Badwords to filter
#Const C_LibChat_ForbiddenWords [
	"fuck", "shit", "bitch", "slut", "twat", "prick", "sucker", "cock", "whore", "faggot", "asshole", "dick",
	"merde", "putain", "salope", "kurw", "kurv" 
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Text G_LibChat_InterfaceFont;
declare Text G_LibChat_DiscordWebhookURL;
declare Integer G_LibChat_LastCommandId;
declare Integer[] G_LibChat_PendingCommands;
declare Text[Integer] G_LibChat_CommandSender;
declare Text[Integer] G_LibChat_CommandName;
declare Text[][Integer] G_LibChat_CommandParams;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for the chat library.
 *
 *	@return		The chat manialink.
 */
Text Private_CreateManialinkChat() {
	declare ChatMessagesLabels = "";
	for (I, 0, C_LibChat_MaxNbMessagesLarge+1)
		ChatMessagesLabels ^= "<frameinstance pos='0 "^I*C_LibChat_ChatLineHeight^"' modelid='FrameModel_ChatLine' id='Frame_ChatMessage#"^I^"' hidden='1' />";

	declare ChatMessageLine = "";
	for (I, 0, 4) {
		ChatMessageLine ^= "<label id='Label_LineLabel#"^I^"' class='Message' size='90' />";
		ChatMessageLine ^= "<quad id='Quad_LineEmoji#"^I^"' class='Emoji' ScriptEvents='1' />";
	}

	declare PickerEmojis = "";
	for (I, 0, 47) {
		declare X = I % 8;
		declare Y = I / 8;
		PickerEmojis ^= "<quad pos='"^X * 6^" "^Y * -6^"' size='4.5 4.5' class='Picker' id='Quad_PickerMoji#"^I^"' ScriptEvents='1' />";
	}

	declare Font = TL::MLEncode(G_LibChat_InterfaceFont);
	return """
<manialink version="3" name="{{{C_LibChat_InterfaceLayerId}}}">
<stylesheet>
	<style class="Message" valign="center2" textsize="{{{C_LibChat_ChatTextSize}}}" textemboss="1" textcolor="FFF" textfont="{{{Font}}}" />
	<style class="Emoji" halign="center" valign="center2" size="3.75 3.75" keepratio="Fit" />
	<style id="Entry_ChatInput" valign="center2" textsize="{{{C_LibChat_ChatTextSize}}}" textemboss="1" textcolor="FFF" textfont="{{{Font}}}" />
	<style id="Label_ChatKeyHint" style="TextButtonNav" valign="center2" textsize=".375" textcolor="FFF" opacity=".5" />
</stylesheet>

<frame id="Frame_EmojiTooltip" z-index="11" hidden="1">
	<label halign="center" valign="center2" textsize="1" textcolor="FFF" textfont="{{{Font}}}" id="Label_EmojiTooltip" />
	<quad size="0 5" halign="center" valign="center" bgcolor="000" opacity=".875" id="Quad_EmojiTooltip" />
</frame>

<frame id="Frame_PlayerProfile" z-index="11" hidden="1">
	<quad pos=".5 9.5" size="9 9" id="Quad_PlayerAvatar" />
	<label pos="11 5" class="Message" textsize="2" id="Label_PlayerNickname" />

	<quad pos="0 10" size="2.5 10" halign="right" id="Quad_PlayerEchelon" />
	<quad pos="0 10" size="10 10" bgcolor="000" opacity=".875" id="Quad_PlayerProfileBg" />
</frame>

<frame id="Frame_ChatWindow" pos="-160 -90" z-index="10">
	<frame id="Frame_EmojiPicker" pos="1 50" hidden="1">
		<frame>
			<label pos="3 -3" halign="center" valign="center2" textsize="1" textcolor="FFF" rot="180" text="►" id="Label_EmojiPickerPrev" />
			<quad size="6 6" bgcolorfocus="FFF" opacity=".125" id="Quad_EmojiPickerPrev" ScriptEvents="1" />
		</frame>
		<frame pos="46">
			<label pos="3 -3" halign="center" valign="center2" textsize="1" textcolor="FFF" text="►" id="Label_EmojiPickerNext" />
			<quad size="6 6" bgcolorfocus="FFF" opacity=".125" id="Quad_EmojiPickerNext" ScriptEvents="1" />
		</frame>

		<label pos="26 -3" size="32" halign="center" valign="center2" textsize="1" textcolor="FFF" textfont="{{{Font}}}" id="Label_PickerEmojiName" />
		<quad size="52 6" bgcolor="000" opacity=".5" />

		<frame pos="3 -8.5">{{{PickerEmojis}}}</frame>

		<quad size="52 45.5" bgcolor="000" opacity=".625" ScriptEvents="1" />
		<quad size="52 45.5" style="Bgs1" substyle="BgDialogBlur" opacity="0" />
	</frame>

	<frame pos="1 {{{C_LibChat_ChatLineHeight*2-1.5}}}" id="Frame_ChatMessagesBox">
		<framemodel id="FrameModel_ChatLine">
			<frame id="Frame_MessageSender" hidden="1">
				<label size="32" class="Message" id="Label_SenderName" />
				<label halign="center" valign="center2" textsize=".5" textcolor="FFF" opacity=".5" text="⏵" id="Label_SenderArrow" />
				<quad pos="-.5" size="0 {{{C_LibChat_ChatLineHeight}}}" valign="center" bgcolorfocus="000" opacity=".5" id="Quad_MessageSender" ScriptEvents="1" />
			</frame>
			{{{ChatMessageLine}}}
		</framemodel>
		<frame id="Frame_LabelsAnim">{{{ChatMessagesLabels}}}</frame>
	</frame>

	<frame pos="1 {{{C_LibChat_ChatLineHeight/2+.5}}}" z-index="1">
		<entry pos="3" size="100 {{{C_LibChat_ChatLineHeight-.5}}}" focusareacolor1="0004" focusareacolor2="0007" id="Entry_ChatInput" ScriptEvents="1" hidden="1" />
		<label pos="3" id="Label_ChatKeyHint" textfont="Eurostile_Bold" />
		<quad pos="-.375" size="3 3" valign="center" image="file://Media/Emoji/emoji.png" opacity=".5" id="Quad_EmojiPickerToggle" ScriptEvents="1" />
	</frame>

	<frame id="Frame_ChatBackground" hidden="1">
		<quad pos="-1" size="122 138" valign="bottom" bgcolor="000" opacity=".75" />
		<quad pos="-1" size="122 138" valign="bottom" style="Bgs1" substyle="BgDialogBlur" opacity="0" />
		<quad pos="-6 -5" size="132 148" valign="bottom" style="Bgs1InRace" substyle="BgButtonShadow" />
	</frame>
</frame>
<script><!--
/**
 *	{{{C_LibChat_InterfaceLayerId}}}
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_DefaultEmoji [
	// Codes
	":100:" => "file://Media/Emoji/hundred.png",
	":angry:" => "file://Media/Emoji/angry.png",
	":blush:" => "file://Media/Emoji/blush.png",
	":clap:" => "file://Media/Emoji/clap.png",
	":cry:" => "file://Media/Emoji/cry.png",
	":fire:" => "file://Media/Emoji/fire.png",
	":fist:" => "file://Media/Emoji/fist.png",
	":frowning:" => "file://Media/Emoji/frowning.png",
	":heart:" => "file://Media/Emoji/heart.png",
	":heart_eyes:" => "file://Media/Emoji/heart_eyes.png",
	":hundred:" => "file://Media/Emoji/hundred.png",
	":joy:" => "file://Media/Emoji/joy.png",
	":kissing_heart:" => "file://Media/Emoji/kiss.png",
	":laughing:" => "file://Media/Emoji/laughing.png",
	":nerd:" => "file://Media/Emoji/nerd.png",
	":neutral_face:" => "file://Media/Emoji/neutral.png",
	":ok:" => "file://Media/Emoji/ok.png",
	":open_mouth:" => "file://Media/Emoji/open_mouth.png",
	":poop:" => "file://Media/Emoji/poop.png",
	":punch:" => "file://Media/Emoji/punch.png",
	":rage:" => "file://Media/Emoji/rage.png",
	":rolling_eyes:" => "file://Media/Emoji/rolling_eyes.png",
	":scream:" => "file://Media/Emoji/scream.png",
	":shrug:" => "file://Media/Emoji/shrug.png",
	":slight_smile:" => "file://Media/Emoji/slight_smile.png",
	":smile:" => "file://Media/Emoji/smile.png",
	":smiley:" => "file://Media/Emoji/smiley.png",
	":smirk:" => "file://Media/Emoji/smirk.png",
	":sob:" => "file://Media/Emoji/sob.png",
	":stuck_out_tongue:" => "file://Media/Emoji/stuck_out_tongue.png",
	":thinking:" => "file://Media/Emoji/thinking.png",
	":thumbsdown:" => "file://Media/Emoji/thumbsdown.png",
	":thumbsup:" => "file://Media/Emoji/thumbsup.png",
	":v:" => "file://Media/Emoji/v.png",
	":wave:" => "file://Media/Emoji/wave.png",
	":wink:" => "file://Media/Emoji/wink.png",
	// Extras
	":dommy:" => "file://Media/Emoji/dommy.png",
	":facepalm:" => "file://Media/Emoji/facepalm.png",
	":feelsbadman:" => "file://Media/Emoji/feelsbadman.png",
	":hang:" => "file://Media/Emoji/hang.png",
	":kappa:" => "file://Media/Emoji/kappa.png",
	":kreygasm:" => "file://Media/Emoji/kreygasm.png",
	":lul:" => "file://Media/Emoji/lul.png",
	":miss:" => "file://Media/Emoji/miss.png",
	":pogchamp:" => "file://Media/Emoji/pogchamp.png",
	":seemsgood:" => "file://Media/Emoji/seemsgood.png",
	":tomkek:" => "file://Media/Emoji/tomkek.png",
	// ManiaPlanet
	":mp:" => "Icons128x32_1|ManiaPlanet",
	":lp:" => "Icons128x128_1|LadderPoints",
	":planets:" => "ManiaPlanetLogos|IconPlanetsSmall",
	// Standard
	":)" => "file://Media/Emoji/smiley.png",
	";)" => "file://Media/Emoji/wink.png",
	":(" => "file://Media/Emoji/frowning.png",
	":D" => "file://Media/Emoji/smile.png",
	":P" => "file://Media/Emoji/stuck_out_tongue.png",
	":o" => "file://Media/Emoji/open_mouth.png",
	":O" => "file://Media/Emoji/open_mouth.png",
	":|" => "file://Media/Emoji/neutral.png",
	"xD" => "file://Media/Emoji/laughing.png",
	"XD" => "file://Media/Emoji/laughing.png",
	"<3" => "file://Media/Emoji/heart.png"
]

declare Text[Text] G_AvailableEmoji;

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ChatWindow <=> (Page.GetFirstChild("Frame_ChatWindow") as CMlFrame);
declare Frame_ChatBackground <=> (Page.GetFirstChild("Frame_ChatBackground") as CMlFrame);
declare Frame_LabelsAnim <=> (Page.GetFirstChild("Frame_LabelsAnim") as CMlFrame);
declare Entry_ChatInput <=> (Page.GetFirstChild("Entry_ChatInput") as CMlEntry);
declare Label_ChatKeyHint <=> (Page.GetFirstChild("Label_ChatKeyHint") as CMlLabel);
declare Frame_ChatMessagesBox <=> (Page.GetFirstChild("Frame_ChatMessagesBox") as CMlFrame);

// Emoji picker
declare Frame_EmojiPicker <=> (Page.GetFirstChild("Frame_EmojiPicker") as CMlFrame);
declare Quad_EmojiPickerToggle <=> (Page.GetFirstChild("Quad_EmojiPickerToggle") as CMlQuad);
declare Label_PickerEmojiName <=> (Page.GetFirstChild("Label_PickerEmojiName") as CMlLabel);
declare Quad_EmojiPickerPrev <=> (Page.GetFirstChild("Quad_EmojiPickerPrev") as CMlQuad);
declare Quad_EmojiPickerNext <=> (Page.GetFirstChild("Quad_EmojiPickerNext") as CMlQuad);
declare Label_EmojiPickerPrev <=> (Page.GetFirstChild("Label_EmojiPickerPrev") as CMlLabel);
declare Label_EmojiPickerNext <=> (Page.GetFirstChild("Label_EmojiPickerNext") as CMlLabel);

declare CMlFrame[] Frame_ChatMessages;
for (I, 0, {{{C_LibChat_MaxNbMessagesLarge+1}}})
	Frame_ChatMessages.add((Page.GetFirstChild("Frame_ChatMessage#"^I) as CMlFrame));

declare Frame_EmojiTooltip <=> (Page.GetFirstChild("Frame_EmojiTooltip") as CMlFrame);
declare Label_EmojiTooltip <=> (Page.GetFirstChild("Label_EmojiTooltip") as CMlLabel);
declare Quad_EmojiTooltip <=> (Page.GetFirstChild("Quad_EmojiTooltip") as CMlQuad);

declare CMlQuad[] Quad_PickerMoji;
for (I, 0, 47) Quad_PickerMoji.add((Page.GetFirstChild("Quad_PickerMoji#"^I) as CMlQuad));

declare Frame_PlayerProfile <=> (Page.GetFirstChild("Frame_PlayerProfile") as CMlFrame);
declare Quad_PlayerProfileBg <=> (Page.GetFirstChild("Quad_PlayerProfileBg") as CMlQuad);
declare Quad_PlayerAvatar <=> (Page.GetFirstChild("Quad_PlayerAvatar") as CMlQuad);
declare Quad_PlayerEchelon <=> (Page.GetFirstChild("Quad_PlayerEchelon") as CMlQuad);
declare Label_PlayerNickname <=> (Page.GetFirstChild("Label_PlayerNickname") as CMlLabel);

// ---------------------------------- //
// Persistent settings
declare persistent Text[] Persistent_LibServerManager_PrivateMutedUsers for LocalUser;
declare persistent Integer Persistent_LibServerManager_PrivateMuteUpdate for LocalUser;
declare persistent Persistent_LibChat_EnableEmojiParser for LocalUser = True;

// ---------------------------------- //
// Net variables
declare netread Boolean Net_LibChat_UseCustomChat for Teams[0];
declare netread Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
declare netread Text[Integer] Net_LibChat_GlobalChatSenders for Teams[0];
declare netread Integer[Integer] Net_LibChat_GlobalChatClans for Teams[0];
declare netread Text[Integer] Net_LibChat_UserChatMessages for InputPlayer;
declare netread Text[Integer] Net_LibChat_UserChatSenders for InputPlayer;
declare netread Integer Net_LibChat_GlobalLastMessage for Teams[0];
declare netread Integer Net_LibChat_UserLastMessage for InputPlayer;
declare netread Text[Text] Net_LibChat_ServerEmoji for Teams[0];

// ---------------------------------- //
// Variables
declare UpdateMessagesList = True;
declare MaxNbMessagesDisplayed = 7;
declare SlideNewMessage = False;
declare CancelNextSlide = False;
declare IsFirstLaunch = True;
declare UpdateTooltip = True;
declare PrevMessageKey = -1;
declare FormatLabels = True;
declare UpdateProfileCard = "";
declare CurrentPlayerClan = 0;
declare PrevPlayerClan = -1;
declare PrevIsSpectator = False;

declare MessagesList = Integer[];
declare MessagesBody = Text[][Integer];
declare MessagesSender = Text[Integer];
declare MessagesClan = Integer[Integer];

declare UpdatePickerMoji = True;
declare PickerMojiCurPage = 1;
declare PickerMojiNbPages = 1;
declare PickerEmojiURL = Text[];
declare PickerEmojiName = Text[];

// Update
declare PrevGlobalLastMessage = -1;
declare PrevUserLastMessage = -1;
declare PrevMaxNbMessagesDisplayed = -1;
declare PrevEnableEmojiParser = !Persistent_LibChat_EnableEmojiParser;

G_AvailableEmoji = C_DefaultEmoji;
foreach (Code => URL in Net_LibChat_ServerEmoji) G_AvailableEmoji[Code] = URL;

foreach (Name => URL in G_AvailableEmoji.sortkey()) {
	if (TL::Length(Name) < 3) continue;
	if (PickerEmojiURL.exists(URL)) continue;
	PickerEmojiURL.add(URL);
	PickerEmojiName.add(Name);
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
Frame_ChatWindow.Visible = Net_LibChat_UseCustomChat;
ClientUI.OverlayHideChat = Frame_ChatWindow.Visible;

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Entry submit
	if (Event.Type == CMlEvent::Type::EntrySubmit) {
		if (Event.Control == Entry_ChatInput) {
			Entry_ChatInput.Hide();
			SendCustomEvent("LibChat_MessageSent", [Entry_ChatInput.Value]);
			Entry_ChatInput.Value = "";
		}
	}
	// ---------------------------------- //
	// Mouse over
	else if (Event.Type == CMlEvent::Type::MouseOver) {
		// ---------------------------------- //
		// Emoji name tooltip
		if (Event.Control.HasClass("Emoji")) {
			declare Text EmojiCode for Event.Control;

			Frame_EmojiTooltip.Visible = EmojiCode != "";
			if (!Frame_EmojiTooltip.Visible) continue;
			Frame_EmojiTooltip.RelativePosition_V3 = Event.Control.AbsolutePosition_V3 + <0., 5.>;

			Label_EmojiTooltip.Value = EmojiCode;
			Quad_EmojiTooltip.Size.X = ComputeWidth(Label_EmojiTooltip) + 2.;
		}

		// Emoji picker toggle button
		else if (Event.ControlId == "Quad_EmojiPickerToggle") {
			Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 1, 0.);
			(Event.Control as CMlQuad).Opacity = 1.;
		}

		// Emoji picker emoji
		else if (Event.Control.HasClass("Picker")) {
			declare Text EmojiCode for Event.Control;
			Label_PickerEmojiName.Value = EmojiCode;
		}

		// ---------------------------------- //
		// Message sender profile
		else if (Event.ControlId == "Quad_MessageSender") {
			declare Text UserLogin for Event.Control;
			declare User <=> GetUser(UserLogin);

			Frame_PlayerProfile.Visible = User != Null;
			if (!Frame_PlayerProfile.Visible) continue;

			UpdateProfileCard = UserLogin;
			Frame_PlayerProfile.RelativePosition_V3 = Input.MousePos;
		}
	}
	// ---------------------------------- //
	// Mouse out
	else if (Event.Type == CMlEvent::Type::MouseOut) {
		// Hide emoji tooltip
		if (Event.Control.HasClass("Emoji")) {
			Frame_EmojiTooltip.Hide();
		}

		// Emoji picker button
		else if (Event.ControlId == "Quad_EmojiPickerToggle") {
			(Event.Control as CMlQuad).Opacity = .5;
		}

		// Current picker page
		else if (Event.Control.HasClass("Picker")) {
			Label_PickerEmojiName.Value = PickerMojiCurPage^" / "^PickerMojiNbPages;
		}

		// Hide player profile
		else if (Event.ControlId == "Quad_MessageSender") {
			Frame_PlayerProfile.Hide();
		}
	}
	// ---------------------------------- //
	// On mouse click
	else if (Event.Type == CMlEvent::Type::MouseClick) {
		// ---------------------------------- //
		// Show emoji picker
		if (Event.ControlId == "Quad_EmojiPickerToggle") {
			Frame_EmojiPicker.Visible = !Frame_EmojiPicker.Visible;
			Audio.PlaySoundEvent(CAudioManager::ELibSound::Valid, 0, 0.);
		}

		// ---------------------------------- //
		// Select an emoji
		else if (Event.Control.HasClass("Picker")) {
			declare Text EmojiCode for Event.Control;

			Entry_ChatInput.Visible = True;
			Entry_ChatInput.Value ^= " "^EmojiCode^" ";
			Entry_ChatInput.StartEdition();
			Frame_EmojiPicker.Hide();
		}

		// ---------------------------------- //
		// Emoji picker prev page
		else if (Event.ControlId == "Quad_EmojiPickerPrev") {
			if (PickerMojiCurPage <= 1) continue;
			PickerMojiCurPage -= 1;
			UpdatePickerMoji = True;
		}

		// ---------------------------------- //
		// Emoji picker next page
		else if (Event.ControlId == "Quad_EmojiPickerNext") {
			if (PickerMojiCurPage >= PickerMojiNbPages) continue;
			PickerMojiCurPage += 1;
			UpdatePickerMoji = True;
		}

		// ---------------------------------- //
		// Message sender profile
		else if (Event.ControlId == "Quad_MessageSender") {
			declare Text UserLogin for Event.Control;
			declare User <=> GetUser(UserLogin);
			if (User == Null) continue;
			ShowProfile(UserLogin);
		}
	}
}

// ---------------------------------- //
// Start typing a message
if (Bindings_Listener("LibChat_BeginTyping", "T")) {
	Entry_ChatInput.Visible = True;
	Entry_ChatInput.StartEdition();
	UpdateTooltip = True;
}

// ---------------------------------- //
// Start typing a team message
if (Bindings_Listener("LibChat_TeamMessage", "Y")) {
	Entry_ChatInput.Visible = True;
	Entry_ChatInput.Value = "/t ";
	Entry_ChatInput.StartEdition();
}

// ---------------------------------- //
// Toggle expand chat
if (Bindings_Listener("LibChat_ToggleChat", "C")) {
	// Expanded mode
	if (MaxNbMessagesDisplayed == {{{C_LibChat_MaxNbMessagesSmall}}}) {
		MaxNbMessagesDisplayed = {{{C_LibChat_MaxNbMessagesLarge}}};
		Frame_ChatWindow.RelativePosition_V3 = <-60., -69.>;
	}

	// Normal mode
	else {
		MaxNbMessagesDisplayed = {{{C_LibChat_MaxNbMessagesSmall}}};
		Frame_ChatWindow.RelativePosition_V3 = <-160., -90.>;
	}

	Frame_ChatBackground.Visible = MaxNbMessagesDisplayed == {{{C_LibChat_MaxNbMessagesLarge}}};
}

Label_ChatKeyHint.Visible = !Entry_ChatInput.Visible;

// ---------------------------------- //
// Update messages on global messages update
if (PrevGlobalLastMessage != Net_LibChat_GlobalLastMessage) {
	PrevGlobalLastMessage = Net_LibChat_GlobalLastMessage;
	UpdateMessagesList = True;
}

// ---------------------------------- //
// Update messages on local user update
if (PrevUserLastMessage != Net_LibChat_UserLastMessage) {
	PrevUserLastMessage = Net_LibChat_UserLastMessage;
	UpdateMessagesList = True;
}

// ---------------------------------- //
// Update messages on chat height change
if (PrevMaxNbMessagesDisplayed != MaxNbMessagesDisplayed) {
	PrevMaxNbMessagesDisplayed = MaxNbMessagesDisplayed;
	UpdateMessagesList = True;
}

// Update the current clan
if (!IsSpectatorClient) {
	CurrentPlayerClan = Clans_GetPlayerClan(InputPlayer);
}

// Update on spectator mode change
if (PrevIsSpectator != IsSpectatorClient) {
	PrevIsSpectator = IsSpectatorClient;
	CurrentPlayerClan = 0;
}

// ---------------------------------- //
// Update messages on clan change
if (PrevPlayerClan != CurrentPlayerClan) {
	PrevPlayerClan = CurrentPlayerClan;
	
	UpdateMessagesList = True;
	CancelNextSlide = True;

	MessagesList.clear();
	MessagesBody.clear();
	MessagesSender.clear();
	MessagesClan.clear();
	PrevMessageKey = 0;
}

// ---------------------------------- //
// Emoji parsing setting change
if (PrevEnableEmojiParser != Persistent_LibChat_EnableEmojiParser) {
	PrevEnableEmojiParser = Persistent_LibChat_EnableEmojiParser;

	UpdateMessagesList = True;
	CancelNextSlide = True;

	MessagesList.clear();
	MessagesBody.clear();
	MessagesSender.clear();
	MessagesClan.clear();
	PrevMessageKey = 0;

	Quad_EmojiPickerToggle.Visible = PrevEnableEmojiParser;
	Label_ChatKeyHint.RelativePosition_V3.X = 0.;
	Entry_ChatInput.RelativePosition_V3.X = 0.;

	if (Quad_EmojiPickerToggle.Visible) {
		Label_ChatKeyHint.RelativePosition_V3.X += 3.;
		Entry_ChatInput.RelativePosition_V3.X += 3.;
	}
}

Frame_ChatMessagesBox.Visible = !Frame_EmojiPicker.Visible;

if (Frame_EmojiPicker.Visible) {
	// ---------------------------------- //
	// Update emoji picker
	if (UpdatePickerMoji) {
		UpdatePickerMoji = False;

		// Page switch
		PickerMojiNbPages = (PickerEmojiURL.count - 1) / Quad_PickerMoji.count + 1;
		PickerMojiCurPage = ML::Clamp(PickerMojiCurPage, 1, PickerMojiNbPages);
		Label_PickerEmojiName.Value = PickerMojiCurPage^" / "^PickerMojiNbPages;

		Quad_EmojiPickerPrev.Visible = PickerMojiCurPage > 1;
		Quad_EmojiPickerNext.Visible = PickerMojiCurPage < PickerMojiNbPages;

		Label_EmojiPickerPrev.Opacity = .5;
		Label_EmojiPickerNext.Opacity = .5;
		if (Quad_EmojiPickerPrev.Visible) Label_EmojiPickerPrev.Opacity = 1.;
		if (Quad_EmojiPickerNext.Visible) Label_EmojiPickerNext.Opacity = 1.;

		foreach (I => Quad in Quad_PickerMoji) {
			declare Key = (PickerMojiCurPage - 1) * Quad_PickerMoji.count + I;
			Quad.Visible = PickerEmojiURL.existskey(Key);
			if (!Quad.Visible) continue;

			SetQuadStyle(Quad, PickerEmojiURL[Key]);

			declare Text EmojiCode for Quad;
			EmojiCode = PickerEmojiName[Key];
		}
	}
}

// ---------------------------------- //
// Update the chat messages list
if (UpdateMessagesList) {
	UpdateMessagesList = False;

	// List all messages sent by the server
	declare MessageKey = PrevMessageKey;
	declare Text[Integer] ChatMessages;
	foreach (Key => Message in Net_LibChat_GlobalChatMessages) ChatMessages[Key] = Message;
	foreach (Key => Message in Net_LibChat_UserChatMessages) ChatMessages[Key] = Message;
	ChatMessages = ChatMessages.sortkey();

	// Filter out and format new messages
	foreach (Key => Message in ChatMessages) {
		if (MessagesList.exists(Key) || Key <= MessageKey) continue;

		declare MessageSender = "";
		if (Net_LibChat_GlobalChatSenders.existskey(Key)) MessageSender = Net_LibChat_GlobalChatSenders[Key];
		else if (Net_LibChat_UserChatSenders.existskey(Key)) MessageSender = Net_LibChat_UserChatSenders[Key];

		// Sender is muted
		if (MessageSender != "" && Persistent_LibServerManager_PrivateMutedUsers.exists(MessageSender)) continue;

		declare MessageClan = 0;
		if (Net_LibChat_GlobalChatClans.existskey(Key)) MessageClan = Net_LibChat_GlobalChatClans[Key];

		// Filter messages by clan.
		if (!IsSpectatorClient && CurrentPlayerClan > 0 && MessageClan > 0 && CurrentPlayerClan != MessageClan) continue;

		MessagesList.add(Key);
		MessagesBody[Key] = ParseMessage(Message, MessageSender != "" && PrevEnableEmojiParser);
		MessagesSender[Key] = MessageSender;
		MessagesClan[Key] = MessageClan;
		MessageKey = Key;
	}

	// Remove messages if there are too many
	while (MessagesList.count > Frame_ChatMessages.count) {
		declare Boolean Removed;
		Removed = MessagesList.removekey(0);
		Removed = MessagesBody.removekey(0);
		Removed = MessagesSender.removekey(0);
		Removed = MessagesClan.removekey(0);
	}

	// Trigger animation for new messages
	if (PrevMessageKey != MessageKey) {
		PrevMessageKey = MessageKey;
		if (!IsFirstLaunch && !CancelNextSlide) SlideNewMessage = True;
	}

	if (SlideNewMessage) {
		Frame_LabelsAnim.RelativePosition_V3.Y -= {{{C_LibChat_ChatLineHeight}}};
		AnimMgr.Add(Frame_LabelsAnim, "<frame pos='0 0' />", 250, CAnimManager::EAnimManagerEasing::SineOut);
	}

	// Format messages frames
	foreach (I => Frame in Frame_ChatMessages) {
		declare Key = MessagesList.count - I - 1;
		Frame.Visible = MessagesList.existskey(Key);
		if (!Frame.Visible) continue;

		declare MessageId = MessagesList[Key];
		declare MessageBody = Text[];
		declare MessageSender = "";
		declare MessageClan = 0;

		if (MessagesBody.existskey(MessageId)) MessageBody = MessagesBody[MessageId];
		if (MessagesSender.existskey(MessageId)) MessageSender = MessagesSender[MessageId];
		if (MessagesClan.existskey(MessageId)) MessageClan = MessagesClan[MessageId];
		
		Frame.Visible = I <= MaxNbMessagesDisplayed;
		if (!Frame.Visible) continue;

		declare PrevSenderIsSame = False;
		declare PrevClanIsSame = False;
		declare PrevMsgKey = Key - 1;

		if (MessagesList.existskey(PrevMsgKey)) {
			if (MessagesSender.existskey(MessagesList[PrevMsgKey])) {
				PrevSenderIsSame = MessageSender == MessagesSender[MessagesList[PrevMsgKey]];
			}

			if (MessagesClan.existskey(MessagesList[PrevMsgKey])) {
				PrevClanIsSame = MessageClan == MessagesClan[MessagesList[PrevMsgKey]];
			}
		}

		FormatChatLine(Frame, MessageBody, MessageSender, MessageClan, SlideNewMessage && I == 0, !PrevSenderIsSame || !PrevClanIsSame);
	}

	SlideNewMessage = False;
	IsFirstLaunch = False;
	CancelNextSlide = False;
}

// Update tooltip text
if (UpdateTooltip) {
	UpdateTooltip = False;
	Label_ChatKeyHint.Value = ReplaceChars(Translate(["Press '%1' to chat", Bindings_GetKey("LibChat_BeginTyping", "T")]));
}

// ---------------------------------- //
// Update profile card by login
if (UpdateProfileCard != "") {
	declare User <=> GetUser(UpdateProfileCard);
	UpdateProfileCard = "";

	declare PlayerEchelon = ML::Clamp(ML::FloorInteger(User.LadderPoints) / 10000, 0, 9);
	Quad_PlayerEchelon.Visible = PlayerEchelon > 0;
	if (Quad_PlayerEchelon.Visible) Quad_PlayerEchelon.ImageUrl = "file://Media/Manialinks/Common/Echelons/small_echelon"^PlayerEchelon^".dds";
	
	Label_PlayerNickname.Value = User.Name;
	Quad_PlayerAvatar.ImageUrl = "file://Avatars/"^User.Login^"/default";

	Quad_PlayerProfileBg.Size.X = 12 + ComputeWidth(Label_PlayerNickname);
}

// ---------------------------------- //
// Hide transparent messages
foreach (I => Frame in Frame_ChatMessages) {
	if (!Frame.Visible) continue;
	if (I > MaxNbMessagesDisplayed) Frame.Visible = False;
	declare Label <=> (Frame.GetFirstChild("Label_LineLabel#0") as CMlLabel);
	if (Label.Opacity <= 0) Frame.Visible = False;
}
***

{{{Translations::InjectInManialink(["Press '%1' to chat"])}}}
{{{Bindings::Functions()}}}
{{{ManialinkTools::Functions(["ComputeWidth", "SetQuadStyle", "ReplaceChars"])}}}
{{{Clans::Framework()}}}

Integer GetCurrentClan() {
	return 0;
}

// ---------------------------------- //
/** Get player by login.
 *
 *	@param	_Login	The login of the player.
 *
 *	@return		The found player.
 */
CUser GetUser(Text _Login) {
	foreach (Score in Scores) if (Score.User.Login == _Login) return Score.User;
	return Null;
}

// ---------------------------------- //
/** Get name of a player by login.
 *
 *	@param	_Login	The login of the player.
 *
 *	@return		The found player's name.
 */
Text GetPlayerName(Text _Login) {
	declare User <=> GetUser(_Login);
	if (User != Null) return User.Name;
	return _Login;
}

// ---------------------------------- //
/** Check, if the text starts with something.
 *
 *	@param	_Text		Text to check.
 *	@param	_Phrase		Phrase to check.
 *
 *	@return		True, if the test starts with phrase.
 */
Boolean StartsWith(Text _Text, Text _Phrase) {
	return TL::SubString(_Text, 0, TL::Length(_Phrase)) == _Phrase;
}

// ---------------------------------- //
/** Check, if the text ends with something.
 *
 *	@param	_Text		Text to check.
 *	@param	_Phrase		Phrase to check.
 *
 *	@return		True, if the test ends with phrase.
 */
Boolean EndsWith(Text _Text, Text _Phrase) {
	return TL::SubString(_Text, TL::Length(_Text) - TL::Length(_Phrase), TL::Length(_Phrase)) == _Phrase;
}

// ---------------------------------- //
/** Find and format emojis.
 *
 *	@param	_Message	The message to format.
 *	@param	_FindEmoji	Wherer should look for emoji or not.
 *
 *	@return		The message components.
 */
Text[] ParseMessage(Text _Message, Boolean _FindEmoji) {
	if (!_FindEmoji) return [_Message];

	declare SplitMessage = TL::Split(" ", _Message);
	declare Text[] OutputSegments;
	declare Text[] OutputEmojis;

	declare CurSegmentText = "";
	declare CurSegmentCount = 0;
	declare ToNextSegment = ""; // Copied text behind to next segment

	// ---------------------------------- //
	// Fetch message words
	foreach (I => _Segment in SplitMessage) {
		declare Segment = ToNextSegment;
		ToNextSegment = "";
		Segment ^= _Segment;
		declare SegmentEnd = I >= SplitMessage.count - 1;

		// ---------------------------------- //
		// Look for emojis inside segment
		if (
			!TL::Find("$l", Segment, True, False) &&
			!TL::Find("$h", Segment, True, False) &&
			!TL::Find("$p", Segment, True, False)
		) {
			foreach (Code => URL in G_AvailableEmoji) {
				if (OutputEmojis.count >= 4) break; 
				if (!TL::Find(Code, Segment, False, True)) continue;
				OutputEmojis.add(URL);

				declare Explode = TL::Split(Code, Segment);
				if (Explode.existskey(0)) Segment = Explode[0];
				if (Explode.existskey(1)) ToNextSegment = Explode[1]^" ";
				
				SegmentEnd = True;
				break;
			}
		}
		
		// Extend segment by a word
		if (Segment != "") {
			if (CurSegmentCount > 0) CurSegmentText ^= " ";
			CurSegmentText ^= Segment;
			CurSegmentCount += 1;
		}

		// End a segment
		if (SegmentEnd) {
			if (CurSegmentText == "") {
				if (OutputSegments.count > 0) CurSegmentText = " "; //< Separates emoji
			} else {
				if (!StartsWith(CurSegmentText, " ") && OutputSegments.count > 0) CurSegmentText = " "^CurSegmentText;
				if (!EndsWith(CurSegmentText, " ")) CurSegmentText ^= " ";
			}

			OutputSegments.add(CurSegmentText);
			CurSegmentText = "";
			CurSegmentCount = 0;
		}
	}

	if (ToNextSegment != "") {
		if (!StartsWith(ToNextSegment, " ") && OutputSegments.count > 0) ToNextSegment = " "^ToNextSegment;
		OutputSegments.add(ToNextSegment);
	}

	// Create output
	declare Text[] OutputArray;
	foreach (I => Segment in OutputSegments) {
		OutputArray.add(Segment);
		if (OutputEmojis.existskey(I)) OutputArray.add(OutputEmojis[I]);
	}
	return OutputArray;
}

// ---------------------------------- //
/** Format message frame.
 *
 *	@param	_Frame		The frame to format.
 *	@param	_Message	Message data to put into the model.
 *	@param	_Sender		Login of the message sender.
 *	@param	_Clan		The clan the message was sent to.
 *	@param	_AnimIn		Show fade-in animation.
 *	@param	_ShowSender	Show name of the message sender.
 */
Void FormatChatLine(CMlFrame _Frame, Text[] _Message, Text _Sender, Integer _Clan, Boolean _AnimIn, Boolean _ShowSender) {
	if (_Frame == Null || !_Frame.Visible) return;

	declare TotalLineLength = 0.;

	// Chat line components
	declare Frame_MessageSender <=> (_Frame.GetFirstChild("Frame_MessageSender") as CMlFrame);
	declare CMlLabel[] Label_LineLabels;
	declare CMlQuad[] Quad_LineEmojis;

	for (I, 0, 4) {
		Label_LineLabels.add((_Frame.GetFirstChild("Label_LineLabel#"^I) as CMlLabel));
		Quad_LineEmojis.add((_Frame.GetFirstChild("Quad_LineEmoji#"^I) as CMlQuad));
	}

	// Line color
	declare LineColor = {{{C_LibChat_ChatLineColor_Default}}};
	if (_Sender != "") LineColor = {{{C_LibChat_ChatLineColor_FromUser}}};

	Frame_MessageSender.Visible = _Sender != "" && _ShowSender;
	if (Frame_MessageSender.Visible) {
		declare Label_SenderName <=> (_Frame.GetFirstChild("Label_SenderName") as CMlLabel);
		declare Label_SenderArrow <=> (_Frame.GetFirstChild("Label_SenderArrow") as CMlLabel);
		declare Quad_MessageSender <=> (_Frame.GetFirstChild("Quad_MessageSender") as CMlQuad);

		Label_SenderName.Value = GetPlayerName(_Sender);
		Quad_MessageSender.Size.X = ML::Min(ComputeWidth(Label_SenderName), Label_SenderName.Size.X) + 1;
		Label_SenderArrow.RelativePosition_V3.X = Quad_MessageSender.Size.X + .5;
		TotalLineLength += Quad_MessageSender.Size.X + 2;

		declare ClanColor = <1., 1., 1.>;
		if (_Clan > 0) ClanColor = Clans_GetClanColor(_Clan);
		Label_SenderArrow.TextColor = ClanColor;

		declare Text UserLogin for Quad_MessageSender;
		UserLogin = _Sender;
	}

	// ---------------------------------- //
	// Format the labels
	foreach (I => Label in Label_LineLabels) {
		declare Quad = Quad_LineEmojis[I];
		Label.Visible = _Message.existskey(I*2);
		Label.Opacity = 1.;
		
		if (Label.Visible) {
			Label.RelativePosition_V3.X = TotalLineLength;
			Label.Opacity = 1.;

			// Value
			Label.Value = _Message[I*2];
			Label.TextColor = LineColor;

			// Length
			TotalLineLength += ComputeWidth(Label) + {{{C_LibChat_EmojisSpacing}}};
			Quad.RelativePosition_V3.X = TotalLineLength + Quad.Size.X / 2;
			TotalLineLength += Quad.Size.X + {{{C_LibChat_EmojisSpacing}}};

			// Anim
			if (_AnimIn) {
				Label.Opacity = .125;
				AnimMgr.Add(Label, "<label opacity='1' />", 250, CAnimManager::EAnimManagerEasing::SineOut);
			}
		}

		// Emojis
		Quad.Visible = _Message.existskey(I*2 + 1);
		Quad.Opacity = 1.;

		if (Quad.Visible) {
			declare URL = _Message[I*2 + 1];
			declare Text EmojiCode for Quad;
			SetQuadStyle(Quad, URL);
			Quad.Opacity = 1.;

			if (G_AvailableEmoji.exists(URL))
				EmojiCode = G_AvailableEmoji.keyof(URL);
			else
				EmojiCode = "";

			// Anim
			if (_AnimIn) {
				Quad.Opacity = .125;
				AnimMgr.Add(Quad, "<quad opacity='1' />", 250, CAnimManager::EAnimManagerEasing::SineOut);
			}
		}
	}
}

main() {
	wait(InputPlayer != Null);
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void Private_SendMessage(Text _Message, CPlayer _Sender, Integer _Clan) {
	if (_Message == "") return;
	declare netwrite Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
	declare netwrite Text[Integer] Net_LibChat_GlobalChatSenders for Teams[0];
	declare netwrite Integer[Integer] Net_LibChat_GlobalChatClans for Teams[0];
	declare netwrite Integer Net_LibChat_GlobalLastMessage for Teams[0];
	Net_LibChat_GlobalLastMessage = Now;
	
	declare Key = Now;
	while (Net_LibChat_GlobalChatMessages.existskey(Key)) Key += 1;

	Net_LibChat_GlobalChatMessages[Key] = _Message;
	Net_LibChat_GlobalChatClans[Key] = _Clan;

	if (_Sender != Null)
		Net_LibChat_GlobalChatSenders[Key] = _Sender.User.Login;
	else
		Net_LibChat_GlobalChatSenders[Key] = "";
	
	while (Net_LibChat_GlobalChatMessages.count > C_LibChat_MaxNbMessagesLarge+1) {
		declare KeyToRemove = 0;
		foreach (Key => Message in Net_LibChat_GlobalChatMessages) { KeyToRemove = Key; break; }

		declare Boolean Removed;
		Removed = Net_LibChat_GlobalChatMessages.removekey(KeyToRemove);
		Removed = Net_LibChat_GlobalChatSenders.removekey(KeyToRemove);
		Removed = Net_LibChat_GlobalChatClans.removekey(KeyToRemove);
	}
}

Void Private_SendMessage(Text _Message, CPlayer _Sender) {
	Private_SendMessage(_Message, _Sender, 0);
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void Private_SendMessage(CPlayer _Player, Text _Message, CPlayer _Sender) {
	if (_Player == Null || _Message == "") return;
	declare netwrite Text[Integer] Net_LibChat_GlobalChatMessages for Teams[0];
	declare netwrite Text[Integer] Net_LibChat_UserChatMessages for _Player;
	declare netwrite Integer Net_LibChat_UserLastMessage for _Player;
	Net_LibChat_UserLastMessage = Now;

	declare Key = Now;
	while (Net_LibChat_GlobalChatMessages.existskey(Key)) Key += 1;
	while (Net_LibChat_UserChatMessages.existskey(Key)) Key += 1;
	Net_LibChat_UserChatMessages[Key] = _Message;

	while (Net_LibChat_UserChatMessages.count > C_LibChat_MaxNbMessagesLarge+1) {
		declare KeyToRemove = 0;
		foreach (Key => Message in Net_LibChat_UserChatMessages) { KeyToRemove = Key; break; }
		declare Removed = Net_LibChat_UserChatMessages.removekey(KeyToRemove);
	}
}

// ---------------------------------- //
/** Get a player by their UI.
 *
 *	@param	_UI		UI of the player to get.
 *
 *	@return		Target player.
 */
CPlayer Private_GetPlayer(CUIConfig _UI) {
	if (_UI == Null) return Null;
	foreach (Player in AllPlayers) {
		declare UI <=> UIManager.GetUI(Player);
		if (UI != Null && UI == _UI) return Player;
	}
	return Null;
}

// ---------------------------------- //
/** Get a player by their login.
 *
 *	@param	_Login	Login of the player to get.
 *
 *	@return		Target player.
 */
CPlayer Private_GetPlayer(Text _Login) {
	foreach (Player in AllPlayers) if (Player.User.Login == _Login) return Player;
	return Null;
}

// ---------------------------------- //
/** Register a new chat command.
 *
 *	@param	_Sender		Login of the player who sent the command.
 *	@param	_Name		Name of the command.
 *	@param	_Params		Command parameters.
 */
Void Private_RegisterCommand(Text _Sender, Text _Name, Text[] _Params) {
	if (_Sender == "" || _Name == "") return;

	G_LibChat_LastCommandId += 1;
	G_LibChat_PendingCommands.add(G_LibChat_LastCommandId);
	G_LibChat_CommandSender	[G_LibChat_LastCommandId] = _Sender;
	G_LibChat_CommandName	[G_LibChat_LastCommandId] = _Name;
	G_LibChat_CommandParams	[G_LibChat_LastCommandId] = _Params;

	while (G_LibChat_CommandSender.count > C_LibChat_MaxCachedCommands) {
		declare Boolean Removed;
		foreach (CommandId => CommandSender in G_LibChat_CommandSender) {
			Removed = G_LibChat_CommandSender	.removekey(CommandId);
			Removed = G_LibChat_CommandName		.removekey(CommandId);
			Removed = G_LibChat_CommandParams	.removekey(CommandId);
		}
	}
}

// ---------------------------------- //
/** Get the clan number of a player.
 *
 *	@param	_Player		The player to get their clan.
 *
 *	@return		Clan of the player.
 */
Integer Private_GetClan(CPlayer _Player) {
	if (_Player == Null) return 0;

	declare CustomClan = Clans::GetPlayerClan(_Player);
	if (CustomClan > 0) return CustomClan;

	switchtype (_Player) {
		case CTmPlayer : return cast(CTmPlayer, _Player).CurrentClan;
		case CSmPlayer : return cast(CSmPlayer, _Player).CurrentClan;
	}
	return 0;
}

// ---------------------------------- //
/** Remove links in a message.
 *
 *	@param	_Segments	Segments of the message to format.
 *
 *	@return		All segments without links in them.
 */
Text[] Private_RemoveLinks(Text[] _Segments) {
	if (_Segments.count <= 0) return _Segments;
	declare Text[] OutputSegments;

	foreach (Segment in _Segments) {
		if (
			TL::Find("$l", Segment, True, False) ||
			TL::Find("$h", Segment, True, False) ||
			TL::Find("$p", Segment, True, False) ||
			TL::Find("http://", Segment, False, False) ||
			TL::Find("https://", Segment, False, False) ||
			TL::Find("maniaplanet://", Segment, False, False) ||
			TL::Find("www.", Segment, False, False)
		) {
			continue;
		}
		OutputSegments.add(Segment);
	}

	return OutputSegments;
}

// ---------------------------------- //
/** Parse links in a message.
 *
 *	@param	_Segments	Segments of the message to format.
 *
 *	@return		All segments with formatted links in them.
 */
Text[] Private_ParseLinks(Text[] _Segments) {
	if (_Segments.count <= 0) return _Segments;
	declare Text[] OutputSegments;

	foreach (_Segment in _Segments) {
		declare Segment = TL::StripFormatting(_Segment);

		// ---------------------------------- //
		// External links (http, https, www)
		if (
			TL::SubString(Segment, 0, 7) == "http://" ||
			TL::SubString(Segment, 0, 8) == "https://" ||
			TL::SubString(Segment, 0, 4) == "www."
		) {
			OutputSegments.add("$<$FA3$l"^Segment^"$>");
			continue;
		}

		// ---------------------------------- //
		// Internal links (maniaplanet, hashcodes)
		if (
			TL::SubString(Segment, 0, 14) == "maniaplanet://" ||
			TL::SubString(Segment, 0, 1) == "#"
		) {
			Segment = TL::Replace(Segment, "maniaplanet:///:", "");
			Segment = TL::Replace(Segment, "maniaplanet://", "");
			OutputSegments.add("$<$6BF$h"^Segment^"$>");
			continue;
		}

		// Normal segments
		OutputSegments.add(_Segment);
	}
	
	return OutputSegments;
}

// ---------------------------------- //
/** Parse badwords in a message.
 *
 *	@param	_Segments	Segments of the message to format.
 *
 *	@return		All segments with formatted badwords in them.
 */
Text[] Private_ParseBadWords(Text[] _Segments) {
	if (_Segments.count <= 0) return _Segments;
	declare Text[] OutputSegments;

	foreach (_Segment in _Segments) {
		declare Segment = TL::StripFormatting(_Segment);
		declare FoundBadWords = False;

		foreach (BadWord in C_LibChat_ForbiddenWords) {
			if (!TL::Find(BadWord, Segment, False, False)) continue;
			FoundBadWords = True;
			break;
		}

		if (!FoundBadWords) {
			OutputSegments.add(_Segment);
			continue;
		}

		declare Stars = "";
		for (I, 1, TL::Length(Segment)) Stars ^= "*";
		OutputSegments.add(Stars);
	}

	return OutputSegments;
}

// ---------------------------------- //
/** Parse the chat message.
 *
 *	@param	_Message	The message to format.
 *	@param	_Sender		Login of the message sender.
 *
 *	@return		The formatted message.
 */
Text Private_ParseMessage(Text _Message, Text _Sender) {
	if (TL::Length(_Message) <= 1) return _Message;
	declare Message = TL::Replace(_Message, "\n", " "); // Line breaking removal
	declare SplitMessage = TL::Split(" ", Message);

	if (ServerManager::ParseBadwords(_Sender))	SplitMessage = Private_ParseBadWords(SplitMessage);	// Parse badwords
	if (ServerManager::RemoveLinks(_Sender))	SplitMessage = Private_RemoveLinks(SplitMessage);	// Remove links
	else if (ServerManager::ParseLinks())		SplitMessage = Private_ParseLinks(SplitMessage);	// Parse links

	return TL::Join(" ", SplitMessage); // Remove spaces
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Set the custom chat visibility.
 *
 *	@param	_Visible	Whether the chat is visible or not.
 */
Void SetVisibility(Boolean _Visible) {
	declare netwrite Boolean Net_LibChat_UseCustomChat for Teams[0];
	Net_LibChat_UseCustomChat = _Visible;
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	Layers::Detach(C_LibChat_InterfaceLayerId);
	Layers::Destroy(C_LibChat_InterfaceLayerId);
}

// ---------------------------------- //
/** Load the library.
 *
 *	@param	_FontName	Name of the font used in chat.
 */
Void Load(Text _FontName) {
	Unload();
	SetVisibility(True);
	G_LibChat_InterfaceFont = _FontName;
	Layers::Create(C_LibChat_InterfaceLayerId, Private_CreateManialinkChat());
	Layers::Attach(C_LibChat_InterfaceLayerId);
}

// ---------------------------------- //
/// Load the library.
Void Load() {
	Load("");
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 */
Void SendMessage(Text _Message) {
	Private_SendMessage(_Message, Null);
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 */
Void SendMessage(CPlayer _Player, Text _Message) {
	if (_Player == Null) return;
	Private_SendMessage(_Player, _Message, Null);
}

// ---------------------------------- //
/** Send a message to a team.
 *
 *	@param	_Clan		Clan to send the message.
 *	@param	_Message	Message to send.
 */
Void SendMessage(Integer _Clan, Text _Message) {
	Private_SendMessage(_Message, Null, _Clan);
}

// ---------------------------------- //
/** Send a message to everyone.
 *
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(Text _Message, CPlayer _Sender) {
	Private_SendMessage(_Message, _Sender);
}

// ---------------------------------- //
/** Send a message to a player.
 *
 *	@param	_Player		Player to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(CPlayer _Player, Text _Message, CPlayer _Sender) {
	if (_Player == Null) return;
	Private_SendMessage(_Player, _Message, _Sender);
}

// ---------------------------------- //
/** Send a message to a team.
 *
 *	@param	_Clan		Clan to send the message.
 *	@param	_Message	Message to send.
 *	@param	_Sender		The message sender.
 */
Void SendMessage(Integer _Clan, Text _Message, CPlayer _Sender) {
	Private_SendMessage(_Message, _Sender, _Clan);
}

Void SendTranslated(CPlayer _Player, Text[] _Message) {
	if (_Player == Null || _Player.User.IsFakeUser || !_Message.existskey(0) || _Message[0] == "") return;
	declare Translated = Translations::Translate(_Player.User.Language, _Message);
	SendMessage(_Player, Translated);
}

Void SendTranslated(Text[] _Message) {
	if (!_Message.existskey(0) || _Message[0] == "") return;
	foreach (Player in AllPlayers) SendTranslated(Player, _Message);
}

// ---------------------------------- //
/** Get the pending chat commands.
 *
 *	@return		Pending commands.
 */
Integer[] PendingCommands() {
	return G_LibChat_PendingCommands;
}

// ---------------------------------- //
/** Get the command sender login.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command sender login.
 */
Text GetCommandSender(Integer _CommandId) {
	if (!G_LibChat_CommandSender.existskey(_CommandId)) return "";
	return G_LibChat_CommandSender[_CommandId];
}

// ---------------------------------- //
/** Get the command player.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command player.
 */
CPlayer GetCommandPlayer(Integer _CommandId) {
	declare CommandSender = GetCommandSender(_CommandId);
	if (CommandSender == "") return Null;
	foreach (Player in AllPlayers) if (Player.User.Login == CommandSender) return Player;
	return Null;
}

// ---------------------------------- //
/** Get the command name.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command name.
 */
Text GetCommandName(Integer _CommandId) {
	if (!G_LibChat_CommandName.existskey(_CommandId)) return "";
	return G_LibChat_CommandName[_CommandId];
}

// ---------------------------------- //
/** Get the command parameters.
 *
 *	@param	_CommandId	Id of the command.
 *
 *	@return		Command parameters.
 */
Text[] GetCommandParams(Integer _CommandId) {
	if (!G_LibChat_CommandParams.existskey(_CommandId)) return Text[];
	return G_LibChat_CommandParams[_CommandId];
}

// ---------------------------------- //
/** Event on new chat message.
 *
 *	@param	_Message	The message that has been sent.
 *	@param	_Sender		The player, who sent the message.
 */
Void Private_OnNewMessage(Text _Message, CPlayer _Sender) {
	if (_Sender == Null || _Message == "") return; 
	declare Message = _Message;
	
	// Check if message is a command
	declare IsCommand = TL::SubString(Message, 0, 1) == "/";
	
	// ---------------------------------- //
	// Handle commands
	if (IsCommand) {
		declare SplitCommand = TL::Split(" ", Message);
		if (!SplitCommand.existskey(0)) return;

		declare CommandSender = _Sender.User.Login;
		declare CommandName = SplitCommand[0];
		declare CommandParams = SplitCommand;
		declare Removed = CommandParams.remove(CommandName);
		CommandName = TL::Replace(CommandName, "/", "");

		Private_RegisterCommand(CommandSender, CommandName, CommandParams);
	}
	
	// ---------------------------------- //
	// Send global message
	else if (!ServerManager::IsMuted(_Sender.User.Login)) {
		declare SplitMessage = TL::Split(" ", Message);
		declare PremadeMsgCode = SplitMessage[0];

		// ---------------------------------- //
		// Premade short answers
		if (SplitMessage.count <= 2 && C_LibChat_PremadeMessages.existskey(PremadeMsgCode)) {
			Message = "$i"^C_LibChat_PremadeMessages[PremadeMsgCode];
			if (SplitMessage.existskey(1) && C_LibChat_PremadeWithRecipient.exists(PremadeMsgCode)) {
				declare TargetName = ServerManager::GetNameByLogin(SplitMessage[1]);
				if (SplitMessage[1] == "all") TargetName = "all";
				Message ^= " $<"^TargetName^"$>";
			}
			Message ^= "!";
		}

		else Message = TL::Join(" ", SplitMessage); // Spaces removal
		Message = Private_ParseMessage(Message, _Sender.User.Login);

		// Discord integration
		Discord::Send("LibChat", TL::StripFormatting(Message), TL::StripFormatting(_Sender.User.Name), "");

		if (Message == "") return;
		declare Messages = Text[];

		// ---------------------------------- //
		// Split too long text message
		if (TL::Length(Message) > C_LibChat_MessageMaxLength) {
			SplitMessage = TL::Split(" ", Message);
			declare CurrentPart = Text[];
			declare CurrentLength = 0;

			foreach (I => Segment in SplitMessage) {
				CurrentPart.add(Segment);
				CurrentLength += TL::Length(Segment) + 1;
				if (CurrentLength < C_LibChat_MessageMaxLength && I != SplitMessage.count - 1) continue;
				Messages.add(TL::Join(" ", CurrentPart));
				CurrentPart.clear();
				CurrentLength = 0;
			}
		}

		// Message wasn't split
		if (Messages.count <= 0) Messages = [Message];

		// Send chat message
		foreach (I => Segment in Messages) SendMessage(Segment, _Sender);
	}
}

// ---------------------------------- //
/** Set the Discord webhook URL.
 *
 * @param	_WebhookURL		The URL of the Discord webhook.
 */
Void SetDiscordWebhookURL(Text _WebhookURL) {
	Discord::DestroyWebhook("LibChat");
	Discord::CreateWebhook("LibChat", _WebhookURL);
	Discord::SetEscapeMentions("LibChat", True);
}

// ---------------------------------- //
/** Library loop.
 *
 *	@param	_UseCustomChat	Whether the chat is used or not.
 */
Void Loop(Boolean _UseCustomChat, Text _WebhookURL) {
	SetVisibility(_UseCustomChat);
	if (!_UseCustomChat) return;
	if (G_LibChat_PendingCommands.count > 0) G_LibChat_PendingCommands.clear();

	// Update webhook
	if (G_LibChat_DiscordWebhookURL != _WebhookURL) {
		G_LibChat_DiscordWebhookURL = _WebhookURL;
		SetDiscordWebhookURL(_WebhookURL);
	}

	// ---------------------------------- //
	// Manage events
	foreach (Event in UIManager.PendingEvents) {
		if (Event.Type == CUIConfigEvent::EType::OnLayerCustomEvent) {
			// ---------------------------------- //
			// User sends a message
			if (Event.CustomEventType == "LibChat_MessageSent" && Event.CustomEventData.existskey(0)) {
				declare Message = Event.CustomEventData[0];
				declare Sender = Private_GetPlayer(Event.UI);

				Private_OnNewMessage(Message, Sender);
			}
		}
	}

	// ---------------------------------- //
	// Manage some of the commands
	foreach (CommandId in PendingCommands()) {
		declare CommandPlayer	<=> GetCommandPlayer(CommandId);
		declare CommandName		= GetCommandName(CommandId);
		declare CommandParams	= GetCommandParams(CommandId);
		if (CommandPlayer == Null || CommandName == "") continue;

		switch (CommandName) {
			// ---------------------------------- //
			// Send team message
			case "t" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;
				if (!CommandParams.existskey(0)) continue;

				declare Message = TL::Join(" ", CommandParams);
				Message = Private_ParseMessage(Message, CommandPlayer.User.Login);

				// Discord integration
				Discord::Send("LibChat", TL::StripFormatting(Message), TL::StripFormatting(CommandPlayer.User.Name), "");

				declare PlayerClan = Private_GetClan(CommandPlayer);
				declare Messages = Text[];

				// ---------------------------------- //
				// Split too long text message
				if (TL::Length(Message) > C_LibChat_MessageMaxLength) {
					declare SplitMessage = TL::Split(" ", Message);
					declare CurrentPart = Text[];
					declare CurrentLength = 0;

					foreach (I => Segment in SplitMessage) {
						CurrentPart.add(Segment);
						CurrentLength += TL::Length(Segment) + 1;
						if (CurrentLength < C_LibChat_MessageMaxLength && I != SplitMessage.count - 1) continue;
						Messages.add(TL::Join(" ", CurrentPart));
						CurrentPart.clear();
						CurrentLength = 0;
					}
				}

				// Message wasn't split
				if (Messages.count <= 0) Messages = [Message];
				
				// Send chat message
				foreach (I => Segment in Messages) SendMessage(PlayerClan, Segment, CommandPlayer);
			}
			// ---------------------------------- //
			// Me command
			case "me" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;
				if (!CommandParams.existskey(0)) continue;

				declare Message = C_LibChat_MessageFormat_MeCmd;
				Message = TL::Replace(Message, "%1", CommandPlayer.User.Name);
				Message = TL::Replace(Message, "%2", TL::Join(" ", CommandParams));
				Message = Private_ParseMessage(Message, CommandPlayer.User.Login);
				SendMessage(Message);
			}
			// ---------------------------------- //
			// Private message
			case "pm" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;

				// Recipient or message missing
				if (CommandParams.count < 2) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Usage: /pm <recipient> <message>");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare Recipient <=> Private_GetPlayer(CommandParams[0]);

				// Recipient not found
				if (Recipient == Null) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: Recipient not found!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				// Sending message to self
				if (Recipient == CommandPlayer) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: Cannot send private message to self!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare Removed = CommandParams.removekey(0);
				declare MessageBody = TL::Join(" ", CommandParams);

				// Sender message
				declare SenderMessage = C_LibChat_MessageFormat_Outgoing;
				SenderMessage = TL::Replace(SenderMessage, "%1", Recipient.User.Name);
				SenderMessage = TL::Replace(SenderMessage, "%2", MessageBody);
				SendMessage(CommandPlayer, SenderMessage);

				// Recipient message
				declare RecipientMessage = C_LibChat_MessageFormat_Incoming;
				RecipientMessage = TL::Replace(RecipientMessage, "%1", CommandPlayer.User.Name);
				RecipientMessage = TL::Replace(RecipientMessage, "%2", MessageBody);
				SendMessage(Recipient, RecipientMessage);

				// Save latest conversation
				declare Text LastPrivateMessageLogin as SenderRecipientLogin for CommandPlayer;
				declare Text LastPrivateMessageLogin as RecipientSenderLogin for Recipient;
				SenderRecipientLogin = Recipient.User.Login;
				RecipientSenderLogin = CommandPlayer.User.Login;
			}
			// ---------------------------------- //
			// Private message reply
			case "pmr" : {
				if (ServerManager::IsMuted(CommandPlayer.User.Login)) continue;

				// Message missing
				if (CommandParams.count < 1) {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Usage: /pmr <message>");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				// No active conversation yet
				declare Text LastPrivateMessageLogin for CommandPlayer;
				if (LastPrivateMessageLogin == "") {
					declare ErrorMessage = C_LibChat_MessageFormat_Error;
					ErrorMessage = TL::Replace(ErrorMessage, "%1", "Error: You don't have an active conversation yet!");
					SendMessage(CommandPlayer, ErrorMessage);
					continue;
				}

				declare NewCommandParams = [LastPrivateMessageLogin];
				foreach (Param in CommandParams) NewCommandParams.add(Param);
				Private_RegisterCommand(CommandPlayer.User.Login, "pm", NewCommandParams);
			}
			

			default : {
				ServerManager::OnChatCommand(CommandPlayer, CommandName, CommandParams);
			}
		}
	}

	// ---------------------------------- //
	// Server manager custom messages
	while (ServerManager::PendingChatMessages()) {
		foreach (RecipientId => MessageBody in ServerManager::PendingMessage()) {
			if (!MessageBody.existskey(0) || MessageBody[0] == "") break;
			declare CPlayer Recipient;

			if (RecipientId != NullId) {
				if (!AllPlayers.existskey(RecipientId)) break;
				Recipient = AllPlayers[RecipientId];
			}

			if (Recipient != Null) SendTranslated(Recipient, MessageBody);
			else SendTranslated(MessageBody);
		}
	}
}

Void Loop(Boolean _UseCustomChat) {
	Loop(_UseCustomChat, "");
}

// ---------------------------------- //
/// Library loop.
Void Loop() {
	Loop(True);
}