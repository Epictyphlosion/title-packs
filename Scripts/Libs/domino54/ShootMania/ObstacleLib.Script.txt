// -------------------------------------- //
//  LIBRARY OBSTACLE by domino54          //
//  script version: 2017-05-21            //
// -------------------------------------- //

/**
 *	Library used to handle race-related functions in Obstacle v2 game mode.
 */

#Const	Version		"2017-05-21"
#Const	ScriptName	"Libs/domino54/ShootMania/ObstacleLib.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/Nadeo/ShootMania/SM2.Script.txt" as SM
// Custom libs
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/" 
#Const C_LibObstacle_WidgetsRotation	2.		///< Rotation of the Armor and Ammo gauge widgets
#Const C_LibObstacle_FrameHideawayPos	-16.	///< Offset for hiding gauges below the bottom screen edge
#Const C_LibObstacle_InvalidTimeColor	<1., .5, 0.>
#Const C_LibObstacle_DiffColorAhead		<.25, .75, 1.>
#Const C_LibObstacle_DiffColorLate		<1., .125, 0.>

#Const C_LibObstacle_ChronoPos	<-154., -84.>
#Const C_LibObstacle_CPDiffPos	<0., 54.>

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[] G_LibObstacle_CurMapSpawnPoints;
declare Ident[][Integer] G_LibObstacle_CurMapCheckpoints;
declare Ident[] G_LibObstacle_CurMapFinishLines;
declare Boolean G_LibObstacle_MapIsLapRace;
declare Integer G_LibObstacle_MapNbLaps;
declare Integer G_LibObstacle_ModeNbLaps;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for chrono module.
 *
 *	@return		The chrono manialink.
 */
Text Private_CreateManialinkChrono() {
	return """
<manialink version="3" name="LibObstacle:Chrono">
<stylesheet>
	<style class="count" valign="center2" textsize="6" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="desc" valign="center2" textsize="1" textemboss="1" textfont="Eurostile_Bold" />
</stylesheet>

<frame id="Frame_HMDClip" size="320 180" halign="center" valign="center">

<frame id="Frame_WidgetChrono" pos="{{{C_LibObstacle_ChronoPos.X^" "^C_LibObstacle_ChronoPos.Y + C_LibObstacle_FrameHideawayPos}}}" rot="{{{-C_LibObstacle_WidgetsRotation}}}" z-index="10">
	<quad pos="0 -.25" size="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/StopwatchGauge.png" id="Quad_TimerGauge" />
	<quad pos="0 -.25" size="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/Stopwatch.png" />
	
	<label pos="5 1.5" class="count" id="Label_ChronoValue" text="0:00.000" />
	
	<frame pos="5 -2.75">
		<label class="desc" id="Label_ChronoInfoText" />
		<label class="desc" id="Label_ChronoInfoGhost" />
	</frame>
</frame>

</frame>
<script><!--
/**
 *	LibObstacle: Chrono
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_WidgetChrono	<=> (Page.GetFirstChild("Frame_WidgetChrono") as CMlFrame);
declare Label_ChronoValue	<=> (Page.GetFirstChild("Label_ChronoValue") as CMlLabel);
declare Label_ChronoInfoText	<=> (Page.GetFirstChild("Label_ChronoInfoText") as CMlLabel);
declare Label_ChronoInfoGhost	<=> (Page.GetFirstChild("Label_ChronoInfoGhost") as CMlLabel);
declare Quad_TimerGauge		<=> (Page.GetFirstChild("Quad_TimerGauge") as CMlQuad);

// ---------------------------------- //
// Variables
declare DisplayChrono = True;
declare ChronoVisible = False;
declare InterfaceColor = 0.;
declare BrightTextColor = <1., 1., 1.>;
declare ChronoDescription = "";

/// Update
declare PrevChronoVisible = False;
declare PrevInterfaceColor = -1.;
declare PrevChronoDescription = "!";
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
ChronoVisible = DisplayChrono && GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>;

// ---------------------------------- //
// Update chrono visibility
if (PrevChronoVisible != ChronoVisible) {
	PrevChronoVisible = ChronoVisible;

	declare Easing = CAnimManager::EAnimManagerEasing::BackOut;
	declare Position = <Frame_WidgetChrono.RelativePosition_V3.X, {{{C_LibObstacle_ChronoPos.Y}}}>;

	if (!ChronoVisible) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.Y += {{{C_LibObstacle_FrameHideawayPos}}};
	}
	
	AnimMgr.Add(Frame_WidgetChrono, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

if (!ChronoVisible) continue;

// ---------------------------------- //
// Get the interface color from the player
if (GUIPlayer != Null && InterfaceColor != GUIPlayer.GetLinearHue) InterfaceColor = GUIPlayer.GetLinearHue;

// ---------------------------------- //
// Set interface color
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	declare NewUIColor = HsvToRgb(<ML::Clamp(InterfaceColor, 0., 1.), 1., 1.>);
	BrightTextColor = Brightness(NewUIColor, 2.);
}

// ---------------------------------- //
// Display current run time
declare netread Integer Net_LibObstacle_RunStartTime for GUIPlayer.Score;
declare netread Boolean Net_LibObstacle_IsCurRunInvalid for GUIPlayer.Score;

declare RaceTime = ML::Max(GameTime - Net_LibObstacle_RunStartTime, 0);

if (Net_LibObstacle_RunStartTime <= 0) {
	Label_ChronoValue.Value = TimeToText(0, True);
	Quad_TimerGauge.RelativeRotation = 0.;
}
else {
	Label_ChronoValue.Value = TimeToText(RaceTime, True);
	Quad_TimerGauge.RelativeRotation = 360. * RaceTime / 60000;
}

// ---------------------------------- //
// Change color depending on current run validation
if (Net_LibObstacle_IsCurRunInvalid) {
	Label_ChronoValue.TextColor = {{{C_LibObstacle_InvalidTimeColor}}};
	Label_ChronoInfoText.TextColor = {{{C_LibObstacle_InvalidTimeColor}}};
	Label_ChronoInfoGhost.TextColor = {{{C_LibObstacle_InvalidTimeColor}}};
	ChronoDescription = "Invalid time";
}
else {
	Label_ChronoValue.TextColor = <1., 1., 1.>;
	Label_ChronoInfoText.TextColor = BrightTextColor;
	Label_ChronoInfoGhost.TextColor = BrightTextColor;
	ChronoDescription = "Race time";
}

// ---------------------------------- //
// Update Armor module information text
if (PrevChronoDescription != ChronoDescription) {
	PrevChronoDescription = ChronoDescription;

	Label_ChronoInfoGhost.Value = Label_ChronoInfoText.Value;
	Label_ChronoInfoText.Value = ReplaceChars(TL::ToUpperCase(TL::GetTranslatedText(ChronoDescription)));
	
	Label_ChronoInfoText.Opacity = 0.;
	Label_ChronoInfoText.RelativePosition_V3.Y = 1.5;
	Label_ChronoInfoGhost.Opacity = 1.;
	Label_ChronoInfoGhost.RelativePosition_V3.Y = 0.;
	
	AnimMgr.Add(Label_ChronoInfoText, "<label pos='0 0' opacity='1' />", 200, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Label_ChronoInfoGhost, "<label pos='0 -1.5' opacity='0' />", 200, CAnimManager::EAnimManagerEasing::Linear);
}
***

{{{ManialinkTools::Functions(["ReplaceChars", "Brightness", "HsvToRgb", "TimeToText"])}}}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Create manialink for checkpoint difference module.
 *
 *	@return		The checkpoint difference manialink.
 */
Text Private_CreateManialinkCheckpointDiff() {
	return """
<manialink version="3" name="LibObstacle:CheckpointDiff">
<stylesheet>
	<style class="F" halign="center" valign="center2" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
</stylesheet>

<frame id="Frame_CurCheckpointTime" pos="{{{C_LibObstacle_CPDiffPos.X^" "^C_LibObstacle_CPDiffPos.Y}}}">
	<label pos="0 2.5" class="F" textsize="5" opacity="0" id="Label_CurCheckpointNb" />
	<label pos="0 -2.5" class="F" textsize="3" opacity="0" id="Label_CurCheckpointTime" />
</frame>

<framemodel id="FrameModel_CheckpointDiff">
	<label pos="0" class="F" textsize="4" opacity="0" id="Label_CheckpointDiffTime" />
	<label pos="0 -3.5" class="F" textsize="1" opacity="0" id="Label_CheckpointDiffName" />
</framemodel>

<frame id="Frame_CheckpointDiffs" pos="{{{C_LibObstacle_CPDiffPos.X^" "^C_LibObstacle_CPDiffPos.Y - 10}}}">
	<frame id="Frame_CheckpointDiffOffset">
		<frameinstance modelid="FrameModel_CheckpointDiff" id="Frame_CheckpointDiff#0" pos="0" />
		<frameinstance modelid="FrameModel_CheckpointDiff" id="Frame_CheckpointDiff#1" pos="36" />
		<frameinstance modelid="FrameModel_CheckpointDiff" id="Frame_CheckpointDiff#2" pos="72" />
		<frameinstance modelid="FrameModel_CheckpointDiff" id="Frame_CheckpointDiff#3" pos="108" />
	</frame>
</frame>

<script><!--
/**
 *	LibObstacle: CheckpointDiff
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_CheckpointSoundBase	"{{{C_ImgBase}}}Sounds/checkpoint-time.wav"
#Const C_CheckpointSoundAhead	"{{{C_ImgBase}}}Sounds/checkpoint-yes.wav"
#Const C_CheckpointSoundLate	"{{{C_ImgBase}}}Sounds/checkpoint-no.wav"

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_CurCheckpointTime		<=> (Page.GetFirstChild("Frame_CurCheckpointTime") as CMlFrame);
declare Label_CurCheckpointNb		<=> (Page.GetFirstChild("Label_CurCheckpointNb") as CMlLabel);
declare Label_CurCheckpointTime		<=> (Page.GetFirstChild("Label_CurCheckpointTime") as CMlLabel);
declare Frame_CheckpointDiffOffset	<=> (Page.GetFirstChild("Frame_CheckpointDiffOffset") as CMlFrame);

declare CMlFrame[] Frame_CheckpointDiffs;
for (I, 0, 3) Frame_CheckpointDiffs.add((Page.GetFirstChild("Frame_CheckpointDiff#"^I) as CMlFrame));

// ---------------------------------- //
// Network
declare netread Integer Net_LibObstacle_MapNbCheckpoints for Teams[0];
declare netread Integer Net_LibObstacle_ModeNbLaps for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayCheckpointDiff = True;
declare CheckpointDiffVisible = False;
declare CheckpointDiffDisplayEndTime = -1;
declare CheckpointDiffsShown = 0;

/// Update
declare PrevCheckpointUpdate = -1;
declare PrevCheckpointDiffVisible = False;
declare PrevGUIPlayerId = NullId;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Trigger checkpoint diff display
if (DisplayCheckpointDiff && (GUIPlayer != Null || InputPlayer != Null)) {
	declare Player <=> GUIPlayer;
	if (GUIPlayer == Null) Player <=> InputPlayer;

	declare netread Integer Net_LibObstacle_CheckpointUpdate for Player;

	if (PrevCheckpointUpdate != Net_LibObstacle_CheckpointUpdate) {
		PrevCheckpointUpdate = Net_LibObstacle_CheckpointUpdate;

		// ---------------------------------- //
		// Display the time difference
		if (PrevGUIPlayerId == Player.Id) {
			CheckpointDiffDisplayEndTime = Now + 3000;

			declare netread Integer Net_LibObstacle_LatestCPTime for Player;
			declare netread Integer Net_LibObstacle_LatestCPOrder for Player.Score;
			declare netread Integer Net_LibObstacle_RaceNbLaps for Player.Score;
			declare netread Integer Net_LibObstacle_LatestCPPosition for Player;
			declare netread Boolean Net_LibObstacle_LatestCPIsBetter for Player;
			declare netread Integer[Text] Net_LibObstacle_CPTimeDiffs for Player;

			declare CheckpointOrder = Net_LibObstacle_LatestCPOrder % (Net_LibObstacle_MapNbCheckpoints + 1);
			Label_CurCheckpointTime.Value = TimeToText(Net_LibObstacle_LatestCPTime, True);

			// Append position
			if (Net_LibObstacle_LatestCPPosition > 0)
				Label_CurCheckpointTime.Value = Net_LibObstacle_LatestCPPosition^") "^Label_CurCheckpointTime.Value;

			// ---------------------------------- //
			// Checkpoint / Lap
			if (CheckpointOrder > 0 || Net_LibObstacle_RaceNbLaps < Net_LibObstacle_ModeNbLaps) {
				if (CheckpointOrder > 0)
					Label_CurCheckpointNb.Value = TL::ToUpperCase(TL::Compose(
						"%1 "^CheckpointOrder^"/"^Net_LibObstacle_MapNbCheckpoints,
						TL::GetTranslatedText("Checkpoint")
					));
				else
					Label_CurCheckpointNb.Value = TL::ToUpperCase(ReplaceChars(TL::Compose(
						TL::GetTranslatedText("Lap %1"),
						Net_LibObstacle_RaceNbLaps^"/"^Net_LibObstacle_ModeNbLaps
					)));

				// Play checkpoint sound
				declare CPSound = C_CheckpointSoundAhead;
				if (!Net_LibObstacle_LatestCPIsBetter) CPSound = C_CheckpointSoundLate;
				Audio.PlaySoundEvent(C_CheckpointSoundBase, -7.5);
				Audio.PlaySoundEvent(CPSound, -12.5, 250);
			}
			// ---------------------------------- //
			// Goal
			else {
				Label_CurCheckpointNb.Value = TL::ToUpperCase(TL::Compose(TL::GetTranslatedText("|BlockInfo|Finish")));

				// Play finish sound
				declare Variant = 0;
				if (!Net_LibObstacle_LatestCPIsBetter) Variant = 1;
				PlayUiSound(::EUISound::Finish, Variant, 1.);
			}

			// ---------------------------------- //
			// Display time differences
			declare CheckpointDiffsTimes = Integer[];
			declare CheckpointDiffsNames = Text[];

			foreach (DiffName => DiffTime in Net_LibObstacle_CPTimeDiffs) {
				CheckpointDiffsTimes.add(DiffTime);
				CheckpointDiffsNames.add(DiffName);
			}

			// ---------------------------------- //
			// Local personal best
			if (Player.User == LocalUser) {
				declare CPPB = ObstaclePB_GetCheckpoint(Net_LibObstacle_LatestCPOrder);
				if (CPPB > 0) {
					CheckpointDiffsTimes.add(Net_LibObstacle_LatestCPTime - CPPB);
					CheckpointDiffsNames.add("PB");
				}
			}

			if (CheckpointDiffsShown < CheckpointDiffsTimes.count) CheckpointDiffsShown = CheckpointDiffsTimes.count;

			// ---------------------------------- //
			// Format difference
			foreach (I => Frame in Frame_CheckpointDiffs) {
				declare Label_CheckpointDiffTime <=> (Frame.GetFirstChild("Label_CheckpointDiffTime") as CMlLabel);
				declare Label_CheckpointDiffName <=> (Frame.GetFirstChild("Label_CheckpointDiffName") as CMlLabel);

				if (I >= CheckpointDiffsShown) {
					Label_CheckpointDiffTime.Opacity = 0.;
					Label_CheckpointDiffName.Opacity = 0.;
					continue;
				}

				declare TimeDiff = CheckpointDiffsTimes[I];
				Label_CheckpointDiffTime.Value = TimeToText(TimeDiff, True);

				// Add "+" for worse time
				if (TimeDiff > 0)  Label_CheckpointDiffTime.Value = "+"^Label_CheckpointDiffTime.Value;

				// Set the color
				if (TimeDiff <= 0) {
					Label_CheckpointDiffTime.TextColor = {{{C_LibObstacle_DiffColorAhead}}};
					Label_CheckpointDiffName.TextColor = {{{C_LibObstacle_DiffColorAhead}}};
				} else {
					Label_CheckpointDiffTime.TextColor = {{{C_LibObstacle_DiffColorLate}}};
					Label_CheckpointDiffName.TextColor = {{{C_LibObstacle_DiffColorLate}}};
				}

				// Get the difference name
				declare DifferenceName = "Difference";
				switch (CheckpointDiffsNames[I]) {
					case "Best" : DifferenceName = "Best time";
					case "Leader" : DifferenceName = "Leader";
					case "PB" : DifferenceName = "Personal best";
				}
				Label_CheckpointDiffName.Value = TL::ToUpperCase(TL::GetTranslatedText(DifferenceName));

				Frame.RelativeScale = 1.125;
				Label_CheckpointDiffTime.Opacity = 0.;
				Label_CheckpointDiffName.Opacity = 0.;

				declare Easing = CAnimManager::EAnimManagerEasing::SineOut;
				declare Delay = Now + (I + 1) * 100;
				AnimMgr.Add(Frame, "<frame scale='1' />", Delay, 125, Easing);
				AnimMgr.Add(Label_CheckpointDiffTime, "<label opacity='1' />", Delay, 125, Easing);
				AnimMgr.Add(Label_CheckpointDiffName, "<label opacity='1' />", Delay, 125, Easing);
			}

			declare Offset = 0.;
			if (CheckpointDiffsTimes.count >= 2) Offset = ((CheckpointDiffsTimes.count - 1) * -36.) / 2;
			Frame_CheckpointDiffOffset.RelativePosition_V3.X = Offset;
		}
	}
}

// Prevents from showing diff for incorrect player
if (GUIPlayer != Null && PrevGUIPlayerId != GUIPlayer.Id) PrevGUIPlayerId = GUIPlayer.Id;

// ---------------------------------- //
// Set the checkpoint diff visibility
CheckpointDiffVisible = DisplayCheckpointDiff && Now <= CheckpointDiffDisplayEndTime;

if (PrevCheckpointDiffVisible != CheckpointDiffVisible) {
	PrevCheckpointDiffVisible = CheckpointDiffVisible;

	declare CAnimManager::EAnimManagerEasing Easing;
	declare Real Opacity;
	declare Real Scale;

	if (CheckpointDiffVisible) {
		Easing = CAnimManager::EAnimManagerEasing::SineOut;
		Opacity = 1.;
		Scale = 1.;
		Frame_CurCheckpointTime.RelativeScale = 1.125;
		Label_CurCheckpointNb.Opacity = 0.;
		Label_CurCheckpointTime.Opacity = 0.;
	} else {
		Easing = CAnimManager::EAnimManagerEasing::SineIn;
		Opacity = 0.;
		Scale = .75;
		Frame_CurCheckpointTime.RelativeScale = 1.;
		Label_CurCheckpointNb.Opacity = 1.;
		Label_CurCheckpointTime.Opacity = 1.;

		foreach (I => Frame in Frame_CheckpointDiffs) {
			if (I >= CheckpointDiffsShown) break;
			declare Label_CheckpointDiffTime <=> (Frame.GetFirstChild("Label_CheckpointDiffTime") as CMlLabel);
			declare Label_CheckpointDiffName <=> (Frame.GetFirstChild("Label_CheckpointDiffName") as CMlLabel);

			Frame.RelativeScale = 1.;
			Label_CheckpointDiffTime.Opacity = 1.;
			Label_CheckpointDiffName.Opacity = 1.;

			declare Delay = Now + (I + 1) * 100;
			AnimMgr.Add(Frame, "<frame scale='"^Scale^"' />", Delay, 125, Easing);
			AnimMgr.Add(Label_CheckpointDiffTime, "<label opacity='"^Opacity^"' />", Delay, 125, Easing);
			AnimMgr.Add(Label_CheckpointDiffName, "<label opacity='"^Opacity^"' />", Delay, 125, Easing);
		}
		CheckpointDiffsShown = 0;
	}
	
	AnimMgr.Add(Frame_CurCheckpointTime, "<frame scale='"^Scale^"' />", 125, Easing);
	AnimMgr.Add(Label_CurCheckpointNb, "<label opacity='"^Opacity^"' />", 125, Easing);
	AnimMgr.Add(Label_CurCheckpointTime, "<label opacity='"^Opacity^"' />", 125, Easing);
}
***

// ---------------------------------- //
/** Get the time of a checkpoint from personal best time.
 *
 *	@param	_Checkpoint		The checkpoint to get time.
 *
 *	@return		The time on a checkpoint.
 */
Integer ObstaclePB_GetCheckpoint(Integer _Checkpoint) {
	declare persistent Integer[][Text] Persistent_LibObstacle_PBMapCheckpoints for LocalUser;
	if (!Persistent_LibObstacle_PBMapCheckpoints.existskey(Map.MapInfo.MapUid)) return -1;
	if (!Persistent_LibObstacle_PBMapCheckpoints[Map.MapInfo.MapUid].existskey(_Checkpoint - 1)) return -1;
	return Persistent_LibObstacle_PBMapCheckpoints[Map.MapInfo.MapUid][_Checkpoint - 1];
}

{{{ManialinkTools::Functions(["Brightness", "TimeToText", "ReplaceChars"])}}}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Create manialink for the markers module.
 *
 *	@return		The the markers manialink.
 */
Text Private_CreateManialinkMarkers() {
	declare MarkersFrames = "";
	for (I, 0, 9) MarkersFrames ^= "<frameinstance modelid='FrameModel_CPMarker' id='Frame_CPMarker#"^I^"' hidden='1' />";

	declare R = 9/16.;
	return """
<manialink version="3" name="LibObstacle:Markers">
<stylesheet>
	<style class="text" halign="center" valign="center2" textsize=".125" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
</stylesheet>

<framemodel id="FrameModel_CPMarker">
	<frame id="Frame_MarkerVisibility">
		<label pos="0 2.5" class="text" id="Label_MarkerDistance" />
		<label pos="0 .5" class="text" scale="1.5" id="Label_MarkerGoalName" />
		<quad pos="0 3" size="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon" colorize="FFF" />
	</frame>
</framemodel>
<frame id="Frame_CPMarkersFrame">
	{{{MarkersFrames}}}
</frame>

<script><!--
/**
 *	LibObstacle: Markers
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

{{{ManialinkTools::Functions(["Brightness", "HsvToRgb"])}}}

main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_CPMarkersFrame <=> (Page.GetFirstChild("Frame_CPMarkersFrame") as CMlFrame);

	declare CMlFrame[] Frame_CPMarkers;
	for (I, 0, 9) Frame_CPMarkers.add((Page.GetFirstChild("Frame_CPMarker#"^I) as CMlFrame));

	// ---------------------------------- //
	// Netcode
	declare netread Integer Net_LibObstacle_MapNbCheckpoints for Teams[0];

	// ---------------------------------- //
	// Variables
	declare MapCheckpoints = Vec3[][Integer];
	declare MapPortals = Vec3[];

	/// Update
	declare PrevMarkersVisible = False;
	declare PrevPlayerCheckpoint = -1;
	declare PrevGUIPlayerColor = -1.;

	// Reset markers
	ClientUI.MarkersXML = "";

	// ---------------------------------- //
	// Load map information
	foreach (MapLandmark in MapLandmarks) {
		if (!TL::Find("Checkpoint", MapLandmark.Tag, True, True) && !TL::Find("Portal", MapLandmark.Tag, True, True)) continue;
		if (!MapCheckpoints.existskey(MapLandmark.Order)) MapCheckpoints[MapLandmark.Order] = Vec3[];
		MapCheckpoints[MapLandmark.Order].add(MapLandmark.Position);
		if (MapLandmark.Tag == "Portal" || MapLandmark.Tag == "PortalEntrance") MapPortals.add(MapLandmark.Position);
	}
	foreach (MapLandmark in MapLandmarks) if (MapLandmark.Tag == "Goal") {
		if (!MapCheckpoints.existskey(0)) MapCheckpoints[0] = Vec3[];
		MapCheckpoints[0].add(MapLandmark.Position);
	}

	while (True) {
		yield;

		// ---------------------------------- //
		// Update markers visibility
		Frame_CPMarkersFrame.Visible = GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>;

		if (PrevMarkersVisible != Frame_CPMarkersFrame.Visible) {
			PrevMarkersVisible = Frame_CPMarkersFrame.Visible;
			ClientUI.MarkersXML = "";
			PrevPlayerCheckpoint = -1;
		}

		if (!Frame_CPMarkersFrame.Visible) continue;

		// ---------------------------------- //
		// Update the color of the interface
		if (PrevGUIPlayerColor != GUIPlayer.GetLinearHue) {
			PrevGUIPlayerColor = GUIPlayer.GetLinearHue;

			declare NewUIColor = HsvToRgb(<ML::Clamp(PrevGUIPlayerColor, 0., 1.), 1., 1.>);
			declare BrightTextColor = Brightness(NewUIColor, 2.);

			foreach (Frame in Frame_CPMarkers) {
				declare Label_MarkerGoalName <=> (Frame.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
				declare Quad_MarkerIcon <=> (Frame.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
				Label_MarkerGoalName.TextColor = BrightTextColor;
				Quad_MarkerIcon.Colorize = NewUIColor;
			}
		}

		// ---------------------------------- //
		// Show the distance to the marker landmark
		foreach (I => Frame in Frame_CPMarkers) {
			declare Frame_MarkerVisibility <=> (Frame.GetFirstChild("Frame_MarkerVisibility") as CMlFrame);
			if (!Frame_MarkerVisibility.Visible) continue;
			declare Label_MarkerDistance <=> (Frame.GetFirstChild("Label_MarkerDistance") as CMlLabel);
			declare Vec3 MapLandmarkPosition for Frame;
			Label_MarkerDistance.Value = "$n"^ML::FloorInteger(ML::Distance(GUIPlayer.Position, MapLandmarkPosition))^" M";
		}

		// Wait for a checkpoint change
		declare netread Integer Net_LibObstacle_LatestCPOrder for GUIPlayer.Score;
		if (PrevPlayerCheckpoint == Net_LibObstacle_LatestCPOrder) continue;
		PrevPlayerCheckpoint = Net_LibObstacle_LatestCPOrder;
		declare NextCheckpointOrder = (PrevPlayerCheckpoint + 1) % (Net_LibObstacle_MapNbCheckpoints + 1);
		
		// Reset markers
		ClientUI.MarkersXML = "";

		// ---------------------------------- //
		// Create markers for the landmarks
		foreach (I => Frame in Frame_CPMarkers) {
			declare Frame_MarkerVisibility <=> (Frame.GetFirstChild("Frame_MarkerVisibility") as CMlFrame);
			Frame_MarkerVisibility.Visible = MapCheckpoints.existskey(NextCheckpointOrder) && I < MapCheckpoints[NextCheckpointOrder].count;
			if (!Frame_MarkerVisibility.Visible) continue;

			// Get the landmark position
			declare Vec3 MapLandmarkPosition for Frame;
			MapLandmarkPosition = MapCheckpoints[NextCheckpointOrder][I];

			// ---------------------------------- //
			// Configure the landmark marker
			declare OffsetY = 2.;
			declare MarkerLabel = TL::GetTranslatedText("Checkpoint")^" #"^NextCheckpointOrder;
			if (NextCheckpointOrder == 0) {
				OffsetY = 27.5;
				MarkerLabel = TL::GetTranslatedText("|BlockInfo|Finish");
			}
			else if (MapPortals.exists(MapLandmarkPosition)) {
				MarkerLabel = TL::GetTranslatedText("Portal")^" #"^NextCheckpointOrder;
			}

			// Set the marker label
			declare Label_MarkerGoalName <=> (Frame.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
			Label_MarkerGoalName.Value = "$n"^TL::ToUpperCase(MarkerLabel);

			// Create the marker
			declare Pos = MapLandmarkPosition.X^" "^MapLandmarkPosition.Y + OffsetY^" "^MapLandmarkPosition.Z;
			ClientUI.MarkersXML ^= "<marker manialinkframeid='Frame_CPMarker#"^I^"' pos='"^Pos^"' visibility='WhenInFrustum' minimapvisibility='Never' />";
		}
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Create manialink for the personal best module.
 *
 *	@return		The the personal best manialink.
 */
Text Private_CreateManialinkPersonalBest() {
	return """
<manialink version="3" name="LibObstacle:PersonalBest">
<script><!--
/**
 *	LibObstacle: PersonalBest
 */

#Include "MathLib" as ML

main() {
	// ---------------------------------- //
	// Network
	declare netread Integer Net_LibObstacle_MapNbCheckpoints for Teams[0];
	declare netread Integer Net_LibObstacle_LastPBUpdateTime for UI;
	declare netread Integer Net_LibObstacle_PBTimeTotal for UI;
	declare netread Integer Net_LibObstacle_PBNbRespawns for UI;
	declare netread Integer[] Net_LibObstacle_PBCheckpoints for UI;
	declare netread Text Net_LibObstacle_PBMapUID for UI;

	// ---------------------------------- //
	// Persistent data
	declare persistent Integer[][Text] Persistent_LibObstacle_PBMapCheckpoints for LocalUser;
	declare persistent Integer[Text] Persistent_LibObstacle_PBMapBestTimes for LocalUser;
	declare persistent Integer[Text] Persistent_LibObstacle_PBMapNbRespawns for LocalUser;

	/// Update
	declare PrevPBUpdateTime = -2;

	while (True) {
		yield;

		// Wait for Personal Best update
		if (PrevPBUpdateTime == Net_LibObstacle_LastPBUpdateTime) continue;
		PrevPBUpdateTime = Net_LibObstacle_LastPBUpdateTime;

		// Check if the map's UID is matching
		declare UID = Map.MapInfo.MapUid;
		if (Map == Null || Net_LibObstacle_PBMapUID != UID) continue;

		// Return if the time or checkpoints are invalid
		if (Net_LibObstacle_PBTimeTotal <= 0) continue;
		if (Net_LibObstacle_PBCheckpoints.count <= Net_LibObstacle_MapNbCheckpoints) continue;

		// PB already exists and is faster
		if (Persistent_LibObstacle_PBMapBestTimes.existskey(UID) &&
			Persistent_LibObstacle_PBMapBestTimes[UID] < Net_LibObstacle_PBTimeTotal) continue;
		
		// Save new Personal Best
		Persistent_LibObstacle_PBMapBestTimes[UID] = Net_LibObstacle_PBTimeTotal;
		Persistent_LibObstacle_PBMapCheckpoints[UID] = Net_LibObstacle_PBCheckpoints;
		Persistent_LibObstacle_PBMapNbRespawns[UID] = ML::Max(Net_LibObstacle_PBNbRespawns, 0);
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Display the checkpoint time and difference to a player.
 *
 *	@param	_Player		The player to show checkpoint time.
 *	@param	_CPTime		Time of the activated checkpoint.
 *	@param	_Position	Player's time position on the activated checkpoint.
 *	@param	_IsBetter	Whether the time is better than previous or the leader's time.
 *	@param	_CPDiffs	Time differences to display ["Best", "Leader", "ObsMania"].
 */
Void Private_DisplayCPDiff(CSmPlayer _Player, Integer _CPTime, Integer _Position, Boolean _IsBetter, Integer[Text] _CPDiffs) {
	if (_Player == Null || _CPTime <= 0) return;

	declare netwrite Integer Net_LibObstacle_CheckpointUpdate for _Player;
	declare netwrite Integer Net_LibObstacle_LatestCPTime for _Player;
	declare netwrite Integer Net_LibObstacle_LatestCPPosition for _Player;
	declare netwrite Boolean Net_LibObstacle_LatestCPIsBetter for _Player;
	declare netwrite Integer[Text] Net_LibObstacle_CPTimeDiffs for _Player;

	Net_LibObstacle_CheckpointUpdate = Now;
	Net_LibObstacle_LatestCPTime = _CPTime;
	Net_LibObstacle_LatestCPPosition = _Position;
	Net_LibObstacle_LatestCPIsBetter = _IsBetter;
	Net_LibObstacle_CPTimeDiffs = _CPDiffs;
}

// ---------------------------------- //
/** Update the current player checkpoint.

 *	@param	_Player		The player to update checkpoint.
 *	@param	_CpOrder	Order of the current checkpoint.
 */
Void Private_SetPlayerCpOrder(CSmPlayer _Player, Integer _CpOrder) {
	if (_Player == Null) return;

	declare netwrite Integer Net_LibObstacle_LatestCPOrder for _Player.Score;
	Net_LibObstacle_LatestCPOrder = ML::Max(_CpOrder, 0);
}

// ---------------------------------- //
/** Update the current player amount of laps.

 *	@param	_Player		The player to update laps amount.
 *	@param	_NbLaps		The amount of laps player has finished.
 */
Void Private_SetPlayerNbLaps(CSmPlayer _Player, Integer _NbLaps) {
	if (_Player == Null) return;

	declare netwrite Integer Net_LibObstacle_RaceNbLaps for _Player.Score;
	Net_LibObstacle_RaceNbLaps = ML::Max(_NbLaps, 0);
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/// Initialize current map.
Void InitMap() {
	G_LibObstacle_CurMapSpawnPoints.clear();
	G_LibObstacle_CurMapCheckpoints.clear();
	G_LibObstacle_CurMapFinishLines.clear();
	G_LibObstacle_MapIsLapRace = False;
	G_LibObstacle_MapNbLaps = 1;

	// ---------------------------------- //
	// Get map spawn points
	declare Ident[Integer] MapStartPoints;
	foreach (MapLandmark in MapLandmarks_PlayerSpawn)
		if (MapLandmark.Tag == "Spawn" && !MapStartPoints.existskey(MapLandmark.Order))
			MapStartPoints[MapLandmark.Order] = MapLandmark.Id;

	MapStartPoints = MapStartPoints.sortkey();
	foreach (Order => Id in MapStartPoints) G_LibObstacle_CurMapSpawnPoints.add(Id);

	// ---------------------------------- //
	// Get map checkpoints
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (!TL::Find("Checkpoint", MapLandmark.Tag, True, True)) continue;

		declare CpOrder = MapLandmark.Order;
		if (!G_LibObstacle_CurMapCheckpoints.existskey(CpOrder)) G_LibObstacle_CurMapCheckpoints[CpOrder] = Ident[];
		G_LibObstacle_CurMapCheckpoints[CpOrder].add(MapLandmark.Id);
	}
	G_LibObstacle_CurMapCheckpoints = G_LibObstacle_CurMapCheckpoints.sortkey();

	// ---------------------------------- //
	// Get map goals
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag == "Goal" || MapLandmark.Tag == "Multilap") G_LibObstacle_CurMapFinishLines.add(MapLandmark.Id);
		if (MapLandmark.Tag == "Multilap") G_LibObstacle_MapIsLapRace = True;
	}

	// Update UI information
	declare netwrite Integer Net_LibObstacle_MapNbCheckpoints for Teams[0];
	Net_LibObstacle_MapNbCheckpoints = G_LibObstacle_CurMapCheckpoints.count;
}

// ---------------------------------- //
/** Check if the current map is valid.
 *
 *	@return		Whether the map is valid or not.
 */
Boolean IsMapValid() {
	if (G_LibObstacle_CurMapSpawnPoints.count <= 0) return False;
	if (G_LibObstacle_CurMapFinishLines.count <= 0) return False;

	// ---------------------------------- //
	// Check checkpoints orders
	if (G_LibObstacle_CurMapCheckpoints.count > 0) {
		declare PrevCheckpointOrder = 0;
		foreach (CpOrder => CpsIds in G_LibObstacle_CurMapCheckpoints) {
			if (CpOrder <= PrevCheckpointOrder || CpsIds.count <= 0) return False;
			PrevCheckpointOrder = CpOrder;
		}
	}

	// The map is valid
	return True;
}

// ---------------------------------- //
/** Get amount of checkpoints on current map.
 *
 *	@return		Amount of checkpoints on the map.
 */
Integer MapNbCheckpoints() {
	return G_LibObstacle_CurMapCheckpoints.count;
}

// ---------------------------------- //
/** Check if the map is a lap race.
 *
 *	@return		True, if the map is a lap race.
 */
Boolean MapIsLapRace() {
	return G_LibObstacle_MapIsLapRace;
}

// ---------------------------------- //
/** Get amount of laps specified by the map author (1 if it's not laps race).
 *
 *	@return		Amount of laps on a map.
 */
Integer MapNbLaps() {
	if (!MapIsLapRace()) return 1;
	return ML::Max(G_LibObstacle_MapNbLaps, 1);
}

// ---------------------------------- //
/** Get amount of laps sset by the mode.
 *
 *	@return		Amount of laps specified by mode (-1 = independant).
 */
Integer ModeNbLaps() {
	if (!MapIsLapRace()) return 1;
	if (G_LibObstacle_ModeNbLaps <= -1) return -1;
	if (G_LibObstacle_ModeNbLaps == 0) return MapNbLaps();
	return G_LibObstacle_ModeNbLaps;
}

// ---------------------------------- //
/** Set the amount of laps on the map.
 *
 *	@param	_NbLaps		Amount of laps to set (-1 = independant, 0 = map value).
 */
Void SetModeNbLaps(Integer _NbLaps) {
	G_LibObstacle_ModeNbLaps = ML::Max(_NbLaps, -1);
	declare netwrite Integer Net_LibObstacle_ModeNbLaps for Teams[0];
	Net_LibObstacle_ModeNbLaps = ModeNbLaps();
}

// ---------------------------------- //
/** Check if the mode is set to independant laps mode.
 *
 *	@return		True, if the mode is set to independant laps mode.
 */
Boolean IndependantLaps() {
	return MapIsLapRace() && ModeNbLaps() <= -1;
}

// ---------------------------------- //
/** Get the ID of the start block with given position.
 *
 *	@param	_Position	Position of the start block to get.
 *
 *	@return		Start block with given position.
 */
CSmMapLandmark GetStartBlock(Integer _Position) {
	if (G_LibObstacle_CurMapSpawnPoints.count <= 0) return Null;
	if (G_LibObstacle_CurMapSpawnPoints.count == 1) return MapLandmarks[G_LibObstacle_CurMapSpawnPoints[0]];

	declare Key = ML::Clamp(_Position, 0, G_LibObstacle_CurMapSpawnPoints.count - 1);
	return MapLandmarks[G_LibObstacle_CurMapSpawnPoints[Key]];
}

// ---------------------------------- //
/** Get the multilap start block of the map.
 *
 *	@return		The multilap start point.
 */
CSmMapLandmark GetMultilapStart() {
	foreach (MapLandmark in MapLandmarks_Gauge) if (MapLandmark.Tag == "Multilap") return MapLandmark;
	return Null;
}

// ---------------------------------- //
/**	Get the checkpoint occupied by the player.
 *
 *	@param	_Player		The player to get checkpoint.
 *
 *	@return		Id of checkpoint occupied by the player.
 */
Integer OccupiedCheckpoint(CSmPlayer _Player) {
	if (_Player == Null || _Player.CapturedLandmark == Null) return 0;
	if (!TL::Find("Checkpoint", _Player.CapturedLandmark.Tag, True, True)) return 0;
	return ML::Max(_Player.CapturedLandmark.Order, 0);
}

// ---------------------------------- //
/** Get amount of checkpoints passed by the player.
 *
 *	@param	_Player		The player to get checkpoints amount.
 *
 *	@return		Amount of checkpoints passed by the player.
 */
Integer PlayerNbCheckpoints(CSmPlayer _Player) {
	if (_Player == Null) return 0;
	declare Integer[] CapturedCheckpointsTimes for _Player.Score;
	return CapturedCheckpointsTimes.count;
}

// ---------------------------------- //
/** Get amount of checkpoints missed by the player.
 *
 *	@param	_Player		The player to get checkpoints amount.
 *
 *	@return		Amount of checkpoints missed by the player.
 */
Integer MissedCheckpoints(CSmPlayer _Player, Integer _CpOrder) {
	if (_Player == Null || _CpOrder <= 0) return 0;
	return _CpOrder - PlayerNbCheckpoints(_Player) - 1;
}

// ---------------------------------- //
/** Get the latest checkpoint activated by the player.
 *
 *	@param	_Player		The player to get latest checkpoints.
 *
 *	@return		The latest checkpoint activated by the player.
 */
CSmMapLandmark GetLatestCheckpoint(CSmPlayer _Player) {
	if (_Player == Null) return Null;
	declare Ident[] CapturedCheckpoints for _Player.Score;
	if (CapturedCheckpoints.count <= 0) return Null;

	declare LatestCpId = CapturedCheckpoints[CapturedCheckpoints.count - 1];
	if (MapLandmarks_Gauge.existskey(LatestCpId)) return MapLandmarks_Gauge[LatestCpId];
	return Null;
}

// ---------------------------------- //
/** Get the player's best time.
 *
 *	@param	_Player		The player to get best time.
 *
 *	@return		The player's best time.
 */
Integer GetBestTime(CSmPlayer _Player) {
	if (_Player == Null) return -1;
	declare Integer BestRunRaceTime for _Player.Score;
	return ML::Max(BestRunRaceTime, -1);
}

// ---------------------------------- //
/** Get the player's best time on a checkpoint.
 *
 *	@param	_Player		The player to get current run time.
 *
 *	@return		The player's current run time.
 */
Integer GetCheckpointBest(CSmPlayer _Player, Integer _CpOrder) {
	if (_Player == Null || _CpOrder <= 0) return -1;
	declare Integer[] BestRunCheckpointsTimes for _Player.Score;
	if (!BestRunCheckpointsTimes.existskey(_CpOrder - 1)) return -1;
	return BestRunCheckpointsTimes[_CpOrder - 1];
}

// ---------------------------------- //
/** Get the score object of the match leader.
 *
 *	@param	_CurRunMode		Get the leader of the current run.
 *
 *	@return		Leader score object.
 */
CSmScore GetLeaderScore(Boolean _CurRunMode) {
	if (Scores.count <= 0) return Null;
	declare CSmScore BestScore;
	declare BestScoreTime = -1;

	foreach (Score in Scores) {
		if (_CurRunMode) {
			declare Integer CurrentRunStartTime for Score;
			declare CurrentRunRaceTime = Now - CurrentRunStartTime;
			if (CurrentRunRaceTime <= 0 || (BestScoreTime > 0 && CurrentRunRaceTime >= BestScoreTime)) continue;
			BestScoreTime = CurrentRunRaceTime;
			BestScore <=> Score;
		} else {
			declare Integer BestRunRaceTime for Score;
			if (BestRunRaceTime <= 0 || (BestScoreTime > 0 && BestRunRaceTime >= BestScoreTime)) continue;
			BestScoreTime = BestRunRaceTime;
			BestScore <=> Score;
		}
	}

	return BestScore;
}

// ---------------------------------- //
/** Get the leader time on given checkpoint.
 *
 *	@param	_CpOrder		The checkpoint to get the leader time.
 *	@param	_CurRunMode		Get the time of the current run.
 *
 *	@return		Leader time on given checkpoint.
 */
Integer GetLeaderCheckpointTime(Integer _CpOrder, Boolean _CurRunMode) {
	if (_CpOrder <= 0) return -1;
	declare LeaderScore <=> GetLeaderScore(_CurRunMode);
	if (LeaderScore == Null) return -1;

	if (_CurRunMode) {
		declare Integer[] CapturedCheckpointsTimes for LeaderScore;
		if (!CapturedCheckpointsTimes.existskey(_CpOrder - 1)) return -1;
		return CapturedCheckpointsTimes[_CpOrder - 1];
	}

	declare Integer[] BestRunCheckpointsTimes for LeaderScore;
	if (!BestRunCheckpointsTimes.existskey(_CpOrder - 1)) return -1;
	return BestRunCheckpointsTimes[_CpOrder - 1];
}

// ---------------------------------- //
/** Get the position of given time on a checkpoint.
 *
 *	@param	_Time		The time to get position.
 *	@param	_CpOrder	The checkpoint to get the leader time.
 *	@param	_CurRace	The checkpoint to get the leader time.
 *
 *	@return		Position on given checkpoint.
 */
Integer GetPositionOnCheckpoint(Integer _Time, Integer _CpOrder, Boolean _CurRace) {
	if (_Time <= 0 || _CpOrder <= 0) return -1;
	declare Integer[] CheckpointTimes;
	
	foreach (Score in Scores) {
		if (_CurRace) {
			declare Integer[] CapturedCheckpointsTimes for Score;
			if (!CapturedCheckpointsTimes.existskey(_CpOrder - 1)) continue;
			CheckpointTimes.add(CapturedCheckpointsTimes[_CpOrder - 1]);
		} else {
			declare Integer[] BestRunCheckpointsTimes for Score;
			if (!BestRunCheckpointsTimes.existskey(_CpOrder - 1)) continue;
			CheckpointTimes.add(BestRunCheckpointsTimes[_CpOrder - 1]);
		}
	}

	// 1st if noone has got a time
	if (CheckpointTimes.count <= 0) return 1;

	// Return the proper position
	CheckpointTimes = CheckpointTimes.sort();
	foreach (Position => Time in CheckpointTimes) if (_Time <= Time) return Position + 1; 
	return ML::Min(CheckpointTimes.count + 1, Scores.count);
}

// ---------------------------------- //
/** Set the player's start time.
 *
 *	@param	_Player		The player to set start time.
 *	@param	_StartTime	The race start time.
 */
Void SetPlayerStartTime(CSmPlayer _Player, Integer _StartTime) {
	if (_Player == Null) return;

	declare netwrite Integer Net_LibObstacle_RunStartTime for _Player.Score;
	declare Integer CurrentRunStartTime for _Player.Score;

	CurrentRunStartTime = _StartTime;
	Net_LibObstacle_RunStartTime = _StartTime;
}

// ---------------------------------- //
/** Get the player's current run time.
 *
 *	@param	_Player		The player to get current run time.
 *
 *	@return		The player's current run time.
 */
Integer GetCurRunTime(CSmPlayer _Player) {
	if (_Player == Null) return -1;
	declare Integer CurrentRunStartTime for _Player.Score;
	if (CurrentRunStartTime <= 0) return -1;
	return Now - CurrentRunStartTime;
}

// ---------------------------------- //
/** Send the new potential best time to a client.
 *
 *	@param	_Player			The player to send run time.
 *	@param	_BestTime		Time of the run.
 *	@param	_Checkpoints	Checkpoints times on the run.
 *	@param	_NbRespawns		Amount of respawns in the run.
 */
Void ClientSendPotentialPersonalBest(CSmPlayer _Player, Integer _BestTime, Integer[] _Checkpoints, Integer _NbRespawns) {
	if (Map == Null || _Player == Null || _BestTime <= 0 || _Checkpoints.count <= MapNbCheckpoints() || _NbRespawns < 0) return;
	declare UI <=> UIManager.GetUI(_Player);
	if (UI == Null) return;

	declare netwrite Integer Net_LibObstacle_LastPBUpdateTime for UI;
	declare netwrite Integer Net_LibObstacle_PBTimeTotal for UI;
	declare netwrite Integer Net_LibObstacle_PBNbRespawns for UI;
	declare netwrite Integer[] Net_LibObstacle_PBCheckpoints for UI;
	declare netwrite Text Net_LibObstacle_PBMapUID for UI;

	Net_LibObstacle_LastPBUpdateTime = Now;
	Net_LibObstacle_PBMapUID = Map.MapInfo.MapUid;
	Net_LibObstacle_PBTimeTotal = _BestTime;
	Net_LibObstacle_PBCheckpoints = _Checkpoints;
	Net_LibObstacle_PBNbRespawns = _NbRespawns;
}

// ---------------------------------- //
/** Check if the player's current run is valid.
 *
 *	@param	_Player		The player to check if the run is valid.
 *
 *	@return		Whether the run is valid or not.
 */
Boolean IsRunValid(CSmPlayer _Player) {
	if (_Player == Null) return False;
	declare Boolean CurrentRunIsValid for _Player.Score;
	return CurrentRunIsValid;
}

// ---------------------------------- //
/** Set the player's current run validation status.
 *
 *	@param	_Player		The player to set run validation.
 *	@param	_Valid		Whether the run is valid or not.
 */
Void SetRunValidation(CSmPlayer _Player, Boolean _Valid) {
	if (_Player == Null) return;
	declare netwrite Boolean Net_LibObstacle_IsCurRunInvalid for _Player.Score;
	declare Boolean CurrentRunIsValid for _Player.Score;
	Net_LibObstacle_IsCurRunInvalid = !_Valid;
	CurrentRunIsValid = _Valid;
}

// ---------------------------------- //
/** Check if the player has finished current run.
 *
 *	@param	_Player		The player to check.

 *	@return		True, if the player has finished the run.
 */
Boolean HasFinished(CSmPlayer _Player) {
	if (_Player == Null) return False;
	declare Boolean CurRunHasFinished for _Player.Score;
	return CurRunHasFinished;
}

// ---------------------------------- //
/** Jump to a checkpoint by ID.	
 *
 *	@param	_Player			The player that jumps to a checkpoint.
 *	@param	_CheckpointId	ID of the checkpoint player is jumping to.
 */
Void JumpToCheckpoint(CSmPlayer _Player, Ident _CheckpointId) {
	if (_Player == Null || !MapLandmarks_Gauge.existskey(_CheckpointId)) return;

	declare MapLandmark <=> MapLandmarks_Gauge[_CheckpointId];
	if (MapLandmark.Tag == "Goal") return;

	declare Ident CurRunJumpCheckpoint for _Player.Score;
	CurRunJumpCheckpoint = _CheckpointId;

	SetRunValidation(_Player, False);
	RespawnPlayer(_Player, MapLandmark);
}

// ---------------------------------- //
/** Jump to a checkpoint by order.	
 *
 *	@param	_Player		The player that jumps to a checkpoint.
 *	@param	_CpOrder	Order of the checkpoint player is jumping to.
 */
Void JumpToCheckpoint(CSmPlayer _Player, Integer _CpOrder) {
	if (_Player == Null || _CpOrder <= 0) return;

	declare Ident[] PossibleCheckpoints;
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (!TL::Find("Checkpoint", MapLandmark.Tag, True, True) || MapLandmark.Order != _CpOrder) continue;
		PossibleCheckpoints.add(MapLandmark.Id);
	}

	if (PossibleCheckpoints.count <= 0) return;
	if (PossibleCheckpoints.count == 1) {
		JumpToCheckpoint(_Player, PossibleCheckpoints[0]);
		return;
	}
	JumpToCheckpoint(_Player, PossibleCheckpoints[ML::Rand(0, PossibleCheckpoints.count - 1)]);
}

// ---------------------------------- //
/** Jump to a checkpoint by position.	
 *
 *	@param	_Player		The player that jumps to a checkpoint.
 *	@param	_Position	Position of the checkpoint player is jumping to.
 */
Void JumpToCheckpoint(CSmPlayer _Player, Vec3 _Position) {
	if (_Player == Null || _Position == <0., 0., 0.>) return;

	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag == "Goal" || MapLandmark.Position != _Position) continue;
		JumpToCheckpoint(_Player, MapLandmark.Id);
		return;
	}
}

// ---------------------------------- //
/** Get the checkpoint the player has jumped to.	
 *
 *	@param	_Player		The player to get jumped checkpoint.
 *
 *	@return		The checkpoint the player has jumped to.
 */
CSmMapLandmark GetJumpCheckpoint(CSmPlayer _Player) {
	if (_Player == Null) return Null;
	declare Ident CurRunJumpCheckpoint for _Player.Score;
	if (!MapLandmarks.existskey(CurRunJumpCheckpoint)) return Null;
	return MapLandmarks[CurRunJumpCheckpoint];
}

// ---------------------------------- //
/** Use a Portal on the map.
 *
 *	@param	_Player			The player who is using a Portal.
 *	@param	_LandmarkId		ID of the Portal entrance landmark.
 */
Void UsePortal(CSmPlayer _Player, Ident _LandmarkId) {
	if (_Player == Null || !MapLandmarks.existskey(_LandmarkId)) return;

	declare MapLandmark <=> MapLandmarks[_LandmarkId];
	declare Ident CurRunPortalSpawn for _Player.Score;
	declare Ident CurRunPortalCheckpoint for _Player.Score;

	switch (MapLandmark.Tag) {
		// ---------------------------------- //
		// New Portal type
		case "PortalEntrance" : {
			declare CSmMapLandmark[] PossibleExits;
			foreach (PortalExit in MapLandmarks_Gauge) if (PortalExit.Tag == "PortalExit" && PortalExit.Order == MapLandmark.Order) PossibleExits.add(PortalExit);
			if (PossibleExits.count <= 0) return;

			// Quick respawn player in the found exit
			declare PortalExit <=> PossibleExits[ML::Rand(0, PossibleExits.count - 1)];
			RespawnPlayer(_Player, PortalExit);
			CurRunPortalSpawn = NullId;
			CurRunPortalCheckpoint = PortalExit.Id;
		}
		// ---------------------------------- //
		// Legacy Portal type
		default : {
			if (MapLandmark.Tag != "Portal" && MapLandmark.Tag != "CheckpointType3") return;

			// Find all possible exit spawns
			declare Ident[] PossibleSpawns;
			foreach (Spawn in MapLandmarks_PlayerSpawn) {
				if (Spawn.Tag != "CPSpawn") continue;
				if (MapLandmark.Order != 0 && Spawn.Order != MapLandmark.Order) continue;
				PossibleSpawns.add(Spawn.Id);
			}

			// Unable to find matching spawns, use spawns for next checkpoint
			if (PossibleSpawns.count <= 0) foreach (Spawn in MapLandmarks_PlayerSpawn) {
				if (Spawn.Tag != "CPSpawn" || MapLandmark.Order <= Spawn.Order) continue;
				PossibleSpawns.add(Spawn.Id);
			}

			// There are no spawns, somehow
			if (PossibleSpawns.count <= 0) return;
			
			// Sort the possible spawns by distances
			declare Real[Ident] SpawnsDistances;
			foreach (SpawnId in PossibleSpawns) SpawnsDistances[SpawnId] = ML::Distance(MapLandmarks[SpawnId].Position, MapLandmark.Position);
			SpawnsDistances = SpawnsDistances.sort();

			// Spawn the player in nearest spawn
			declare CSmMapLandmark ExitSpawn;
			foreach (SpawnId => Distance in SpawnsDistances) { ExitSpawn <=> MapLandmarks_PlayerSpawn[SpawnId]; break; }
			SM::SpawnPlayer(_Player, 0, ExitSpawn.PlayerSpawn, Now);
			CurRunPortalSpawn = ExitSpawn.Id;
			CurRunPortalCheckpoint = NullId;
		}
	}
}

// ---------------------------------- //
/** Get the latest Portal spawn the player was using.
 *
 *	@param	_Player			The player who is using a Portal.
 *
 *	@return		The latest Portal spawn.
 */
CSmMapLandmark GetPortalSpawn(CSmPlayer _Player) {
	if (_Player == Null) return Null;

	declare Ident CurRunPortalSpawn for _Player.Score;
	if (!MapLandmarks_PlayerSpawn.existskey(CurRunPortalSpawn)) return Null;
	return MapLandmarks_PlayerSpawn[CurRunPortalSpawn];
}

// ---------------------------------- //
/** Get the latest Portal checkpoint the player was using.
 *
 *	@param	_Player			The player who is using a Portal.
 *
 *	@return		The latest Portal checkpoint.
 */
CSmMapLandmark GetPortalCheckpoint(CSmPlayer _Player) {
	if (_Player == Null) return Null;

	declare Ident CurRunPortalCheckpoint for _Player.Score;
	if (!MapLandmarks_Gauge.existskey(CurRunPortalCheckpoint)) return Null;
	return MapLandmarks_Gauge[CurRunPortalCheckpoint];
}

// ---------------------------------- //
/** Tell the library to init player's race on next spawn.
 *
 *	@param	_Player		The player to init on next spawn.
 */
Void RestartOnSpawn(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare Boolean IsRaceInitialized for _Player.Score;
	IsRaceInitialized = False;
}

// ---------------------------------- //
/** Reset a player's current race.
 *
 *	@param	_Player		The player to reset race.
 */
Void ResetPlayerCurRun(CSmPlayer _Player) {
	if (_Player == Null) return;
	SetRunValidation(_Player, True);
	
	declare netwrite Integer Net_LibObstacle_CurRunRaceRespawns for _Player.Score;
	Net_LibObstacle_CurRunRaceRespawns = 0;

	declare Integer ResetCPOrder for _Player;
	ResetCPOrder = Now + 500;

	declare Integer[] CapturedCheckpointsTimes for _Player.Score;
	declare Ident[] CapturedCheckpoints for _Player.Score;
	declare Integer CurRunRaceNbLaps for _Player.Score;
	declare Integer CurRunRaceRespawns for _Player.Score;
	declare Ident CurRunPortalSpawn for _Player.Score;
	declare Ident CurRunPortalCheckpoint for _Player.Score;
	declare Ident CurRunJumpCheckpoint for _Player.Score;
	declare Boolean CurRunHasFinished for _Player.Score;

	CapturedCheckpointsTimes.clear();
	CapturedCheckpoints.clear();
	CurRunRaceNbLaps = 0;
	CurRunRaceRespawns = 0;
	CurRunPortalSpawn = NullId;
	CurRunPortalCheckpoint = NullId;
	CurRunJumpCheckpoint = NullId;
	CurRunHasFinished = False;
}

// ---------------------------------- //
/** Reset a player's current and best race.
 *
 *	@param	_Player		The player to reset race.
 */
Void ResetPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;

	declare Integer[] BestRunCheckpointsTimes for _Player.Score;
	declare Integer BestRunRaceTime for _Player.Score;
	declare Integer BestRunRaceRespawns for _Player.Score;

	BestRunCheckpointsTimes.clear();
	BestRunRaceTime = -1;
	BestRunRaceRespawns = 0;

	ResetPlayerCurRun(_Player);
	RestartOnSpawn(_Player);
	SetPlayerStartTime(_Player, -1);
	SetRunValidation(_Player, True);

	declare netwrite Integer Net_LibObstacle_CheckpointUpdate for _Player;
	declare netwrite Integer Net_LibObstacle_LatestCPTime for _Player;
	declare netwrite Integer Net_LibObstacle_LatestCPOrder for _Player.Score;
	declare netwrite Boolean Net_LibObstacle_LatestCPIsBetter for _Player;
	declare netwrite Integer[Text] Net_LibObstacle_CPTimeDiffs for _Player;

	Net_LibObstacle_CheckpointUpdate = -1;
	Net_LibObstacle_LatestCPTime = -1;
	Net_LibObstacle_LatestCPOrder = 0;
	Net_LibObstacle_LatestCPIsBetter = False;
	Net_LibObstacle_CPTimeDiffs.clear();
}

// ---------------------------------- //
/// Reset all players.
Void ResetEveryone() {
	foreach (Player in AllPlayers) ResetPlayer(Player);
}

// ---------------------------------- //
/** Spawn the player for the race.
 *
 *	@param	_Player		The player to spawn.
 *	@param	_StartTime	Start time of the race.
 *	@param	_Position	The spawn position in the race.
 */
Void SpawnPlayer(CSmPlayer _Player, Integer _StartTime, Integer _Position) {
	if (_Player == Null) return;

	// Portal was activated
	declare PortalSpawn <=> GetPortalSpawn(_Player);
	if (PortalSpawn != Null) {
		SM::SpawnPlayer(_Player, 0, PortalSpawn.PlayerSpawn, Now);
		return;
	}

	declare MapLandmark <=> GetStartBlock(_Position);
	if (MapLandmark == Null) return;
	SM::SpawnPlayer(_Player, 0, MapLandmark.PlayerSpawn, _StartTime);

	// ---------------------------------- //
	// Initialize the race
	declare Boolean IsRaceInitialized for _Player.Score;
	if (!IsRaceInitialized) {
		IsRaceInitialized = True;
		ResetPlayerCurRun(_Player);
		SetPlayerStartTime(_Player, _Player.StartTime);
	}
	// ---------------------------------- //
	// Respawn in the latest checkpoint
	else if (PlayerNbCheckpoints(_Player) > 0) {
		declare Boolean RespawnOnLatestCp for _Player;
		RespawnOnLatestCp = True;
	}
}

Void SpawnPlayer(CSmPlayer _Player) {
	SpawnPlayer(_Player, Now + 3000, 0);
}

// ---------------------------------- //
/** Increment the amount of respawns of a player.
 *
 *	@param	_Player		The player to increment their respawns amount.
 *	@param	_Penalty	The time penalty given to the player.
 */
Void IncrementRespawns(CSmPlayer _Player, Integer _Penalty) {
	if (_Player == Null) return;

	declare Integer CurRunRaceRespawns for _Player.Score;
	CurRunRaceRespawns += 1;

	declare netwrite Integer Net_LibObstacle_CurRunRaceRespawns for _Player.Score;
	Net_LibObstacle_CurRunRaceRespawns = CurRunRaceRespawns;

	// Give the time penalty
	if (_Penalty > 0) {
		declare Integer CurrentRunStartTime for _Player.Score;
		SetPlayerStartTime(_Player, CurrentRunStartTime - _Penalty);
	}
}

Void IncrementRespawns(CSmPlayer _Player) {
	IncrementRespawns(_Player, 0);
}

// ---------------------------------- //
/** Get the amount of respawns of a player.	
 *
 *	@param	_Player			The player to get their respawns amount.
 *	@param	_CurRunMode		Whether the current or best run respawns are returned.
 *
 *	@return		The amount of player's respawns.
 */
Integer GetNbRespawns(CSmPlayer _Player, Boolean _CurRunMode) {
	if (_Player == Null) return 0;
	if (_CurRunMode) {
		declare Integer CurRunRaceRespawns for _Player.Score;
		return CurRunRaceRespawns;
	}
	declare Integer BestRunRaceRespawns for _Player.Score;
	return BestRunRaceRespawns;
}

// ---------------------------------- //
/** Trigger next race checkpoint or a goal.	
 *
 *	@param	_Player			The player who triggers a landmark.
 *	@param	_LandmarkId		The landmark to trigger.
 *	@param	_CurRunMode		Compare result to the current run leader.
 *
 *	@return		Whether the landmark has been captured or not.
 */
Boolean TriggerLandmark(CSmPlayer _Player, Ident _LandmarkId, Boolean _CurRunMode) {
	if (_Player == Null || _LandmarkId == NullId) return False;

	// Get the ID of the checkpoint
	declare CpOrder = 0;
	declare IsFinishBlock = False;
	declare IsMultilapBlock = False;

	if (MapLandmarks_Gauge.existskey(_LandmarkId)) {
		declare MapLandmark <=> MapLandmarks_Gauge[_LandmarkId];
		IsFinishBlock = MapLandmark.Tag == "Goal" || MapLandmark.Tag == "Multilap";
		IsMultilapBlock = MapLandmark.Tag == "Multilap";

		if (IsFinishBlock) CpOrder = MapNbCheckpoints() + 1;
		else CpOrder = MapLandmark.Order;
	}

	// Multilap
	declare Integer CurRunRaceNbLaps for _Player.Score;
	if (CurRunRaceNbLaps > 0) CpOrder += (MapNbCheckpoints() + 1) * CurRunRaceNbLaps;
	if (CpOrder <= 0) return False;

	// ---------------------------------- //
	// Notify player about missed checkpoints
	declare MissedCheckpoints = MissedCheckpoints(_Player, CpOrder);
	if (!IsMultilapBlock && MissedCheckpoints > 0) {
		declare Msg = _("You missed a checkpoint!");
		if (MissedCheckpoints > 1) Msg = TL::Compose(_("You missed %1 checkpoints"), TL::ToText(MissedCheckpoints));
		Message::SendStatusMessage(_Player, Msg, 2000, 2, CUIConfig::EUISound::Warning, 1);
	}
	if (MissedCheckpoints != 0) return False;

	// ---------------------------------- //
	// Capture goal
	declare Integer[] CapturedCheckpointsTimes for _Player.Score;
	declare Ident[] CapturedCheckpoints for _Player.Score;
	declare Integer CurRunRaceRespawns for _Player.Score;
	declare Boolean CurRunHasFinished for _Player.Score;

	declare CurCheckpointTime = GetCurRunTime(_Player);
	CapturedCheckpointsTimes.add(CurCheckpointTime);
	CapturedCheckpoints.add(_LandmarkId);
	if (IsFinishBlock) CurRunRaceNbLaps += 1; 

	// ---------------------------------- //
	// Disable portals and jumped checkpoint
	declare Ident CurRunPortalSpawn for _Player.Score;
	declare Ident CurRunPortalCheckpoint for _Player.Score;
	declare Ident CurRunJumpCheckpoint for _Player.Score;

	CurRunPortalSpawn = NullId;
	CurRunPortalCheckpoint = NullId;
	CurRunJumpCheckpoint = NullId;

	// Get the checkpoint differences
	declare Integer[Text] Differences;
	declare IsBetter = True;

	// High score mode
	if (!_CurRunMode) {
		declare PlayerCPBest = GetCheckpointBest(_Player, CpOrder);
		if (PlayerCPBest > 0) {
			Differences["Best"] = CurCheckpointTime - PlayerCPBest;
			IsBetter = CurCheckpointTime <= PlayerCPBest;
		}
	}

	// Get difference to leader
	declare LeaderScore <=> GetLeaderScore(_CurRunMode);
	if (LeaderScore != Null && _Player.Score != LeaderScore) {
		declare LeaderCPTime = GetLeaderCheckpointTime(CpOrder, _CurRunMode);
		if (LeaderCPTime > 0) {
			Differences["Leader"] = CurCheckpointTime - LeaderCPTime;
			if (_CurRunMode) IsBetter = CurCheckpointTime <= LeaderCPTime;
		}
	}

	// Get the position on the checkpoint
	declare Position = -1;
	if (Scores.count > 1) Position = GetPositionOnCheckpoint(CurCheckpointTime, CpOrder, _CurRunMode);

	Private_DisplayCPDiff(_Player, CurCheckpointTime, Position, IsBetter, Differences);
	Private_SetPlayerCpOrder(_Player, CpOrder);
	Private_SetPlayerNbLaps(_Player, CurRunRaceNbLaps);

	declare IndependantLaps = G_LibObstacle_ModeNbLaps <= 0;
	declare StopRace = IsFinishBlock && (!MapIsLapRace() || IndependantLaps || CurRunRaceNbLaps >= G_LibObstacle_ModeNbLaps);
	CurRunHasFinished = StopRace;

	// ---------------------------------- //
	// Compare with the best run
	if (StopRace) {
		declare BestTime = GetBestTime(_Player);
		if (BestTime <= 0 || CurCheckpointTime < BestTime) {
			declare Integer[] BestRunCheckpointsTimes for _Player.Score;
			declare Integer BestRunRaceTime for _Player.Score;
			declare Integer BestRunRaceRespawns for _Player.Score;

			BestRunCheckpointsTimes = CapturedCheckpointsTimes;
			BestRunRaceTime = CurCheckpointTime;
			BestRunRaceRespawns = CurRunRaceRespawns;

			ClientSendPotentialPersonalBest(_Player, BestRunRaceTime, BestRunCheckpointsTimes, BestRunRaceRespawns);
		}
	}

	return True;
}

Boolean TriggerLandmark(CSmPlayer _Player, Ident _LandmarkId) {
	return TriggerLandmark(_Player, _LandmarkId, False);
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	ResetEveryone();

	// Reset map information
	G_LibObstacle_CurMapSpawnPoints.clear();
	G_LibObstacle_CurMapCheckpoints.clear();
	G_LibObstacle_CurMapFinishLines.clear();
	G_LibObstacle_MapIsLapRace = False;
	G_LibObstacle_MapNbLaps = 1;
	G_LibObstacle_ModeNbLaps = 0;

	// Destroy custom interface layers
	Layers::Detach("LibObstacle:Chrono");
	Layers::Destroy("LibObstacle:Chrono");
	Layers::Detach("LibObstacle:CheckpointDiff");
	Layers::Destroy("LibObstacle:CheckpointDiff");
	Layers::Detach("LibObstacle:Markers");
	Layers::Destroy("LibObstacle:Markers");
	Layers::Detach("LibObstacle:PersonalBest");
	Layers::Destroy("LibObstacle:PersonalBest");

	declare netwrite Integer Net_LibObstacle_MapNbCheckpoints for Teams[0];
	Net_LibObstacle_MapNbCheckpoints = -1;
}

// ---------------------------------- //
/// Load the library.
Void Load() {
	Unload();

	// Create custom interfaces
	Layers::Create("LibObstacle:Chrono", Private_CreateManialinkChrono());
	Layers::Attach("LibObstacle:Chrono");
	Layers::Create("LibObstacle:CheckpointDiff", Private_CreateManialinkCheckpointDiff());
	Layers::Attach("LibObstacle:CheckpointDiff");
	Layers::Create("LibObstacle:Markers", Private_CreateManialinkMarkers());
	Layers::SetType("LibObstacle:Markers", CUILayer::EUILayerType::Markers);
	Layers::Attach("LibObstacle:Markers");
	Layers::Create("LibObstacle:PersonalBest", Private_CreateManialinkPersonalBest());
	Layers::Attach("LibObstacle:PersonalBest");
}

// ---------------------------------- //
/// Library loop.
Void Loop() {
	foreach (Player in Players) {
		// ---------------------------------- //
		// Respawn player on the latest checkpoint
		declare Boolean RespawnOnLatestCp for Player;
		if (RespawnOnLatestCp && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			RespawnOnLatestCp = False;

			// Get the target checkpoint
			declare CSmMapLandmark MapLandmark;
			if (MapLandmark == Null) MapLandmark <=> GetPortalCheckpoint(Player);
			if (MapLandmark == Null) MapLandmark <=> GetJumpCheckpoint(Player);
			if (MapLandmark == Null) MapLandmark <=> GetLatestCheckpoint(Player);
			if (MapLandmark != Null) RespawnPlayer(Player, MapLandmark);
		}

		// ---------------------------------- //
		// Reset checkpoint order so everything works right after finishing
		declare Integer ResetCPOrder for Player;
		if (ResetCPOrder > 0 && Now >= ResetCPOrder) {
			ResetCPOrder = -1;
			Private_SetPlayerCpOrder(Player, 0);
			Private_SetPlayerNbLaps(Player, 0);
		}
	}
}