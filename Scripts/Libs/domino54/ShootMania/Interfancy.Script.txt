// -------------------------------------- //
//  LIBRARY INTERFANCY by domino54        //
//  script version: 2017-04-29            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library features a lot of custom interface replacement
 *	modules, which can be used in all game modes.
 *
 *	Available modules:
 *	- Gauges		Replaces gauges, moves chat and features reload boost indicator
 *	- ScoreSummary	Replaces score summary
 *	- Countdown		Replaces countdown timer
 *	- SpecInfo		Replaces spected player information box
 *	- Crosshair		Replaces crosshair, features also first bullet reload gauge and notices
 */

#Const	Version		"2017-04-29"
#Const	ScriptName	"Interfancy.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/" 
#Const C_LibInterfancy_WidgetsRotation		2.		///< Rotation of the Armor and Ammo gauge widgets
#Const C_LibInterfancy_NbGaugesInModel		10		///< Amount of gauges in a single gauge widget
#Const C_LibInterfancy_GaugeTotalLength		48.		///< Length of a widget's gauge bar
#Const C_LibInterfancy_GaugeSpacingWidth	.5		///< Spaceing between smaller gauges in the widget
#Const C_LibInterfancy_FrameHideawayPos		-16.	///< Offset for hiding gauges below the bottom screen edge
#Const C_LibInterfancy_GaugeSoundVolume		-10.	///< Volume of the gauges sounds
#Const C_LibInterfancy_NearMissDisplayTime	1000	///< Duration for how long the near miss message is displayed

#Const C_LibInterfancy_ArmorPos			<-154., -84.>
#Const C_LibInterfancy_StaminaPos		<0., -85.>
#Const C_LibInterfancy_AmmunitionPos	<154., -84.>
#Const C_LibInterfancy_ScoreSummaryPos	<0., 90.>
#Const C_LibInterfancy_SpecInfoPos		<0., -68.>
#Const C_LibInterfancy_CountdownPos		<0., 86.25>
#Const C_LibInterfancy_CrosshairPos		<0., 0.>
#Const C_LibInterfancy_NearMissMsgPos	<0., -7.5>

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare Text[]			G_LibInterfancy_ModulesLoaded;
declare Boolean[Text]	G_LibInterfancy_ModuleVisibility;
declare Vec3[Text]		G_LibInterfancy_ModulePosition;
declare Integer G_LibInterfancy_PrevStartTime;
declare Integer G_LibInterfancy_PrevEndTime;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Check if a module is loaded
 *
 *	@param	_ModuleId		The module to check
 *
 *	@return					True if the given module is loaded, False otherwise
 */
Boolean Private_ModuleIsLoaded(Text _ModuleId) {
	return G_LibInterfancy_ModulesLoaded.exists(_ModuleId);
}

// ---------------------------------- //
/** Update the settings for a module
 *
 *	@param	_Name		The name of the setting
 *	@param	_Value		The value of the setting
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = Now;
	Net_LibInterfancy_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Create universal gauge frame for modules
 *
 *	@return		The gauge frame manialink
 */
Text Private_CreateUnivarsalGaugeModel() {
	declare UniversalGaugeModel = "";
	for (I, 0, C_LibInterfancy_NbGaugesInModel - 1)
		UniversalGaugeModel ^= "<gauge size='0 8' valign='center' drawbg='0' drawblockbg='0' id='Gauge_Step#"^I^"' hidden='1' />";
	return UniversalGaugeModel;
}

// ---------------------------------- //
/** Create the gauges module manialink
 *
 *	@return		The gauges module manialink
 */
Text Private_CreateManialinkGauges() {
	return """
<manialink version="3" name="LibInterfancy:Gauges">
<stylesheet>
	<style class="count" valign="center2" textsize="3" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="desc" valign="center2" textsize="1" textemboss="1" textfont="Eurostile_Bold" />
</stylesheet>

<frame id="Frame_HMDClip" size="320 180" halign="center" valign="center">

<frame id="Frame_WidgetArmor" pos="{{{C_LibInterfancy_ArmorPos.X^" "^C_LibInterfancy_ArmorPos.Y + C_LibInterfancy_FrameHideawayPos}}}" rot="{{{-C_LibInterfancy_WidgetsRotation}}}">
	<quad size="10 10" halign="center" valign="center" id="Quad_ModuleIcon" />
	<quad size="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost" />
	
	<label pos="5 2.75" class="count" id="Label_ModuleCounter" />
	<frame id="Frame_Gauge" pos="5">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame pos="5 -2.75">
		<label class="desc" id="Label_ModuleInfoText" />
		<label class="desc" id="Label_ModuleInfoGhost" />
	</frame>
</frame>

<frame id="Frame_WidgetStamina" pos="{{{C_LibInterfancy_StaminaPos.X^" "^C_LibInterfancy_StaminaPos.Y + C_LibInterfancy_FrameHideawayPos}}}">
	<quad pos="0 5" size="10 10" halign="center" valign="center" id="Quad_ModuleIcon" />
	<quad pos="0 5" size="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost" />
	
	<frame id="Frame_GaugeStamina" pos="{{{-C_LibInterfancy_GaugeTotalLength / 2}}}">
		{{{Private_CreateUnivarsalGaugeModel()}}}
	</frame>
	
	<frame pos="0 -2.75">
		<label halign="center" class="desc" id="Label_ModuleInfoText" />
		<label halign="center" class="desc" id="Label_ModuleInfoGhost" />
	</frame>
</frame>

<frame id="Frame_WidgetAmmo" pos="{{{C_LibInterfancy_AmmunitionPos.X^" "^C_LibInterfancy_AmmunitionPos.Y + C_LibInterfancy_FrameHideawayPos}}}" rot="{{{C_LibInterfancy_WidgetsRotation}}}">
	<quad size="10 10" halign="center" valign="center" id="Quad_ModuleIcon" />
	<quad size="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost" />
	
	<label pos="-5 2.75" halign="right" class="count" id="Label_ModuleCounter" />
	<frame id="Frame_GaugeAmmo" pos="-5 -.35" rot="-180">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame pos="-5 -2.75">
		<label halign="right" class="desc" id="Label_ModuleInfoText" />
		<label halign="right" class="desc" id="Label_ModuleInfoGhost" />
	</frame>
	
	<frame pos="-40 -4"><frame id="Frame_ReloadBoost" pos="0 -8">
		<label pos="3" class="count" id="Label_BoostTimer" />
		<quad size="5 5" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/ReloadBoost.png" id="Quad_BoostIcon" />
		<gauge pos="-1" size="24 8" halign="right" valign="center" drawbg="0" drawblockbg="0" ratio="1" id="Gauge_ReloadBoost" />
	</frame></frame>
</frame>

</frame>

<script><!--
/**
 *	LibInterfancy: Gauges
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_AvailableModules	["Armor", "Stamina", "Ammo"]
#Const C_WeaponsNames		[1 => "Laser", 2 => "Rocket", 3 => "Nucleus", 5 => "Arrow", 6 => "Missile"]
#Const C_UIChatPosition		[False => <0., 0.>, True => <0., 0.05>]
#Const C_NbGaugesInModel	{{{C_LibInterfancy_NbGaugesInModel}}}
#Const C_FrameHideawayPos	{{{C_LibInterfancy_FrameHideawayPos}}}
#Const C_GaugeTotalLength	{{{C_LibInterfancy_GaugeTotalLength}}}
#Const C_GaugeSpacingWidth	{{{C_LibInterfancy_GaugeSpacingWidth}}}
#Const C_GaugeSoundVolume	{{{C_LibInterfancy_GaugeSoundVolume}}}
#Const C_GaugePositionFix	4.
#Const C_StaminaDisplayTime	1500

/// Icons of the modules
#Const C_ModulesIcons [
	"Armor"		=> "{{{C_ImgBase}}}Icons/Armor.png",
	"Laser"		=> "{{{C_ImgBase}}}Icons/Laser.png",
	"Rocket"	=> "{{{C_ImgBase}}}Icons/Rocket.png",
	"Nucleus"	=> "{{{C_ImgBase}}}Icons/Nucleus.png",
	"Arrow"		=> "{{{C_ImgBase}}}Icons/Arrow.png",
	"Missile"	=> "{{{C_ImgBase}}}Icons/Rocket.png",
	"Stamina"	=> "{{{C_ImgBase}}}Icons/Jump.png",
	"Sprint"	=> "{{{C_ImgBase}}}Icons/Run.png"
]

#Const C_ModulesSounds [
	"AmmoStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeEnergyBallSlot.wav",
	"ArmorStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeHealthGradFull.wav",
	"StaminaFull"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaFull.wav",
	"StaminaEmpty"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaEmpty.wav"
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare CMlGauge[][Text] G_Gauges;
declare Text[Text] G_ModulesIcons;

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ReloadBoost	<=> (Page.GetFirstChild("Frame_ReloadBoost") as CMlFrame);
declare Gauge_ReloadBoost	<=> (Page.GetFirstChild("Gauge_ReloadBoost") as CMlGauge);
declare Label_BoostTimer	<=> (Page.GetFirstChild("Label_BoostTimer") as CMlLabel);
declare Quad_BoostIcon		<=> (Page.GetFirstChild("Quad_BoostIcon") as CMlQuad);

declare CMlFrame[Text] Frame_Widget;
declare CMlLabel[Text] Label_ModuleCounter;
declare CMlLabel[Text] Label_ModuleInfoText;
declare CMlLabel[Text] Label_ModuleInfoGhost;
declare CMlQuad[Text] Quad_ModuleIcon;
declare CMlQuad[Text] Quad_ModuleIconGhost;

foreach (Module in C_AvailableModules) {
	Frame_Widget[Module] = (Page.GetFirstChild("Frame_Widget"^Module) as CMlFrame);
	declare Frame = Frame_Widget[Module];
	
	Label_ModuleCounter[Module] = (Frame.GetFirstChild("Label_ModuleCounter") as CMlLabel);
	Label_ModuleInfoText[Module] = (Frame.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
	Label_ModuleInfoGhost[Module] = (Frame.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
	Quad_ModuleIcon[Module] = (Frame.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
	Quad_ModuleIconGhost[Module] = (Frame.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);
	
	// ---------------------------------- //
	// Load gauge modules
	G_Gauges[Module] = CMlGauge[];
	for (I, 0, C_NbGaugesInModel - 1) G_Gauges[Module].add((Frame.GetFirstChild("Gauge_Step#"^I) as CMlGauge));
}

declare GaugesModulesVisibility = False;

// ---------------------------------- //
// Armor module
declare Frame_WidgetArmor			<=> (Page.GetFirstChild("Frame_WidgetArmor") as CMlFrame);
declare Label_ModuleCounterArmor	<=> (Frame_WidgetArmor.GetFirstChild("Label_ModuleCounter") as CMlLabel);
declare Label_ModuleInfoTextArmor	<=> (Frame_WidgetArmor.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
declare Label_ModuleInfoGhostArmor	<=> (Frame_WidgetArmor.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
declare Quad_ModuleIconArmor		<=> (Frame_WidgetArmor.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
declare Quad_ModuleIconGhostArmor	<=> (Frame_WidgetArmor.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);

declare CMlGauge[] Gauge_ModuleArmor;
for (I, 0, C_NbGaugesInModel - 1) Gauge_ModuleArmor.add((Frame_WidgetArmor.GetFirstChild("Gauge_Step#"^I) as CMlGauge));

declare ModuleDisplay_Armor = True;
declare ModuleVisibility_Armor = False;
declare ModuleRatio_Armor = 0.;
declare ModuleSlots_Armor = 0;
declare ModuleUpdateGauges_Armor = True;
declare ModuleDescription_Armor = "";
declare ModuleIcon_Armor = C_ModulesIcons["Armor"];

declare PrevModuleVisibility_Armor = False;
declare PrevModuleRatio_Armor = -1.;
declare PrevModuleSlots_Armor = -1;
declare PrevModuleDescription_Armor = "";
declare PrevModuleIcon_Armor = "";

// ---------------------------------- //
// Ammo module
declare Frame_WidgetAmmo			<=> (Page.GetFirstChild("Frame_WidgetAmmo") as CMlFrame);
declare Label_ModuleCounterAmmo		<=> (Frame_WidgetAmmo.GetFirstChild("Label_ModuleCounter") as CMlLabel);
declare Label_ModuleInfoTextAmmo	<=> (Frame_WidgetAmmo.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
declare Label_ModuleInfoGhostAmmo	<=> (Frame_WidgetAmmo.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
declare Quad_ModuleIconAmmo			<=> (Frame_WidgetAmmo.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
declare Quad_ModuleIconGhostAmmo	<=> (Frame_WidgetAmmo.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);

declare CMlGauge[] Gauge_ModuleAmmo;
for (I, 0, C_NbGaugesInModel - 1) Gauge_ModuleAmmo.add((Frame_WidgetAmmo.GetFirstChild("Gauge_Step#"^I) as CMlGauge));

declare ModuleDisplay_Ammo = True;
declare ModuleVisibility_Ammo = False;
declare ModuleRatio_Ammo = 0.;
declare ModuleSlots_Ammo = 0;
declare ModuleUpdateGauges_Ammo = True;
declare ModuleDescription_Ammo = "";
declare ModuleIcon_Ammo = C_ModulesIcons["Rocket"];

declare PrevModuleVisibility_Ammo = False;
declare PrevModuleRatio_Ammo = -1.;
declare PrevModuleSlots_Ammo = -1;
declare PrevModuleDescription_Ammo = "";
declare PrevModuleIcon_Ammo = "";

// ---------------------------------- //
// Stamina module
declare Frame_WidgetStamina				<=> (Page.GetFirstChild("Frame_WidgetStamina") as CMlFrame);
declare Label_ModuleInfoTextStamina		<=> (Frame_WidgetStamina.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
declare Label_ModuleInfoGhostStamina	<=> (Frame_WidgetStamina.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
declare Quad_ModuleIconStamina			<=> (Frame_WidgetStamina.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
declare Quad_ModuleIconGhostStamina		<=> (Frame_WidgetStamina.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);
declare Gauge_ModuleStamina = [(Frame_WidgetStamina.GetFirstChild("Gauge_Step#0") as CMlGauge)];

declare ModuleDisplay_Stamina = True;
declare ModuleVisibility_Stamina = False;
declare ModuleRatio_Stamina = 0.;
declare ModuleDescription_Stamina = "";
declare ModuleIcon_Stamina = C_ModulesIcons["Stamina"];

declare PrevModuleVisibility_Stamina = False;
declare PrevModuleRatio_Stamina = -1.;
declare PrevModuleDescription_Stamina = "";
declare PrevModuleIcon_Stamina = "";

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_LibInterfancy_AlwaysShowStamina for LocalUser = False;

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];
declare netread Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];

// ---------------------------------- //
// Variables
declare Gauges_Display = True;
declare InterfaceColor = 0.;
declare StaminaDisplayEndTime = -1;
declare Integer[Ident] PlayerIsOnTechArmor;
declare ShowReloadBoost = False;
declare GUIPlayerIsInVehicle = False;

// Update
declare PrevSettingsUpdate = -1;
declare PrevGauges_Display = False;
declare PrevGUIPlayerLogin = "";
declare PrevGUIPlayerCurWeapon = 0;
declare PrevInterfaceColor = -1.;
declare PrevShowReloadBoost = False;

// Init
G_ModulesIcons = C_ModulesIcons;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Gauges_Display"	: Gauges_Display		= SettingValue == "True";
			case "Armor_Display"	: ModuleDisplay_Armor	= SettingValue == "True";
			case "Ammo_Display"		: ModuleDisplay_Ammo	= SettingValue == "True";
			case "Stamina_Display"	: ModuleDisplay_Stamina	= SettingValue == "True";
			default : {
				if (TL::SubString(SettingName, 0, 11) == "Gauges_Icon" && SettingValue != "") {
					declare IconId = TL::Replace(SettingName, "Gauges_Icon", "");
					G_ModulesIcons[IconId] = SettingValue;
					PrevModuleIcon_Ammo = "";
					PrevModuleIcon_Stamina = "";
				}
			}
		}
	}
}

// ---------------------------------- //
// Get for how long players are loading their Armors
foreach (Player in Players) {
	if (Player.RequestsSpectate || Player.IsBot || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
	
	if (Player.IsOnTechArmor) {
		if (!PlayerIsOnTechArmor.existskey(Player.Id)) PlayerIsOnTechArmor[Player.Id] = GameTime;
	}
	else if (PlayerIsOnTechArmor.existskey(Player.Id)) {
		declare Removed = PlayerIsOnTechArmor.removekey(Player.Id);
	}
}

// ---------------------------------- //
// Set the chat offset
if (PrevGauges_Display != Gauges_Display) {
	PrevGauges_Display = Gauges_Display;
	ClientUI.OverlayChatOffset = C_UIChatPosition[Gauges_Display];
	ClientUI.OverlayChatHideAvatar = Gauges_Display;
}

// ---------------------------------- //
// Set the gauges visibility
GaugesModulesVisibility = UI.OverlayHideGauges && Gauges_Display && GUIPlayer != Null;

// ---------------------------------- //
// Get the interface color from the player
if (GUIPlayer != Null && InterfaceColor != GUIPlayer.GetLinearHue) InterfaceColor = GUIPlayer.GetLinearHue;

// ---------------------------------- //
// Set interface color
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	declare NewUIColor = HsvToRgb(<ML::Clamp(InterfaceColor, 0., 1.), 1., 1.>);

	foreach (Module in C_AvailableModules) {
		foreach (Gauge in G_Gauges[Module]) Gauge.Color = NewUIColor;
		declare BrightTextColor = Brightness(NewUIColor, 4.);
		Label_ModuleInfoText[Module].TextColor = BrightTextColor;
		Label_ModuleInfoGhost[Module].TextColor = BrightTextColor;
	}
	
	Gauge_ReloadBoost.Color = NewUIColor;
}

// ---------------------------------- //
// Reload boost
if (GUIPlayer != Null) {
	declare netread Integer Net_LibInterfancy_BoostStartTime for GUIPlayer;
	declare netread Integer Net_LibInterfancy_BoostDuration for GUIPlayer;
	ShowReloadBoost = GameTime <= Net_LibInterfancy_BoostStartTime + Net_LibInterfancy_BoostDuration;
}
else ShowReloadBoost = False;

// ---------------------------------- //
// Reload boost gauge animation
if (PrevShowReloadBoost != ShowReloadBoost) {
	PrevShowReloadBoost = ShowReloadBoost;
	
	declare Easing = CAnimManager::EAnimManagerEasing::BackOut;
	declare Position = <Frame_ReloadBoost.RelativePosition_V3.X, 0.>;
	
	if (!ShowReloadBoost) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.Y -= 8.;
		Label_BoostTimer.Value = "0";
		Gauge_ReloadBoost.Size.X = 0.;
	}
	
	AnimMgr.Add(Frame_ReloadBoost, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

// ---------------------------------- //
// Setup boost gauge
if (ShowReloadBoost) {
	declare netread Integer Net_LibInterfancy_BoostStartTime for GUIPlayer;
	declare netread Integer Net_LibInterfancy_BoostDuration for GUIPlayer;

	Gauge_ReloadBoost.Size.X = 20 * (1. - ML::ToReal(GameTime - Net_LibInterfancy_BoostStartTime) / Net_LibInterfancy_BoostDuration) + 4.;
	Label_BoostTimer.Value = TL::ToText((Net_LibInterfancy_BoostStartTime + Net_LibInterfancy_BoostDuration - GameTime) / 1000 + 1);
}

// Check if the player is in a vehicle (in quite ugly way)
GUIPlayerIsInVehicle = GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && GUIPlayer.Armor > 0 && GameTime >= GUIPlayer.StartTime - 1500 && !GUIPlayer.IsInAir && !GUIPlayer.IsTouchingGround && !GUIPlayer.IsInWater;

// ---------------------------------- //
// Update the Armor module visibility
ModuleVisibility_Armor = GaugesModulesVisibility && ModuleDisplay_Armor && GUIPlayer.ArmorMax > 0 && GUIPlayer.Position != <0., 0., 0.> && !GUIPlayerIsInVehicle;

if (PrevModuleVisibility_Armor != ModuleVisibility_Armor) {
	PrevModuleVisibility_Armor = ModuleVisibility_Armor;

	declare Easing = CAnimManager::EAnimManagerEasing::BackOut;
	declare Position = <Frame_WidgetArmor.RelativePosition_V3.X, {{{C_LibInterfancy_ArmorPos.Y}}}>;

	if (!ModuleVisibility_Armor) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.Y += C_FrameHideawayPos;
		PrevModuleRatio_Armor = -1.;
	}
	
	AnimMgr.Add(Frame_WidgetArmor, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

// ---------------------------------- //
// Manage the Armor module
if (ModuleVisibility_Armor) {
	// ---------------------------------- //
	// Get the Armor module ratio and slots
	ModuleRatio_Armor = GUIPlayer.Armor / 100.;
	ModuleSlots_Armor = GUIPlayer.ArmorMax / 100;

	// Armor loading on Armor pads
	if (GUIPlayer.IsOnTechArmor && PlayerIsOnTechArmor.existskey(GUIPlayer.Id))
		ModuleRatio_Armor += (GameTime - PlayerIsOnTechArmor[GUIPlayer.Id]) % 1875 / 1875.;

	// Clamp the ratio
	ModuleRatio_Armor = ML::Clamp(ModuleRatio_Armor, 0., ML::ToReal(ModuleSlots_Armor));

	// ---------------------------------- //
	// Update Armor module on ratio change
	if (PrevModuleRatio_Armor != ModuleRatio_Armor) {
		ModuleUpdateGauges_Armor = True;

		// ---------------------------------- //
		// Play sound when additional Armor point is loaded
		if (
			PrevGUIPlayerLogin == GUIPlayer.User.Login && GUIPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned &&
			PrevModuleRatio_Armor >= 0 && ML::FloorInteger(ModuleRatio_Armor) > PrevModuleRatio_Armor
		)
			Audio.PlaySoundEvent(C_ModulesSounds["ArmorStep"], C_GaugeSoundVolume);

		PrevModuleRatio_Armor = ModuleRatio_Armor;
	}

	// ---------------------------------- //
	// Update Armor module on slots amount change
	if (PrevModuleSlots_Armor != ModuleSlots_Armor) {
		PrevModuleSlots_Armor = ModuleSlots_Armor;
		ModuleUpdateGauges_Armor = True;
	}

	// ---------------------------------- //
	// Update Armor module gauges
	if (ModuleUpdateGauges_Armor) {
		ModuleUpdateGauges_Armor = False;
		SetModuleRatio(Gauge_ModuleArmor, ModuleRatio_Armor, ModuleSlots_Armor);
		Label_ModuleCounterArmor.Value = ML::FloorInteger(ModuleRatio_Armor)^"$777/"^ModuleSlots_Armor;
	}

	// ---------------------------------- //
	// Set the Armor module dynamic description
	declare netread Text Net_LibInterfancy_ArmorReplacement for GUIPlayer;

	if (GUIPlayer.IsOnTechArmor) {
		// Healing on the Armor pad
		if (GUIPlayer.Armor < GUIPlayer.ArmorMax) ModuleDescription_Armor = "Healing...";

		// Standing on Armor pad while having full Armor
		else ModuleDescription_Armor = "Healing Pad";
	}

	// Standing on the Laser pad
	else if (GUIPlayer.IsOnTechLaser) ModuleDescription_Armor = "Zoom Pad";

	// Standing on the Arrow pad
	else if (GUIPlayer.IsOnTechArrow) ModuleDescription_Armor = "Arrow Pad";

	// Standing on the Safe Zone
	else if (GUIPlayer.IsOnTechSafeZone) ModuleDescription_Armor = "Safe Zone";

	// While underground or in bunkers
	else if (GUIPlayer.IsUnderground) ModuleDescription_Armor = "Tunnels";

	// Custom text
	else if (Net_LibInterfancy_ArmorReplacement != "") ModuleDescription_Armor = Net_LibInterfancy_ArmorReplacement;

	// Default text
	else ModuleDescription_Armor = "Armor";

	// ---------------------------------- //
	// Update Armor module information text
	if (PrevModuleDescription_Armor != ModuleDescription_Armor) {
		PrevModuleDescription_Armor = ModuleDescription_Armor;

		Label_ModuleInfoGhostArmor.Value = Label_ModuleInfoTextArmor.Value;
		Label_ModuleInfoTextArmor.Value = TL::ToUpperCase(Translate(ModuleDescription_Armor));
		
		Label_ModuleInfoTextArmor.Opacity = 0.;
		Label_ModuleInfoTextArmor.RelativePosition_V3.Y = 1.5;
		Label_ModuleInfoGhostArmor.Opacity = 1.;
		Label_ModuleInfoGhostArmor.RelativePosition_V3.Y = 0.;
		
		AnimMgr.Add(Label_ModuleInfoTextArmor, "<label pos='0 0' opacity='1' />", 200, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Label_ModuleInfoGhostArmor, "<label pos='0 -1.5' opacity='0' />", 200, CAnimManager::EAnimManagerEasing::Linear);
	}

	// ---------------------------------- //
	// Get the icon of the module
	declare ModuleIcon_Armor = G_ModulesIcons["Armor"];
	if (G_ModulesIcons.existskey(ModuleDescription_Armor)) ModuleIcon_Armor = G_ModulesIcons[ModuleDescription_Armor];

	// ---------------------------------- //
	// Update Armor module icon
	if (PrevModuleIcon_Armor != ModuleIcon_Armor) {
		SetIconImage(Quad_ModuleIconArmor, ModuleIcon_Armor);
		SetIconImage(Quad_ModuleIconGhostArmor, PrevModuleIcon_Armor);
		PrevModuleIcon_Armor = ModuleIcon_Armor;

		Quad_ModuleIconArmor.Opacity = 0.;
		Quad_ModuleIconArmor.RelativeScale = 1.5;
		Quad_ModuleIconGhostArmor.Opacity = 1.;
		Quad_ModuleIconGhostArmor.RelativeScale = 1.;
		
		AnimMgr.Add(Quad_ModuleIconArmor, "<quad opacity='1' scale='1' />", 200, CAnimManager::EAnimManagerEasing::CircOut);
		AnimMgr.Add(Quad_ModuleIconGhostArmor, "<quad opacity='0' scale='.5' />", 100, CAnimManager::EAnimManagerEasing::Linear);
	}
}

// ---------------------------------- //
// Update the Ammo module visibility
ModuleVisibility_Ammo = GaugesModulesVisibility && ModuleDisplay_Ammo && GUIPlayer.Position != <0., 0., 0.> && GUIPlayer.CurWeapon > 0 && GUIPlayer.CurAmmoMax > 0;

if (PrevModuleVisibility_Ammo != ModuleVisibility_Ammo) {
	PrevModuleVisibility_Ammo = ModuleVisibility_Ammo;

	declare Easing = CAnimManager::EAnimManagerEasing::BackOut;
	declare Position = <Frame_WidgetAmmo.RelativePosition_V3.X, {{{C_LibInterfancy_AmmunitionPos.Y}}}>;

	if (!ModuleVisibility_Ammo) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.Y += C_FrameHideawayPos;
		PrevModuleRatio_Ammo = -1.;
	}
	
	AnimMgr.Add(Frame_WidgetAmmo, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

// ---------------------------------- //
// Manage the Ammo module
if (ModuleVisibility_Ammo) {
	// ---------------------------------- //
	// Get the Ammo module ratio and slots
	ModuleRatio_Ammo = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;
	ModuleSlots_Ammo = GUIPlayer.CurAmmoMax / GUIPlayer.CurAmmoUnit;

	// ---------------------------------- //
	// Update Ammo module on ratio change
	if (PrevModuleRatio_Ammo != ModuleRatio_Ammo) {
		ModuleUpdateGauges_Ammo = True;

		// ---------------------------------- //
		// Play sound when next ammo bullet is loaded
		if (
			PrevGUIPlayerLogin == GUIPlayer.User.Login && PrevGUIPlayerCurWeapon == GUIPlayer.CurWeapon &&
			PrevModuleRatio_Ammo >= 0 && ML::FloorInteger(ModuleRatio_Ammo) > PrevModuleRatio_Ammo
		)
			Audio.PlaySoundEvent(C_ModulesSounds["AmmoStep"], C_GaugeSoundVolume);

		PrevModuleRatio_Ammo = ModuleRatio_Ammo;
	}

	// ---------------------------------- //
	// Update Ammo module on slots amount change
	if (PrevModuleSlots_Ammo != ModuleSlots_Ammo) {
		PrevModuleSlots_Ammo = ModuleSlots_Ammo;
		ModuleUpdateGauges_Ammo = True;
	}

	// ---------------------------------- //
	// Update Ammo module gauges
	if (ModuleUpdateGauges_Ammo) {
		ModuleUpdateGauges_Ammo = False;
		SetModuleRatio(Gauge_ModuleAmmo, ModuleRatio_Ammo, ModuleSlots_Ammo);
		Label_ModuleCounterAmmo.Value = ML::FloorInteger(ModuleRatio_Ammo)^"$777/"^ModuleSlots_Ammo;
	}

	// ---------------------------------- //
	// Set name and icon of a custom weapon
	declare netread Text Net_LibInterfancy_CustomWeaponName for GUIPlayer;
	if (Net_LibInterfancy_CustomWeaponName != "") ModuleDescription_Ammo = Net_LibInterfancy_CustomWeaponName;
	
	// Display name and icon of the current weapon
	else if (C_WeaponsNames.existskey(GUIPlayer.CurWeapon)) ModuleDescription_Ammo = C_WeaponsNames[GUIPlayer.CurWeapon];
	
	// Display default name and icon if something went wrong
	else ModuleDescription_Ammo = "Rocket";

	// ---------------------------------- //
	// Update Ammo module information text
	if (PrevModuleDescription_Ammo != ModuleDescription_Ammo) {
		PrevModuleDescription_Ammo = ModuleDescription_Ammo;

		Label_ModuleInfoGhostAmmo.Value = Label_ModuleInfoTextAmmo.Value;
		Label_ModuleInfoTextAmmo.Value = TL::ToUpperCase(Translate(ModuleDescription_Ammo));
		
		Label_ModuleInfoTextAmmo.Opacity = 0.;
		Label_ModuleInfoTextAmmo.RelativePosition_V3.Y = 1.5;
		Label_ModuleInfoGhostAmmo.Opacity = 1.;
		Label_ModuleInfoGhostAmmo.RelativePosition_V3.Y = 0.;
		
		AnimMgr.Add(Label_ModuleInfoTextAmmo, "<label pos='0 0' opacity='1' />", 200, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Label_ModuleInfoGhostAmmo, "<label pos='0 -1.5' opacity='0' />", 200, CAnimManager::EAnimManagerEasing::Linear);
	}

	// ---------------------------------- //
	// Set the icon corresponding to the current weapon
	if (G_ModulesIcons.existskey(ModuleDescription_Ammo)) ModuleIcon_Ammo = G_ModulesIcons[ModuleDescription_Ammo];

	// ---------------------------------- //
	// Update Ammo module icon
	if (PrevModuleIcon_Ammo != ModuleIcon_Ammo) {
		SetIconImage(Quad_ModuleIconAmmo, ModuleIcon_Ammo);
		SetIconImage(Quad_ModuleIconGhostAmmo, PrevModuleIcon_Ammo);
		PrevModuleIcon_Ammo = ModuleIcon_Ammo;

		Quad_ModuleIconAmmo.Opacity = 0.;
		Quad_ModuleIconAmmo.RelativeScale = 1.5;
		Quad_ModuleIconGhostAmmo.Opacity = 1.;
		Quad_ModuleIconGhostAmmo.RelativeScale = 1.;
		
		AnimMgr.Add(Quad_ModuleIconAmmo, "<quad opacity='1' scale='1' />", 200, CAnimManager::EAnimManagerEasing::CircOut);
		AnimMgr.Add(Quad_ModuleIconGhostAmmo, "<quad opacity='0' scale='.5' />", 100, CAnimManager::EAnimManagerEasing::Linear);
	}
}

// ---------------------------------- //
// Hide full Stamina bar after some delay
if (GUIPlayer != Null && GUIPlayer.Stamina < GUIPlayer.StaminaMax * 3600) StaminaDisplayEndTime = Now + C_StaminaDisplayTime;

// ---------------------------------- //
// Update the Stamina module visibility
ModuleVisibility_Stamina = GaugesModulesVisibility && GUIPlayer.Position != <0., 0., 0.> && !GUIPlayerIsInVehicle && ModuleDisplay_Stamina && Now <= StaminaDisplayEndTime;

if (PrevModuleVisibility_Stamina != ModuleVisibility_Stamina) {
	PrevModuleVisibility_Stamina = ModuleVisibility_Stamina;

	declare Easing = CAnimManager::EAnimManagerEasing::BackOut;
	declare Position = <Frame_WidgetStamina.RelativePosition_V3.X, {{{C_LibInterfancy_StaminaPos.Y}}}>;

	if (!ModuleVisibility_Stamina) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.Y += C_FrameHideawayPos;
	}
	
	AnimMgr.Add(Frame_WidgetStamina, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

// ---------------------------------- //
// Manage the Stamina module
if (ModuleVisibility_Stamina) {
	// ---------------------------------- //
	// Get the Stamina module ratio
	ModuleRatio_Stamina = GUIPlayer.Stamina / GUIPlayer.StaminaMax / 3600;

	// ---------------------------------- //
	// Update Stamina module on ratio change
	if (PrevModuleRatio_Stamina != ModuleRatio_Stamina) {
		SetModuleRatio(Gauge_ModuleStamina, ModuleRatio_Stamina, 1);

		if (PrevGUIPlayerLogin == GUIPlayer.User.Login && PrevModuleRatio_Stamina >= 0) {
			// ---------------------------------- //
			// Play sound when Stamina is fully loaded
			if (ModuleRatio_Stamina >= 1 && PrevModuleRatio_Stamina < 1)
				Audio.PlaySoundEvent(C_ModulesSounds["StaminaFull"], C_GaugeSoundVolume);

			// ---------------------------------- //
			// Play sound when Stamina has been emptied
			if (ModuleRatio_Stamina <= 0 && PrevModuleRatio_Stamina > 0)
				Audio.PlaySoundEvent(C_ModulesSounds["StaminaEmpty"], C_GaugeSoundVolume);
		}

		PrevModuleRatio_Stamina = ModuleRatio_Stamina;
	}

	// ---------------------------------- //
	// Set sprinting description when on tech
	if (GUIPlayer.IsOnTech) {
		ModuleDescription_Stamina = "Sprint Path";
		ModuleIcon_Stamina = G_ModulesIcons["Sprint"];
	}
	// ---------------------------------- //
	// Set default Dtamina description
	else {
		ModuleDescription_Stamina = "Stamina";
		ModuleIcon_Stamina = G_ModulesIcons["Stamina"];
	}

	// ---------------------------------- //
	// Update Stamina module information text
	if (PrevModuleDescription_Stamina != ModuleDescription_Stamina) {
		PrevModuleDescription_Stamina = ModuleDescription_Stamina;

		Label_ModuleInfoGhostStamina.Value = Label_ModuleInfoTextStamina.Value;
		Label_ModuleInfoTextStamina.Value = TL::ToUpperCase(Translate(ModuleDescription_Stamina));
		
		Label_ModuleInfoTextStamina.Opacity = 0.;
		Label_ModuleInfoTextStamina.RelativePosition_V3.Y = 1.5;
		Label_ModuleInfoGhostStamina.Opacity = 1.;
		Label_ModuleInfoGhostStamina.RelativePosition_V3.Y = 0.;
		
		AnimMgr.Add(Label_ModuleInfoTextStamina, "<label pos='0 0' opacity='1' />", 200, CAnimManager::EAnimManagerEasing::Linear);
		AnimMgr.Add(Label_ModuleInfoGhostStamina, "<label pos='0 -1.5' opacity='0' />", 200, CAnimManager::EAnimManagerEasing::Linear);
	}

	// ---------------------------------- //
	// Set the icon corresponding to the current weapon
	if (G_ModulesIcons.existskey(ModuleDescription_Stamina)) ModuleIcon_Stamina = G_ModulesIcons[ModuleDescription_Stamina];

	// ---------------------------------- //
	// Update Stamina module icon
	if (PrevModuleIcon_Stamina != ModuleIcon_Stamina) {
		SetIconImage(Quad_ModuleIconStamina, ModuleIcon_Stamina);
		SetIconImage(Quad_ModuleIconGhostStamina, PrevModuleIcon_Stamina);
		PrevModuleIcon_Stamina = ModuleIcon_Stamina;

		Quad_ModuleIconStamina.Opacity = 0.;
		Quad_ModuleIconStamina.RelativeScale = 1.5;
		Quad_ModuleIconGhostStamina.Opacity = 1.;
		Quad_ModuleIconGhostStamina.RelativeScale = 1.;
		
		AnimMgr.Add(Quad_ModuleIconStamina, "<quad opacity='1' scale='1' />", 200, CAnimManager::EAnimManagerEasing::CircOut);
		AnimMgr.Add(Quad_ModuleIconGhostStamina, "<quad opacity='0' scale='.5' />", 100, CAnimManager::EAnimManagerEasing::Linear);
	}
}

// ---------------------------------- //
// Update player
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.User.Login) PrevGUIPlayerLogin = GUIPlayer.User.Login;
	if (PrevGUIPlayerCurWeapon != GUIPlayer.CurWeapon) PrevGUIPlayerCurWeapon = GUIPlayer.CurWeapon;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Functions(["SetGaugeRatio", "Brightness", "HsvToRgb"])}}}

// ---------------------------------- //
/** Set icon image of the Quad
 *
 *	@param	_Quad		The Quad to set image
 *	@param	_Image		Image to set
 */
Void SetIconImage(CMlQuad _Quad, Text _Image) {
	if (_Quad == Null) return;
	_Quad.ImageUrl = "";
	_Quad.Style = "";
	_Quad.Substyle = "";
	if (_Image == "") return;
	
	declare ManiaStylePath = TL::Split("|", _Image);
	if (ManiaStylePath.count == 2) {
		_Quad.Style = ManiaStylePath[0];
		_Quad.Substyle = ManiaStylePath[1];
	}
	else _Quad.ImageUrl = _Image;
}

// ---------------------------------- //
/** Set module value
 *
 *	@param	_Gauges		Array of gauges used by the module
 *	@param	_Energy		Amount of currently loaded energy
 *	@param	_Slots		Amount of available energy slots
 */
Void SetModuleRatio(CMlGauge[] _Gauges, Real _Energy, Integer _Slots) {
	declare persistent Persistent_LibInterfancy_ShowGaugesBgs for LocalUser = False;
	
	// ---------------------------------- //
	// Hide gauges if there are no slots
	if (_Slots <= 0) {
		foreach (Gauge in _Gauges) Gauge.Visible = False;
		
		// There is nothing more to do without slots
		return;
	}
	// ---------------------------------- //
	// Adjust up to N gauges for slots
	else if (_Slots <= _Gauges.count) {
		declare SpacingSizeSub = 0.;
		if (_Slots >= 2) SpacingSizeSub = C_GaugeSpacingWidth * (_Slots - 1) / _Slots;
		declare GaugeSlotSize = C_GaugeTotalLength / _Slots + C_GaugePositionFix - SpacingSizeSub;
		
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I <= _Slots - 1;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = GaugeSlotSize;
			Gauge.RelativePosition_V3.X = (GaugeSlotSize - C_GaugePositionFix) * I - C_GaugePositionFix / 2;
			Gauge.DrawBlockBackground = Persistent_LibInterfancy_ShowGaugesBgs;
			if (I > 0) Gauge.RelativePosition_V3.X += C_GaugeSpacingWidth * I;
		}
	}
	// ---------------------------------- //
	// Use one gauge for over N slots
	else {
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I == 0;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = C_GaugeTotalLength + C_GaugePositionFix;
			Gauge.RelativePosition_V3.X = -C_GaugePositionFix / 2;
		}
	}
	
	// ---------------------------------- //
	// Set gauges ratios
	foreach (I => Gauge in _Gauges) {
		if (!Gauge.Visible) continue;
		// Gauge.DrawBlockBackground = _Module == "Stamina";
		
		// ---------------------------------- //
		// Format ratios for gauges until N slots
		if (_Slots <= C_NbGaugesInModel) SetGaugeRatio(Gauge, _Energy - I);
		
		// ---------------------------------- //
		// Format ratio for gauge above N slots
		else SetGaugeRatio(Gauge, _Energy / _Slots);
	}
}

{{{Translations::InjectInManialink(["Laser", "Nucleus", "Arrow", "Rocket", "Stamina", "Sprint Path", "Armor", "Healing Pad", "Healing...", "Zoom Pad", "Arrow Pad", "Safe Zone", "Tunnels", "Handheld Charge", "Frozen Arrow", "Plasma Grenade", "Torpede", "Wide Rail"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the score summary module.
 *
 *	@return		The score summary manialink.
 */
Text Private_CreateManialinkScoreSummary() {
	return """
<manialink version="3" name="LibInterfancy:ScoreSummary">
<stylesheet>
	<style class="bg" size="30 10" colorize="777" />
	<style class="font" textsize="4" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF" />
</stylesheet>

<frame id="Frame_HMDClip" size="320 180" halign="center" valign="center">

<framemodel id="FrameModel_SummaryCardL">
	<label pos="-3 -3" valign="center2" class="font" text="0" halign="right" id="Label_TeamPoints" />
	<label pos="-3 -7" valign="center2" class="font" textsize="2" halign="right" id="Label_TeamRoundPoints" hidden="1" />
	<quad class="bg" image="{{{C_ImgBase}}}UiScoreSummaryLeft.png" halign="right" id="Quad_TeamColorCard" />
</framemodel>

<framemodel id="FrameModel_SummaryCardR">
	<label pos="3 -3" valign="center2" class="font" text="0" halign="left" id="Label_TeamPoints" />
	<label pos="3 -7" valign="center2" class="font" textsize="2" halign="left" id="Label_TeamRoundPoints" hidden="1" />
	<quad class="bg" image="{{{C_ImgBase}}}UiScoreSummaryRight.png" halign="left" id="Quad_TeamColorCard" />
</framemodel>

<frame id="Frame_ScoreSummary" pos="{{{C_LibInterfancy_ScoreSummaryPos.X^" "^C_LibInterfancy_ScoreSummaryPos.Y + 15}}}">
	<frameinstance modelid="FrameModel_SummaryCardL" id="Frame_SummaryCard#0" hidden="1" pos="-65" />
	<frameinstance modelid="FrameModel_SummaryCardL" id="Frame_SummaryCard#1" hidden="1" pos="-37.5" />
	<frameinstance modelid="FrameModel_SummaryCardL" id="Frame_SummaryCard#2" hidden="1" pos="-10" />
	<frameinstance modelid="FrameModel_SummaryCardR" id="Frame_SummaryCard#3" hidden="1" pos="10" />
	<frameinstance modelid="FrameModel_SummaryCardR" id="Frame_SummaryCard#4" hidden="1" pos="37.5" />
	<frameinstance modelid="FrameModel_SummaryCardR" id="Frame_SummaryCard#5" hidden="1" pos="65" />
</frame>

</frame>

<script><!--
/**
 *	LibInterfancy: ScoreSummary
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	15.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ScoreSummary <=> (Page.GetFirstChild("Frame_ScoreSummary") as CMlFrame);

// Load the summary cards
declare CMlFrame[] Frame_SummaryCards;
for (I, 0, 5) Frame_SummaryCards.add((Page.GetFirstChild("Frame_SummaryCard#"^I) as CMlFrame));

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare ScoreSummary_Display = False;
declare ShowScoreSummary = False;
declare ShowRoundPoints = False;

declare NbTeams = Teams.count;
declare UpdateSummaryCards = True;
declare TeamColors = Vec3[Integer];
declare CustomTeamsColors = Vec3[Integer];
declare CustomTeamsPoints = Integer[Integer];
declare ClanRoundScores = [1 => 0, 2 => 0];

declare PrevSettingsUpdate = -1;
declare PrevShowScoreSummary = False;
declare PrevNbTeams = -1;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
declare PrevClanScores = Integer[Integer];
declare PrevClanRoundScores = Integer[Integer];
declare PrevShowRoundPoints = False;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "ScoreSummary_Display" : ScoreSummary_Display = SettingValue == "True";
			case "ScoreSummary_ShowRoundPoints" : ShowRoundPoints = SettingValue == "True";
			case "NbTeams" : NbTeams = ML::Max(TL::ToInteger(SettingValue), 0);
			default : {
				// ---------------------------------- //
				// Set custom color of a team
				if (TL::SubText(SettingName, 0, 15) == "CustomTeamColor") {
					declare Team = TL::ToInteger(TL::Replace(SettingName, "CustomTeamColor", ""));
					if (Team <= 0) continue;
					
					declare ColorText = TL::Split(" ", SettingValue);
					if (ColorText.count != 3) continue;
					
					declare Color = <-1., -1., -1.>;
					for (I, 0, 2) Color[I] = TL::ToReal(ColorText[I]);
					
					// ---------------------------------- //
					// Update the team color
					if (!CustomTeamsColors.existskey(Team) || Color != CustomTeamsColors[Team]) {
						UpdateSummaryCards = True;
						if (Color == <-1., -1., -1.>) {
							declare Removed = CustomTeamsColors.removekey(Team);
						}
						else CustomTeamsColors[Team] = Color;
					}
				}
				// ---------------------------------- //
				// Set custom amount of points of a team
				if (TL::SubText(SettingName, 0, 16) == "CustomTeamPoints") {
					declare Team = TL::ToInteger(TL::Replace(SettingName, "CustomTeamPoints", ""));
					if (Team <= 0) continue;
					
					declare Points = TL::ToInteger(SettingValue);
					if (Points < 0) {
						declare Removed = CustomTeamsPoints.removekey(Team);
					}
					else CustomTeamsPoints[Team] = Points;
				}
			}
		}
	}
}

ShowScoreSummary = ScoreSummary_Display;

// ---------------------------------- //
// Set score summary visibility
if (PrevShowScoreSummary != ShowScoreSummary) {
	PrevShowScoreSummary = ShowScoreSummary;
	
	declare TargetPosition = Frame_ScoreSummary.RelativePosition_V3;
	TargetPosition.Y = {{{C_LibInterfancy_ScoreSummaryPos.Y}}};
	declare TargetEasing = CAnimManager::EAnimManagerEasing::CircOut;
	
	if (!ShowScoreSummary) {
		TargetPosition.Y += C_FrameHideaway;
		TargetEasing = CAnimManager::EAnimManagerEasing::CircIn;
	}
	
	AnimMgr.Add(Frame_ScoreSummary, "<frame pos='"^TargetPosition.X^" "^TargetPosition.Y^"' />", 250, TargetEasing);
}

if (!ShowScoreSummary) continue;

// ---------------------------------- //
// Set round points visibility
if (PrevShowRoundPoints != ShowRoundPoints) {
	PrevShowRoundPoints = ShowRoundPoints;

	foreach (Frame in Frame_SummaryCards) {
		declare Label_TeamRoundPoints <=> (Frame.GetFirstChild("Label_TeamRoundPoints") as CMlLabel);
		Label_TeamRoundPoints.Visible = ShowRoundPoints;
	}
}

ClanRoundScores = [1 => UI.ScoreSummary_RoundPoints1, 2 => UI.ScoreSummary_RoundPoints2];

// ---------------------------------- //
// Update teams cards on teams number change
if (PrevNbTeams != NbTeams) {
	PrevNbTeams = NbTeams;
	UpdateSummaryCards = True;
}

// ---------------------------------- //
// Update teams cards on default teams colors change
foreach (TeamId => Team in Teams) {
	if (PrevTeamsColors[TeamId] == Team.ColorPrimary) continue;
	PrevTeamsColors[TeamId] = Team.ColorPrimary;
	UpdateSummaryCards = True;
}

// ---------------------------------- //
// Update teams cards
if (UpdateSummaryCards) {
	UpdateSummaryCards = False;
	PrevClanScores.clear();
	PrevClanRoundScores.clear();
	
	// Get the colors of the teams
	TeamColors = [1 => Teams[0].ColorPrimary, 2 => Teams[1].ColorPrimary];
	foreach (Team => Color in CustomTeamsColors) TeamColors[Team] = Color;
	
	// First team card offset
	declare Offset = 2 - ML::Clamp(NbTeams - 2, 1, 6) / 2;
	
	// ---------------------------------- //
	// Manage the teams card
	foreach (I => Frame in Frame_SummaryCards) {
		Frame.Visible = I >= Offset && I <= Offset + (NbTeams - 1);
		if (!Frame.Visible) continue;
		declare Clan = I - Offset + 1;
		
		// ---------------------------------- //
		// Update color of the card
		declare Quad_TeamColorCard		<=> (Frame.GetFirstChild("Quad_TeamColorCard") as CMlQuad);
		declare Label_TeamRoundPoints	<=> (Frame.GetFirstChild("Label_TeamRoundPoints") as CMlLabel);
		Label_TeamRoundPoints.Visible = ShowRoundPoints;
		
		declare Color = <.5, .5, .5>;
		if (TeamColors.existskey(Clan)) Color = Brightness(TeamColors[Clan], 1.5);
		Quad_TeamColorCard.Colorize = Color;
	}
}

// ---------------------------------- //
// Update clans scores
for (Clan, 1, NbTeams) {
	// ---------------------------------- //
	// Set match scores
	declare ClanPoints = 0;
	if (CustomTeamsPoints.existskey(Clan)) ClanPoints = CustomTeamsPoints[Clan];
	else if (ClanScores.existskey(Clan)) ClanPoints = ClanScores[Clan];
	
	if (!PrevClanScores.existskey(Clan) || PrevClanScores[Clan] != ClanPoints) {
		PrevClanScores[Clan] = ClanPoints;
		
		// ---------------------------------- //
		// Get the target frame
		declare TeamCardFrameNum = GetTeamCardNum(Clan, NbTeams);
		if (!Frame_SummaryCards.existskey(TeamCardFrameNum)) continue;
		declare Frame = Frame_SummaryCards[TeamCardFrameNum];
		
		// Update displayed points
		declare Label_TeamPoints <=> (Frame.GetFirstChild("Label_TeamPoints") as CMlLabel);
		Label_TeamPoints.Value = TL::ToText(ClanPoints);
		
		// ---------------------------------- //
		// White flash animation
		declare Quad_TeamColorCard <=> (Frame.GetFirstChild("Quad_TeamColorCard") as CMlQuad);
		Quad_TeamColorCard.Colorize = <1., 1., 1.>;
		
		declare TargetColor = "888";
		if (TeamColors.existskey(Clan)) TargetColor = TL::ColorToText(Brightness(TeamColors[Clan], 1.5));
		AnimMgr.Add(Quad_TeamColorCard, "<quad colorize='"^TargetColor^"' />", 250, CAnimManager::EAnimManagerEasing::Linear);
	}
	
	// ---------------------------------- //
	// Set round scores
	if (
		ClanRoundScores.existskey(Clan) &&
		(!PrevClanRoundScores.existskey(Clan) || PrevClanRoundScores[Clan] != ClanRoundScores[Clan])
	) {
		PrevClanRoundScores[Clan] = ClanRoundScores[Clan];
		
		// ---------------------------------- //
		// Get the target frame
		declare TeamCardFrameNum = GetTeamCardNum(Clan, NbTeams);
		if (!Frame_SummaryCards.existskey(TeamCardFrameNum)) continue;
		declare Frame = Frame_SummaryCards[TeamCardFrameNum];
		
		// Update displayed points
		declare Label_TeamRoundPoints <=> (Frame.GetFirstChild("Label_TeamRoundPoints") as CMlLabel);
		Label_TeamRoundPoints.Value = TL::ToText(ML::Max(ClanRoundScores[Clan], 0));
	}
}
***

// ---------------------------------- //
/** Get number of the team's summary card.
 *
 *	@param	_Team		The team to get card number.
 *	@param	_NbTeams	Number of teams shown on the UI.
 *
 *	@return		Number of a summary card for the given team.
 */
Integer GetTeamCardNum(Integer _Team, Integer _NbTeams) {
	if (_Team <= 0 || _NbTeams <= 0) return 0;
	declare Offset = 2 - ML::Clamp(_NbTeams - 2, 1, 6) / 2;
	return Offset + _Team - 1;
}

{{{ManialinkTools::Function("Brightness")}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the countdown module.
 *
 *	@return		The countdown manialink.
 */
Text Private_CreateManialinkCountdown() {
	return """
<manialink version="3" name="LibInterfancy:Countdown">
<frame id="Frame_Countdown" pos="{{{C_LibInterfancy_CountdownPos.X^" "^C_LibInterfancy_CountdownPos.Y}}}">
	<label halign="center" valign="center2" textsize="4" textemboss="1" textcolor="FB0" textfont="Eurostile_Bold" id="Label_Countdown" />
</frame>

<script><!--
/**
 *	LibInterfancy: Countdown
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_CountdownSongsNames 	["Countdown1Compressed.ogg", "Countdown02.ogg"]
#Const C_CountdownSongDuration	30000

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Countdown <=> (Page.GetFirstChild("Frame_Countdown") as CMlFrame);
declare Label_Countdown <=> (Page.GetFirstChild("Label_Countdown") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Persistent settings
declare persistent Boolean Persistent_LibInterfancy_DisableCountdownSong for LocalUser;

// ---------------------------------- //
// Varialbes
declare Countdown_Display = False;
declare Countdown_UseMusic = True;
declare ScoreSummary_Display = False;
declare StartTime = -1;
declare EndTime = -1;
declare CurrentTick = -1;
declare CountdownMusic = CAudioSource;

declare PrevSettingsUpdate = -1;
declare PrevTick = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Countdown_Display" : Countdown_Display = SettingValue == "True";
			case "Countdown_UseMusic" : Countdown_UseMusic = SettingValue == "True";
			case "ScoreSummary_Display" : ScoreSummary_Display = SettingValue == "True";
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
			case "EndTime" : {
				EndTime = TL::ToInteger(SettingValue);
				if (
					CountdownMusic != Null && 
					((EndTime > 0 && GameTime < EndTime - C_CountdownSongDuration) ||
					(EndTime <= 0 && CountdownMusic.PlayCursor < C_CountdownSongDuration / 1000.))
				) {
					CountdownMusic.Stop();
					Audio.DestroySound(CountdownMusic);
					CountdownMusic = Null;
				}
			}
		}
	}
}

// ---------------------------------- //
// Set visibility
Frame_Countdown.Visible = Countdown_Display && StartTime >= 0;

// ---------------------------------- //
// Display current time
if (Frame_Countdown.Visible) {
	declare Integer Time;
	declare Countdown = True;
	
	// ---------------------------------- //
	// UI.CountdownEndTime is greater than zero
	if (UI.CountdownEndTime > 0 && GameTime < UI.CountdownEndTime) {
		Time = GameTime - UI.CountdownEndTime;
		CurrentTick = ML::Abs(Time) / 1000 + 1;
		if (CurrentTick > 4 || CurrentTick < 1) CurrentTick = -1;
	}
	// ---------------------------------- //
	// EndTime is greater than zero
	else if (EndTime > 0) {
		Time = GameTime - EndTime;
		CurrentTick = (-Time + 1000) / 1000;
		if (CurrentTick > 31 || CurrentTick < -1) CurrentTick = -1;
		Countdown = GameTime < EndTime;
	}
	// ---------------------------------- //
	// Display game duration
	else {
		Time = GameTime - StartTime;
		CurrentTick = -1;
		Countdown = False;
	}
	
	// Set label value
	Label_Countdown.Value = TimeToText(Time, Countdown, ScoreSummary_Display && UseClans);
}

// ---------------------------------- //
// Countdown soundtrack
if (
	Countdown_UseMusic && !Persistent_LibInterfancy_DisableCountdownSong &&
	EndTime > 0 && EndTime - GameTime < C_CountdownSongDuration && GameTime < EndTime
) {
	// ---------------------------------- //
	// Create new soundtrack
	if (CountdownMusic == Null) {
		declare NextTrackURL = "{{{C_ImgBase}}}Sounds/"^GetCountdownMusicName();
		if (Http.IsValidUrl(NextTrackURL)) CountdownMusic = Audio.CreateSound(NextTrackURL, 15., True, False, False);
	}
	else {
		// ---------------------------------- //
		// Start the music when countdown begins
		if (!CountdownMusic.IsPlaying) CountdownMusic.Play();

		// Adjust the music play cursor if not matching countdown time
		declare NewPlayCursor = (C_CountdownSongDuration - (EndTime - GameTime)) / 1000.;
		if (ML::Abs(CountdownMusic.PlayCursor - NewPlayCursor) > .0625) CountdownMusic.PlayCursor = NewPlayCursor;
	}
}

// ---------------------------------- //
// Stop countdown soundtrack
if (CountdownMusic != Null && CountdownMusic.IsPlaying && CountdownMusic.PlayCursor > C_CountdownSongDuration / 1000. + 5.) CountdownMusic.Stop();

// ---------------------------------- //
// Show animation when last tick changes
if (PrevTick != CurrentTick) {
	PrevTick = CurrentTick;
	declare AnimStartTick = 0;
	
	// ---------------------------------- //
	// Play countdown sounds when the music is not playing
	if (Countdown_UseMusic && UI.CountdownEndTime <= 0 && (CountdownMusic == Null || CountdownMusic.PlayCursor <= 0) && CurrentTick >= 0) {
		AnimStartTick = 15;
		
		switch (CurrentTick) {
			case 15 : PlayUiSound(::EUISound::Warning, 0, 1.);
			case 1 : Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_D.wav", -12.5);
			case 0 : PlayUiSound(::EUISound::TimeOut, 1, 1.);
			default : if (CurrentTick < 15) {
				if (CurrentTick > 5) Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_B.wav", -12.5);
				else Audio.PlaySoundEvent("{{{C_ImgBase}}}/Sounds/UITimeTick_C.wav", -12.5);
			}
		}
	}
	
	// ---------------------------------- //
	// Display tick animation
	if (CurrentTick > 0 && (AnimStartTick == 0 || CurrentTick < AnimStartTick)) {
		Label_Countdown.RelativeScale = 2.;
		Label_Countdown.RelativeRotation = 7.5;
		if (UI.CountdownEndTime > 0) Label_Countdown.TextColor = <0., 1., 0.>;
		else Label_Countdown.TextColor = <1., 0., 0.>;
		
		AnimMgr.Add(Label_Countdown, "<label scale='1' textcolor='FB0' rot='0' />", 1000, CAnimManager::EAnimManagerEasing::CircOut);
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Compose text from given time
 *
 *	@param	_Time		Time to transform
 *	@param	_Decimal	Display decimal part when under minute
 *	@param	_CompactHr	Show campact version of hour time
 *
 *	@return		Composed text
 */
Text TimeToText(Integer _Time, Boolean _Decimal, Boolean _CompactHr) {
	if (_Time == 0) return "0.00";
	declare Time = ML::Abs(_Time);
	
	if (_Decimal && Time < 60000) return Time / 1000^"."^(Time / 100) % 10;
	
	declare Seconds = (Time / 1000) % 60;
	declare Minutes = (Time / 60000) % 60;
	declare Hours = Time / 3600000;
	
	if (_CompactHr && Hours > 0) {
		declare Separator = ":";
		if (Time % 1000 < 500) Separator = " ";
		return Hours^Separator^TL::FormatInteger(Minutes, 2);
	}
	
	if (Hours > 0) return Hours^":"^TL::FormatInteger(Minutes, 2)^":"^TL::FormatInteger(Seconds, 2);
	return Minutes^":"^TL::FormatInteger(Seconds, 2);
}

// ---------------------------------- //
/** Get name of next countdown track
 *
 *	@return		Name of the next countdown track.
 */
Text GetCountdownMusicName() {
	if (C_CountdownSongsNames.count <= 0) return "";
	declare persistent Text[] Persistent_LibInterfancy_TimerMusics for LocalUser;
	declare persistent Text Persistent_LibInterfancy_PrevCountdownSong for LocalUser;

	// ---------------------------------- //
	// Check if array includes non-existing tracks
	declare Text[] ToRemove;
	foreach (Track in Persistent_LibInterfancy_TimerMusics) if (!C_CountdownSongsNames.exists(Track)) ToRemove.add(Track);
	foreach (Track in ToRemove) {
		declare Removed = Persistent_LibInterfancy_TimerMusics.remove(Track);
	}

	// Fill the list if empty
	if (Persistent_LibInterfancy_TimerMusics.count <= 0)
		Persistent_LibInterfancy_TimerMusics = C_CountdownSongsNames;

	// ---------------------------------- //
	// Get the next track
	declare CountdownMusicName = "";
	while (Persistent_LibInterfancy_TimerMusics.count > 0) {
		CountdownMusicName = Persistent_LibInterfancy_TimerMusics[ML::Rand(0, Persistent_LibInterfancy_TimerMusics.count - 1)];
		if (CountdownMusicName != Persistent_LibInterfancy_PrevCountdownSong) break;
		if (Persistent_LibInterfancy_TimerMusics.count <= 1) break;
	}
	declare Removed = Persistent_LibInterfancy_TimerMusics.remove(CountdownMusicName);
	Persistent_LibInterfancy_PrevCountdownSong = CountdownMusicName;

	return CountdownMusicName;
}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the spectator information module.
 *
 *	@return		The spectator information manialink.
 */
Text Private_CreateManialinkSpecInfo() {
	return """
<manialink version="3" name="LibInterfancy:SpecInfo">
<stylesheet>
	<style id="Label_PlayerName" textemboss="1" textsize="3" textcolor="FFF" textfont="Eurostile" />
	<style id="Label_PlayerZone" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" textprefix="$t" />
</stylesheet>

<frame id="Frame_SpectatorInfo" pos="{{{C_LibInterfancy_SpecInfoPos.X^" "^C_LibInterfancy_SpecInfoPos.Y}}}" hidden="1">
	<label pos="0 3.25" halign="center" valign="center2" id="Label_PlayerName" />
	<quad size="54 3.5" halign="center" valign="center" image="{{{C_ImgBase}}}ColorSeparator.png" id="Quad_PlayerColor" />
	<frame pos="0 -3" id="Frame_PlayerZone">
		<quad size="4 4" valign="center" id="Quad_PlayerZone" />
		<label valign="center2" id="Label_PlayerZone" />
	</frame>
</frame>

<script><!--
/**
 *	LibInterfancy: SpecInfo
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_SpectatorInfo <=> (Page.GetFirstChild("Frame_SpectatorInfo") as CMlFrame);
declare Label_PlayerName <=> (Page.GetFirstChild("Label_PlayerName") as CMlLabel);
declare Quad_PlayerColor <=> (Page.GetFirstChild("Quad_PlayerColor") as CMlQuad);
declare Frame_PlayerZone <=> (Page.GetFirstChild("Frame_PlayerZone") as CMlFrame);
declare Quad_PlayerZone <=> (Page.GetFirstChild("Quad_PlayerZone") as CMlQuad);
declare Label_PlayerZone <=> (Page.GetFirstChild("Label_PlayerZone") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare SpecInfo_Display = True;

/// Update
declare PrevSettingsUpdate = -1;
declare PrevGUIPlayerLogin = "";
declare PrevGUIPlayerHue = -1.;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "SpecInfo_Display" : SpecInfo_Display = SettingValue == "True";
		}
	}
}

// ---------------------------------- //
// Set spectator information visibility
Frame_SpectatorInfo.Visible = SpecInfo_Display && GUIPlayer != Null && GUIPlayer.User != LocalUser && GUIPlayer.Position != <0., 0., 0.>;
if (!Frame_SpectatorInfo.Visible) continue;

// ---------------------------------- //
// Update on color change
if (GUIPlayer != Null && PrevGUIPlayerHue != GUIPlayer.GetLinearHue) {
	PrevGUIPlayerHue = GUIPlayer.GetLinearHue;
	Quad_PlayerColor.Colorize = HsvToRgb(<ML::Clamp(PrevGUIPlayerHue, 0., 1.), 1., 1.>);
}

// ---------------------------------- //
// Update player information
if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
	PrevGUIPlayerLogin = GUIPlayer.User.Login;
	
	// ---------------------------------- //
	// Update name
	declare PlayerName = GUIPlayer.User.Login;
	if (TL::Length(TL::StripFormatting(GUIPlayer.User.Name)) > 3) PlayerName = GUIPlayer.User.Name;
	Label_PlayerName.SetText(PlayerName);
	
	// ---------------------------------- //
	// Update zone name
	declare ZoneName = "World";
	declare ZonePath = TL::Split("|", GUIPlayer.User.ZonePath);
	if (ZonePath.count > 0) ZoneName = ZonePath[ML::Min(2, ZonePath.count - 1)];
	if (GUIPlayer.User.IsFakeUser) ZoneName = "Bot";
	
	// ---------------------------------- //
	// Update zone icon
	if (ZonePath.count > 2) Quad_PlayerZone.ImageUrl = GUIPlayer.User.CountryFlagUrl;
	else Quad_PlayerZone.ImageUrl = GUIPlayer.User.LadderZoneFlagUrl;
	
	// ---------------------------------- //
	// Update position
	Label_PlayerZone.SetText(ZoneName);
	Label_PlayerZone.RelativePosition_V3.X = Quad_PlayerZone.Size.X + .5;
	Frame_PlayerZone.RelativePosition_V3.X = -(Label_PlayerZone.RelativePosition_V3.X + ComputeWidth(Label_PlayerZone)) / 2;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Functions(["ComputeWidth", "HsvToRgb"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		yield;
		+++Yield+++
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the crosshair module.
 *
 *	@return		The crosshair manialink.
 */
Text Private_CreateManialinkCrosshair() {
	return """
<manialink version="3" name="LibInterfancy:Crosshair">
<stylesheet>
	<style class="CrosshairNote" halign="center" valign="center2" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="ch" halign="center" valign="center" />
</stylesheet>

<frame id="Frame_Crosshair" pos="{{{C_LibInterfancy_CrosshairPos.X^" "^C_LibInterfancy_CrosshairPos.Y}}}" hidden="1">
	<quad size="1 1" halign="center" valign="center" image="{{{C_ImgBase}}}Crosshair/Dot.png" id="Quad_CrosshairDot" />
	<frame id="Frame_CrosshairAnim">
		<quad size="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Rocket.png" id="Quad_CrosshairRocket" />
		<quad size="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Laser.png" id="Quad_CrosshairLaser" />
		<quad size="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Nucleus.png" id="Quad_CrosshairNucleus" />
		<quad size="12 48" halign="center" image="{{{C_ImgBase}}}Crosshair/Arrow.png" id="Quad_CrosshairArrow" />
	</frame>
	<frame id="Frame_CrosshairGauge" hidden="1">
		<frame size="16 32" valign="center" halign="left">
			<quad size="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeRight" />
		</frame>
		<frame size="16 32" valign="center" halign="right">
			<quad size="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeLeft" rot="-180" />
		</frame>
	</frame>
</frame>

<frame id="Frame_CrosshairNote" pos="{{{C_LibInterfancy_NearMissMsgPos.X^" "^C_LibInterfancy_NearMissMsgPos.Y}}}">
	<label class="CrosshairNote" id="Label_CrosshairNote" />
	<label class="CrosshairNote" id="Label_CrosshairNote2" />
</frame>

<script><!--
/**
 *	LibInterfancy: Crosshair
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_NearMissDisplayTime	{{{C_LibInterfancy_NearMissDisplayTime}}}
#Const C_OpacityFadeLimit		.125

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Crosshair			<=> (Page.GetFirstChild("Frame_Crosshair") as CMlFrame);
declare Frame_CrosshairAnim		<=> (Page.GetFirstChild("Frame_CrosshairAnim") as CMlFrame);

declare Quad_CrosshairDot		<=> (Page.GetFirstChild("Quad_CrosshairDot") as CMlQuad);
declare Quad_CrosshairLaser		<=> (Page.GetFirstChild("Quad_CrosshairLaser") as CMlQuad);
declare Quad_CrosshairRocket	<=> (Page.GetFirstChild("Quad_CrosshairRocket") as CMlQuad);
declare Quad_CrosshairNucleus	<=> (Page.GetFirstChild("Quad_CrosshairNucleus") as CMlQuad);
declare Quad_CrosshairArrow		<=> (Page.GetFirstChild("Quad_CrosshairArrow") as CMlQuad);

declare Frame_CrosshairGauge	<=> (Page.GetFirstChild("Frame_CrosshairGauge") as CMlFrame);
declare Quad_GaugeRight	<=> (Page.GetFirstChild("Quad_GaugeRight") as CMlQuad);
declare Quad_GaugeLeft	<=> (Page.GetFirstChild("Quad_GaugeLeft") as CMlQuad);

declare Label_CrosshairNote		<=> (Page.GetFirstChild("Label_CrosshairNote") as CMlLabel);
declare Label_CrosshairNote2	<=> (Page.GetFirstChild("Label_CrosshairNote2") as CMlLabel);

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_LibInterfancy_UseCustomCrosshair for LocalUser = True;
declare persistent Persistent_LibInterfancy_HideCrosshairNotes for LocalUser = False;
declare persistent Persistent_LibInterfancy_HideCrosshairGauge for LocalUser = False;

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare Crosshair_Display = True;
declare AnimateCrosshair = False;
declare CrosshairVisible = True;
declare UpdateCrosshairNoteText = True;
declare CrosshairNoteValue = "";
declare CrosshairNoteEndTime = -1;
declare SpawnInvulnerabilityDuration = 2000;

declare PrevGUIPlayerLogin = "";
declare PrevAmmoCount = 0;
declare PrevCurWeapon = 0;
declare PrevCrosshairNoteValue = "";
declare PrevCrosshairNoteEndTime = -1;
declare PrevSettingsUpdate = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	if (Event.Type == CMlEvent::Type::KeyPress) {
		if (Event.KeyName == "B") Persistent_LibInterfancy_UseCustomCrosshair = !Persistent_LibInterfancy_UseCustomCrosshair;
	}
}

// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "SpawnInvulnerabilityDuration" : SpawnInvulnerabilityDuration = TL::ToInteger(SettingValue);
		}
	}
}

CrosshairVisible = !IsInGameMenuDisplayed;

// ---------------------------------- //
// Set crosshair visibility
ClientUI.OverlayHideCrosshair = !Crosshair_Display || Persistent_LibInterfancy_UseCustomCrosshair || !CrosshairVisible;
Frame_Crosshair.Visible =
	ClientUI.OverlayHideCrosshair && CrosshairVisible && GUIPlayer != Null && !GUIPlayer.IsOnTechNoWeapon && !GUIPlayer.IsInWater &&
	GUIPlayer.Position != <0., 0., 0.> && GameTime >= GUIPlayer.StartTime - 1500 &&
	GUIPlayer.CurAmmoMax > 0 && GUIPlayer.CurAmmoUnit > 0 && GUIPlayer.IsInAir != GUIPlayer.IsTouchingGround;

// ---------------------------------- //
// Update GUIPlayer
if (GUIPlayer != Null && PrevGUIPlayerLogin != GUIPlayer.User.Login) {
	PrevGUIPlayerLogin = GUIPlayer.User.Login;
	PrevAmmoCount = 0;
	PrevCurWeapon = 0;
}

// ---------------------------------- //
// Manage crosshair
if (Frame_Crosshair.Visible) {
	Quad_CrosshairDot.Visible = GUIPlayer.CurWeapon != 5;
	
	Quad_CrosshairLaser.Visible = GUIPlayer.CurWeapon == 1;
	Quad_CrosshairRocket.Visible = GUIPlayer.CurWeapon == 2;
	Quad_CrosshairNucleus.Visible = GUIPlayer.CurWeapon == 3;
	Quad_CrosshairArrow.Visible = GUIPlayer.CurWeapon == 5;
	
	// ---------------------------------- //
	// Trigger animation on weapon change
	if (PrevCurWeapon != GUIPlayer.CurWeapon) {
		if (PrevCurWeapon > 0) AnimateCrosshair = True;
		PrevCurWeapon = GUIPlayer.CurWeapon;
	}
	
	// ---------------------------------- //
	// Trigger animation on shoot
	if (PrevAmmoCount != GUIPlayer.CurAmmo) {
		if (PrevAmmoCount > 0 && PrevAmmoCount > GUIPlayer.CurAmmo) AnimateCrosshair = True;
		PrevAmmoCount = GUIPlayer.CurAmmo;
	}

	// ---------------------------------- //
	// Display weapon loading gauge
	Frame_CrosshairGauge.Visible = GUIPlayer.CurAmmo < GUIPlayer.CurAmmoUnit || GameTime - GUIPlayer.StartTime < SpawnInvulnerabilityDuration;
	if (Frame_CrosshairGauge.Visible) {
		declare Ratio = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;

		// Show gauge also while recently spawned player is invincible
		if (GameTime - GUIPlayer.StartTime < SpawnInvulnerabilityDuration)
			Ratio = ML::ToReal(GameTime - GUIPlayer.StartTime) / SpawnInvulnerabilityDuration;
		
		Quad_GaugeRight.RelativeRotation = ML::Clamp(Ratio, 0., .5) * 360 - 180;
		Quad_GaugeLeft.RelativeRotation = ML::Clamp(Ratio, .5, 1.) * 360 - 180;
		Quad_GaugeRight.Opacity = ML::Min(1 - Ratio, C_OpacityFadeLimit) / C_OpacityFadeLimit;
		Quad_GaugeLeft.Opacity = Quad_GaugeRight.Opacity;
		
		Quad_CrosshairLaser.Opacity = 1. - Quad_GaugeRight.Opacity;
		Quad_CrosshairRocket.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairNucleus.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairArrow.Opacity = Quad_CrosshairLaser.Opacity;
	}
	// ---------------------------------- //
	// Reset custom crosshairs opacity
	else if (Quad_CrosshairLaser.Opacity != 1) {
		Quad_CrosshairLaser.Opacity = 1.;
		Quad_CrosshairRocket.Opacity = 1.;
		Quad_CrosshairNucleus.Opacity = 1.;
		Quad_CrosshairArrow.Opacity = 1.;
	}
}

// ---------------------------------- //
// Animate crosshair
if (AnimateCrosshair) {
	AnimateCrosshair = False;
	Frame_CrosshairAnim.RelativeScale = 2.5;
	AnimMgr.Add(Frame_CrosshairAnim, "<frame scale='1' />", 750, CAnimManager::EAnimManagerEasing::CircOut);
}

// ---------------------------------- //
// Update note on GUIPlayer change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
		PrevGUIPlayerLogin = GUIPlayer.User.Login;
		UpdateCrosshairNoteText = True;
	}
} else if (PrevGUIPlayerLogin != "") {
	PrevGUIPlayerLogin = "";
	UpdateCrosshairNoteText = True;
}

// ---------------------------------- //
// Get the current player crosshair note end time
if (GUIPlayer != Null) {
	declare netread Integer Net_LibInterfancy_CrosshairNoteTime for GUIPlayer;
	CrosshairNoteEndTime = Net_LibInterfancy_CrosshairNoteTime;
}
else CrosshairNoteEndTime = -1;

// ---------------------------------- //
// Update note on time change
if (PrevCrosshairNoteEndTime != CrosshairNoteEndTime) {
	PrevCrosshairNoteEndTime = CrosshairNoteEndTime;
	UpdateCrosshairNoteText = True;
}

// ---------------------------------- //
// Hide no longer visible crosshair note
if (CrosshairNoteValue != "" && GameTime > CrosshairNoteEndTime) CrosshairNoteValue = "";

// ---------------------------------- //
// Update crosshair note text
if (UpdateCrosshairNoteText) {
	UpdateCrosshairNoteText = False;

	if (GUIPlayer != Null && !Persistent_LibInterfancy_HideCrosshairNotes && GameTime < CrosshairNoteEndTime) {
		declare netread Text[] Net_LibInterfancy_CrosshairNoteBody for GUIPlayer;
		CrosshairNoteValue = TL::GetTranslatedText(Translate(Net_LibInterfancy_CrosshairNoteBody));
	}
	else CrosshairNoteValue = "";
}

// ---------------------------------- //
// Update crosshair note message
if (PrevCrosshairNoteValue != CrosshairNoteValue) {
	PrevCrosshairNoteValue = CrosshairNoteValue;

	Label_CrosshairNote2.SetText(Label_CrosshairNote.Value);
	Label_CrosshairNote.SetText(CrosshairNoteValue);
	
	Label_CrosshairNote.Opacity = 0.;
	Label_CrosshairNote2.Opacity = 1.;
	Label_CrosshairNote.RelativePosition_V3.Y = 2.;
	Label_CrosshairNote2.RelativePosition_V3.Y = 0.;
	
	AnimMgr.Add(Label_CrosshairNote, "<label pos='0 0' opacity='1' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Label_CrosshairNote2, "<label pos='0 -2' opacity='0' />", 125, CAnimManager::EAnimManagerEasing::Linear);
}

Label_CrosshairNote.Visible = Label_CrosshairNote.Opacity > 0;
Label_CrosshairNote2.Visible = Label_CrosshairNote2.Opacity > 0;
***

{{{Translations::InjectInManialink([
	"Laser", "Nucleus", "Arrow", "Rocket", "Replie", "Skills", "%1 miss",
	"$<%1$> healed you!", "Healed %1 players", "Healed 1 player", "$<%1$> boosted you!", "Boosted %1 players", "Boosted 1 player"
])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Set visibility of a module.
 *
 *	@param	_ModuleName		Name of the module to set visibilty.
 *	@param	_Visible		If True, the module will be visible.
 */
Void SetModuleVisibility(Text _ModuleName, Boolean _Visible) {
	if (Private_ModuleIsLoaded(_ModuleName)) {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = True;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = True;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = True;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = True;
		}
	} else {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = !_Visible;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = !_Visible;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = !_Visible;
			case "Crosshair"	: UIManager.UIAll.OverlayHideCrosshair = !_Visible;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = !_Visible;
		}
	}
	G_LibInterfancy_ModuleVisibility[_ModuleName] = _Visible;
	Private_SetModuleSetting(_ModuleName^"_Display", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Get visibility of a module.
 *
 *	@param	_ModuleName		Name of the module to get its visibility.
 *
 *	@return		True when the module is visible, False otherwise.
 */
Boolean GetModuleVisibility(Text _ModuleName) {
	if (Private_ModuleIsLoaded(_ModuleName) && G_LibInterfancy_ModuleVisibility.existskey(_ModuleName))
		return G_LibInterfancy_ModuleVisibility[_ModuleName];
	
	switch (_ModuleName) {
		case "Countdown"	: return !UIManager.UIAll.OverlayHideCountdown;
		case "SpecInfo"		: return !UIManager.UIAll.OverlayHideSpectatorInfos;
		case "Crosshair"	: return !UIManager.UIAll.OverlayHideCrosshair;
		case "321Go"		: return !UIManager.UIAll.OverlayHide321Go;
	}
	return False;
}

// ---------------------------------- //
/** Load new or replace existing icons in the gauges module.
 *	You can load custom weapons icons, they will appear when
 *	player has custom weapon name specified and icon with such
 *	name has been set.
 *
 *	@param	_IconsImages	Array of gauges icons keyed by their names. Images can be both links
 *							to icons files or an existing game style in format "Style|Substyle".
 */
Void SetGaugesIconsImages(Text[Text] _IconsImages) {
	if (_IconsImages.count <= 0) return;
	foreach (Icon => Image in _IconsImages) Private_SetModuleSetting("Gauges_Icon"^Icon, Image);
}

// ---------------------------------- //
/** Set visibility of the round points in scores summary.
 *
 *	@param	_Visible	If True, round points will be seen aside of the normal points.
 */
Void SetRoundPointsVisibility(Boolean _Visible) {
	Private_SetModuleSetting("ScoreSummary_ShowRoundPoints", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Set visibility of the armor gauge.
 *
 *	@param	_Visible	If True, armor will be visible.
 */
Void SetArmorVisibility(Boolean _Visible) {
	Private_SetModuleSetting("Armor_Display", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Set visibility of the ammo gauge.
 *
 *	@param	_Visible	If True, ammo will be visible.
 */
Void SetAmmoVisibility(Boolean _Visible) {
	Private_SetModuleSetting("Ammo_Display", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Set visibility of the stamina gauge.
 *
 *	@param	_Visible	If True, stamina will be visible.
 */
Void SetStaminaVisibility(Boolean _Visible) {
	Private_SetModuleSetting("Stamina_Display", TL::ToText(_Visible));
}

// ---------------------------------- //
/** Display a notice under player's crosshair.
 *
 *	@param	_Player		The player to display crosshair notice.
 *	@param	_Message	Array of message elements to by the client, first one being the base of the message.
 *	@param	_Duration	Display duration of the crosshair notice.
 */
Void SendCrosshairNote(CSmPlayer _Player, Text[] _Message, Integer _Duration) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _Message.count <= 0 || _Message[0] == "") return;
	
	declare netwrite Integer Net_LibInterfancy_CrosshairNoteTime for _Player;
	declare netwrite Text[] Net_LibInterfancy_CrosshairNoteBody for _Player;
	
	Net_LibInterfancy_CrosshairNoteTime = Now + _Duration;
	Net_LibInterfancy_CrosshairNoteBody = _Message;
}

// ---------------------------------- //
/** Display near miss notice under player's crosshair.
 *
 *	@param	_Player		The player to display near miss notice.
 *	@param	_Distance	Distance of the near miss event.
 */
Void DisplayNearMiss(CSmPlayer _Player, Real _Distance) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _Distance <= 0 || _Distance > 1) return;
	
	// ---------------------------------- //
	// Get the distance text
	declare Text DistanceText;
	if (_Distance > 0 && _Distance < 1) {
		if (_Distance >= 0.01)
			DistanceText = ML::FloorInteger(_Distance * 100)^"cm";
		else if (_Distance >= 0.001)
			DistanceText = ML::FloorInteger(_Distance * 1000)^"mm";
		else
			DistanceText = ML::FloorInteger(_Distance * 1000000)^"µm";
	}
	
	// Send note
	SendCrosshairNote(_Player, ["%1 miss", DistanceText], C_LibInterfancy_NearMissDisplayTime);
}

// ---------------------------------- //
/** Update player's reload speed boost information.
 *
 *	@param	_Player			The player to update boost information.
 *	@param	_StartTime		Reload speed boost start time.
 *	@param	_Duration		Duration of the reload speed boost.
 */
Void SetPlayerReloadData(CSmPlayer _Player, Integer _StartTime, Integer _Duration) {
	if (_Player == Null) return;
	declare netwrite Integer Net_LibInterfancy_BoostStartTime for _Player;
	declare netwrite Integer Net_LibInterfancy_BoostDuration for _Player;
	Net_LibInterfancy_BoostStartTime = _StartTime;
	Net_LibInterfancy_BoostDuration = _Duration;
}

// ---------------------------------- //
/** Change player's interface and character color.
 *
 *	@deprecated		No longer need to use this function to set a player's color.
 *
 *	@param	_Player		The player to set color.
 *	@param	_Color		Color to apply to the player.
 */
Void ForceColor(CSmPlayer _Player, Vec3 _Color) {
	if (_Player == Null) return;
	
	// Set player forced color
	if (_Color != <-1., -1., -1.>) {
		declare Color = _Color;
		for (I, 0, 2) Color[I] = ML::Clamp(Color[I], 0., 1.);
		_Player.ForceColor = Color;
	}
	
	// Reset forced color
	else _Player.ForceColor = <-1., -1., -1.>;
}

// ---------------------------------- //
/** Reset custom color of a player.
 *
 *	@param	_Player		The player to reset custom forced color.
 */
Void ResetColor(CSmPlayer _Player) {
	ForceColor(_Player, <-1., -1., -1.>);
}

// ---------------------------------- //
/** Change the name of weapon currently worn by a player.
 *
 *	@param	_Player		The player to change current weapon name.
 *	@param	_Name		The custom name of weapon to set.
 */
Void SetPlayerCustomWeapon(CSmPlayer _Player, Text _Name) {
	if (_Player == Null || _Player.IsBot) return;
	declare netwrite Text Net_LibInterfancy_CustomWeaponName for _Player;
	Net_LibInterfancy_CustomWeaponName = _Name;
}

// ---------------------------------- //
/** Set custom text displayed on the armor module.
 *
 *	@param	_Player		The player to change the armor text.
 *	@param	_Name		The custom text to set.
 */
Void SetArmorText(CSmPlayer _Player, Text _Value) {
	if (_Player == Null || _Player.IsBot) return;
	declare netwrite Text Net_LibInterfancy_ArmorReplacement for _Player;
	Net_LibInterfancy_ArmorReplacement = _Value;
}

// ---------------------------------- //
/** Set spawn invulnerability duration.
 *
 *	@param	_Duration	Time for how long all players are unable to interact with otherss after being spawned.
 */
Void SetSpawnInvulnerabilityDuration(Integer _Duration) {
	SpawnInvulnerabilityDuration = _Duration;
	Private_SetModuleSetting("SpawnInvulnerabilityDuration", TL::ToText(_Duration));
}

// ---------------------------------- //
/** Set new value for the end time (visuals only).
 *
 *	@param	_NewEndTime		The new end time to set.
 */
Void SetEndTime(Integer _NewEndTime) {
	declare NewEndTime = ML::Max(_NewEndTime, -1);
	Private_SetModuleSetting("EndTime", TL::ToText(NewEndTime));
}

// ---------------------------------- //
/** Set if the countdown module should play the countdown soundtrack.
 *
 *	@param	_UseMusic	If True, special music during the countdown will be played.
 */
Void SetUseMusic(Boolean _UseMusic) {
	Private_SetModuleSetting("Countdown_UseMusic", TL::ToText(_UseMusic));
}

// ---------------------------------- //
/** Set the amount of teams in scores summary.
 *
 *	@param	_NbTeams	The amount of teams playing in the match.
 */
Void SetNbCustomTeams(Integer _NbTeams) {
	Private_SetModuleSetting("NbTeams", TL::ToText(_NbTeams));
}

// ---------------------------------- //
/** Set the color of a custom team in the scores summary.
 *
 *	@param	_Team	Team to set the color.
 *	@param	_Color	The color of a custom team.
 */
Void SetCustomTeamColor(Integer _Team, Vec3 _Color) {
	Private_SetModuleSetting("CustomTeamColor"^_Team, _Color.X^" "^_Color.Y^" "^_Color.Z);
}

// ---------------------------------- //
/** Reset the color of a team in scores summary.
 *
 *	@param	_Team	The team to reset its color.
 */
Void ResetCustomTeamColor(Integer _Team) {
	SetCustomTeamColor(_Team, <-1., -1., -1.>);
}

// ---------------------------------- //
/** Set the amount of points of a custom team in the scores summary.
 *
 *	@param	_Team		Team to set the point samount.
 *	@param	_Points		The amount of points of a custom team.
 */
Void SetCustomTeamPoints(Integer _Team, Integer _Points) {
	Private_SetModuleSetting("CustomTeamPoints"^_Team, TL::ToText(_Points));
}

// ---------------------------------- //
/** Reset the amount of points of a team in scores summary.
 *
 *	@param	_Team	The team to reset its amount of points.
 */
Void ResetCustomTeamPoints(Integer _Team) {
	SetCustomTeamPoints(_Team, -1);
}

// ---------------------------------- //
/** Reset all data sent through network by the library.
 *
 *	@deprecated		No longer need to use this function.
 */
Void ClearData() {}

// ---------------------------------- //
/** Load a module by its name.
 *
 *	@param	_ModuleId	Name of the module to load.
 */
Void LoadModule(Text _ModuleId) {
	if (Private_ModuleIsLoaded(_ModuleId)) return;
	G_LibInterfancy_ModulesLoaded.add(_ModuleId);
	
	switch (_ModuleId) {
		case "Gauges"		: Layers::Create(_ModuleId, Private_CreateManialinkGauges());
		case "ScoreSummary"	: Layers::Create(_ModuleId, Private_CreateManialinkScoreSummary());
		case "Countdown"	: Layers::Create(_ModuleId, Private_CreateManialinkCountdown());
		case "SpecInfo"		: Layers::Create(_ModuleId, Private_CreateManialinkSpecInfo());
		case "Crosshair"	: Layers::Create(_ModuleId, Private_CreateManialinkCrosshair());
	}
	
	Layers::Attach(_ModuleId);
	SetModuleVisibility(_ModuleId, True);
}

// ---------------------------------- //
/** Load several modules by their names.
 *
 *	@param	_ModulesIds		An array with names of modules to load with the library.
 */
Void LoadModules(Text[] _ModulesIds) { foreach (ModuleId in _ModulesIds) LoadModule(ModuleId); }

// ---------------------------------- //
/** Unload a module by its name.
 *
 *	@param	_ModuleId		Name of the module to unload.
 */
Void UnloadModule(Text _ModuleId) {
	declare Removed = G_LibInterfancy_ModulesLoaded.remove(_ModuleId);
	if (Removed) {
		// Remove module layer
		Layers::Detach(_ModuleId);
		Layers::Destroy(_ModuleId);
		SetModuleVisibility(_ModuleId, True);
	}
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	foreach (ModuleId in G_LibInterfancy_ModulesLoaded) UnloadModule(ModuleId);	
	
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = 0;
	Net_LibInterfancy_Settings.clear();
	
	G_LibInterfancy_ModulesLoaded.clear();
	G_LibInterfancy_ModuleVisibility.clear();
	G_LibInterfancy_PrevStartTime = -1;
	G_LibInterfancy_PrevEndTime = -1;
}

// ---------------------------------- //
/// Load the library.
Void Load() { Unload(); }

// ---------------------------------- //
/** (Overload) Load the library with some modules.
 *
 *	@param	_AutoLoadModules	A list of modules to load with the library.
 */
Void Load(Text[] _AutoLoadModules) {
	Load();
	LoadModules(_AutoLoadModules);
}

// ---------------------------------- //
/** Loop containing functions erasing unnecessary data and automatically updating the game start and end time.
 *
 *	@param	_UseDefaultEndTime		Wherher the library should use the default end time value.
 */
Void Loop(Boolean _UseDefaultEndTime) {
	// ---------------------------------- //
	// Update Start and End time in Countdown module
	if (G_LibInterfancy_PrevStartTime != StartTime) {
		G_LibInterfancy_PrevStartTime = StartTime;
		Private_SetModuleSetting("StartTime", TL::ToText(StartTime));
	}
	if (_UseDefaultEndTime && G_LibInterfancy_PrevEndTime != EndTime) {
		G_LibInterfancy_PrevEndTime = EndTime;
		Private_SetModuleSetting("EndTime", TL::ToText(EndTime));
	}
}

// ---------------------------------- //
/// Loop without using the system end time.
Void Loop() { Loop(False); }