// -------------------------------------- //
//  LIBRARY INTERFANCY by domino54        //
//  script version: 2016-12-12            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library features a lot of custom interface
 *	replacement modules, which can be used in all game modes.
 *
 *	Available modules:
 *	- Gauges		Replaces gauges, moves chat and features reload boost indicator
 *	- ScoreSummary	Replaces score summary
 *	- Countdown		Replaces countdown timer
 *	- SpecInfo		Replaces spected player information box
 *	- Crosshair		Replaces crosshair, features also first bullet reload gauge and notices
 */

#Const	Version		"2016-12-12"
#Const	ScriptName	"Interfancy.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_LibInterfancy_WidgetsRotation		2.
#Const C_LibInterfancy_NbGaugesInModel		10
#Const C_LibInterfancy_GaugeTotalLength		48.
#Const C_LibInterfancy_GaugeSpacingWidth	.5
#Const C_LibInterfancy_FrameHideawayPos		-16.
#Const C_LibInterfancy_GaugeSoundVolume		-10.
#Const C_LibInterfancy_NearMissDisplayTime	1000

#Const C_LibInterfancy_ArmorPos			<-154., -84., 5.>
#Const C_LibInterfancy_StaminaPos		<0., -85., 5.>
#Const C_LibInterfancy_AmmunitionPos	<154., -84., 5.>
#Const C_LibInterfancy_ScoreSummaryPos	<0., 90., 5.>
#Const C_LibInterfancy_SpecInfoPos		<0., -68., 5.>
#Const C_LibInterfancy_CountdownPos		<0., 86.25, 5.>
#Const C_LibInterfancy_CrosshairPos		<0., 0., -5.>
#Const C_LibInterfancy_NearMissMsgPos	<0., -7.5, -4.>

// ---------------------------------- //
// Globales
// ---------------------------------- //
declare Text[]			G_LibInterfancy_ModulesLoaded;
declare Boolean[Text]	G_LibInterfancy_ModuleVisibility;
declare Vec3[Text]		G_LibInterfancy_ModulePosition;
declare Integer G_LibInterfancy_PrevStartTime;
declare Integer G_LibInterfancy_PrevEndTime;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Check if a module is loaded
 *
 *	@param	_ModuleId		The module to check
 *
 *	@return					True if the given module is loaded, False otherwise
 */
Boolean Private_ModuleIsLoaded(Text _ModuleId) {
	return (G_LibInterfancy_ModulesLoaded.exists(_ModuleId));
}

// ---------------------------------- //
/** Update the settings for a module
 *
 *	@param	_Name		The name of the setting
 *	@param	_Value		The value of the setting
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = Now;
	Net_LibInterfancy_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Create universal gauge frame for modules
 *
 *	@return		The gauge frame manialink
 */
Text Private_CreateUnivarsalGaugeModel() {
	declare UniversalGaugeModel = "";
	for (I, 0, C_LibInterfancy_NbGaugesInModel - 1) UniversalGaugeModel ^= """
		<gauge sizen="0 8" valign="center" drawbg="0" drawblockbg="0" id="Gauge_Step#{{{I}}}" hidden="1"/>
	""";
	return UniversalGaugeModel;
}

// ---------------------------------- //
/** Create the Gauge module manialink
 *
 *	@return		The Gauges module manialink
 */
Text Private_CreateManialinkGauges() {
	return """
<manialink version="2" name="LibInterfancy:Gauges">
<stylesheet>
	<style class="count" valign="center2" textsize="3" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
	<style class="desc" valign="center2" textsize="1" textemboss="1" textfont="Eurostile_Bold"/>
</stylesheet>

<frame id="Frame_HMDClip" clip="1" clipsizen="320 180">

<frame id="Frame_WidgetArmor" posn="{{{C_LibInterfancy_ArmorPos.X^" "^C_LibInterfancy_ArmorPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_ArmorPos.Z}}}" rot="{{{-C_LibInterfancy_WidgetsRotation}}}">
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<label posn="5 2.75" class="count" id="Label_ModuleCounter"/>
	<frame id="Frame_Gauge" posn="5">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame posn="5 -2.75">
		<label class="desc" id="Label_ModuleInfoText"/>
		<label class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
</frame>

<frame id="Frame_WidgetStamina" posn="{{{C_LibInterfancy_StaminaPos.X^" "^C_LibInterfancy_StaminaPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_StaminaPos.Z}}}">
	<quad posn="0 5" sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad posn="0 5" sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<frame id="Frame_GaugeStamina" posn="{{{-C_LibInterfancy_GaugeTotalLength / 2}}}">
		{{{Private_CreateUnivarsalGaugeModel()}}}
	</frame>
	
	<frame posn="0 -2.75">
		<label halign="center" class="desc" id="Label_ModuleInfoText"/>
		<label halign="center" class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
</frame>

<frame id="Frame_WidgetAmmo" posn="{{{C_LibInterfancy_AmmunitionPos.X^" "^C_LibInterfancy_AmmunitionPos.Y + C_LibInterfancy_FrameHideawayPos^" "^C_LibInterfancy_AmmunitionPos.Z}}}" rot="{{{C_LibInterfancy_WidgetsRotation}}}">
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIcon"/>
	<quad sizen="10 10" halign="center" valign="center" id="Quad_ModuleIconGhost"/>
	
	<label posn="-5 2.75" halign="right" class="count" id="Label_ModuleCounter"/>
	<frame id="Frame_GaugeAmmo" posn="-5 -.35" rot="-180">{{{Private_CreateUnivarsalGaugeModel()}}}</frame>
	
	<frame posn="-5 -2.75">
		<label halign="right" class="desc" id="Label_ModuleInfoText"/>
		<label halign="right" class="desc" id="Label_ModuleInfoGhost"/>
	</frame>
	
	<frame posn="-40 -4"><frame id="Frame_ReloadBoost" posn="0 -8">
		<gauge posn="-1" sizen="24 8" halign="right" valign="center" drawbg="0" drawblockbg="0" ratio="1" id="Gauge_ReloadBoost"/>
		<quad sizen="5 5" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/ReloadBoost.png" id="Quad_BoostIcon"/>
		<label posn="3" class="count" id="Label_BoostTimer"/>
	</frame></frame>
</frame>

</frame>

<script><!--
/**
 *	LibInterfancy: Gauges
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_AvailableModules	["Armor", "Stamina", "Ammo"]
#Const C_WeaponsNames		[1 => "Laser", 2 => "Rocket", 3 => "Nucleus", 5 => "Arrow"]
#Const C_UIChatPosition		[False => <0., 0.>, True => <0., 0.05>]
#Const C_NbGaugesInModel	{{{C_LibInterfancy_NbGaugesInModel}}}
#Const C_FrameHideawayPos	{{{C_LibInterfancy_FrameHideawayPos}}}
#Const C_GaugeTotalLength	{{{C_LibInterfancy_GaugeTotalLength}}}
#Const C_GaugeSpacingWidth	{{{C_LibInterfancy_GaugeSpacingWidth}}}
#Const C_GaugeSoundVolume	{{{C_LibInterfancy_GaugeSoundVolume}}}
#Const C_GaugePositionFix	4.
#Const C_StaminaDisplayTime	1500

/// Icons of the modules
#Const C_ModulesIcons [
	"Armor"		=> "{{{C_ImgBase}}}Icons/Armor.png",
	"Laser"		=> "{{{C_ImgBase}}}Icons/Laser.png",
	"Rocket"	=> "{{{C_ImgBase}}}Icons/Rocket.png",
	"Nucleus"	=> "{{{C_ImgBase}}}Icons/Nucleus.png",
	"Arrow"		=> "{{{C_ImgBase}}}Icons/Arrow.png",
	"Stamina"	=> "{{{C_ImgBase}}}Icons/Jump.png",
	"Sprint"	=> "{{{C_ImgBase}}}Icons/Run.png"
]

#Const C_ModulesSounds [
	"AmmoStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeEnergyBallSlot.wav",
	"ArmorStep"		=> "{{{C_ImgBase}}}SoundGauge/UIGaugeHealthGradFull.wav",
	"StaminaFull"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaFull.wav",
	"StaminaEmpty"	=> "{{{C_ImgBase}}}SoundGauge/UIGaugeStaminaEmpty.wav"
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare CMlGauge[][Text] G_Gauges;
declare Text[Text] G_ModulesIcons;

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ReloadBoost	<=> (Page.GetFirstChild("Frame_ReloadBoost") as CMlFrame);
declare Gauge_ReloadBoost	<=> (Page.GetFirstChild("Gauge_ReloadBoost") as CMlGauge);
declare Label_BoostTimer	<=> (Page.GetFirstChild("Label_BoostTimer") as CMlLabel);
declare Quad_BoostIcon		<=> (Page.GetFirstChild("Quad_BoostIcon") as CMlQuad);

declare CMlFrame[Text] Frame_Widget;
declare CMlLabel[Text] Label_ModuleCounter;
declare CMlLabel[Text] Label_ModuleInfoText;
declare CMlLabel[Text] Label_ModuleInfoGhost;
declare CMlQuad[Text] Quad_ModuleIcon;
declare CMlQuad[Text] Quad_ModuleIconGhost;

foreach (Module in C_AvailableModules) {
	Frame_Widget[Module] = (Page.GetFirstChild("Frame_Widget"^Module) as CMlFrame);
	declare Frame = Frame_Widget[Module];
	
	Label_ModuleCounter[Module] = (Frame.GetFirstChild("Label_ModuleCounter") as CMlLabel);
	Label_ModuleInfoText[Module] = (Frame.GetFirstChild("Label_ModuleInfoText") as CMlLabel);
	Label_ModuleInfoGhost[Module] = (Frame.GetFirstChild("Label_ModuleInfoGhost") as CMlLabel);
	Quad_ModuleIcon[Module] = (Frame.GetFirstChild("Quad_ModuleIcon") as CMlQuad);
	Quad_ModuleIconGhost[Module] = (Frame.GetFirstChild("Quad_ModuleIconGhost") as CMlQuad);
	
	// ---------------------------------- //
	// Load gauge modules
	G_Gauges[Module] = CMlGauge[];
	for (I, 0, C_NbGaugesInModel - 1) G_Gauges[Module].add((Frame.GetFirstChild("Gauge_Step#"^I) as CMlGauge));
}

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];
declare netread Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];

/// Players colors
declare netread Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];

/// Custom weapons
declare netread Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];

// ---------------------------------- //
// Variables
declare Gauges_Display = True;
declare DisplayArmor = True;
declare DisplayAmmo = True;
declare DisplayStamina = True;

declare Vec3 InterfaceColor;
declare StaminaDisplayEndTime = -1;
declare Integer[Text] PlayerIsOnTechArmor;
declare ShowReloadBoost = False;

declare Boolean[Text] FrameVisible;
declare Real[Text] ModuleRatio;
declare Integer[Text] ModuleSlots;
declare Text[Text] ModuleInfoText;
declare Text[Text] ModuleIcon;

/// Update
declare PrevGauges_Display = False;
declare Text PrevGUIPlayerLogin;
declare Integer PrevGUIPlayerCurWeapon;
declare Vec3 PrevInterfaceColor;
declare PrevShowReloadBoost = False;

declare Boolean[Text] PrevFrameVisible;
declare Real[Text] PrevModuleRatio;
declare Integer[Text] PrevModuleSlots;
declare Text[Text] PrevModuleInfoText;
declare Text[Text] PrevModuleIcon;

declare PrevSettingsUpdate = -1;

G_ModulesIcons = C_ModulesIcons;
ModuleIcon["Armor"] = G_ModulesIcons["Armor"];
ModuleSlots["Stamina"] = 1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Gauges_Display"	: Gauges_Display	= SettingValue == "True";
			case "Armor_Display"	: DisplayArmor		= SettingValue == "True";
			case "Ammo_Display"		: DisplayAmmo		= SettingValue == "True";
			case "Stamina_Display"	: DisplayStamina	= SettingValue == "True";
			default : {
				if (TL::SubString(SettingName, 0, 11) == "Gauges_Icon" && SettingValue != "") {
					declare IconId = TL::Replace(SettingName, "Gauges_Icon", "");
					G_ModulesIcons[IconId] = SettingValue;
					PrevModuleIcon.clear();
				}
			}
		}
	}
}

// ---------------------------------- //
// Update interface colour
if (GUIPlayer != Null) {
	// Use the colour of current clan
	if (GUIPlayer.CurrentClan > 0) InterfaceColor = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
	
	// Use colour forced by the mode
	else if (Net_LibInterfancy_ForcedColors.existskey(GUIPlayer.Login))
		InterfaceColor = Net_LibInterfancy_ForcedColors[GUIPlayer.User.Login];
	
	// Use the player favourite colour
	else InterfaceColor = GUIPlayer.User.Color;
}

// ---------------------------------- //
// Set interface colour
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	
	foreach (Module in C_AvailableModules) {
		foreach (Gauge in G_Gauges[Module]) Gauge.Color = InterfaceColor;
		
		declare BrightTextColor = Brightness(InterfaceColor, 4.);
		Label_ModuleInfoText[Module].TextColor = BrightTextColor;
		Label_ModuleInfoGhost[Module].TextColor = BrightTextColor;
	}
	Gauge_ReloadBoost.Color = InterfaceColor;
}

// ---------------------------------- //
// Hide full stamina bar after some delay
if (GUIPlayer != Null && GUIPlayer.Stamina < GUIPlayer.StaminaMax * 3600)
	StaminaDisplayEndTime = Now + C_StaminaDisplayTime;

// ---------------------------------- //
// Set the chat offset
if (PrevGauges_Display != Gauges_Display) {
	PrevGauges_Display = Gauges_Display;
	
	ClientUI.OverlayChatOffset = C_UIChatPosition[Gauges_Display];
	ClientUI.OverlayChatHideAvatar = Gauges_Display;
}

// ---------------------------------- //
// Get for how long players are loading their armor
foreach (Player in Players) {
	if (Player.RequestsSpectate || Player.IsBot || Player.Position == <0., 0., 0.>) continue;
	
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && Player.Armor > 0 && Player.IsOnTechArmor) {
		if (!PlayerIsOnTechArmor.existskey(Player.Login) || PlayerIsOnTechArmor[Player.Login] <= 0)
			PlayerIsOnTechArmor[Player.Login] = GameTime;
	}
	else PlayerIsOnTechArmor[Player.Login] = -1;
}

// ---------------------------------- //
// Manage modules
foreach (Module in C_AvailableModules) {
	// ---------------------------------- //
	// Update module visibility
	declare ShowModule = False;
	switch (Module) {
		case "Armor" : ShowModule = GUIPlayer != Null && DisplayArmor && GUIPlayer.ArmorMax > 0;
		case "Stamina" : ShowModule = GUIPlayer != Null && DisplayStamina && !GUIPlayer.IsOnTechNoWeapon && Now < StaminaDisplayEndTime;
		case "Ammo" : ShowModule = GUIPlayer != Null && DisplayAmmo && GUIPlayer.CurAmmoMax > 0 && GUIPlayer.CurAmmoUnit > 0 && !GUIPlayer.IsOnTechNoWeapon;
	}
	
	FrameVisible[Module] = UI.OverlayHideGauges && Gauges_Display && GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && ShowModule;
	
	// ---------------------------------- //
	// Set module visibility
	if (!PrevFrameVisible.existskey(Module) || PrevFrameVisible[Module] != FrameVisible[Module]) {
		PrevFrameVisible[Module] = FrameVisible[Module];
		
		declare Easing = "EaseOutBack";
		declare Real PosY;
		
		switch (Module) {
			case "Armor" : PosY = {{{C_LibInterfancy_ArmorPos.Y}}};
			case "Stamina" : PosY = {{{C_LibInterfancy_StaminaPos.Y}}};
			case "Ammo" : PosY = {{{C_LibInterfancy_AmmunitionPos.Y}}};
		}
		
		if (!FrameVisible[Module]) {
			PrevModuleRatio[Module] = -1.;
			Easing = "EaseInCirc";
			PosY += C_FrameHideawayPos;
		}
		
		LibManialink_AnimStop(Frame_Widget[Module]);
		declare Position = Frame_Widget[Module].RelativePosition.X^" "^PosY^" "^Frame_Widget[Module].RelativePosition.Z;
		LibManialink_Anim(Frame_Widget[Module], "<frame posn='"^Position^"'/>", 200, Easing);
	}
	
	if (!FrameVisible[Module]) continue;
	
	switch (Module) {
		// ---------------------------------- //
		// Armor module
		case "Armor" : {
			declare GUIPlayerArmorLoaded = 0.;
			if (
				GUIPlayer.Armor % 100 == 0 &&
				PlayerIsOnTechArmor.existskey(GUIPlayer.Login) && PlayerIsOnTechArmor[GUIPlayer.Login] >= 0
			)
				GUIPlayerArmorLoaded = (GameTime - PlayerIsOnTechArmor[GUIPlayer.Login]) % 1850 / 1850.;
			
			ModuleRatio[Module] = GUIPlayer.Armor / 100. + GUIPlayerArmorLoaded;
			ModuleSlots[Module] = GUIPlayer.ArmorMax / 100;
			
			if (GUIPlayer.IsOnTechArmor) {
				if (GUIPlayer.Armor < GUIPlayer.ArmorMax) ModuleInfoText[Module] = "Healing...";
				else ModuleInfoText[Module] = "Healing Pad";
			}
			else if (GUIPlayer.IsOnTechLaser)
				ModuleInfoText[Module] = "Zoom Pad";
			else if (GUIPlayer.IsOnTechArrow)
				ModuleInfoText[Module] = "Arrow Pad";
			else if (GUIPlayer.IsOnTechSafeZone)
				ModuleInfoText[Module] = "Safe Zone";
			else if (GUIPlayer.IsUnderground)
				ModuleInfoText[Module] = "Tunnels";
			else
				ModuleInfoText[Module] = "Armor";
		}
		// ---------------------------------- //
		// Stamina module
		case "Stamina" : {
			ModuleRatio[Module] = (GUIPlayer.Stamina / 3600.) / GUIPlayer.StaminaMax;
			
			if (GUIPlayer.IsOnTech) {
				ModuleInfoText[Module] = "Sprint Path";
				ModuleIcon[Module] = G_ModulesIcons["Sprint"];
			} else {
				ModuleInfoText[Module] = "Stamina";
				ModuleIcon[Module] = G_ModulesIcons["Stamina"];
			}
		}
		// ---------------------------------- //
		// Ammunition module
		case "Ammo" : {
			ModuleRatio[Module] = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;
			ModuleSlots[Module] = GUIPlayer.CurAmmoMax / GUIPlayer.CurAmmoUnit;
			
			// ---------------------------------- //
			// Display name and icon of a custom weapon
			if (
				Net_LibInterfancy_PlayersWeaponsNames.existskey(GUIPlayer.User.Login) &&
				Net_LibInterfancy_PlayersWeaponsNames[GUIPlayer.User.Login] != ""
			) {
				declare WeaponName = Net_LibInterfancy_PlayersWeaponsNames[GUIPlayer.User.Login];
				ModuleInfoText[Module] = WeaponName;
				if (G_ModulesIcons.existskey(WeaponName)) ModuleIcon[Module] = G_ModulesIcons[WeaponName];
			}
			// ---------------------------------- //
			// Display name and icon of a default weapon
			else if (C_WeaponsNames.existskey(GUIPlayer.CurWeapon)) {
				ModuleInfoText[Module] = C_WeaponsNames[GUIPlayer.CurWeapon];
				ModuleIcon[Module] = G_ModulesIcons[C_WeaponsNames[GUIPlayer.CurWeapon]];
			}
			// ---------------------------------- //
			// Display default name and icon, if something went wrong
			else {
				ModuleInfoText[Module] = "Weapon";
				ModuleIcon[Module] = G_ModulesIcons[C_WeaponsNames[2]];
			}
		}
	}
	
	// ---------------------------------- //
	// Format counter
	if (Module != "Stamina")
		Label_ModuleCounter[Module].Value = ML::FloorInteger(ModuleRatio[Module])^"$777/"^ModuleSlots[Module];
	
	// ---------------------------------- //
	// Update gauges ratio
	if (
		!PrevModuleRatio.existskey(Module) || !PrevModuleSlots.existskey(Module) ||
		PrevModuleRatio[Module] != ModuleRatio[Module] ||
		PrevModuleSlots[Module] != ModuleSlots[Module]
	) {
		SetModuleRatio(Module, ModuleRatio[Module], ModuleSlots[Module]);
		
		// ---------------------------------- //
		// Play the interface sounds
		if (PrevGUIPlayerLogin == GUIPlayer.Login && PrevModuleRatio.existskey(Module) && PrevModuleRatio[Module] > -1) {
			if (ML::FloorInteger(ModuleRatio[Module]) > PrevModuleRatio[Module]) {
				switch (Module) {
					// ---------------------------------- //
					// Armor loaded
					case "Armor" : {
						if (GUIPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned)
							Audio.PlaySoundEvent(C_ModulesSounds["ArmorStep"], C_GaugeSoundVolume);
					}
					// ---------------------------------- //
					// Weapon loaded
					case "Ammo" : {
						if (PrevGUIPlayerCurWeapon == GUIPlayer.CurWeapon)
							Audio.PlaySoundEvent(C_ModulesSounds["AmmoStep"], C_GaugeSoundVolume);
						
						else PrevGUIPlayerCurWeapon = GUIPlayer.CurWeapon;
					}
					// ---------------------------------- //
					// Stamina loaded
					case "Stamina" : Audio.PlaySoundEvent(C_ModulesSounds["StaminaFull"], C_GaugeSoundVolume);
				}
			}
			
			if (Module == "Stamina" && ModuleRatio[Module] <= 0 && PrevModuleRatio[Module] > 0)
				Audio.PlaySoundEvent(C_ModulesSounds["StaminaEmpty"], C_GaugeSoundVolume);
		}
		
		PrevModuleRatio[Module] = ModuleRatio[Module];
		PrevModuleSlots[Module] = ModuleSlots[Module];
	}
	
	// ---------------------------------- //
	// Update module information text
	if (!PrevModuleInfoText.existskey(Module) || PrevModuleInfoText[Module] != ModuleInfoText[Module]) {
		Label_ModuleInfoText[Module].SetText("$t"^Translate(ModuleInfoText[Module]));
		if (PrevModuleInfoText.existskey(Module))
			Label_ModuleInfoGhost[Module].SetText("$t"^Translate(PrevModuleInfoText[Module]));
			
		LibManialink_AnimStop(Label_ModuleInfoText[Module]);
		LibManialink_AnimStop(Label_ModuleInfoGhost[Module]);
		
		Label_ModuleInfoText[Module].Opacity = 0.;
		Label_ModuleInfoText[Module].RelativePosition.Y = 1.5;
		Label_ModuleInfoGhost[Module].Opacity = 1.;
		Label_ModuleInfoGhost[Module].RelativePosition.Y = 0.;
		
		LibManialink_Anim(Label_ModuleInfoText[Module], "<label posn='0 0' opacity=1 />", 200, "EaseLinear");
		LibManialink_Anim(Label_ModuleInfoGhost[Module], "<label posn='0 -1.5' opacity=0 />", 200, "EaseLinear");
		PrevModuleInfoText[Module] = ModuleInfoText[Module];
	}
	
	// ---------------------------------- //
	// Update module icon
	if (!PrevModuleIcon.existskey(Module) || PrevModuleIcon[Module] != ModuleIcon[Module]) {
		SetIconImage(Quad_ModuleIcon[Module], ModuleIcon[Module]);
		if (PrevModuleIcon.existskey(Module)) SetIconImage(Quad_ModuleIconGhost[Module], PrevModuleIcon[Module]);
		
		LibManialink_AnimStop(Quad_ModuleIcon[Module]);
		LibManialink_AnimStop(Quad_ModuleIconGhost[Module]);
		
		Quad_ModuleIcon[Module].Opacity = 0.;
		Quad_ModuleIconGhost[Module].Opacity = 1.;
		
		LibManialink_Anim(Quad_ModuleIcon[Module], "<quad opacity=1 />", 125, "EaseLinear");
		LibManialink_Anim(Quad_ModuleIconGhost[Module], "<quad opacity=0 />", 125, "EaseLinear");
		PrevModuleIcon[Module] = ModuleIcon[Module];
	}
}

// ---------------------------------- //
// Reload boost
ShowReloadBoost = (
	GUIPlayer != Null && Net_LibInterfancy_ReloadData.existskey(GUIPlayer.Login) &&
	GameTime <= Net_LibInterfancy_ReloadData[GUIPlayer.Login].X + Net_LibInterfancy_ReloadData[GUIPlayer.Login].Y
);

// ---------------------------------- //
// Relaod boost animation
if (PrevShowReloadBoost != ShowReloadBoost) {
	PrevShowReloadBoost = ShowReloadBoost;
	
	declare Easing = "EaseOutBack";
	declare Real PosY;
	
	if (!ShowReloadBoost) {
		Label_BoostTimer.SetText("0");
		Gauge_ReloadBoost.Size.X = 0.;
		Easing = "EaseInCirc";
		PosY -= 8.;
	}
	
	LibManialink_AnimStop(Frame_ReloadBoost);
	declare Position = Frame_ReloadBoost.RelativePosition.X^" "^PosY^" "^Frame_ReloadBoost.RelativePosition.Z;
	LibManialink_Anim(Frame_ReloadBoost, "<frame posn='"^Position^"'/>", 200, Easing);
}

// ---------------------------------- //
// Setup boost gauge
if (ShowReloadBoost) {
	declare BoostStartTime = Net_LibInterfancy_ReloadData[GUIPlayer.Login].X;
	declare BoostDuration = Net_LibInterfancy_ReloadData[GUIPlayer.Login].Y;
	Gauge_ReloadBoost.Size.X = 20 * (1. - ML::ToReal(GameTime - BoostStartTime) / BoostDuration) + 4.;
	Label_BoostTimer.Value = TL::ToText((BoostStartTime + BoostDuration - GameTime) / 1000 + 1);
}

// Update player
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.Login) PrevGUIPlayerLogin = GUIPlayer.Login;
	if (PrevGUIPlayerCurWeapon != GUIPlayer.CurWeapon) PrevGUIPlayerCurWeapon = GUIPlayer.CurWeapon;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Functions(["SetGaugeRatio", "Brightness"])}}}

// ---------------------------------- //
/** Set icon image of the Quad
 *
 *	@param	_Quad		The Quad to set image
 *	@param	_Image		Image to set
 */
Void SetIconImage(CMlQuad _Quad, Text _Image) {
	if (_Quad == Null) return;
	_Quad.ImageUrl = "";
	_Quad.Style = "";
	_Quad.Substyle = "";
	if (_Image == "") return;
	
	declare ManiaStylePath = TL::Split("|", _Image);
	if (ManiaStylePath.count == 2) {
		_Quad.Style = ManiaStylePath[0];
		_Quad.Substyle = ManiaStylePath[1];
	}
	else _Quad.ImageUrl = _Image;
}

// ---------------------------------- //
/** Set module value
 *
 *	@param	_Module		Module to set energy
 *	@param	_Energy		Amount of currently loaded energy
 *	@param	_Slots		Amount of available energy slots
 */
Void SetModuleRatio(Text _Module, Real _Energy, Integer _Slots) {
	if (!G_Gauges.existskey(_Module)) return;
	declare Gauges = G_Gauges[_Module];
	
	// ---------------------------------- //
	// Hide gauges if there are no slots
	if (_Slots <= 0) {
		foreach (Gauge in Gauges) Gauge.Visible = False;
		
		// There is nothing more to do without slots
		return;
	}
	// ---------------------------------- //
	// Adjust up to N gauges for slots
	else if (_Slots <= Gauges.count) {
		declare SpacingSizeSub = 0.;
		if (_Slots >= 2) SpacingSizeSub = C_GaugeSpacingWidth * (_Slots - 1) / _Slots;
		declare GaugeSlotSize = C_GaugeTotalLength / _Slots + C_GaugePositionFix - SpacingSizeSub;
		
		foreach (I => Gauge in Gauges) {
			Gauge.Visible = I <= _Slots - 1;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = GaugeSlotSize;
			Gauge.RelativePosition.X = (GaugeSlotSize - C_GaugePositionFix) * I - C_GaugePositionFix / 2;
			if (I > 0) Gauge.RelativePosition.X += C_GaugeSpacingWidth * I;
		}
	}
	// ---------------------------------- //
	// Use one gauge for over N slots
	else {
		foreach (I => Gauge in Gauges) {
			Gauge.Visible = I == 0;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = C_GaugeTotalLength + C_GaugePositionFix;
			Gauge.RelativePosition.X = -C_GaugePositionFix / 2;
		}
	}
	
	// ---------------------------------- //
	// Set gauges ratios
	foreach (I => Gauge in Gauges) {
		if (!Gauge.Visible) continue;
		// Gauge.DrawBlockBackground = _Module == "Stamina";
		
		// ---------------------------------- //
		// Format ratios for gauges until N slots
		if (_Slots <= C_NbGaugesInModel) SetGaugeRatio(Gauge, _Energy - I);
		
		// ---------------------------------- //
		// Format ratio for gauge above N slots
		else SetGaugeRatio(Gauge, _Energy / _Slots);
	}
}

{{{Manialink::Animations(["EaseInOutSine", "EaseInCirc", "EaseOutBack"])}}}
{{{Translations::InjectInManialink(["Laser", "Nucleus", "Arrow", "Rocket", "Stamina", "Sprint Path", "Armor", "Healing Pad", "Healing...", "Zoom Pad", "Arrow Pad", "Safe Zone", "Tunnels", "Handheld Charge", "Frozen Arrow", "Plasma Grenade", "Torpede", "Wide Rail"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the score summary module
 *
 *	@return		The manialink
 */
Text Private_CreateManialinkScoreSummary() {
	return """
<manialink version="2" name="LibInterfancy:ScoreSummary">
<stylesheet>
	<style class="bg" sizen="30 10" colorize="777"/>
	<style class="font" textsize="4" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_ScoreSummary" posn="{{{C_LibInterfancy_ScoreSummaryPos.X^" "^C_LibInterfancy_ScoreSummaryPos.Y + 15^" "^C_LibInterfancy_ScoreSummaryPos.Z}}}">
	<quad posn="-10" class="bg" image="{{{C_ImgBase}}}UiScoreSummaryLeft.png" halign="right" id="Quad_SummaryBgLeft"/>
	<label posn="-13 -3" valign="center2" class="font" text="0" halign="right" id="Label_SummaryPtsLeft"/>
	<label posn="-13 -7" valign="center2" class="font" textsize="2" halign="right" id="Label_SummaryRoundLeft" hidden="1"/>
	
	<quad posn="10" class="bg" image="{{{C_ImgBase}}}UiScoreSummaryRight.png" id="Quad_SummaryBgRight"/>
	<label posn="13 -3" valign="center2" class="font" text="0" id="Label_SummaryPtsRight"/>
	<label posn="13 -7" valign="center2" class="font" textsize="2" id="Label_SummaryRoundRight" hidden="1"/>
</frame>

<script><!--
/**
 *	LibInterfancy: ScoreSummary
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	15.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ScoreSummary		<=> (Page.GetFirstChild("Frame_ScoreSummary")		as CMlFrame);
declare Quad_SummaryBgLeft		<=> (Page.GetFirstChild("Quad_SummaryBgLeft")		as CMlQuad);
declare Quad_SummaryBgRight		<=> (Page.GetFirstChild("Quad_SummaryBgRight")		as CMlQuad);
declare Label_SummaryPtsLeft	<=> (Page.GetFirstChild("Label_SummaryPtsLeft")		as CMlLabel);
declare Label_SummaryPtsRight	<=> (Page.GetFirstChild("Label_SummaryPtsRight")	as CMlLabel);
declare Label_SummaryRoundLeft	<=> (Page.GetFirstChild("Label_SummaryRoundLeft")	as CMlLabel);
declare Label_SummaryRoundRight	<=> (Page.GetFirstChild("Label_SummaryRoundRight")	as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare Boolean ScoreSummary_Display;
declare Boolean ShowScoreSummary;
declare ClanRoundScores = [1 => 0, 2 => 0];

declare PrevSettingsUpdate = -1;
declare PrevShowScoreSummary = False;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
declare PrevClanScores = Integer[Integer];
declare PrevClanRoundScores = Integer[Integer];
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "ScoreSummary_Display" : ScoreSummary_Display = SettingValue == "True";
			case "ScoreSummary_ShowRoundPoints" : {
				declare ShowRoundPoints = SettingValue == "True";
				Label_SummaryRoundLeft.Visible = ShowRoundPoints;
				Label_SummaryRoundRight.Visible = ShowRoundPoints;
			}
		}
	}
}

ShowScoreSummary = ScoreSummary_Display && UseClans;

// ---------------------------------- //
// Set score summary visibility
if (PrevShowScoreSummary != ShowScoreSummary) {
	PrevShowScoreSummary = ShowScoreSummary;
	
	declare TargetPosition = Frame_ScoreSummary.RelativePosition;
	TargetPosition.Y = {{{C_LibInterfancy_ScoreSummaryPos.Y}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowScoreSummary) {
		TargetPosition.Y += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
	}
	
	LibManialink_Anim(
		"<frame id='Frame_ScoreSummary' posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>",
		250, TargetEasing
	);
}

if (!ShowScoreSummary) continue;

ClanRoundScores = [1 => UI.ScoreSummary_RoundPoints1, 2 => UI.ScoreSummary_RoundPoints2];

// ---------------------------------- //
// Update teams colors
foreach (TeamId => Team in Teams) {
	if (PrevTeamsColors[TeamId] != Team.ColorPrimary) {
		PrevTeamsColors[TeamId] = Team.ColorPrimary;
	
		LibManialink_AnimStop(Quad_SummaryBgLeft);
		LibManialink_AnimStop(Quad_SummaryBgRight);
		
		Quad_SummaryBgLeft.Colorize = Brightness(Teams[0].ColorPrimary, 1.5);
		Quad_SummaryBgRight.Colorize = Brightness(Teams[1].ColorPrimary, 1.5);
	}
}

// ---------------------------------- //
// Update clans scores
for (Clan, 1, 2) {
	// ---------------------------------- //
	// Set match scores
	if (
		ClanScores.existskey(Clan) && (!PrevClanScores.existskey(Clan) ||
		PrevClanScores[Clan] != ClanScores[Clan])
	) {
		PrevClanScores[Clan] = ClanScores[Clan];
		
		declare CMlLabel Label;
		declare CMlQuad Quad;
		
		switch (Clan) {
			case 1 : {
				Label = Label_SummaryPtsLeft;
				Quad = Quad_SummaryBgLeft;
			}
			case 2 : {
				Label = Label_SummaryPtsRight;
				Quad = Quad_SummaryBgRight;
			}
		}
		
		if (Label != Null) Label.SetText(TL::ToText(ClanScores[Clan]));
		
		if (Quad != Null) {
			Quad.Colorize = <1., 1., 1.>;
			declare TargetColor = TL::ColorToText(Brightness(Teams[Clan - 1].ColorPrimary, 1.5));
			LibManialink_Anim(Quad, "<quad colorize='"^TargetColor^"'/>", 250, "EaseLinear");
		}
	}
	
	// ---------------------------------- //
	// Set round scores
	if (
		ClanRoundScores.existskey(Clan) && (!PrevClanRoundScores.existskey(Clan) ||
		PrevClanRoundScores[Clan] != ClanRoundScores[Clan])
	) {
		PrevClanRoundScores[Clan] = ClanRoundScores[Clan];
		
		declare CMlLabel Label;
		switch (Clan) {
			case 1 : Label = Label_SummaryRoundLeft;
			case 2 : Label = Label_SummaryRoundRight;
		}
		if (Label != Null) Label.SetText(TL::ToText(ML::Max(0, ClanRoundScores[Clan])));
	}
}
***

{{{ManialinkTools::Function("Brightness")}}}
{{{Manialink::Animations(["EaseInCirc", "EaseOutCirc"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the countdown module
 *
 *	@return		The manialink
 */
Text Private_CreateManialinkCountdown() {
	return """
<manialink version="2" name="LibInterfancy:Countdown">
<frame id="Frame_Countdown" posn="{{{C_LibInterfancy_CountdownPos.X^" "^C_LibInterfancy_CountdownPos.Y^" "^C_LibInterfancy_CountdownPos.Z}}}">
	<label halign="center" valign="center2" textsize="4" textemboss="1" textcolor="FB0" textfont="Eurostile_Bold" id="Label_Countdown"/>
</frame>

<script><!--
/**
 *	LibInterfancy: Countdown
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Countdown <=> (Page.GetFirstChild("Frame_Countdown") as CMlFrame);
declare Label_Countdown <=> (Page.GetFirstChild("Label_Countdown") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

// ---------------------------------- //
// Varialbes
declare Countdown_Display = False;
declare StartTime = -1;
declare EndTime = -1;
declare CurrentTick = -1;

declare PrevSettingsUpdate = -1;
declare PrevTick = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "Countdown_Display" : Countdown_Display = SettingValue == "True";
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
			case "EndTime" : EndTime = TL::ToInteger(SettingValue);
		}
	}
}

// ---------------------------------- //
// Set visibility
Frame_Countdown.Visible = Countdown_Display && StartTime >= 0;

// ---------------------------------- //
// Display current time
if (Frame_Countdown.Visible) {
	declare Integer Time;
	
	// ---------------------------------- //
	// UI.CountdownEndTime is greater than zero
	if (UI.CountdownEndTime > 0 && GameTime < UI.CountdownEndTime) {
		Time = GameTime - UI.CountdownEndTime;
		CurrentTick = ML::Abs(Time) / 1000 + 1;
		if (CurrentTick > 4 || CurrentTick < 1) CurrentTick = -1;
	}
	// ---------------------------------- //
	// EndTime is greater than zero
	else if (EndTime > 0 && GameTime < EndTime) {
		Time = GameTime - EndTime;
		CurrentTick = ML::Abs(Time) / 1000 + 1;
		if (CurrentTick > 14 || CurrentTick < 1) CurrentTick = -1;
	}
	// ---------------------------------- //
	// Display game duration
	else {
		Time = GameTime - StartTime;
		CurrentTick = -1;
	}
	
	// Set label value
	Label_Countdown.Value = TimeToText(Time);
}

// ---------------------------------- //
// Show animation when last tick changes
if (PrevTick != CurrentTick) {
	PrevTick = CurrentTick;
	
	if (CurrentTick != -1) {
		LibManialink_AnimStop(Label_Countdown);
		
		Label_Countdown.RelativeScale = 1.75;
		Label_Countdown.RelativeRotation = 7.5;
		if (UI.CountdownEndTime > 0) Label_Countdown.TextColor = <0., 1., 0.>;
		else Label_Countdown.TextColor = <1., 0., 0.>;
		
		LibManialink_Anim(Label_Countdown, "<label scale=1 textcolor=FB0 rot=0 />", 1000, "EaseOutCirc");
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Compose text from given time
 *
 *	@param	_Time	Time to transform
 *
 *	@return		Composed text
 */
Text TimeToText(Integer _Time) {
	if (_Time == 0) return "0:00";
	declare Time = ML::Abs(_Time);
	if (_Time < 0) Time += 1000;
	
	declare Seconds = (Time / 1000) % 60;
	declare Minutes = (Time / 60000) % 60;
	declare Hours = Time / 3600000;
	
	if (Hours > 0) {
		declare Separator = ":";
		if (Time % 1000 < 500) Separator = " ";
		return Hours^Separator^TL::FormatInteger(Minutes, 2);
	}
	return Minutes^":"^TL::FormatInteger(Seconds, 2);
}

{{{Manialink::Animations(["EaseOutCirc"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the spectator information module
 *
 *	@return		The manialink
 */
Text Private_CreateManialinkSpecInfo() {
	return """
<manialink version="2" name="LibInterfancy:SpecInfo">
<stylesheet>
	<style id="Label_PlayerName" textemboss="1" textsize="3" textcolor="FFF" textfont="Eurostile"/>
	<style id="Label_PlayerZone" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" textprefix="$t"/>
</stylesheet>

<frame id="Frame_SpectatorInfo" posn="{{{C_LibInterfancy_SpecInfoPos.X^" "^C_LibInterfancy_SpecInfoPos.Y^" "^C_LibInterfancy_SpecInfoPos.Z}}}" hidden="1">
	<label posn="0 3.25" halign="center" valign="center2" id="Label_PlayerName"/>
	<quad sizen="54 3.5" halign="center" valign="center" image="{{{C_ImgBase}}}ColorSeparator.png" id="Quad_PlayerColor"/>
	<frame posn="0 -3" id="Frame_PlayerZone">
		<quad sizen="4 4" valign="center" id="Quad_PlayerZone"/>
		<label valign="center2" id="Label_PlayerZone"/>
	</frame>
</frame>

<script><!--
/**
 *	LibInterfancy: SpecInfo
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_SpectatorInfo <=> (Page.GetFirstChild("Frame_SpectatorInfo") as CMlFrame);
declare Label_PlayerName <=> (Page.GetFirstChild("Label_PlayerName") as CMlLabel);
declare Quad_PlayerColor <=> (Page.GetFirstChild("Quad_PlayerColor") as CMlQuad);
declare Frame_PlayerZone <=> (Page.GetFirstChild("Frame_PlayerZone") as CMlFrame);
declare Quad_PlayerZone <=> (Page.GetFirstChild("Quad_PlayerZone") as CMlQuad);
declare Label_PlayerZone <=> (Page.GetFirstChild("Label_PlayerZone") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInterfancy_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInterfancy_Settings for Teams[0];

/// Players colors
declare netread Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];

// ---------------------------------- //
// Variables
declare SpecInfo_Display = True;

/// Update
declare PrevSettingsUpdate = -1;
declare PrevGUIPlayerLogin = "";
declare PrevGUIPlayerClan = -1;
declare PrevTeamsColors = [0 => Vec3, 1 => Vec3];
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInterfancy_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInterfancy_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInterfancy_Settings) {
		switch (SettingName) {
			case "SpecInfo_Display" : SpecInfo_Display = SettingValue == "True";
		}
	}
}

// ---------------------------------- //
// Set spectator information visibility
Frame_SpectatorInfo.Visible = SpecInfo_Display && GUIPlayer != Null && GUIPlayer.User != LocalUser && GUIPlayer.Position != <0., 0., 0.>;
if (!Frame_SpectatorInfo.Visible) continue;

// ---------------------------------- //
// Update on player clan change
if (PrevGUIPlayerClan != GUIPlayer.CurrentClan) {
	PrevGUIPlayerClan = GUIPlayer.CurrentClan;
	PrevGUIPlayerLogin = "";
}

// ---------------------------------- //
// Update on team color change
for (I, 0, 1) if (PrevTeamsColors[I] != Teams[I].ColorPrimary) {
	PrevTeamsColors[I] = Teams[I].ColorPrimary;
	if (I == GUIPlayer.CurrentClan - 1) PrevGUIPlayerLogin = "";
}

// ---------------------------------- //
// Update player information
if (PrevGUIPlayerLogin != GUIPlayer.Login) {
	PrevGUIPlayerLogin = GUIPlayer.Login;
	
	// ---------------------------------- //
	// Update name
	declare PlayerName = GUIPlayer.Login;
	if (TL::Length(TL::StripFormatting(GUIPlayer.User.Name)) > 3) PlayerName = GUIPlayer.User.Name;
	Label_PlayerName.SetText(PlayerName);
	
	// ---------------------------------- //
	// Update colour
	declare Color = GUIPlayer.User.Color;
	
	// Use the player clan colour
	if (GUIPlayer.CurrentClan > 0) Color = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
	
	// Use forced colour
	else if (Net_LibInterfancy_ForcedColors.existskey(GUIPlayer.User.Login))
		Color = Net_LibInterfancy_ForcedColors[GUIPlayer.User.Login];
	
	Quad_PlayerColor.Colorize = Color;
	
	// ---------------------------------- //
	// Update zone name
	declare ZoneName = "World";
	declare ZonePath = TL::Split("|", GUIPlayer.User.ZonePath);
	if (ZonePath.count > 0) ZoneName = ZonePath[ML::Min(2, ZonePath.count - 1)];
	if (GUIPlayer.User.IsFakeUser) ZoneName = "Bot";
	
	// ---------------------------------- //
	// Update zone icon
	if (ZonePath.count > 2) Quad_PlayerZone.ImageUrl = GUIPlayer.User.CountryFlagUrl;
	else Quad_PlayerZone.ImageUrl = GUIPlayer.User.LadderZoneFlagUrl;
	
	// ---------------------------------- //
	// Update position
	Label_PlayerZone.SetText(ZoneName);
	Label_PlayerZone.RelativePosition.X = Quad_PlayerZone.Size.X + .5;
	Frame_PlayerZone.RelativePosition.X = -(Label_PlayerZone.RelativePosition.X + ComputeWidth(Label_PlayerZone)) / 2;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

{{{ManialinkTools::Function("ComputeWidth")}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		yield;
		+++Yield+++
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the crosshair module
 *
 *	@return		The manialink
 */
Text Private_CreateManialinkCrosshair() {
	return """
<manialink version="2" name="LibInterfancy:Crosshair">
<stylesheet>
	<style class="MissMessage" halign="center" valign="center2" textemboss="1" textsize="2" textcolor="FFF" textfont="Eurostile_Bold"/>
	<style class="ch" halign="center" valign="center"/>
</stylesheet>

<frame id="Frame_Crosshair" posn="{{{C_LibInterfancy_CrosshairPos.X^" "^C_LibInterfancy_CrosshairPos.Y^" "^C_LibInterfancy_CrosshairPos.Z}}}" hidden="1">
	<quad sizen="1 1" halign="center" valign="center" image="{{{C_ImgBase}}}Crosshair/Dot.png" id="Quad_CrosshairDot"/>
	<frame id="Frame_CrosshairAnim">
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Rocket.png" id="Quad_CrosshairRocket"/>
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Laser.png" id="Quad_CrosshairLaser"/>
		<quad sizen="16 16" class="ch" image="{{{C_ImgBase}}}Crosshair/Nucleus.png" id="Quad_CrosshairNucleus"/>
		<quad sizen="12 48" halign="center" image="{{{C_ImgBase}}}Crosshair/Arrow.png" id="Quad_CrosshairArrow"/>
	</frame>
	<frame id="Frame_CrosshairGauge" hidden="1">
		<frame clip="1" clipposn="8" clipsizen="16 32">
			<quad posn="-.2" sizen="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeRight"/>
		</frame>
		<frame clip="1" clipposn="-8" clipsizen="16 32">
			<quad posn=".2" sizen="28 28" class="ch" image="{{{C_ImgBase}}}Crosshair/Gauge.png" id="Quad_GaugeLeft"/>
		</frame>
	</frame>
</frame>

<frame id="Frame_NearMissMessage" posn="{{{C_LibInterfancy_NearMissMsgPos.X^" "^C_LibInterfancy_NearMissMsgPos.Y^" "^C_LibInterfancy_NearMissMsgPos.Z}}}">
	<label class="MissMessage" id="Label_NearMissMessage"/>
	<label class="MissMessage" id="Label_NearMissGhost"/>
</frame>

<script><!--
/**
 *	LibInterfancy: Crosshair
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_NearMissDisplayTime	{{{C_LibInterfancy_NearMissDisplayTime}}}
#Const C_OpacityFadeLimit		.125

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Crosshair			<=> (Page.GetFirstChild("Frame_Crosshair") as CMlFrame);
declare Frame_CrosshairAnim		<=> (Page.GetFirstChild("Frame_CrosshairAnim") as CMlFrame);

declare Quad_CrosshairDot		<=> (Page.GetFirstChild("Quad_CrosshairDot") as CMlQuad);
declare Quad_CrosshairLaser		<=> (Page.GetFirstChild("Quad_CrosshairLaser") as CMlQuad);
declare Quad_CrosshairRocket	<=> (Page.GetFirstChild("Quad_CrosshairRocket") as CMlQuad);
declare Quad_CrosshairNucleus	<=> (Page.GetFirstChild("Quad_CrosshairNucleus") as CMlQuad);
declare Quad_CrosshairArrow		<=> (Page.GetFirstChild("Quad_CrosshairArrow") as CMlQuad);

declare Frame_CrosshairGauge	<=> (Page.GetFirstChild("Frame_CrosshairGauge") as CMlFrame);
declare Quad_GaugeRight	<=> (Page.GetFirstChild("Quad_GaugeRight") as CMlQuad);
declare Quad_GaugeLeft	<=> (Page.GetFirstChild("Quad_GaugeLeft") as CMlQuad);

declare Label_NearMissMessage	<=> (Page.GetFirstChild("Label_NearMissMessage") as CMlLabel);
declare Label_NearMissGhost		<=> (Page.GetFirstChild("Label_NearMissGhost") as CMlLabel);

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_LibInterfancy_UseCustomCrosshair for LocalUser = True;

// ---------------------------------- //
// Netcode
declare netread Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
declare netread Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];

// ---------------------------------- //
// Variables
declare Crosshair_Display = True;
declare AnimateCrosshair = False;
declare UpdateNote = True;
declare CrosshairNote = "";
declare CrosshairNoteTime = -1;

declare PrevGUIPlayerLogin = "";
declare PrevAmmoCount = 0;
declare PrevCurWeapon = 0;
declare PrevCrosshairNote = "";
declare PrevCrosshairNoteTime = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	if (Event.Type == CMlEvent::Type::KeyPress) {
		if (Event.KeyName == "B") Persistent_LibInterfancy_UseCustomCrosshair = !Persistent_LibInterfancy_UseCustomCrosshair;
	}
}

// ---------------------------------- //
// Set crosshair visibility
ClientUI.OverlayHideCrosshair = !Crosshair_Display || Persistent_LibInterfancy_UseCustomCrosshair;
Frame_Crosshair.Visible =
	ClientUI.OverlayHideCrosshair && GUIPlayer != Null && !GUIPlayer.IsOnTechNoWeapon && !GUIPlayer.IsInWater &&
	GUIPlayer.Position != <0., 0., 0.> && GameTime >= GUIPlayer.StartTime - 1500 &&
	GUIPlayer.CurAmmoMax > 0 && GUIPlayer.CurAmmoUnit > 0;

// ---------------------------------- //
// Update GUIPlayer
if (GUIPlayer != Null && PrevGUIPlayerLogin != GUIPlayer.Login) {
	PrevGUIPlayerLogin = GUIPlayer.Login;
	PrevAmmoCount = 0;
	PrevCurWeapon = 0;
}

// ---------------------------------- //
// Manage crosshair
if (Frame_Crosshair.Visible) {
	Quad_CrosshairDot.Visible = GUIPlayer.CurWeapon != 5;
	Frame_CrosshairGauge.Visible = GUIPlayer.CurAmmo < GUIPlayer.CurAmmoUnit;
	
	Quad_CrosshairLaser.Visible = GUIPlayer.CurWeapon == 1;
	Quad_CrosshairRocket.Visible = GUIPlayer.CurWeapon == 2;
	Quad_CrosshairNucleus.Visible = GUIPlayer.CurWeapon == 3;
	Quad_CrosshairArrow.Visible = GUIPlayer.CurWeapon == 5;
	
	// ---------------------------------- //
	// Trigger animation on weapon change
	if (PrevCurWeapon != GUIPlayer.CurWeapon) {
		if (PrevCurWeapon > 0) AnimateCrosshair = True;
		PrevCurWeapon = GUIPlayer.CurWeapon;
	}
	
	// ---------------------------------- //
	// Trigger animation on shoot
	if (PrevAmmoCount != GUIPlayer.CurAmmo) {
		if (PrevAmmoCount > 0 && PrevAmmoCount > GUIPlayer.CurAmmo) AnimateCrosshair = True;
		PrevAmmoCount = GUIPlayer.CurAmmo;
	}
	
	// ---------------------------------- //
	// Display Gauge
	if (Frame_CrosshairGauge.Visible) {
		declare Ratio = ML::ToReal(GUIPlayer.CurAmmo) / GUIPlayer.CurAmmoUnit;
		Quad_GaugeRight.RelativeRotation = ML::Clamp(Ratio, 0., .5) * 360 - 180;
		Quad_GaugeLeft.RelativeRotation = ML::Clamp(Ratio, .5, 1.) * 360 - 180;
		
		Quad_GaugeRight.Opacity = ML::Min(1 - Ratio, C_OpacityFadeLimit) / C_OpacityFadeLimit;
		Quad_GaugeLeft.Opacity = Quad_GaugeRight.Opacity;
		
		Quad_CrosshairLaser.Opacity = 1. - Quad_GaugeRight.Opacity;
		Quad_CrosshairRocket.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairNucleus.Opacity = Quad_CrosshairLaser.Opacity;
		Quad_CrosshairArrow.Opacity = Quad_CrosshairLaser.Opacity;
	}
	// ---------------------------------- //
	// Reset opacity
	else {
		Quad_CrosshairLaser.Opacity = 1.;
		Quad_CrosshairRocket.Opacity = 1.;
		Quad_CrosshairNucleus.Opacity = 1.;
		Quad_CrosshairArrow.Opacity = 1.;
	}
}

// ---------------------------------- //
// Animate crosshair
if (AnimateCrosshair) {
	AnimateCrosshair = False;
	LibManialink_AnimStop(Frame_CrosshairAnim);
	Frame_CrosshairAnim.RelativeScale = 2.5;
	LibManialink_Anim(Frame_CrosshairAnim, "<frame scale=1 />", 750, "EaseOutCirc");
}

// ---------------------------------- //
// Update note on GUIPlayer change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.Login) {
		PrevGUIPlayerLogin = GUIPlayer.Login;
		UpdateNote = True;
	}
} else if (PrevGUIPlayerLogin != "") {
	PrevGUIPlayerLogin = "";
	UpdateNote = True;
}

// ---------------------------------- //
// Get the current player crosshair note end time
if (GUIPlayer != Null && Net_LibInterfancy_CrosshairNoteTime.existskey(GUIPlayer.Login)) {
	if (GameTime < Net_LibInterfancy_CrosshairNoteTime[GUIPlayer.Login]) {
		CrosshairNoteTime = Net_LibInterfancy_CrosshairNoteTime[GUIPlayer.Login];
	} else CrosshairNoteTime = -1;
} else CrosshairNoteTime = -1;

// ---------------------------------- //
// Update on time change
if (PrevCrosshairNoteTime != CrosshairNoteTime) {
	PrevCrosshairNoteTime = CrosshairNoteTime;
	UpdateNote = True;
}

// ---------------------------------- //
// Update note text
if (UpdateNote) {
	UpdateNote = False;
	if (PrevCrosshairNoteTime > 0 && Net_LibInterfancy_CrosshairNote.existskey(GUIPlayer.Login))
		CrosshairNote = TL::GetTranslatedText(Translate(Net_LibInterfancy_CrosshairNote[GUIPlayer.Login]));
	else
		CrosshairNote = "";
}

// ---------------------------------- //
// Update near miss message
if (PrevCrosshairNote != CrosshairNote) {
	PrevCrosshairNote = CrosshairNote;
	Label_NearMissGhost.SetText(Label_NearMissMessage.Value);
	Label_NearMissMessage.SetText(CrosshairNote);
	
	LibManialink_AnimStop(Label_NearMissMessage);
	LibManialink_AnimStop(Label_NearMissGhost);
	
	Label_NearMissMessage.Opacity = 0.;
	Label_NearMissGhost.Opacity = 1.;
	Label_NearMissMessage.RelativePosition.Y = 2.;
	Label_NearMissGhost.RelativePosition.Y = 0.;
	
	LibManialink_Anim(Label_NearMissMessage, "<label posn='0 0' opacity=1 />", 125, "EaseLinear");
	LibManialink_Anim(Label_NearMissGhost, "<label posn='0 -2' opacity=0 />", 125, "EaseLinear");
}

Label_NearMissMessage.Visible = Label_NearMissMessage.Opacity > 0;
Label_NearMissGhost.Visible = Label_NearMissGhost.Opacity > 0;
***

{{{Manialink::Animations(["EaseLinear", "EaseOutCirc"])}}}
{{{Translations::InjectInManialink(["%1 miss", "$<%1$> healed you!", "Healed %1 players", "Healed 1 player", "$<%1$> boosted you!", "Boosted %1 players", "Boosted 1 player", "Laser", "Nucleus", "Arrow", "Rocket", "Skills"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
 *
 *	@return		The version number of the script
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script
 *
 *	@return		The name of the script
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Display a module
 *
 *	@param	_ModuleName		The name of the module to set
 *	@param	_Display		Show or not the module
 */
Void SetModuleVisibility(Text _ModuleName, Boolean _Display) {
	if (Private_ModuleIsLoaded(_ModuleName)) {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = True;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = True;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = True;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = True;
		}
	} else {
		switch (_ModuleName) {
			case "Gauges"		: UIManager.UIAll.OverlayHideGauges = !_Display;
			case "Countdown"	: UIManager.UIAll.OverlayHideCountdown = !_Display;
			case "SpecInfo"		: UIManager.UIAll.OverlayHideSpectatorInfos = !_Display;
			case "Crosshair"	: UIManager.UIAll.OverlayHideCrosshair = !_Display;
			case "321Go"		: UIManager.UIAll.OverlayHide321Go = !_Display;
		}
	}
	G_LibInterfancy_ModuleVisibility[_ModuleName] = _Display;
	Private_SetModuleSetting(_ModuleName^"_Display", TL::ToText(_Display));
}

// ---------------------------------- //
/** Get the visibility of a module
 *
 *	@param	_ModuleName		The name of the module to get
 *
 *	@return					True if the module is visible, False otherwise
 */
Boolean GetModuleVisibility(Text _ModuleName) {
	if (Private_ModuleIsLoaded(_ModuleName) && G_LibInterfancy_ModuleVisibility.existskey(_ModuleName))
		return G_LibInterfancy_ModuleVisibility[_ModuleName];
	
	switch (_ModuleName) {
		case "Countdown"	: return !UIManager.UIAll.OverlayHideCountdown;
		case "SpecInfo"		: return !UIManager.UIAll.OverlayHideSpectatorInfos;
		case "Crosshair"	: return !UIManager.UIAll.OverlayHideCrosshair;
		case "321Go"		: return !UIManager.UIAll.OverlayHide321Go;
	}
	return False;
}

// ---------------------------------- //
/** Set icon images used in the Gauges module
 *
 *	@param	_IconImages		Icon images. Can be both image or style.
 */
Void SetGaugesIconsImages(Text[Text] _IconImages) {
	if (_IconImages.count <= 0) return;
	foreach (Icon => Image in _IconImages) Private_SetModuleSetting("Gauges_Icon"^Icon, Image);
}

// ---------------------------------- //
/** Set round points visibility in scores summary
 *
 *	@param	_Visible	Round points visibility
 */
Void SetRoundPointsVisibility(Boolean _Visible) {
	Private_SetModuleSetting("ScoreSummary_ShowRoundPoints", TL::ToText(_Visible));
}

// ---------------------------------- //
/// Update Start and End time in Countdown module
Void UpdateTime() {
	if (G_LibInterfancy_PrevStartTime != StartTime) {
		G_LibInterfancy_PrevStartTime = StartTime;
		Private_SetModuleSetting("StartTime", TL::ToText(StartTime));
	}
	if (G_LibInterfancy_PrevEndTime != EndTime) {
		G_LibInterfancy_PrevEndTime = EndTime;
		Private_SetModuleSetting("EndTime", TL::ToText(EndTime));
	}
}

// ---------------------------------- //
/** Display crosshair message
 *
 *	@param	_Player			The player to display message
 *	@param	_NoteParams		Message parameters
 *	@param	_Duration		Duration of the message
 */
Void SendCrosshairNote(CSmPlayer _Player, Text[] _NoteParams, Integer _Duration) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _NoteParams.count <= 0 || _NoteParams[0] == "") return;
	
	declare netwrite Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
	declare netwrite Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];
	
	Net_LibInterfancy_CrosshairNote[_Player.User.Login] = _NoteParams;
	Net_LibInterfancy_CrosshairNoteTime[_Player.User.Login] = Now + _Duration;
}

// ---------------------------------- //
/** Display near miss message
 *
 *	@param	_Player		The player to display message
 *	@param	_Distance	Miss distance
 */
Void DisplayNearMiss(CSmPlayer _Player, Real _Distance) {
	if (_Player == Null || _Player.IsBot || _Player.IsFakePlayer || _Distance <= 0 || _Distance > 1) return;
	
	// ---------------------------------- //
	// Get the distance text
	declare Text DistanceText;
	if (_Distance > 0 && _Distance < 1) {
		if (_Distance >= 0.01)
			DistanceText = ML::FloorInteger(_Distance * 100)^"cm";
		else if (_Distance >= 0.001)
			DistanceText = ML::FloorInteger(_Distance * 1000)^"mm";
		else
			DistanceText = ML::FloorInteger(_Distance * 1000000)^"µm";
	}
	
	// Send note
	SendCrosshairNote(_Player, ["%1 miss", DistanceText], C_LibInterfancy_NearMissDisplayTime);
}

// ---------------------------------- //
/** Set player reload boost data
 *
 *	@param	_Player			Player to set data
 *	@param	_StartTime		Reload boost start time
 *	@param	_Duration		Reload boost duration
 */
Void SetPlayerReloadData(CSmPlayer _Player, Integer _StartTime, Integer _Duration) {
	if (_Player == Null) return;
	declare netwrite Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];
	Net_LibInterfancy_ReloadData[_Player.User.Login] = <_StartTime, _Duration, 0>;
}

// ---------------------------------- //
/** Force interface colour for a player
 *
 *	@param	_Player		The player to force colour
 *	@param	_Color		The colour to force
 */
Void ForceColor(CSmPlayer _Player, Vec3 _Color) {
	if (_Player == Null) return;
	
	declare Color = _Color;
	for (I, 0, 2) Color[I] = ML::Clamp(Color[I], 0., 1.);
	_Player.ForceColor = _Color;
	
	declare netwrite Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];
	Net_LibInterfancy_ForcedColors[_Player.User.Login] = Color;
}

Void SetPlayerCustomWeapon(CSmPlayer _Player, Text _CustomWeapon) {
	if (_Player == Null || _Player.IsBot) return;
	
	declare netwrite Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];
	
	if (_CustomWeapon != "") Net_LibInterfancy_PlayersWeaponsNames[_Player.User.Login] = _CustomWeapon;
	
	else if (Net_LibInterfancy_PlayersWeaponsNames.existskey(_Player.User.Login)) {
		declare Removed = Net_LibInterfancy_PlayersWeaponsNames.removekey(_Player.User.Login);
	}
}

// ---------------------------------- //
/// Reset all library net data
Void ClearData() {
	declare netwrite Text[][Text] Net_LibInterfancy_CrosshairNote for Teams[0];
	declare netwrite Integer[Text] Net_LibInterfancy_CrosshairNoteTime for Teams[0];
	declare netwrite Int3[Text] Net_LibInterfancy_ReloadData for Teams[0];
	declare netwrite Vec3[Text] Net_LibInterfancy_ForcedColors for Teams[0];
	declare netwrite Text[Text] Net_LibInterfancy_PlayersWeaponsNames for Teams[0];
	
	Net_LibInterfancy_CrosshairNote.clear();
	Net_LibInterfancy_CrosshairNoteTime.clear();
	Net_LibInterfancy_ReloadData.clear();
	Net_LibInterfancy_ForcedColors.clear();
	Net_LibInterfancy_PlayersWeaponsNames.clear();
}

// ---------------------------------- //
/** Load a module
 *
 *	@param	_ModuleId		The name of the module to load
 */
Void LoadModule(Text _ModuleId) {
	if (Private_ModuleIsLoaded(_ModuleId)) return;
	G_LibInterfancy_ModulesLoaded.add(_ModuleId);
	
	switch (_ModuleId) {
		case "Gauges"		: Layers::Create(_ModuleId, Private_CreateManialinkGauges());
		case "ScoreSummary"	: Layers::Create(_ModuleId, Private_CreateManialinkScoreSummary());
		case "Countdown"	: Layers::Create(_ModuleId, Private_CreateManialinkCountdown());
		case "SpecInfo"		: Layers::Create(_ModuleId, Private_CreateManialinkSpecInfo());
		case "Crosshair"	: Layers::Create(_ModuleId, Private_CreateManialinkCrosshair());
	}
	
	Layers::Attach(_ModuleId);
	SetModuleVisibility(_ModuleId, True);
}

// ---------------------------------- //
/** Load several modules
 *
 *	@param	_ModulesIds		A list of modules to load with the library
 */
Void LoadModules(Text[] _ModulesIds) { foreach (ModuleId in _ModulesIds) LoadModule(ModuleId); }

// ---------------------------------- //
/** Unload a module
 *
 *	@param	_ModuleId		The name of the module to unload
 */
Void UnloadModule(Text _ModuleId) {
	declare Removed = G_LibInterfancy_ModulesLoaded.remove(_ModuleId);
	if (Removed) {
		// Remove module layer
		Layers::Detach(_ModuleId);
		Layers::Destroy(_ModuleId);
		SetModuleVisibility(_ModuleId, True);
	}
}

// ---------------------------------- //
/// Unload the library
Void Unload() {
	foreach (ModuleId in G_LibInterfancy_ModulesLoaded) UnloadModule(ModuleId);		
	
	declare netwrite Net_LibInterfancy_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInterfancy_Settings for Teams[0] = Text[Text];
	Net_LibInterfancy_SettingsUpdate = 0;
	Net_LibInterfancy_Settings.clear();
	
	G_LibInterfancy_ModulesLoaded.clear();
	G_LibInterfancy_ModuleVisibility.clear();
	G_LibInterfancy_PrevStartTime = -1;
	G_LibInterfancy_PrevEndTime = -1;
}

// ---------------------------------- //
/// Load the library
Void Load() { Unload(); }

// ---------------------------------- //
/** (Overload) Load the library with some modules
 *
 *	@param	_AutoLoadModules	A list of modules to load with the library
 */
Void Load(Text[] _AutoLoadModules) {
	Load();
	LoadModules(_AutoLoadModules);
}