// -------------------------------------- //
//  LIBRARY PLAYERS TURRETS by domino54   //
//  script version: 2017-08-22            //
// -------------------------------------- //

/**
 *	Library used to manage placing and usage of turrets
 *	by the players. Players can have one turret to assist
 *	them during the match. Turret is added to a player's
 *	inventory, where they can deploy it or destory, if it
 *	has been already placed.
 */

#Const Version		"2017-08-22"
#Const ScriptName	"Libs/domino54/ShootMania/PlayersTurrets.Script.txt"

#Include "MathLib" as ML
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/MarkersPro.Script.txt" as Markers
#Include "Libs/domino54/Translations.Script.txt" as Translations
#Include "Libs/domino54/ShootMania/Inventory.Script.txt" as Inventory
#Include "Libs/domino54/ShootMania/Minimap.Script.txt" as Minimap

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_LibPlayersTurrets_TurretModelPath		"SMCommon\\Turrets\\Turret1.Item.Gbx"
#Const C_LibPlayersTurrets_GUILayerIdStatus		"LibPlayersTurrets:Status"
#Const C_LibPlayersTurrets_GUILayerIdMarker		"LibPlayersTurrets:Marker"
#Const C_LibPlayersTurrets_InventoryItemId		"LibPlayersTurrets_Turret"
#Const C_LibPlayersTurrets_DefaultActionInput	CSmModeEvent::EActionInput::Consumable2
#Const C_LibPlayersTurrets_DefaultDeployTime	1500	///< Default turret deploy time.
#Const C_LibPlayersTurrets_DefaultCooldown		10000	///< Default cooldown after turret destruction.
#Const C_LibPlayersTurrets_DefaultArmorMax		500		///< Default turret armor max.
#Const C_LibPlayersTurrets_DeployCancelDist		.75		///< Distance after which deploy is aborted.
#Const C_LibPlayersTurrets_NbGaugesInModel		10		///< Amount of gauges in a single gauge widget.
#Const C_LibPlayersTurrets_GaugeTotalLength		36.		///< Length of a widget's gauge bar.
#Const C_LibPlayersTurrets_GaugeSpacingWidth	.5		///< Spaceing between smaller gauges in the widget.
#Const C_LibPlayersTurrets_TurretInfoPos		<155., -58.>

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident G_LibPlayersTurrets_TurretModelId;		///< ID of the turret item model.
declare Ident[] G_LibPlayersTurrets_CreatedTurrets;		///< IDs of the turrets created by the library.
declare Integer G_LibPlayersTurrets_DeployTime;			///< Time player has to stand still to deploy a turret.
declare Integer G_LibPlayersTurrets_TurretCooldown;		///< Cooldown before new turret can be placed after destruction.
declare Integer G_LibPlayersTurrets_TurretArmorMax;		///< Turret maximum armor.
declare Boolean G_LibPlayersTurrets_AutoDestroyTurrets;	///< Automatically destroy turrets.
declare Text[] G_LibPlayersTurrets_CreatedMarkersMM;	///< Minimap markers created by the library.
declare Text[] G_LibPlayersTurrets_CreatedMarkersWorld;	///< Physical markers created by the library.
declare Integer[Ident] G_LibPlayersTurrets_TakenMarkersSlots;

/// Turrets information
declare Ident[Ident] G_LibPlayersTurrets_TurretPlayerId;	///< ID of the turret's owner.
declare Integer[Ident] G_LibPlayersTurrets_TurretClan;		///< Clan of the turret.
declare Vec3[Ident] G_LibPlayersTurrets_TurretPosition;		///< Position of the turret.

/// Update
declare Integer[Ident] G_LibPlayersTurrets_PrevTurretArmor;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for the turret intormation.
 *
 *	@return		The turret information mnaialink.
 */
Text Private_CreateManialinkTurretsUI() {
	declare Gauges = "";
	for (I, 0, C_LibPlayersTurrets_NbGaugesInModel - 1)
		Gauges ^= "<gauge size='0 7.5' valign='center' drawbg='0' drawblockbg='0' id='Gauge_Step#"^I^"' hidden='1' />";

	return """
<manialink version="3" name="{{{C_LibPlayersTurrets_GUILayerIdStatus}}}">
<stylesheet>
	<style class="count" valign="center2" textsize="2.25" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="desc" valign="center2" textsize=".875" textemboss="1" textfont="Eurostile_Bold" />
</stylesheet>
<frame halign="center" valign="center" size="320 180">

<frame id="Frame_TurretInfo" pos="{{{C_LibPlayersTurrets_TurretInfoPos.X + C_LibPlayersTurrets_GaugeTotalLength + 10^" "^C_LibPlayersTurrets_TurretInfoPos.Y}}}" rot="0">
	<quad size="7 7" halign="center" valign="center" image="{{{C_ImgBase}}}Icons/Turret.png" />
	
	<label pos="-4 2.5" halign="right" class="count" id="Label_TurretInfoCounter" />
	<frame id="Frame_GaugeAmmo" pos="-4 -.35" rot="-180">{{{Gauges}}}</frame>
	
	<frame pos="-4 -2.5">
		<label halign="right" class="desc" id="Label_TurretInfoText" />
		<label halign="right" class="desc" id="Label_TurretInfoGhost" />
	</frame>
</frame>

</frame>
<script><!--
/**
 *	{{{C_LibPlayersTurrets_GUILayerIdStatus}}}
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_GaugeTotalLength	{{{C_LibPlayersTurrets_GaugeTotalLength}}}
#Const C_GaugeSpacingWidth	{{{C_LibPlayersTurrets_GaugeSpacingWidth}}}
#Const C_GaugePositionFix	4.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_TurretInfo		<=> (Page.GetFirstChild("Frame_TurretInfo") as CMlFrame);
declare Label_TurretInfoCounter	<=> (Page.GetFirstChild("Label_TurretInfoCounter") as CMlLabel);
declare Label_TurretInfoText	<=> (Page.GetFirstChild("Label_TurretInfoText") as CMlLabel);
declare Label_TurretInfoGhost	<=> (Page.GetFirstChild("Label_TurretInfoGhost") as CMlLabel);

declare CMlGauge[] Gauge_TurretInfoBar;
for (I, 0, {{{C_LibPlayersTurrets_NbGaugesInModel - 1}}})
	Gauge_TurretInfoBar.add((Page.GetFirstChild("Gauge_Step#"^I) as CMlGauge));

// ---------------------------------- //
// Variables
declare TurretInfoVisible = False;
declare UpdateTurretGauge = True;
declare DescriptionText = "";

/// Update
declare PrevTurretInfoVisible = False;
declare PrevInterfaceColor = -1.;
declare PrevTurretArmor = -1;
declare PrevTurretArmorMax = -1;
declare PrevDescriptionText = "!";
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
if (!PageIsVisible) continue;
Frame_TurretInfo.Visible = !IsInGameMenuDisplayed;

// ---------------------------------- //
// Update turret information visibility
if (GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>) {
	declare netread Integer Net_LibPlayersTurrets_TurretDeployTime for GUIPlayer;
	TurretInfoVisible = Net_LibPlayersTurrets_TurretDeployTime > 0;
}
else TurretInfoVisible = False;

if (PrevTurretInfoVisible != TurretInfoVisible) {
	PrevTurretInfoVisible = TurretInfoVisible;

	declare Easing = CAnimManager::EAnimManagerEasing::CircOut;
	declare Position = <{{{C_LibPlayersTurrets_TurretInfoPos.X}}}, Frame_TurretInfo.RelativePosition_V3.Y>;
	
	if (!TurretInfoVisible) {
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
		Position.X += C_GaugeTotalLength + 10.;
	}
	
	AnimMgr.Add(Frame_TurretInfo, "<frame pos='"^Position.X^" "^Position.Y^"' />", 200, Easing);
}

if (!TurretInfoVisible) continue;

// ---------------------------------- //
// Update interface color
if (PrevInterfaceColor != GUIPlayer.GetLinearHue) {
	PrevInterfaceColor = GUIPlayer.GetLinearHue;
	declare InterfaceColor = HsvToRgb(<PrevInterfaceColor, 1., 1.>);

	foreach (Gauge in Gauge_TurretInfoBar) Gauge.Color = InterfaceColor;
	Label_TurretInfoText.TextColor = Brightness(InterfaceColor, 4.);
	Label_TurretInfoGhost.TextColor = Label_TurretInfoText.TextColor;
}

// ---------------------------------- //
// Upate gauge on armor change
declare netread Integer Net_LibPlayersTurrets_TurretArmor for GUIPlayer;
if (PrevTurretArmor != Net_LibPlayersTurrets_TurretArmor) {
	PrevTurretArmor = Net_LibPlayersTurrets_TurretArmor;
	UpdateTurretGauge = True;
}

// ---------------------------------- //
// Update gauge on armor max change
declare netread Integer Net_LibPlayersTurrets_TurretArmorMax for GUIPlayer;
if (PrevTurretArmorMax != Net_LibPlayersTurrets_TurretArmorMax) {
	PrevTurretArmorMax = Net_LibPlayersTurrets_TurretArmorMax;
	UpdateTurretGauge = True;
}

// Update gauge while turret is being deployed
declare netread Integer Net_LibPlayersTurrets_TurretSpawnTime for GUIPlayer;
if (GameTime <= Net_LibPlayersTurrets_TurretSpawnTime + 500) UpdateTurretGauge = True;

// ---------------------------------- //
// Update turret gauge
if (UpdateTurretGauge) {
	UpdateTurretGauge = False;

	// ---------------------------------- //
	// Display the turret deploying progress
	if (GameTime < Net_LibPlayersTurrets_TurretSpawnTime) {
		declare netread Integer Net_LibPlayersTurrets_TurretDeployTime for GUIPlayer;
		declare Ratio = ML::Clamp(
			ML::ToReal(GameTime - Net_LibPlayersTurrets_TurretDeployTime) /
			(Net_LibPlayersTurrets_TurretSpawnTime - Net_LibPlayersTurrets_TurretDeployTime),
			0., .99
		);

		Label_TurretInfoCounter.Value = ML::NearestInteger(Ratio * 100)^"%";
		SetModuleRatio(Gauge_TurretInfoBar, Ratio, 1);
		DescriptionText = "Deploying turret";
	}
	// ---------------------------------- //
	// Show the current player's turret's armor
	else {
		declare GaugeRatio = PrevTurretArmor / 100.;
		declare GaugeSlots = PrevTurretArmorMax / 100;

		Label_TurretInfoCounter.Value = ML::FloorInteger(GaugeRatio)^"$777/"^GaugeSlots;
		SetModuleRatio(Gauge_TurretInfoBar, GaugeRatio, GaugeSlots);
		DescriptionText = "Turret";
	}
}

// ---------------------------------- //
// Update description label
if (PrevDescriptionText != DescriptionText) {
	PrevDescriptionText = DescriptionText;

	Label_TurretInfoGhost.Value = Label_TurretInfoText.Value;
	Label_TurretInfoText.Value = TL::ToUpperCase(Translate(DescriptionText));
	
	Label_TurretInfoText.Opacity = 0.;
	Label_TurretInfoText.RelativePosition_V3.Y = 1.5;
	Label_TurretInfoGhost.Opacity = 1.;
	Label_TurretInfoGhost.RelativePosition_V3.Y = 0.;
	
	AnimMgr.Add(Label_TurretInfoText, "<label pos='0 0' opacity='1' />", 200, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Label_TurretInfoGhost, "<label pos='0 -1.5' opacity='0' />", 200, CAnimManager::EAnimManagerEasing::Linear);
}
***

{{{ManialinkTools::Functions(["Brightness", "SetGaugeRatio", "HsvToRgb"])}}}
{{{Translations::InjectInManialink(["Turret", "Deploying turret"])}}}

// ---------------------------------- //
/** Set module value
 *
 *	@param	_Gauges		Array of gauges used by the module
 *	@param	_Energy		Amount of currently loaded energy
 *	@param	_Slots		Amount of available energy slots
 */
Void SetModuleRatio(CMlGauge[] _Gauges, Real _Energy, Integer _Slots) {
	declare persistent Persistent_LibInterfancy_ShowGaugesBgs for LocalUser = False;
	
	// ---------------------------------- //
	// Hide gauges if there are no slots
	if (_Slots <= 0) {
		foreach (Gauge in _Gauges) Gauge.Visible = False;
		
		// There is nothing more to do without slots
		return;
	}
	// ---------------------------------- //
	// Adjust up to N gauges for slots
	else if (_Slots <= _Gauges.count) {
		declare SpacingSizeSub = 0.;
		if (_Slots >= 2) SpacingSizeSub = C_GaugeSpacingWidth * (_Slots - 1) / _Slots;
		declare GaugeSlotSize = C_GaugeTotalLength / _Slots + C_GaugePositionFix - SpacingSizeSub;
		
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I <= _Slots - 1;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = GaugeSlotSize;
			Gauge.RelativePosition_V3.X = (GaugeSlotSize - C_GaugePositionFix) * I - C_GaugePositionFix / 2;
			Gauge.DrawBlockBackground = Persistent_LibInterfancy_ShowGaugesBgs;
			if (I > 0) Gauge.RelativePosition_V3.X += C_GaugeSpacingWidth * I;
		}
	}
	// ---------------------------------- //
	// Use one gauge for over N slots
	else {
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I == 0;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = C_GaugeTotalLength + C_GaugePositionFix;
			Gauge.RelativePosition_V3.X = -C_GaugePositionFix / 2;
		}
	}
	
	// ---------------------------------- //
	// Set gauges ratios
	foreach (I => Gauge in _Gauges) {
		if (!Gauge.Visible) continue;
		// Gauge.DrawBlockBackground = _Module == "Stamina";
		
		// ---------------------------------- //
		// Format ratios for gauges until N slots
		if (_Slots <= _Gauges.count) SetGaugeRatio(Gauge, _Energy - I);
		
		// ---------------------------------- //
		// Format ratio for gauge above N slots
		else SetGaugeRatio(Gauge, _Energy / _Slots);
	}
}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}

--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the marker module.
 *
 *	@return		The marker manialink.
 */
Text Private_CreateManialinkTurretMarker() {
	declare R = 9/16.;

	declare GaugeModel = "";
	for (I, 0, 9) GaugeModel ^= "<gauge size='0 7' valign='center' drawbg='0' id='Gauge_Step#"^I^"' hidden='1' />";

	declare TurretsMarkers = "";
	for (I, 0, 15)
		TurretsMarkers ^= "<frameinstance modelid='FrameModel_TurretMarker' id='Frame_TurretMarker#"^I^"' hidden='1' />";

	return """
<manialink version="3" name="{{{C_LibPlayersTurrets_GUILayerIdMarker}}}">
<stylesheet>
	<style class="FontB" halign="center" valign="center2" textsize="1" textemboss="1" textprefix="$n" textcolor="FFF" textfont="Eurostile_Bold" />
</stylesheet>

<frame id="Frame_PlayerTurretMarker">
	<quad size="{{{8*R}}} 8" halign="center" valign="center" autoscale="0" image="{{{C_ImgBase}}}Minimap/Turret.png" id="Quad_PlayerTurretMarker" hidden="1" />
</frame>

<framemodel id="FrameModel_TurretMarker">
	<frame id="Frame_TurretMarkerContainer" pos="0 3" hidden="1">
		<quad pos="0 4" size="{{{7*R}}} 7" halign="center" valign="center" autoscale="0" image="{{{C_ImgBase}}}Minimap/Turret.png" id="Quad_TurretIcon" />
		<label class="FontB" textprefix="$n$t" id="Label_MarkerTextTurret" />
		<frame pos="{{{-14. * R}}} -2">{{{GaugeModel}}}</frame>
		<label pos="0 -4.25" class="FontB" id="Label_MarkerTurretOwner" />
		<quad pos="0 -1.75" size="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon" />
	</frame>
</framemodel>
{{{TurretsMarkers}}}

<frameinstance modelid="FrameModel_TurretMarker" id="Frame_CurPlayerMarker" hidden="1" />

<script><!--

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_ScaleDistanceMax	30.
#Const C_GaugeTotalLength	{{{28. * R}}}
#Const C_GaugePositionFix	4.
#Const C_GaugeSpacingWidth	0.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load manialink elements
declare Frame_CurPlayerMarker <=> ((Page.GetFirstChild("Frame_CurPlayerMarker") as CMlFrame).Controls[0] as CMlFrame);
declare Quad_PlayerTurretIcon <=> (Frame_CurPlayerMarker.GetFirstChild("Quad_TurretIcon") as CMlQuad);
declare Quad_PlayerMarkerIcon <=> (Frame_CurPlayerMarker.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
declare Label_PlayerTextTurret <=> (Frame_CurPlayerMarker.GetFirstChild("Label_MarkerTextTurret") as CMlLabel);
declare Label_PlayerTurretOwner <=> (Frame_CurPlayerMarker.GetFirstChild("Label_MarkerTurretOwner") as CMlLabel);

// ---------------------------------- //
// Load turrets markers
declare CMlFrame[] Frame_TurretMarkers;
for (I, 0, 15) {
	declare Frame <=> (Page.GetFirstChild("Frame_TurretMarker#"^I) as CMlFrame);
	Frame_TurretMarkers.add(Frame);
	declare CMlGauge[] Gauges for Frame;
	for (I, 0, 9) Gauges.add((Frame.GetFirstChild("Gauge_Step#"^I) as CMlGauge));
}

/// Local player Turret marker gauges
declare CMlGauge[] LocalTurretGauges;
for (I, 0, 9)
	LocalTurretGauges.add((Frame_CurPlayerMarker.GetFirstChild("Gauge_Step#"^I) as CMlGauge));

/// Translations
Label_PlayerTextTurret.Value = Translate("Turret");

// ---------------------------------- //
// Net data
declare netread Integer Net_LibPlayersTurrets_TurretsLastUpdate for Teams[0];
declare netread Vec3[Integer] Net_LibPlayersTurrets_TurretMarkerPos for Teams[0];
declare netread Text[Integer] Net_LibPlayersTurrets_TurretOwnerLogin for Teams[0];

// ---------------------------------- //
// Variables
declare UpdateTurretsMarkers = True;
declare UpdateTurretGauge = True;
declare LocalPlayerTurretPos = Vec3;

// Update
declare PrevGUIPlayerColor = -1.;
declare PrevTurretsUpdate = -1;
declare PrevGUIPlayerId = NullId;
declare PrevGUIPlayerName = "";
declare PrevTurretArmor = -1;
declare PrevTurretArmorMax = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update markers on server command
if (PrevTurretsUpdate != Net_LibPlayersTurrets_TurretsLastUpdate) {
	PrevTurretsUpdate = Net_LibPlayersTurrets_TurretsLastUpdate;
	UpdateTurretsMarkers = True;
}

// ---------------------------------- //
// Update markers on GUIPlayer change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerId != GUIPlayer.Id) {
		PrevGUIPlayerId = GUIPlayer.Id;
		UpdateTurretsMarkers = True;
	}
} else if (PrevGUIPlayerId != NullId) {
	PrevGUIPlayerId = NullId;
	UpdateTurretsMarkers = True;
}

// ---------------------------------- //
// Update turrets markers
if (UpdateTurretsMarkers) {
	UpdateTurretsMarkers = False;

	foreach (I => Frame in Frame_TurretMarkers) {
		declare OwnerLogin = "";
		if (Net_LibPlayersTurrets_TurretOwnerLogin.existskey(I)) OwnerLogin = Net_LibPlayersTurrets_TurretOwnerLogin[I];

		// Local player turret position
		if (GUIPlayer != Null && GUIPlayer.User.Login == OwnerLogin && Net_LibPlayersTurrets_TurretMarkerPos.existskey(I))
			LocalPlayerTurretPos = Net_LibPlayersTurrets_TurretMarkerPos[I];

		// Get the main container
		declare Container = (Frame.Controls[0] as CMlFrame);
		Container.Visible = Net_LibPlayersTurrets_TurretMarkerPos.existskey(I) && (GUIPlayer == Null || OwnerLogin != GUIPlayer.User.Login);
		if (!Container.Visible) continue;

		// ---------------------------------- //
		// Laod marker elements
		declare Label_MarkerTextTurret <=> (Frame.GetFirstChild("Label_MarkerTextTurret") as CMlLabel);
		declare Label_MarkerTurretOwner <=> (Frame.GetFirstChild("Label_MarkerTurretOwner") as CMlLabel);
		declare Quad_TurretIcon <=> (Frame.GetFirstChild("Quad_TurretIcon") as CMlQuad);
		declare Quad_MarkerIcon <=> (Frame.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

		// Get the Turret owner
		declare CSmPlayer Owner;
		foreach (Player in Players) if (Player.User.Login == OwnerLogin) { Owner <=> Player; break; }
		
		// ---------------------------------- //
		// Update color of the marker
		declare MarkerColor = <1., 1., 1.>;
		if (Owner != Null) MarkerColor = HsvToRgb(<Owner.GetLinearHue, 1., 1.>);
		Quad_MarkerIcon.Colorize = MarkerColor;
		Quad_TurretIcon.Colorize = MarkerColor;

		declare CMlGauge[] Gauges for Frame;
		foreach (Gauge in Gauges) Gauge.Color = MarkerColor;

		Label_MarkerTextTurret.Value = Translate("Turret");
		Label_MarkerTextTurret.TextColor = Brightness(MarkerColor, 3.);

		// ---------------------------------- //
		// Display Turret's owner name
		declare OwnerName = OwnerLogin;
		if (Owner != Null) OwnerName = Owner.User.Name;
		Label_MarkerTurretOwner.Value = OwnerName;
	}
}

// ---------------------------------- //
// Manage visible markers
foreach (I => Frame in Frame_TurretMarkers) {
	if (!Frame.Visible || !Frame.Controls[0].Visible) continue;
	
	declare TurretPosition = Net_LibPlayersTurrets_TurretMarkerPos[I];
	declare Container = (Frame.Controls[0] as CMlFrame);

	// ---------------------------------- //
	// Marker scale depending on distance to the Turret
	if (GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>) {
		declare Distance = ML::Distance(GUIPlayer.Position, TurretPosition);
		Container.RelativeScale = 1. - (ML::Min(Distance, C_ScaleDistanceMax) / C_ScaleDistanceMax) * .5;
	}
	else Container.RelativeScale = .5;

	declare OwnerLogin = "";
	declare CSmPlayer Owner;
	if (Net_LibPlayersTurrets_TurretOwnerLogin.existskey(I)) OwnerLogin = Net_LibPlayersTurrets_TurretOwnerLogin[I];
	foreach (Player in Players) if (Player.User.Login == OwnerLogin) { Owner <=> Player; break; }
	if (Owner == Null) continue;

	declare netread Integer Net_LibPlayersTurrets_TurretArmor for Owner;
	declare netread Integer Net_LibPlayersTurrets_TurretArmorMax for Owner;
	
	declare CMlGauge[] Gauges for Frame;
	SetModuleRatio(Gauges, Net_LibPlayersTurrets_TurretArmor / 100., Net_LibPlayersTurrets_TurretArmorMax / 100);
}

// ---------------------------------- //
// Local player Turret marker visibility
Frame_CurPlayerMarker.Visible = GUIPlayer != Null && GUIPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned;
if (Frame_CurPlayerMarker.Visible) {
	declare netread Integer Net_LibPlayersTurrets_TurretSpawnTime for GUIPlayer;
	Frame_CurPlayerMarker.Visible = Net_LibPlayersTurrets_TurretSpawnTime > 0 && GameTime >= Net_LibPlayersTurrets_TurretSpawnTime;
}

// ---------------------------------- //
// Manage current player Turret marker
if (GUIPlayer != Null && Frame_CurPlayerMarker.Visible) {
	// ---------------------------------- //
	// Update local player Turret marker color
	if (PrevGUIPlayerColor != GUIPlayer.GetLinearHue) {
		PrevGUIPlayerColor = GUIPlayer.GetLinearHue;
		declare MarkerColor = HsvToRgb(<PrevGUIPlayerColor, 1., 1.>);

		Quad_PlayerTurretIcon.Colorize = MarkerColor;
		Quad_PlayerMarkerIcon.Colorize = MarkerColor;
		Label_PlayerTextTurret.TextColor = Brightness(MarkerColor, 3.);
		foreach (Gauge in LocalTurretGauges) Gauge.Color = MarkerColor;
	}

	// ---------------------------------- //
	// Update GUIPlayer Turret's owner's name
	if (PrevGUIPlayerName != GUIPlayer.User.Name) {
		PrevGUIPlayerName = GUIPlayer.User.Name;
		Label_PlayerTurretOwner.Value = PrevGUIPlayerName;
	}

	// ---------------------------------- //
	// Update gauge on Turret armor change
	declare netread Integer Net_LibPlayersTurrets_TurretArmor for GUIPlayer;
	if (PrevTurretArmor != Net_LibPlayersTurrets_TurretArmor) {
		PrevTurretArmor = Net_LibPlayersTurrets_TurretArmor;
		UpdateTurretGauge = True;
	}

	// ---------------------------------- //
	// Update gauge on Turret armor max change
	declare netread Integer Net_LibPlayersTurrets_TurretArmorMax for GUIPlayer;
	if (PrevTurretArmorMax != Net_LibPlayersTurrets_TurretArmorMax) {
		PrevTurretArmorMax = Net_LibPlayersTurrets_TurretArmorMax;
		UpdateTurretGauge = True;
	}

	// ---------------------------------- //
	// Update armor gauge
	if (UpdateTurretGauge) {
		UpdateTurretGauge = False;
		SetModuleRatio(LocalTurretGauges, Net_LibPlayersTurrets_TurretArmor / 100., Net_LibPlayersTurrets_TurretArmorMax / 100);
	}

	// ---------------------------------- //
	// Change marker scale depending on distance
	if (GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>) {
		declare Distance = ML::Distance(GUIPlayer.Position, LocalPlayerTurretPos);
		Frame_CurPlayerMarker.RelativeScale = 1. - (ML::Min(Distance, C_ScaleDistanceMax) / C_ScaleDistanceMax) * .5;
	}
	else Frame_CurPlayerMarker.RelativeScale = .5;
}

***

{{{Translations::InjectInManialink(["Turret"])}}}
{{{ManialinkTools::Functions(["HsvToRgb", "Brightness", "SetGaugeRatio"])}}}

// ---------------------------------- //
/** Set module value
 *
 *	@param	_Gauges		Array of gauges used by the module
 *	@param	_Energy		Amount of currently loaded energy
 *	@param	_Slots		Amount of available energy slots
 */
Void SetModuleRatio(CMlGauge[] _Gauges, Real _Energy, Integer _Slots) {
	declare persistent Persistent_LibInterfancy_ShowGaugesBgs for LocalUser = False;
	
	// ---------------------------------- //
	// Hide gauges if there are no slots
	if (_Slots <= 0) {
		foreach (Gauge in _Gauges) Gauge.Visible = False;
		
		// There is nothing more to do without slots
		return;
	}
	// ---------------------------------- //
	// Adjust up to N gauges for slots
	else if (_Slots <= _Gauges.count) {
		declare SpacingSizeSub = 0.;
		if (_Slots >= 2) SpacingSizeSub = C_GaugeSpacingWidth * (_Slots - 1) / _Slots;
		declare GaugeSlotSize = C_GaugeTotalLength / _Slots + C_GaugePositionFix - SpacingSizeSub;
		
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I <= _Slots - 1;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = GaugeSlotSize;
			Gauge.RelativePosition_V3.X = (GaugeSlotSize - C_GaugePositionFix) * I - C_GaugePositionFix / 2;
			if (I > 0) Gauge.RelativePosition_V3.X += C_GaugeSpacingWidth * I;
		}
	}
	// ---------------------------------- //
	// Use one gauge for over N slots
	else {
		foreach (I => Gauge in _Gauges) {
			Gauge.Visible = I == 0;
			if (!Gauge.Visible) continue;
			
			Gauge.Size.X = C_GaugeTotalLength + C_GaugePositionFix;
			Gauge.RelativePosition_V3.X = -C_GaugePositionFix / 2;
		}
	}
	
	// ---------------------------------- //
	// Set gauges ratios
	foreach (I => Gauge in _Gauges) {
		if (!Gauge.Visible) continue;
		// Gauge.DrawBlockBackground = _Module == "Stamina";
		
		// ---------------------------------- //
		// Format ratios for gauges until N slots
		if (_Slots <= _Gauges.count) SetGaugeRatio(Gauge, _Energy - I);
		
		// ---------------------------------- //
		// Format ratio for gauge above N slots
		else SetGaugeRatio(Gauge, _Energy / _Slots);
	}
}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>
	""";
}

// ---------------------------------- //
/** Update player information about their turret.
 *
 *	@param	_Player		The player to update turret information.
 */
Void Private_UpdatePlayerTurretInfo(CSmPlayer _Player) {
	if (_Player == Null) return;

	declare Integer LibPlayersTurrets_TurretDeployTime for _Player;
	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployPos for _Player;
	declare Integer LibPlayersTurrets_TurretCooldownStart for _Player;
	declare Integer LibPlayersTurrets_TurretCooldownDuration for _Player;

	declare netwrite Integer Net_LibPlayersTurrets_TurretDeployTime for _Player;
	declare netwrite Integer Net_LibPlayersTurrets_TurretSpawnTime for _Player;
	declare netwrite Vec3 Net_LibPlayersTurrets_TurretDeployPos for _Player;

	Net_LibPlayersTurrets_TurretDeployTime = LibPlayersTurrets_TurretDeployTime;
	Net_LibPlayersTurrets_TurretSpawnTime = LibPlayersTurrets_TurretSpawnTime;
	Net_LibPlayersTurrets_TurretDeployPos = LibPlayersTurrets_TurretDeployPos;

	Inventory::SetItemIsActive(_Player, C_LibPlayersTurrets_InventoryItemId, LibPlayersTurrets_TurretDeployTime > 0);
	Inventory::SetItemCooldown(
		_Player, C_LibPlayersTurrets_InventoryItemId,
		LibPlayersTurrets_TurretCooldownStart,
		LibPlayersTurrets_TurretCooldownDuration
	);
}

// ---------------------------------- //
/** Update UI information about turret's armor.
 *
 *	@param	_TurretId	ID of the turret to update information.
 */
Void Private_UpdateTurretArmorInfo(Ident _TurretId) {
	if (_TurretId == NullId || !TurretsManager.Turrets.existskey(_TurretId) || !G_LibPlayersTurrets_CreatedTurrets.exists(_TurretId)) return;
	declare Turret <=> TurretsManager.Turrets[_TurretId];

	declare PlayerId = G_LibPlayersTurrets_TurretPlayerId[_TurretId];
	if (!AllPlayers.existskey(PlayerId)) return;
	declare Player <=> AllPlayers[PlayerId];

	declare netwrite Integer Net_LibPlayersTurrets_TurretArmor for Player;
	declare netwrite Integer Net_LibPlayersTurrets_TurretArmorMax for Player;

	Net_LibPlayersTurrets_TurretArmor = Turret.Armor;
	Net_LibPlayersTurrets_TurretArmorMax = Turret.ArmorMax;
}

Void Private_TriggerTurretsMarkersUpdate() {
	declare netwrite Integer Net_LibPlayersTurrets_TurretsLastUpdate for Teams[0];
	Net_LibPlayersTurrets_TurretsLastUpdate = Now;
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Get the spawn time of a player's turret.
 *
 *	@param	_Player		The player to get turret spawn time.
 *
 *	@return		Spawn time of the turret.
 */
Integer GetTurretSpawnTime(CSmPlayer _Player) {
	if (_Player == Null) return -1;
	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	return LibPlayersTurrets_TurretSpawnTime;
}

// ---------------------------------- //
/** Check if the player has deployed their turret.
 *
 *	@param	_Player		The player to check.
 *
 *	@return		True, if the player has deployed their turret.
 */
Boolean HasTurretDeployed(CSmPlayer _Player) {
	if (_Player == Null) return False;
	return GetTurretSpawnTime(_Player) > 0;
}

// ---------------------------------- //
/** Check if the player has their turret spawned.
 *
 *	@param	_Player		The player to check.
 *
 *	@return		True, if the player has their turret spawned.
 */
Boolean HasTurretSpawned(CSmPlayer _Player) {
	if (_Player == Null) return False;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;
	return LibPlayersTurrets_PlayerTurretId != NullId;
}

// ---------------------------------- //
/** Get all turrets created by the library.
 *	/!\ Use for one frame duration only! /!\
 *
 *	@return		Turrets created by the library.
 */
CModeTurret[] GetTurrets() {
	declare CModeTurret[] LibraryTurrets;
	foreach (TurretId in G_LibPlayersTurrets_CreatedTurrets) {
		if (!TurretsManager.Turrets.existskey(TurretId)) continue;
		LibraryTurrets.add(TurretsManager.Turrets[TurretId]);
	}
	return LibraryTurrets;
}

// ---------------------------------- //
/** Check if the Turret belongs to the library.
 *
 *	@param	_Turret	The Turret to ckeck.
 *
 *	@return		True, if the Turret belongs to the library.
 */
Boolean BelongsToLib(CModeTurret _Turret) {
	return _Turret != Null && G_LibPlayersTurrets_CreatedTurrets.exists(_Turret.Id);
}

// ---------------------------------- //
/** Get the turret of a player.
 *
 *	@param	_Player		The player to get their turret.
 *
 *	@return		The player's turret.
 */
CModeTurret GetPlayerTurret(CSmPlayer _Player) {
	if (_Player == Null || !HasTurretSpawned(_Player)) return Null;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;
	declare TurretId = LibPlayersTurrets_PlayerTurretId;
	if (TurretsManager.Turrets.existskey(TurretId)) return TurretsManager.Turrets[TurretId];
	return Null;
}

// ---------------------------------- //
/** Get the owner of a turret.
 *
 *	@param	_Turret		The turret to get its owner.
 *
 *	@return		The owner of the turret.
 */
CSmPlayer GetTurretOwner(CModeTurret _Turret) {
	if (_Turret == Null || !G_LibPlayersTurrets_CreatedTurrets.exists(_Turret.Id)) return Null;

	if (G_LibPlayersTurrets_TurretPlayerId.existskey(_Turret.Id)) {
		declare PlayerId = G_LibPlayersTurrets_TurretPlayerId[_Turret.Id];
		if (AllPlayers.existskey(PlayerId)) return AllPlayers[PlayerId];
	}
	return Null;
}

// ---------------------------------- //
/** Get the clan of a turret.
 *
 *	@param	_Turret		The turret to get its clan.
 *
 *	@return		The clan of the turret.
 */
Integer GetTurretClan(CModeTurret _Turret) {
	if (_Turret == Null || !G_LibPlayersTurrets_CreatedTurrets.exists(_Turret.Id)) return -1;
	if (!G_LibPlayersTurrets_TurretClan.existskey(_Turret.Id)) return -1;
	return G_LibPlayersTurrets_TurretClan[_Turret.Id];
}

// ---------------------------------- //
/** Get the position of a turret.
 *
 *	@param	_Turret		The turret to get its position.
 *
 *	@return		The position of the turret.
 */
Vec3 GetTurretPosition(CModeTurret _Turret) {
	if (_Turret == Null || !G_LibPlayersTurrets_CreatedTurrets.exists(_Turret.Id)) return Vec3;
	if (!G_LibPlayersTurrets_TurretPosition.existskey(_Turret.Id)) return Vec3;
	return G_LibPlayersTurrets_TurretPosition[_Turret.Id];
}

// ---------------------------------- //
/** Destroy a turret.
 *
 *	@param	_TurretId	The ID of the turret to destroy.
 *	@param	_Cooldown	Time before the player can deploy a new turret.
 *
 *	@return		True, if the turret has been destroyed.
 */
Boolean DestroyTurret(Ident _TurretId, Integer _Cooldown) {
	if (_TurretId == NullId || !G_LibPlayersTurrets_CreatedTurrets.exists(_TurretId)) return False;

	if (TurretsManager.Turrets.existskey(_TurretId)) {
		declare Turret <=> TurretsManager.Turrets[_TurretId];
		TurretsManager.Turret_Destroy(Turret);
	}

	if (G_LibPlayersTurrets_TurretPlayerId.existskey(_TurretId)) {
		declare PlayerId = G_LibPlayersTurrets_TurretPlayerId[_TurretId];
		if (AllPlayers.existskey(PlayerId)) {
			declare Player <=> AllPlayers[PlayerId];
	
			declare Integer LibPlayersTurrets_TurretDeployTime for Player;
			declare Integer LibPlayersTurrets_TurretSpawnTime for Player;
			declare Vec3 LibPlayersTurrets_TurretDeployPos for Player;
			declare Vec3 LibPlayersTurrets_TurretDeployDir for Player;
			declare Ident LibPlayersTurrets_PlayerTurretId for Player;
			declare Integer LibPlayersTurrets_TurretCooldownStart for Player;
			declare Integer LibPlayersTurrets_TurretCooldownDuration for Player;
		
			LibPlayersTurrets_TurretDeployTime = -1;
			LibPlayersTurrets_TurretSpawnTime = -1;
			LibPlayersTurrets_TurretDeployPos = Vec3;
			LibPlayersTurrets_TurretDeployDir = Vec3;
			LibPlayersTurrets_PlayerTurretId = NullId;

			if (_Cooldown > 0) {
				LibPlayersTurrets_TurretCooldownStart = Now;
				LibPlayersTurrets_TurretCooldownDuration = _Cooldown;
			}
			Private_UpdatePlayerTurretInfo(Player);

			// Remove the minimap marker
			declare TurretMarkerId = "LibPlayersTurrets_"^Player.User.Login;
			declare Removed = G_LibPlayersTurrets_CreatedMarkersMM.remove(TurretMarkerId);
			Minimap::DestroyMarker(TurretMarkerId);
			Markers::RemoveMarker(TurretMarkerId, Player);
		}
	}

	if (G_LibPlayersTurrets_TakenMarkersSlots.existskey(_TurretId)) {
		declare netwrite Vec3[Integer] Net_LibPlayersTurrets_TurretMarkerPos for Teams[0];

		declare MarkerSlot = G_LibPlayersTurrets_TakenMarkersSlots[_TurretId];
		declare TurretMarkerId = "LibPlayersTurrets#"^MarkerSlot;

		declare Boolean Removed;
		Removed = G_LibPlayersTurrets_TakenMarkersSlots.removekey(_TurretId);
		Removed = Net_LibPlayersTurrets_TurretMarkerPos.removekey(MarkerSlot);

		Markers::RemoveMarker(TurretMarkerId);
		Private_TriggerTurretsMarkersUpdate();
	}

	declare Boolean Removed;
	Removed = G_LibPlayersTurrets_CreatedTurrets.remove(_TurretId);
	Removed = G_LibPlayersTurrets_TurretPlayerId.removekey(_TurretId);
	Removed = G_LibPlayersTurrets_TurretClan.removekey(_TurretId);
	Removed = G_LibPlayersTurrets_PrevTurretArmor.removekey(_TurretId);
	return True;
}

Boolean DestroyTurret(Ident _TurretId) {
	return DestroyTurret(_TurretId, 0);
}

// ---------------------------------- //
/** Destroy the turret of a player.
 *
 *	@param	_Player		The player to destroy their turret.
 *	@param	_Cooldown	Time before the player can deploy a new turret.
 *
 *	@return		True, if the turret has been destroyed.
 */
Boolean DestroyTurret(CSmPlayer _Player, Integer _Cooldown) {
	if (_Player == Null || !HasTurretDeployed(_Player)) return False;

	declare Integer LibPlayersTurrets_TurretDeployTime for _Player;
	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployPos for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployDir for _Player;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;

	LibPlayersTurrets_TurretDeployTime = -1;
	LibPlayersTurrets_TurretSpawnTime = -1;
	LibPlayersTurrets_TurretDeployPos = Vec3;
	LibPlayersTurrets_TurretDeployDir = Vec3;

	Private_UpdatePlayerTurretInfo(_Player);

	// Remove the minimap marker
	declare TurretMarkerId = "LibPlayersTurrets_"^_Player.User.Login;
	declare Removed = G_LibPlayersTurrets_CreatedMarkersWorld.remove(TurretMarkerId);
	Minimap::DestroyMarker(TurretMarkerId);
	Markers::RemoveMarker(TurretMarkerId, _Player);

	return DestroyTurret(LibPlayersTurrets_PlayerTurretId, _Cooldown);
}

Boolean DestroyTurret(CSmPlayer _Player) {
	return DestroyTurret(_Player, 0);
}

// ---------------------------------- //
/// Destroy all turrets creaded by the library.
Void DestroyAllTurrets() {
	while (G_LibPlayersTurrets_CreatedTurrets.count > 0) {
		declare Destroyed = DestroyTurret(G_LibPlayersTurrets_CreatedTurrets[0]);
	}

	// Remove all markers
	while (G_LibPlayersTurrets_CreatedMarkersMM.count > 0) {
		declare TurretMarkerId = G_LibPlayersTurrets_CreatedMarkersMM[0];
		declare Removed = G_LibPlayersTurrets_CreatedMarkersMM.remove(TurretMarkerId);
		Minimap::DestroyMarker(TurretMarkerId);
	}
	while (G_LibPlayersTurrets_CreatedMarkersWorld.count > 0) {
		declare TurretMarkerId = G_LibPlayersTurrets_CreatedMarkersWorld[0];
		declare Removed = G_LibPlayersTurrets_CreatedMarkersWorld.remove(TurretMarkerId);
		Markers::RemoveMarker(TurretMarkerId);
	}
}

// ---------------------------------- //
/** Create a turret after being deployed by a player.
 *
 *	@param	_Player		The player to create their turret.
 *
 *	@return		Created turret.
 */
CModeTurret CreateTurret(CSmPlayer _Player) {
	if (_Player == Null || !HasTurretDeployed(_Player) || HasTurretSpawned(_Player)) return Null;

	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployPos for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployDir for _Player;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;

	declare Turret <=> TurretsManager.Turret_Create(
		G_LibPlayersTurrets_TurretModelId, LibPlayersTurrets_TurretDeployPos,
		LibPlayersTurrets_TurretDeployDir, _Player.CurrentClan, _Player 
	);
	if (Turret == Null) return Null;

	G_LibPlayersTurrets_CreatedTurrets.add(Turret.Id);
	G_LibPlayersTurrets_TurretPlayerId[Turret.Id] = _Player.Id;
	G_LibPlayersTurrets_TurretClan[Turret.Id] = _Player.CurrentClan;
	G_LibPlayersTurrets_TurretPosition[Turret.Id] = LibPlayersTurrets_TurretDeployPos;

	LibPlayersTurrets_PlayerTurretId = Turret.Id;
	LibPlayersTurrets_TurretSpawnTime = Now;

	// ---------------------------------- //
	// Set the turret armor
	declare TurretArmorMax = ML::Max(G_LibPlayersTurrets_TurretArmorMax, 100);
	Turret.ArmorMax = TurretArmorMax;
	Turret.Armor = TurretArmorMax;

	Private_UpdatePlayerTurretInfo(_Player);

	// ---------------------------------- //
	// Create minimap and private marker
	declare TurretMarkerId = "LibPlayersTurrets_"^_Player.User.Login;
	declare Pos = LibPlayersTurrets_TurretDeployPos;
	Minimap::SetMarker(TurretMarkerId, "Turret.png", Vec3, LibPlayersTurrets_TurretDeployPos, _Player);
	G_LibPlayersTurrets_CreatedMarkersMM.add(TurretMarkerId);

	Markers::AddMarker(TurretMarkerId, """<marker
		pos="{{{Pos.X^" "^Pos.Y + .5^" "^Pos.Z}}}" box="1 1 1" visibility="WhenInFrustum"
		minimapvisibility="Never" manialinkframeid="Frame_CurPlayerMarker" 
	/> """, _Player);
	G_LibPlayersTurrets_CreatedMarkersWorld.add(TurretMarkerId);

	// ---------------------------------- //
	// Create world marker
	declare MarkerSlot = 0;
	while (G_LibPlayersTurrets_TakenMarkersSlots.exists(MarkerSlot)) MarkerSlot += 1;
	declare WorldMarkerId = "LibPlayersTurrets#"^MarkerSlot;

	Markers::AddMarker(WorldMarkerId, """<marker
		pos="{{{Pos.X^" "^Pos.Y + .5^" "^Pos.Z}}}" box="1 1 1" visibility="WhenInMiddleOfScreen"
		minimapvisibility="Never" manialinkframeid="Frame_TurretMarker#{{{MarkerSlot}}}" 
	/> """);
	G_LibPlayersTurrets_TakenMarkersSlots[Turret.Id] = MarkerSlot;

	// Marker net data
	declare netwrite Vec3[Integer] Net_LibPlayersTurrets_TurretMarkerPos for Teams[0];
	declare netwrite Text[Integer] Net_LibPlayersTurrets_TurretOwnerLogin for Teams[0];
	Net_LibPlayersTurrets_TurretMarkerPos[MarkerSlot] = LibPlayersTurrets_TurretDeployPos;
	Net_LibPlayersTurrets_TurretOwnerLogin[MarkerSlot] = _Player.User.Login;
	Private_TriggerTurretsMarkersUpdate();

	return Turret;
}

// ---------------------------------- //
/** Start deploying the turret of a player.
 *
 *	@param	_Player			The player who is deploying their turret.
 *	@param	_DeployDelay	Time the player needs to stand in one place to deploy the turret.
 *
 *	@return		True, if the turret started being deployed.
 */
Boolean DeployTurret(CSmPlayer _Player, Integer _DeployDelay) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || HasTurretSpawned(_Player)) return False;
	if (!Inventory::ItemExists(_Player, C_LibPlayersTurrets_InventoryItemId)) return False;
	if (!Inventory::CooldownIsReady(_Player, C_LibPlayersTurrets_InventoryItemId)) return False;

	declare Integer LibPlayersTurrets_TurretDeployTime for _Player;
	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	declare Vec3 LibPlayersTurrets_LatestGroundPosition for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployPos for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployDir for _Player;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;

	LibPlayersTurrets_TurretDeployTime = Now;
	LibPlayersTurrets_TurretSpawnTime = LibPlayersTurrets_TurretDeployTime + ML::Max(_DeployDelay, 0);
	LibPlayersTurrets_TurretDeployPos = LibPlayersTurrets_LatestGroundPosition; // _Player.Position;
	LibPlayersTurrets_TurretDeployDir = <_Player.AimDirection.X, 0., _Player.AimDirection.Z>;
	LibPlayersTurrets_PlayerTurretId = NullId;

	if (_DeployDelay <= 0) {
		declare Turret <=> CreateTurret(_Player);
	}

	Private_UpdatePlayerTurretInfo(_Player);
	return True;
}

Boolean DeployTurret(CSmPlayer _Player) {
	return DeployTurret(_Player, -1);
}

// ---------------------------------- //
/** Add the turret to a player's inventory.
 *
 *	@param	_Player			The player to add turret to their inventory.
 *	@param	_ActionInput	The button player will have to press to use their turret.
 */
Void AddToInventory(CSmPlayer _Player, CSmModeEvent::EActionInput _ActionInput) {
	if (_Player == Null || Inventory::ItemExists(_Player, C_LibPlayersTurrets_InventoryItemId)) return;

	declare ActionInput = C_LibPlayersTurrets_DefaultActionInput;
	if (_ActionInput != CSmModeEvent::EActionInput::None) ActionInput = _ActionInput;

	Inventory::CreateItemSlot(_Player, C_LibPlayersTurrets_InventoryItemId, ActionInput, -1, "Turret.png");
	Private_UpdatePlayerTurretInfo(_Player);
}

Void AddToInventory(CSmPlayer _Player) {
	if (_Player == Null) return;
	AddToInventory(_Player, C_LibPlayersTurrets_DefaultActionInput);
}

// ---------------------------------- //
/** Remove the turret from a player's inventory.
 *
 *	@param	_Player		The player to remove turret from inventory.
 */
Void RemoveFromInventory(CSmPlayer _Player) {
	if (_Player == Null || !Inventory::ItemExists(_Player, C_LibPlayersTurrets_InventoryItemId)) return;
	Inventory::DestroyItemSlot(_Player, C_LibPlayersTurrets_InventoryItemId);
	declare Destroyed = DestroyTurret(_Player);
}

// ---------------------------------- //
/** Use the turret in a player's inventory.
 *
 *	@param	_Player			The player who is using an inventory item.
 *	@param	_ActionInput	The key that has been pressed by the player.
 *
 *	@return		True, if the action has been processed by the library.
 */
Boolean UseActionButton(CSmPlayer _Player, CSmModeEvent::EActionInput _ActionInput) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return False;
	if (!Inventory::ItemExists(_Player, C_LibPlayersTurrets_InventoryItemId)) return False;

	declare TurretHotkey = Inventory::GetSlotHotkey(_Player, C_LibPlayersTurrets_InventoryItemId);
	if (_ActionInput != TurretHotkey) return False;

	if (HasTurretDeployed(_Player)) {
		declare Destroyed = DestroyTurret(_Player, G_LibPlayersTurrets_TurretCooldown);
	} else {
		declare Deployed = DeployTurret(_Player, G_LibPlayersTurrets_DeployTime);
	}
	return True;
}

// ---------------------------------- //
/** Completely reset a player.
 *
 *	@param	_Player		The player to reset.
 */
Void ResetPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare Destroyed = DestroyTurret(_Player);
	RemoveFromInventory(_Player);

	declare Integer LibPlayersTurrets_TurretDeployTime for _Player;
	declare Integer LibPlayersTurrets_TurretSpawnTime for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployPos for _Player;
	declare Vec3 LibPlayersTurrets_TurretDeployDir for _Player;
	declare Ident LibPlayersTurrets_PlayerTurretId for _Player;
	declare Integer LibPlayersTurrets_TurretCooldownStart for _Player;
	declare Integer LibPlayersTurrets_TurretCooldownDuration for _Player;

	LibPlayersTurrets_TurretDeployTime = -1;
	LibPlayersTurrets_TurretSpawnTime = -1;
	LibPlayersTurrets_TurretDeployPos = Vec3;
	LibPlayersTurrets_TurretDeployDir = Vec3;
	LibPlayersTurrets_PlayerTurretId = NullId;
	LibPlayersTurrets_TurretCooldownStart = -1;
	LibPlayersTurrets_TurretCooldownDuration = -1;

	Private_UpdatePlayerTurretInfo(_Player);
}

// ---------------------------------- //
/// Reset all players.
Void ResetAllPlayers() {
	foreach (Player in AllPlayers) ResetPlayer(Player);
	DestroyAllTurrets();
}

// ---------------------------------- //
/** Set the turret deploy time.
 *
 *	@param	_DeployTime		The new deploy time.
 */
Void SetDeployTime(Integer _DeployTime) {
	declare DeployTime = _DeployTime;
	if (DeployTime < 0) DeployTime = C_LibPlayersTurrets_DefaultDeployTime; 
	G_LibPlayersTurrets_DeployTime = ML::Max(DeployTime, 0);
}

// ---------------------------------- //
/** Set the turret cooldown.
 *
 *	@param	_Cooldown	The new cooldown.
 */
Void SetCooldown(Integer _Cooldown) {
	declare Cooldown = _Cooldown;
	if (Cooldown < 0) Cooldown = C_LibPlayersTurrets_DefaultCooldown; 
	G_LibPlayersTurrets_TurretCooldown = ML::Max(Cooldown, 0);
}

// ---------------------------------- //
/** Get the Turret cooldown.
 *
 *	@return		Current cooldown value.
 */
Integer GetCooldown() {
	return G_LibPlayersTurrets_TurretCooldown;
}

// ---------------------------------- //
/** Set the turret maximum armor.
 *
 *	@param	_ArmorMax	The new maximum armor.
 */
Void SetArmorMax(Integer _ArmorMax) {
	declare ArmorMax = _ArmorMax;
	if (ArmorMax < 0) ArmorMax = C_LibPlayersTurrets_DefaultArmorMax; 
	G_LibPlayersTurrets_TurretArmorMax = ML::Max(ArmorMax, 100);
}

// ---------------------------------- //
/** Get the Turret maximum armor.
 *
 *	@return		Current maximum armor value.
 */
Integer GetArmorMax() {
	return G_LibPlayersTurrets_TurretArmorMax;
}

// ---------------------------------- //
/** Set if the library will automatically destroy Turrets.
 *
 *	@param	_AutoDestroyTurrets	Updated setting.
 */
Void SetAutoDestroyTurrets(Boolean _AutoDestroyTurrets) {
	G_LibPlayersTurrets_AutoDestroyTurrets = _AutoDestroyTurrets;
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	DestroyAllTurrets();
	ResetAllPlayers();

	Layers::Detach(C_LibPlayersTurrets_GUILayerIdStatus);
	Layers::Destroy(C_LibPlayersTurrets_GUILayerIdStatus);

	Layers::Detach(C_LibPlayersTurrets_GUILayerIdMarker);
	Layers::Destroy(C_LibPlayersTurrets_GUILayerIdMarker);
}

// ---------------------------------- //
/// Load the library.
Void Load() {
	Unload();

	G_LibPlayersTurrets_TurretModelId = ItemList_Add(C_LibPlayersTurrets_TurretModelPath);
	SetDeployTime(-1);
	SetCooldown(-1);
	SetArmorMax(-1);
	SetAutoDestroyTurrets(True);

	Layers::Create(C_LibPlayersTurrets_GUILayerIdStatus, Private_CreateManialinkTurretsUI());
	Layers::Attach(C_LibPlayersTurrets_GUILayerIdStatus);

	Layers::Create(C_LibPlayersTurrets_GUILayerIdMarker, Private_CreateManialinkTurretMarker());
	Layers::SetType(C_LibPlayersTurrets_GUILayerIdMarker, CUILayer::EUILayerType::Markers);
	Layers::Attach(C_LibPlayersTurrets_GUILayerIdMarker);
}

// ---------------------------------- //
/// Library loop.
Void Loop() {
	// ---------------------------------- //
	// Manage players
	foreach (Player in AllPlayers) {
		declare Vec3 LibPlayersTurrets_LatestGroundPosition for Player;
		if (Player.IsTouchingGround) LibPlayersTurrets_LatestGroundPosition = Player.Position;

		if (!HasTurretSpawned(Player)) {
			// ---------------------------------- //
			// Abort deploying if the player has moved
			declare Vec3 LibPlayersTurrets_TurretDeployPos for Player;
			if (HasTurretDeployed(Player) && (
				ML::Distance(Player.Position, LibPlayersTurrets_TurretDeployPos) > C_LibPlayersTurrets_DeployCancelDist ||
				!Player.IsTouchingGround
			)) {
				declare Destroyed = DestroyTurret(Player);
			}

			// ---------------------------------- //
			// Spawn deployed turrets
			if (Now >= GetTurretSpawnTime(Player)) {
				declare Turret <=> CreateTurret(Player);
			}
		}

		// ---------------------------------- //
		// Destroy turret if the player has changed their clan
		declare PlayerTurret <=> GetPlayerTurret(Player);
		if (PlayerTurret != Null) {
			declare TurretClan = GetTurretClan(PlayerTurret);
			if (TurretClan != Player.CurrentClan) DestroyTurret(PlayerTurret.Id);
		}
	}

	declare Ident[] TurretsToDestroy;

	// ---------------------------------- //
	// Manage turrets
	foreach (TurretId in G_LibPlayersTurrets_CreatedTurrets) {
		if (!TurretsManager.Turrets.existskey(TurretId)) continue;
		declare Turret <=> TurretsManager.Turrets[TurretId];

		// ---------------------------------- //
		// On turret armor change
		if (
			!G_LibPlayersTurrets_PrevTurretArmor.existskey(TurretId) ||
			G_LibPlayersTurrets_PrevTurretArmor[TurretId] != Turret.Armor
		) {
			G_LibPlayersTurrets_PrevTurretArmor[TurretId] = Turret.Armor;
			Private_UpdateTurretArmorInfo(TurretId);
			if (G_LibPlayersTurrets_AutoDestroyTurrets && Turret.Armor <= 0) TurretsToDestroy.add(TurretId);
		}

		// ---------------------------------- //
		// Destroy turrets without owners
		declare TurretOwner = GetTurretOwner(Turret);
		if (TurretOwner == Null || !Players.exists(TurretOwner)) TurretsToDestroy.add(TurretId);
	}

	// Destroy unnecessary turrets
	while (TurretsToDestroy.count > 0) {
		declare Boolean Removed;
		Removed = DestroyTurret(TurretsToDestroy[0], G_LibPlayersTurrets_TurretCooldown);
		Removed = TurretsToDestroy.removekey(0);
	}
}