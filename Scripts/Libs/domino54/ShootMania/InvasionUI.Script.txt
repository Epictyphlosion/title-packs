// -------------------------------------- //
//  INVASION INTERFACE LIB by domino54    //
//  script version: 2016-09-25            //
// -------------------------------------- //

#Const Version		"2016-09-25"
#Const ScriptName	"InvasionUI.Script.txt"

#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"

#Const C_LibInvasionUI_ScoreZeroes		6	///< Number of total characters in score label
#Const C_LibInvasionUI_MaxBossesBars	10	///< Maxinum amount of bosses bars displayed under timer

/// List of all available modules
#Const C_AvailableModules [
	"CountdownInfo", "PoleGauge", "ToadsArmor", "Score", "MedalScore", "Evolution",
	"GoldMarker", "CustomWeaponBar", "ToadsCounter", "SoloScore", "BossHealth"
]

/// Modules positions
#Const C_LibInvasionUI_CountdownPos		<0., 90., 5.>
#Const C_LibInvasionUI_PoleGaugePos 	<-160., 90., 5.>
#Const C_LibInvasionUI_ToadsArmorPos	<155., -74., 3.>
#Const C_LibInvasionUI_ScorePos			<-159., 72.5, 5.>
#Const C_LibInvasionUI_MedalScorePos	<160., 85.5, 5.>
#Const C_LibInvasionUI_EvolutionPos		<-159.5, 55., 5.>
#Const C_LibInvasionUI_WeaponBarPos		<0., -68., 5.>
#Const C_LibInvasionUI_ToadsCounterPos	<-160., -90., 5.>
#Const C_LibInvasionUI_SoloScorePos		<0., 0., 5.>
#Const C_LibInvasionUI_BossHealthPos	<0., 77.75, 5.>

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Text[] G_LibInvasionUI_ModulesLoaded;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Check if a module is loaded
 *
 *	@param	_ModuleId		The module to check
 *
 *	@return					True if the given module is loaded, False otherwise
 */
Boolean Private_ModuleIsLoaded(Text _ModuleId) {
	return G_LibInvasionUI_ModulesLoaded.exists(_ModuleId);
}

// ---------------------------------- //
/** Update the settings for a module
 *
 *	@param	_Name		The name of the setting
 *	@param	_Value		The value of the setting
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibInvasionUI_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInvasionUI_Settings for Teams[0] = Text[Text];
	Net_LibInvasionUI_SettingsUpdate = Now;
	Net_LibInvasionUI_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Create the manialink for the countdown info module
 *
 *	@return		The manialink
 */
Text Private_CreateMLCountdownInfo() {
	return """
<manialink version="2" name="LibInvasionUI:CountdownInfo">
<stylesheet>
	<style id="Label_CountdownInfo" textsize="1" textfont="Eurostile_Bold" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_CountdownInfo" posn="{{{C_LibInvasionUI_CountdownPos.X^" "^C_LibInvasionUI_CountdownPos.Y^" "^C_LibInvasionUI_CountdownPos.Z}}}">
	<label posn="0 -8.5" halign="center" valign="center2" textprefix="$t$s" id="Label_CountdownInfo"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: CountdownInfo
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_CountdownInfo <=> (Page.GetFirstChild("Frame_CountdownInfo") as CMlFrame);
declare Label_CountdownInfo <=> (Page.GetFirstChild("Label_CountdownInfo") as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare StartTime = -1;
declare WavesToInvasion = -1;

declare PrevSettingsUpdate = -1;
declare PrevWavesToInvasion = -2;
declare PrevCountdownColor = Vec3;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "WavesToInvasion" : WavesToInvasion = TL::ToInteger(SettingValue);
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
		}
	}
}

Frame_CountdownInfo.Visible = DisplayInterface && StartTime > 0;

if (!Frame_CountdownInfo.Visible) continue;

// ---------------------------------- //
// Update information
if (PrevWavesToInvasion != WavesToInvasion) {
	PrevWavesToInvasion = WavesToInvasion;
	
	declare Text CountdownInfo;
	switch (WavesToInvasion) {
		case 1 : CountdownInfo = "1 wave to Invasion";
		case 0 : CountdownInfo = "Invasion mode!";
		case -1 : CountdownInfo = "Preparation time";
		default : CountdownInfo = "%1 waves to Invasion";
	}
	
	Label_CountdownInfo.SetText(Translate([CountdownInfo, TL::ToText(WavesToInvasion)]));
}
***

// ---------------------------------- //
/** Compute width of the label text
 *
 *	@param	_Label	Label to check text length
 *
 *	@return		Width of the label text
 */
Real ComputeWidth(CMlLabel _Label) {
	if (_Label == Null) return 0.;
	return _Label.ComputeWidth(_Label.Value) * _Label.RelativeScale;
}

{{{Translations::InsertToManialink(["1 wave to Invasion", "Invasion mode!", "Preparation time", "%1 waves to Invasion"])}}}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the pole gauge module
 *
 *	@return		The manialink
 */
Text Private_CreateMLPoleGauge() {
	return """
<manialink version="2" name="LibInvasionUI:PoleGauge">
<stylesheet>
	<style id="Label_GaugeInfo" textsize="1" textfont="Eurostile_Bold" textcolor="888" textprefix="$t"/>
	<style id="Label_ToadsReached" textsize="4" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF"/>
	<style id="Label_NbPoleLimit" textsize="2" textfont="Eurostile_Bold" textemboss="1" textcolor="888"/>
</stylesheet>

<frame id="Frame_PoleGauge" posn="{{{C_LibInvasionUI_PoleGaugePos.X - 70^" "^C_LibInvasionUI_PoleGaugePos.Y^" "^C_LibInvasionUI_PoleGaugePos.Z}}}">
	<quad posn="3 -3" sizen="0 7" bgcolor="0F0" id="Quad_PoleGaugeBar"/>
	<quad posn="0 0 1" sizen="70 14" rot="180" halign="right" valign="bottom" image="{{{C_ImgBase}}}UiPoleCaptureFg.png"/>
	<label posn="3 -10.85 2" sizen="36 2" valign="center2" id="Label_GaugeInfo"/>
	<label posn="4 -5.75 2" valign="center2" id="Label_ToadsReached" text="0"/>
	<label posn="66 -5.75 2" valign="center2" halign="right" id="Label_NbPoleLimit" text="0"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: PoleGauge
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	-70.
#Const C_GaugeQuadSize	<64., 7.>
#Const C_GaugeColors	[0. => <0., 1., 0.>, .5 => <1., 1., 0.>, 1. => <1., 0., 0.>]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_PoleGauge		<=> (Page.GetFirstChild("Frame_PoleGauge")		as CMlFrame);
declare Quad_PoleGaugeBar	<=> (Page.GetFirstChild("Quad_PoleGaugeBar")	as CMlQuad);
declare Label_ToadsReached	<=> (Page.GetFirstChild("Label_ToadsReached")	as CMlLabel);
declare Label_NbPoleLimit	<=> (Page.GetFirstChild("Label_NbPoleLimit")	as CMlLabel);

Translate("Label_GaugeInfo", "Toads reached pole");

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare ShowGaugeBar = False;
declare PoleLimit = 0;
declare NbToadsReachedPole = 0;
declare AnimateGaugeBar = True;

declare PrevSettingsUpdate = -1;
declare PrevShowGaugeBar = False;
declare PrevPoleLimit = -1;
declare PrevNbToadsReachedPole = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "PoleLimit" : PoleLimit = TL::ToInteger(SettingValue);
			case "NbToadsReachedPole" : NbToadsReachedPole = ML::Clamp(TL::ToInteger(SettingValue), 0, PoleLimit);
		}
	}
}

ShowGaugeBar = DisplayInterface && PoleLimit > 0;

// ---------------------------------- //
// Set gauge visibility
if (PrevShowGaugeBar != ShowGaugeBar) {
	PrevShowGaugeBar = ShowGaugeBar;
	
	declare TargetPosition = Frame_PoleGauge.RelativePosition;
	TargetPosition.X = {{{C_LibInvasionUI_PoleGaugePos.X}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowGaugeBar) {
		TargetPosition.X += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
		NbToadsReachedPole = 0;
	}
	
	LibManialink_Anim(
		Frame_PoleGauge,
		"<frame posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>",
		250, TargetEasing
	);
}

if (!ShowGaugeBar) continue;

// ---------------------------------- //
// Update pole limit
if (PrevPoleLimit != PoleLimit) {
	PrevPoleLimit = PoleLimit;
	
	Label_NbPoleLimit.SetText(TL::ToText(PoleLimit));
	AnimateGaugeBar = True;
}

// ---------------------------------- //
// Update Toads reached pole amount
if (PrevNbToadsReachedPole != NbToadsReachedPole) {
	PrevNbToadsReachedPole = NbToadsReachedPole;
	
	Label_ToadsReached.SetText(TL::ToText(NbToadsReachedPole));
	AnimateGaugeBar = True;
}

// ---------------------------------- //
// Animate gauge bar
if (AnimateGaugeBar) {
	AnimateGaugeBar = False;
	
	declare GaugeRatio = 0.;
	if (PoleLimit > 0) GaugeRatio = ML::Clamp(ML::ToReal(NbToadsReachedPole) / PoleLimit, 0., 1.);
	declare GaugeColor = TL::ColorToText(ColorTransition(GaugeRatio, C_GaugeColors));
	
	LibManialink_Anim(
		Quad_PoleGaugeBar,
		"<quad sizen='"^C_GaugeQuadSize.X * GaugeRatio^" "^C_GaugeQuadSize.Y^"' bgcolor="^GaugeColor^"/>",
		250, "EaseInOutSine"
	);
}
***

// ---------------------------------- //
/** Get the color depending on a ratio
 *
 *	@param	_Ratio			The ratio of the color
 *	@param	_ColorRatios	List of the colors for each ratio
 *
 *	@return		The Blend color according to the ratio
 */
Vec3 ColorTransition(Real _Ratio, Vec3[Real] _ColorRatios) {
	if (_ColorRatios.count <= 0) return <0., 0., 0.>;
	if (_ColorRatios.count == 1) foreach (Color in _ColorRatios) return Color;
	if (_ColorRatios.existskey(_Ratio)) return _ColorRatios[_Ratio];
	
	// Sort all colors ratios in ascending order
	declare Real[] SortedRatios;
	foreach (Ratio => Color in _ColorRatios) SortedRatios.add(Ratio);
	SortedRatios = SortedRatios.sort();
	
	// Get the lowest color ratio
	declare MinimumRatio = SortedRatios[0];
	foreach (Ratio in SortedRatios) if (Ratio > MinimumRatio && Ratio < _Ratio) MinimumRatio = Ratio;
	
	// Get the highest color ratio
	declare MaximumRatio = SortedRatios[SortedRatios.count - 1];
	foreach (Ratio in SortedRatios) if (Ratio < MaximumRatio && Ratio > _Ratio) MaximumRatio = Ratio;
	
	// Get the colors blend properties
	declare BlendRatio = (_Ratio - MinimumRatio) / (MaximumRatio - MinimumRatio);
	declare MinimumColor = _ColorRatios[MinimumRatio];
	declare MaximumColor = _ColorRatios[MaximumRatio];
	
	// Compute the final color
	declare Vec3 OutputColor;
	for (I, 0, 2) OutputColor[I] = MinimumColor[I] + (MaximumColor[I] - MinimumColor[I]) * BlendRatio;
	return OutputColor;
}

{{{Manialink::Animations(["EaseInOutSine", "EaseInCirc", "EaseOutCirc"])}}}
{{{Translations::InsertToManialink(["Toads reached pole"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the Toads Armor module
 *
 *	@return		The manialink
 */
Text Private_CreateMLToadsArmor() {
	return """
<manialink version="2" name="LibInvasionUI:ToadsArmor">
<stylesheet>
	<style id="Label_ToadsArmor" textsize="2" textfont="Eurostile_Bold" textcolor="000"/>
</stylesheet>

<frame id="Frame_ToadsArmor" posn="{{{C_LibInvasionUI_ToadsArmorPos.X^" "^C_LibInvasionUI_ToadsArmorPos.Y^" "^C_LibInvasionUI_ToadsArmorPos.Z}}}" scale="0">
	<quad sizen="8 8" halign="center" valign="center" image="{{{C_ImgBase}}}IconToadsArmor.png" id="Quad_ToadsArmor" colorize="777"/>
	<label posn="0 .25 1" sizen="5 3" halign="center" valign="center2" id="Label_ToadsArmor" text="0"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: ToadsArmor
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_ToadsArmor <=> (Page.GetFirstChild("Frame_ToadsArmor") as CMlFrame);
declare Label_ToadsArmor <=> (Page.GetFirstChild("Label_ToadsArmor") as CMlLabel);
declare Quad_ToadsArmor <=> (Page.GetFirstChild("Quad_ToadsArmor") as CMlQuad);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare ShowToadsArmor = False;
declare ToadsArmor = 0;

declare PrevSettingsUpdate = -1;
declare PrevShowToadsArmor = False;
declare PrevToadsArmor = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***	
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "ToadsArmor" : ToadsArmor = TL::ToInteger(SettingValue);
		}
	}
}

ShowToadsArmor = DisplayInterface && ToadsArmor > 0;

// ---------------------------------- //
// Set Toads Armor icon visibility
if (PrevShowToadsArmor != ShowToadsArmor) {
	PrevShowToadsArmor = ShowToadsArmor;
	
	declare TargetScale = 1.;
	declare TargetEasing = "EaseOutBack";
	
	if (!ShowToadsArmor) {
		TargetScale = 0.;
		TargetEasing = "EaseInBack";
	}
	
	LibManialink_Anim(Frame_ToadsArmor, "<frame scale="^TargetScale^" />", 500, TargetEasing);
}

if (!ShowToadsArmor) continue;

// ---------------------------------- //
// Update Toads Armor points
if (PrevToadsArmor != ToadsArmor) {
	Label_ToadsArmor.SetText(TL::ToText(ToadsArmor / 100));
	
	if (PrevToadsArmor > 0 && ToadsArmor > 0) {
		declare Color = LocalUser.Color;
		if (GUIPlayer != Null) {
			if (!Teams.existskey(GUIPlayer.CurrentClan - 1)) Color = GUIPlayer.User.Color;
			else Color = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
		}
		
		LibManialink_Anim(Frame_ToadsArmor, "<frame scale=3 />", 750, "EaseInOutCirc");
		LibManialink_AnimChain(Frame_ToadsArmor, "<frame scale=1 />", 750, "EaseInOutCirc");
		
		LibManialink_Anim(Quad_ToadsArmor, "<frame colorize="^TL::ColorToText(Color)^" />", 750, "EaseInOutCirc");
		LibManialink_AnimChain(Quad_ToadsArmor, "<frame colorize=777 />", 750, "EaseInOutCirc");
	}
	
	PrevToadsArmor = ToadsArmor;
}
***

{{{Manialink::Animations(["EaseInOutCirc", "EaseOutBack", "EaseInBack"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the score module
 *
 *	@return		The manialink
 */
Text Private_CreateMLScore() {
	return """
<manialink version="2" name="LibInvasionUI:Score">
<stylesheet>
	<style class="info" textsize="2" textfont="Eurostile_Bold" textemboss="1" textcolor="999"/>
</stylesheet>

<frame id="Frame_Score" posn="{{{C_LibInvasionUI_ScorePos.X - 50^" "^C_LibInvasionUI_ScorePos.Y^" "^C_LibInvasionUI_ScorePos.Z}}}"><frame id="Frame_ScoreAnim">
	<label valign="center2" class="info" textsize="8" id="Label_Score" text="000000"/>
	<label posn="0 -5" valign="center2" class="info" textprefix="$T" text="Score" translate="1"/>
</frame></frame>

<script><!--
/**
 *	LibInvasionUI: Score
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	-50.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Score <=> (Page.GetFirstChild("Frame_Score") as CMlFrame);
declare Label_Score <=> (Page.GetFirstChild("Label_Score") as CMlLabel);
declare Frame_ScoreAnim <=> (Page.GetFirstChild("Frame_ScoreAnim") as CMlFrame);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare TimeScoreCounting = False;
declare ShowScore = False;
declare StartTime = -1;
declare NbPoints = 0;
declare TimePoints = 0;

declare PrevSettingsUpdate = -1;
declare PrevShowScore = False;
declare PrevPlayerLogin = "";
declare PrevNbPoints = 0;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "TimeScoreCounting" : TimeScoreCounting = SettingValue == "True";
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
		}
	}
}

ShowScore = (DisplayInterface && ((GUIPlayer != Null && GUIPlayer.Score != Null) || !IsSpectatorMode));

// ---------------------------------- //
// Set score label visibility
if (PrevShowScore != ShowScore) {
	PrevShowScore = ShowScore;
	
	declare TargetPosition = Frame_Score.RelativePosition;
	TargetPosition.X = {{{C_LibInvasionUI_ScorePos.X}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowScore) {
		TargetPosition.X += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
	}
	
	LibManialink_Anim(Frame_Score, "<frame posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>", 250, TargetEasing);
}

if (!ShowScore) continue;

// ---------------------------------- //
// Update current player score
if (GUIPlayer != Null && GUIPlayer.Score != Null) {
	NbPoints = GUIPlayer.Score.Points;
	
	if (PrevNbPoints != NbPoints) {
		PrevNbPoints = NbPoints;
		
		// Do animation
		if (PrevPlayerLogin == GUIPlayer.User.Login) {
			LibManialink_Anim(Frame_ScoreAnim, "<frame scale=1.1 />", 125, "EaseLinear");
			LibManialink_AnimInsert(Frame_ScoreAnim, "<frame scale=1 />", 125, 125, "EaseLinear");
		}
	}
	
	PrevPlayerLogin = GUIPlayer.User.Login;
}
// ---------------------------------- //
// Reset score
else if (!IsSpectatorMode) {
	PrevPlayerLogin = "";
	PrevNbPoints = 0;
}

// ---------------------------------- //
// Set points
if (TimeScoreCounting) TimePoints = ((GameTime - StartTime) / 1000) * 10;
Label_Score.Value = GetScoreLabel(NbPoints * 10 + TimePoints);
***

// ---------------------------------- //
/** Get the score text with zeroes
 *
 *	@param	_Points		Score points
 *
 *	@return		Score text string
 */
Text GetScoreLabel(Integer _Points) {
	declare Zeroes = {{{C_LibInvasionUI_ScoreZeroes}}};
	
	if (_Points <= 0) {
		declare Text TextScore;
		for (I, 0, Zeroes - 1) TextScore ^= "0";
		return TextScore;
	}
	
	declare TextScore = TL::ToText(_Points);
	declare Length = TL::Length(TextScore);
	
	TextScore = "$FFF"^TextScore;
	if (Length < Zeroes) for (I, Length, Zeroes - 1) TextScore = "0"^TextScore;
	
	return TextScore;
}

{{{Manialink::Animations(["EaseInCirc", "EaseOutCirc"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the medal score module
 *
 *	@return		The manialink
 */
Text Private_CreateMLMedalScore() {
	return """
<manialink version="2" name="LibInvasionUI:MedalScore">
<stylesheet>
	<style id="Label_TargetPoints" scale=".75" textfont="Eurostile_Bold" textcolor="999"/>
	<style class="medal" posn="0 0 1" sizen="20 10" valign="center" opacity="0"/>
</stylesheet>

<frame id="Frame_MedalScore" posn="{{{C_LibInvasionUI_MedalScorePos.X + 80^" "^C_LibInvasionUI_MedalScorePos.Y^" "^C_LibInvasionUI_MedalScorePos.Z}}}">
	<frame posn="-80">
		<quad sizen="80 10" valign="center" image="{{{C_ImgBase}}}MedalScoreFg.png"/>
		<label posn="73 0 2" halign="center" valign="center2" text="????" id="Label_TargetPoints"/>
		<quad posn="17 0 -1" sizen="50 4" valign="center" bgcolor="000" id="Quad_ProgressGauge"/>
		<quad class="medal" image="{{{C_ImgBase}}}MedalScoreBronze.dds" id="Quad_MedalBronze"/>
		<quad class="medal" image="{{{C_ImgBase}}}MedalScoreSilver.dds" id="Quad_MedalSilver"/>
		<quad class="medal" image="{{{C_ImgBase}}}MedalScoreGold.dds" id="Quad_MedalGold"/>
		<quad class="medal" image="{{{C_ImgBase}}}MedalScoreNadeo.dds" id="Quad_MedalAuthor"/>
	</frame>
</frame>

<script><!--
/**
 *	LibInvasionUI: MedalScore
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	80.
#Const C_MedalColors	[<1., .6, .2>, <.85, .85, .85>, <1., .9, 0.>, <.8, 1., 0.>, <.8, 1., 0.>]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***	
// ---------------------------------- //
// Load interface elements
declare Frame_MedalScore	<=> (Page.GetFirstChild("Frame_MedalScore")		as CMlFrame);
declare Quad_ProgressGauge	<=> (Page.GetFirstChild("Quad_ProgressGauge")	as CMlQuad);
declare Label_TargetPoints	<=> (Page.GetFirstChild("Label_TargetPoints")	as CMlLabel);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare TimeScoreCounting = False;
declare ShowMedalScore = False;
declare StartTime = -1;
declare IsSoloMode = False;
declare CurrentMedal = 0;

declare TargetScore = 0;
declare TotalPoints = 0.;
declare TimePoints = 0.;

declare PrevSettingsUpdate = -1;
declare PrevShowMedalScore = False;
declare PrevMedal = -1;

// ---------------------------------- //
// Check map records
declare ObjectiveBronze	= TL::ToInteger(Map.ObjectiveTextBronze);
declare ObjectiveSilver	= TL::ToInteger(Map.ObjectiveTextSilver);
declare ObjectiveGold	= TL::ToInteger(Map.ObjectiveTextGold);
declare ObjectiveAuthor	= TL::ToInteger(Map.ObjectiveTextAuthor);

declare MapHasValidRecords = (
	ObjectiveBronze > 0 &&
	ObjectiveSilver > 0 &&
	ObjectiveGold > 0 &&
	ObjectiveAuthor > 0 &&
	ObjectiveBronze < ObjectiveSilver &&
	ObjectiveSilver < ObjectiveGold &&
	ObjectiveGold < ObjectiveAuthor
);
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***		
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface"	: DisplayInterface = SettingValue == "True";
			case "TimeScoreCounting"	: TimeScoreCounting = SettingValue == "True";
			case "StartTime" : StartTime = TL::ToInteger(SettingValue);
			case "IsSoloMode" : IsSoloMode = SettingValue == "True";
		}
	}
}

ShowMedalScore = InputPlayer != Null && MapHasValidRecords && IsSoloMode && DisplayInterface;

// ---------------------------------- //
// Set score label visibility
if (PrevShowMedalScore != ShowMedalScore) {
	PrevShowMedalScore = ShowMedalScore;
	
	declare TargetPosition = Frame_MedalScore.RelativePosition;
	TargetPosition.X = {{{C_LibInvasionUI_MedalScorePos.X}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowMedalScore) {
		TargetPosition.X += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
	}
	
	LibManialink_Anim(Frame_MedalScore, "<frame posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>", 250, TargetEasing);
}

if (!ShowMedalScore) continue;

// ---------------------------------- //
// Set points
if (TimeScoreCounting) TimePoints = ((GameTime - StartTime) / 1000.) * 10.;
TotalPoints = TimePoints + InputPlayer.Score.Points * 10;
if (TotalPoints < 0) TotalPoints = 0.;

// ---------------------------------- //
// Update current medal
if (TotalPoints >= ObjectiveAuthor) CurrentMedal = 4;
else if (TotalPoints >= ObjectiveGold) CurrentMedal = 3;
else if (TotalPoints >= ObjectiveSilver) CurrentMedal = 2;
else if (TotalPoints >= ObjectiveBronze) CurrentMedal = 1;
else CurrentMedal = 0;

// ---------------------------------- //
// Gauge bar
switch (CurrentMedal) {
	case 4 : TargetScore = ObjectiveAuthor;
	case 3 : TargetScore = ObjectiveAuthor;
	case 2 : TargetScore = ObjectiveGold;
	case 1 : TargetScore = ObjectiveSilver;
	case 0 : TargetScore = ObjectiveBronze;
}

Quad_ProgressGauge.Size.X = 50. * ML::Clamp(TotalPoints / TargetScore, 0., 1.);

// ---------------------------------- //
// Animate icons and update requirements
while (PrevMedal < CurrentMedal) {
	PrevMedal += 1;
	
	// ---------------------------------- //
	// Update score requirements
	Label_TargetPoints.SetText(TL::ToText(TargetScore));
	
	// ---------------------------------- //
	// Update currently fought for medal color
	if (C_MedalColors.existskey(CurrentMedal))
		Quad_ProgressGauge.BgColor = C_MedalColors[CurrentMedal];
	
	// ---------------------------------- //
	// Do blink animation
	declare Text QuadId;
	switch (PrevMedal) {
		case 1 : QuadId = "Quad_MedalBronze";
		case 2 : QuadId = "Quad_MedalSilver";
		case 3 : QuadId = "Quad_MedalGold";
		case 4 : QuadId = "Quad_MedalAuthor";
	}
	
	if (QuadId != "") {
		LibManialink_AnimRepeatStart(250, 20);
		LibManialink_Anim("<quad id='"^QuadId^"' opacity=0 />", 125, "EaseInOutSine");
		LibManialink_AnimInsert("<quad id='"^QuadId^"' opacity=1 />", 125, 125, "EaseInOutSine");
		LibManialink_AnimRepeatEnd();
		
		// Play sound notification
		Audio.PlaySoundEvent(CAudioManager::ELibSound::Victory, CurrentMedal - 1, -5.);
	}
}
***

{{{Manialink::Functions(["AnimRepeat"])}}}
{{{Manialink::Animations(["EaseInOutSine", "EaseInCirc", "EaseOutCirc"])}}}

main() {
	wait(Map != Null && InputPlayer != Null);
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the Evolution progress module
 *
 *	@return		The manialink
 */
Text Private_CreateMLEvolution() {
	return """
<manialink version="2" name="LibInvasionUI:Evolution">
<stylesheet>
	<style class="font" textsize="2" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF" textprefix="$T"/>
</stylesheet>

<frame id="Frame_Evolution" posn="{{{C_LibInvasionUI_EvolutionPos.X - 30^" "^C_LibInvasionUI_EvolutionPos.Y^" "^C_LibInvasionUI_EvolutionPos.Z}}}">
	<quad sizen="20 20" valign="center" image="{{{C_ImgBase}}}UiEvolutionBg.png"/>
	<quad posn="3.5 -9 -1" sizen="2.25 0" rot="180" bgcolor="FFF" id="Label_EvoProgressGauge"/>
	<label posn="4.625 6.5 1" sizen="20 3" valign="center2" class="font" id="Label_EvoFrameTitleText" text="Evolution"/>
	<label posn="4.5 1.75 1" valign="center2" class="font" textsize="6" id="Label_EvoCurrentLevel" text="1"/>
	<label posn="4.5 -3.5 1" valign="center2" class="font" textcolor="888" id="Label_EvoCurrentPoints" text="0"/>
	<label posn="4.5 -6.5 1" valign="center2" class="font" textcolor="888" id="Label_EvoTargetPoints" text="/4"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: Evolution
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_FrameHideaway	-30.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_Evolution <=> (Page.GetFirstChild("Frame_Evolution") as CMlFrame);
declare Label_EvoCurrentLevel	<=> (Page.GetFirstChild("Label_EvoCurrentLevel")	as CMlLabel);
declare Label_EvoCurrentPoints	<=> (Page.GetFirstChild("Label_EvoCurrentPoints")	as CMlLabel);
declare Label_EvoTargetPoints	<=> (Page.GetFirstChild("Label_EvoTargetPoints")	as CMlLabel);
declare Label_EvoProgressGauge	<=> (Page.GetFirstChild("Label_EvoProgressGauge")	as CMlQuad);

// Translations
Translate("Label_EvoFrameTitleText", "Evolution");

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];
declare netread Int3[Text] Net_LibInvasionUI_PlayerEvolutionData for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare ShowEvolution = False;
declare UseEvolution = False;
declare GUIColor = <1., 1., 1.>;
declare AnimGauge = True;

declare PlayerEvoLevel = 0;
declare PlayerEvoPointsCur = 0;
declare PlayerEvoPointsNext = 0;

declare PrevSettingsUpdate = -1;
declare PrevShowEvolution = False;
declare PrevPlayerEvoLevel = 1;
declare PrevPlayerEvoPointsCur = 0;
declare PrevPlayerEvoPointsNext = 4;
declare PrevGUIColor = Vec3;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***		
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "UseEvolution" : UseEvolution = SettingValue == "True";
		}
	}
}

ShowEvolution = DisplayInterface && UseEvolution && (GUIPlayer != Null || !IsSpectatorMode);

// ---------------------------------- //
// Set Evolution widget visibility
if (PrevShowEvolution != ShowEvolution) {
	PrevShowEvolution = ShowEvolution;
	
	declare TargetPosition = Frame_Evolution.RelativePosition;
	TargetPosition.X = {{{C_LibInvasionUI_EvolutionPos.X}}};
	declare TargetEasing = "EaseOutCirc";
	
	if (!ShowEvolution) {
		TargetPosition.X += C_FrameHideaway;
		TargetEasing = "EaseInCirc";
	}
	
	LibManialink_Anim(Frame_Evolution, "<frame posn='"^TargetPosition.X^" "^TargetPosition.Y^" "^TargetPosition.Z^"'/>", 250, TargetEasing);
}

if (!ShowEvolution) continue;

// ---------------------------------- //
// Obtain Evolution data
if (GUIPlayer != Null && Net_LibInvasionUI_PlayerEvolutionData.existskey(GUIPlayer.Login)) {
	PlayerEvoLevel		= Net_LibInvasionUI_PlayerEvolutionData[GUIPlayer.Login].X;
	PlayerEvoPointsCur	= Net_LibInvasionUI_PlayerEvolutionData[GUIPlayer.Login].Y;
	PlayerEvoPointsNext	= Net_LibInvasionUI_PlayerEvolutionData[GUIPlayer.Login].Z;
}

// ---------------------------------- //
// Update player level
if (PrevPlayerEvoLevel != PlayerEvoLevel) {
	PrevPlayerEvoLevel = PlayerEvoLevel;
	
	Label_EvoCurrentLevel.SetText(TL::ToText(PlayerEvoLevel));
	Label_EvoCurrentLevel.RelativeScale = 0.;
	LibManialink_Anim(Label_EvoCurrentLevel, "<label scale=1 />", 375, "EaseOutCirc");
}

// ---------------------------------- //
// Update player current points
if (PrevPlayerEvoPointsCur != PlayerEvoPointsCur) {
	PrevPlayerEvoPointsCur = PlayerEvoPointsCur;
	
	Label_EvoCurrentPoints.SetText(TL::ToText(PlayerEvoPointsCur));
	AnimGauge = True;
}

// ---------------------------------- //
// Update player points to next
if (PrevPlayerEvoPointsNext != PlayerEvoPointsNext) {
	PrevPlayerEvoPointsNext = PlayerEvoPointsNext;
	
	Label_EvoTargetPoints.SetText("/"^PlayerEvoPointsNext);
	AnimGauge = True;
}

// ---------------------------------- //
// Set interface color
if (GUIPlayer != Null) {
	if (GUIPlayer.CurrentClan == 0) GUIColor = GUIPlayer.User.Color;
	else GUIColor = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
}

if (PrevGUIColor != GUIColor) {
	PrevGUIColor = GUIColor;
	
	AnimGauge = True;
	declare TextColor = Brightness(GUIColor, 2.);
	
	LibManialink_Anim(Label_EvoCurrentPoints, "<label textcolor="^TL::ColorToText(TextColor)^"/>", 250, "EaseInOutSine");
	LibManialink_Anim(Label_EvoTargetPoints, "<label textcolor="^TL::ColorToText(TextColor)^"/>", 250, "EaseInOutSine");
}

// ---------------------------------- //
// Animate gauge
if (AnimGauge) {
	AnimGauge = False;
	
	declare SizeY = 0.;
	if (PlayerEvoPointsNext > 0) SizeY = 18. * PlayerEvoPointsCur / PlayerEvoPointsNext;
	
	LibManialink_Anim(Label_EvoProgressGauge, "<quad sizen='2.25 "^SizeY^"' bgcolor="^TL::ColorToText(GUIColor)^"/>", 250, "EaseInOutSine");
}
***

// ---------------------------------- //
/** Change color brightness
 *
 *	@param	_Color			Input color
 *	@param	_Brightness		Target brightness
 *
 *	@return		New color
 */
Vec3 Brightness(Vec3 _Color, Real _Brightness) {
	if (_Brightness == 1) return _Color;
	if (_Brightness <= 0) return Vec3;
	
	declare Vec3 OutputColor;
	if (_Brightness < 1) for (I, 0, 2) OutputColor[I] = _Color[I] * _Brightness;
	else if (_Brightness > 1) for (I, 0, 2) OutputColor[I] = 1 - (1 / _Brightness) + _Color[I] * (1 / _Brightness);
	return OutputColor;
}

{{{Manialink::Animations(["EaseInOutSine", "EaseInCirc", "EaseOutCirc"])}}}
{{{Translations::InsertToManialink(["Evolution"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the Gold item marker module
 *
 *	@return		The manialink
 */
Text Private_CreateMLGoldMarker() {
	declare Ratio = 9/16.;
	declare StepsML = "";
	for (I, 0, 7) StepsML ^= """
<quad sizen="{{{14 * Ratio}}} 14" halign="center" valign="center" image="{{{C_ImgBase}}}SimpleSteps/Step{{{I}}}.png" id="Quad_MarkerStep{{{I}}}"/>""";
	
	return """
<manialink version="2" name="LibInvasionUI:GoldMarker">
<frame id="Frame_GoldMarker" scale="0">
	<quad sizen="{{{14 * Ratio}}} 14" halign="center" valign="center" image="{{{C_ImgBase}}}SimpleBG.png"/>
	<quad sizen="{{{6 * Ratio}}} 10" halign="center" valign="center" image="{{{C_ImgBase}}}IconCrystalGoldEmpty.png"/>
	<quad posn="0 0 1" sizen="{{{6 * Ratio}}} 10" halign="center" valign="center" image="{{{C_ImgBase}}}IconCrystalGold.png"/>
	<frame id="Frame_GaugeSteps" posn="0 0 1">
		{{{StepsML}}}
	</frame>
</frame>

<script><!--
/**
 *	LibInvasionUI: GoldMarker
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_GaugeColors [0. => <1., 0., 0.>, 1. => <1., 1., 0.>]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare CMlQuad[] Quad_MarkerSteps;
for (I, 0, 7) Quad_MarkerSteps.add((Page.GetFirstChild("Quad_MarkerStep"^I) as CMlQuad));

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];
declare netread Boolean[Text] Net_LibInvasionUI_PlayerHasCustomWeapon for Teams[0];
declare netread Integer[Text] Net_LibInvasionUI_PlayerGoldSpawnId for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare ShowGoldMarker = False;
declare GoldSpawnTime = -1;
declare GoldSpawnDuration = -1;
declare GoldSpawnId = -1;
declare GaugeRatio = 0.;

declare PrevSettingsUpdate = -1;
declare PrevShowGoldMarker = False;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***	
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
			case "GoldSpawnDuration" : GoldSpawnDuration = TL::ToInteger(SettingValue);
			case "GoldSpawnTime" : GoldSpawnTime = TL::ToInteger(SettingValue);
			case "GoldSpawnId" : GoldSpawnId = TL::ToInteger(SettingValue);
		}
	}
}

ShowGoldMarker = (
	DisplayInterface && GoldSpawnDuration > 0 && GameTime <= GoldSpawnTime + GoldSpawnDuration &&
	(GUIPlayer == Null ||
	
	// Hide if player already has a weapon equipped
	((!Net_LibInvasionUI_PlayerHasCustomWeapon.existskey(GUIPlayer.User.Login) ||
	!Net_LibInvasionUI_PlayerHasCustomWeapon[GUIPlayer.User.Login]) &&
	
	// Hide if player picked up Gold and does no longer have weapon
	(!Net_LibInvasionUI_PlayerGoldSpawnId.existskey(GUIPlayer.User.Login) ||
	Net_LibInvasionUI_PlayerGoldSpawnId[GUIPlayer.User.Login] != GoldSpawnId)))
);

// ---------------------------------- //
// Set Gold marker visibility
if (PrevShowGoldMarker != ShowGoldMarker) {
	PrevShowGoldMarker = ShowGoldMarker;
	
	declare TargetScale = 1.;
	declare TargetEasing = "EaseOutBack";
	
	if (!ShowGoldMarker) {
		TargetScale = 0.;
		TargetEasing = "EaseInBack";
	}
	
	LibManialink_Anim("<frame id='Frame_GoldMarker' scale="^TargetScale^" />", 500, TargetEasing);
}

if (!ShowGoldMarker) continue;

// ---------------------------------- //
// Set gauge ratio
GaugeRatio = 1. - ML::Clamp(ML::ToReal(GameTime - GoldSpawnTime) / GoldSpawnDuration, 0., 1.);

// ---------------------------------- //
// Display gauge steps
for (I, 0, 7) {
	declare StepStart = 1/8. * I;
	declare StepEnd = StepStart + 1/8.;
	
	declare Opacity = 0.;
	if (GaugeRatio >= StepStart) Opacity = (GaugeRatio - StepStart) * 8;
	if (GaugeRatio >= StepEnd) Opacity = 1.;
	
	Quad_MarkerSteps[I].Opacity = Opacity;
	Quad_MarkerSteps[I].Colorize = ColorTransition(GaugeRatio, C_GaugeColors);
}
***

// ---------------------------------- //
/** Get the color depending on a ratio
 *
 *	@param	_Ratio			The ratio of the color
 *	@param	_ColorRatios	List of the colors for each ratio
 *
 *	@return		The Blend color according to the ratio
 */
Vec3 ColorTransition(Real _Ratio, Vec3[Real] _ColorRatios) {
	if (_ColorRatios.count <= 0) return <0., 0., 0.>;
	if (_ColorRatios.count == 1) foreach (Color in _ColorRatios) return Color;
	if (_ColorRatios.existskey(_Ratio)) return _ColorRatios[_Ratio];
	
	// Sort all colors ratios in ascending order
	declare Real[] SortedRatios;
	foreach (Ratio => Color in _ColorRatios) SortedRatios.add(Ratio);
	SortedRatios = SortedRatios.sort();
	
	// Get the lowest color ratio
	declare MinimumRatio = SortedRatios[0];
	foreach (Ratio in SortedRatios) if (Ratio > MinimumRatio && Ratio < _Ratio) MinimumRatio = Ratio;
	
	// Get the highest color ratio
	declare MaximumRatio = SortedRatios[SortedRatios.count - 1];
	foreach (Ratio in SortedRatios) if (Ratio < MaximumRatio && Ratio > _Ratio) MaximumRatio = Ratio;
	
	// Get the colors blend properties
	declare BlendRatio = (_Ratio - MinimumRatio) / (MaximumRatio - MinimumRatio);
	declare MinimumColor = _ColorRatios[MinimumRatio];
	declare MaximumColor = _ColorRatios[MaximumRatio];
	
	// Compute the final color
	declare Vec3 OutputColor;
	for (I, 0, 2) OutputColor[I] = MinimumColor[I] + (MaximumColor[I] - MinimumColor[I]) * BlendRatio;
	return OutputColor;
}

{{{Manialink::Animations(["EaseInBack", "EaseOutBack"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the custom weapon bar module
 *
 *	@return		The manialink
 */
Text Private_CreateMLCustomWeaponBar() {
	return """
<manialink version="2" name="LibInvasionUI:CustomWeaponBar">
<stylesheet>
	<style id="Label_CustomWeaponName" textsize="2" textfont="Eurostile_Bold" textcolor="888" textprefix="$T"/>
	<style id="Label_EvolutionBonusAmount" textemboss="1" textfont="Eurostile_Bold" textcolor="FFF"/>
	<style id="Label_EvolutionSubtitle" textemboss="1" textsize="1" textfont="Eurostile_Bold" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_CustomWeaponBar" posn="{{{C_LibInvasionUI_WeaponBarPos.X^" "^C_LibInvasionUI_WeaponBarPos.Y^" "^C_LibInvasionUI_WeaponBarPos.Z}}}" scale="0">
	<quad sizen="96 12" halign="center" valign="center" image="{{{C_ImgBase}}}UiWeaponGaugeFg.png"/>
	<quad posn="-45 1.75 -1" sizen="90 4" valign="center" id="Quad_WeaponDurationBar" bgcolor="000"/>
	<label posn="0 -2.25 1" sizen="31 3" halign="center" valign="center2" id="Label_CustomWeaponName" text="Unassigned"/>
	
	<frame id="Frame_EvolutionBonus" posn="52.5 1.5" hidden="1">
		<label posn="0 1.5" halign="center" valign="center2" id="Label_EvolutionBonusAmount" text="+0s"/>
		<label posn="0 -1.5" halign="center" valign="center2" id="Label_EvolutionSubtitle" text="EVO"/>
	</frame>
</frame>

<quad posn="0 0 -75" sizen="320 180" halign="center" valign="center" image="{{{C_ImgBase}}}BonusEffect.dds" opacity="0" id="Quad_ScreenEdgeGlow"/>

<script><!--
/**
 *	LibInvasionUI: CustomWeaponBar
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_SpectatorOffset	12.

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_CustomWeaponBar	<=> (Page.GetFirstChild("Frame_CustomWeaponBar")	as CMlFrame);
declare Quad_WeaponDurationBar	<=> (Page.GetFirstChild("Quad_WeaponDurationBar")	as CMlQuad);
declare Label_CustomWeaponName	<=> (Page.GetFirstChild("Label_CustomWeaponName")	as CMlLabel);
declare Frame_EvolutionBonus	<=> (Page.GetFirstChild("Frame_EvolutionBonus")		as CMlFrame);
declare Label_EvolutionBonusAmount	<=> (Page.GetFirstChild("Label_EvolutionBonusAmount")		as CMlLabel);
declare Quad_ScreenEdgeGlow		<=> (Page.GetFirstChild("Quad_ScreenEdgeGlow")		as CMlQuad);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];
declare netread Int3[Text] Net_LibInvasionUI_PlayerWeaponData for Teams[0]; ///< <Start time, Duration, Evolution bonus>
declare netread Text[Text] Net_LibInvasionUI_PlayerWeaponName for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayInterface = False;
declare ShowCustomWeaponBar = False;
declare GUIColor = <1., 1., 1.>;
declare CurWeaponName = "Unassigned";

declare PlayerHasCustomWeapon = False;
declare PlayerWeaponBuffStartTime = 0;
declare PlayerWeaponBuffDuration = 0;
declare PlayerWeaponEvolutionBonus = 0;

declare PrevSettingsUpdate = -1;
declare PrevShowCustomWeaponBar = False;
declare PrevGUIColor = Vec3;
declare PrevWeaponName = "";
declare PrevEvolutionBonus = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayInterface = SettingValue == "True";
		}
	}
}

// ---------------------------------- //
// Read current player data
if (GUIPlayer != Null && Net_LibInvasionUI_PlayerWeaponData.existskey(GUIPlayer.User.Login)) {
	PlayerWeaponBuffStartTime	= Net_LibInvasionUI_PlayerWeaponData[GUIPlayer.User.Login].X;
	PlayerWeaponBuffDuration	= Net_LibInvasionUI_PlayerWeaponData[GUIPlayer.User.Login].Y;
	PlayerWeaponEvolutionBonus	= Net_LibInvasionUI_PlayerWeaponData[GUIPlayer.User.Login].Z;
	PlayerHasCustomWeapon = GameTime < PlayerWeaponBuffStartTime + PlayerWeaponBuffDuration + PlayerWeaponEvolutionBonus;
}
else if (PlayerHasCustomWeapon) PlayerHasCustomWeapon = False;

ShowCustomWeaponBar = DisplayInterface && GUIPlayer != Null && PlayerHasCustomWeapon;

// ---------------------------------- //
// Set weapon gauge visibility
if (PrevShowCustomWeaponBar != ShowCustomWeaponBar) {
	PrevShowCustomWeaponBar = ShowCustomWeaponBar;
	
	declare TargetScale = 1.;
	declare TargetEasing = "EaseOutBack";
	
	if (!ShowCustomWeaponBar) {
		TargetScale = 0.;
		TargetEasing = "EaseInBack";
	}
	
	LibManialink_Anim(Frame_CustomWeaponBar, "<frame scale="^TargetScale^" />", 500, TargetEasing);
	LibManialink_Anim(Quad_ScreenEdgeGlow, "<frame opacity="^TargetScale * .75^" />", 500, TargetEasing);
}

if (!ShowCustomWeaponBar) continue;

// ---------------------------------- //
// Set the frame offset in spectator mode
Frame_CustomWeaponBar.RelativePosition.Y = {{{C_LibInvasionUI_WeaponBarPos.Y}}};
if (IsSpectatorMode) Frame_CustomWeaponBar.RelativePosition.Y += C_SpectatorOffset;

// Magic!
Quad_ScreenEdgeGlow.RelativeScale = 1. + (.5 + ML::Sin((Now / 50.) / ML::PI()) * .5) * .125;

// ---------------------------------- //
// Update interface color
if (Teams.existskey(GUIPlayer.CurrentClan - 1)) GUIColor = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
else GUIColor = GUIPlayer.User.Color;

if (PrevGUIColor != GUIColor) {
	PrevGUIColor = GUIColor;
	LibManialink_Anim(Quad_WeaponDurationBar, "<quad bgcolor="^TL::ColorToText(GUIColor)^" />", 250, "EaseInOutSine");
	Quad_ScreenEdgeGlow.Colorize = GUIColor;
}

// ---------------------------------- //
// Set the name of the weapon
if (!Net_LibInvasionUI_PlayerWeaponName.existskey(GUIPlayer.User.Login)) CurWeaponName = "Unassigned";
else CurWeaponName = Net_LibInvasionUI_PlayerWeaponName[GUIPlayer.User.Login];

if (PrevWeaponName != CurWeaponName) {
	PrevWeaponName = CurWeaponName;
	Translate("Label_CustomWeaponName", CurWeaponName);
}

// ---------------------------------- //
// Set gauge ratio
declare GaugeRatio = 0;
declare Duration = PlayerWeaponBuffDuration + PlayerWeaponEvolutionBonus;

if (Duration > 0) GaugeRatio = 1 - ML::ToReal(GameTime - PlayerWeaponBuffStartTime) / Duration;
Quad_WeaponDurationBar.Size.X = 90. * ML::Clamp(GaugeRatio, 0., 1.);

// ---------------------------------- //
// Display Evolution level time bonus
if (PrevEvolutionBonus != PlayerWeaponEvolutionBonus) {
	PrevEvolutionBonus = PlayerWeaponEvolutionBonus;
	
	Frame_EvolutionBonus.Visible = PlayerWeaponEvolutionBonus > 0;
	if (Frame_EvolutionBonus.Visible) Label_EvolutionBonusAmount.Value = "+"^PlayerWeaponEvolutionBonus / 1000^"s";
}
***

{{{Translations::InsertToManialink([""])}}}
{{{Manialink::Animations(["EaseInOutSine", "EaseInBack", "EaseOutBack"])}}}

main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the Toads counter module
 *
 *	@return		The manialink
 */
Text Private_CreateMLToadsCounter() {
	return """
<manialink version="2" name="LibInvasionUI:ToadsCounter">
<stylesheet>
	<style id="Label_ToadsAmount" scale=".5" textemboss="1" textfont="Eurostile_Bold" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_ToadsCounter" posn="{{{C_LibInvasionUI_ToadsCounterPos.X^" "^C_LibInvasionUI_ToadsCounterPos.Y^" "^C_LibInvasionUI_ToadsCounterPos.Z}}}">
	<label posn="0" valign="bottom" id="Label_ToadsAmount"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: ToadsCounter
 */

#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Label_ToadsAmount <=> (Page.GetFirstChild("Label_ToadsAmount") as CMlLabel);
	
	declare ToadsCount = 0;
	declare PrevToadsCount = -1;
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		if (!PageIsVisible) continue;
		
		// ---------------------------------- //
		// Update the amount of Toads
		ToadsCount = 0;
		foreach (Player in Players) if (Player.IsBot) ToadsCount += 1;
		
		if (PrevToadsCount != ToadsCount) {
			PrevToadsCount = ToadsCount;
			Label_ToadsAmount.SetText(TL::Compose("Toads: %1", TL::ToText(ToadsCount)));
		}
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the solo score module
 *
 *	@return		The manialink
 */
Text Private_CreateMLSoloScore() {
	return """
<manialink version="2" name="LibInvasionUI:SoloScore">
<stylesheet>
	<style class="fontB" halign="center" valign="center2" textemboss="1" textfont="Eurostile_Bold" textcolor="FFF"/>
	<style class="medal" sizen="10 10" halign="center"/>
</stylesheet>

<frame id="Frame_SoloScore" posn="{{{C_LibInvasionUI_SoloScorePos.X^" "^C_LibInvasionUI_SoloScorePos.Y^" "^C_LibInvasionUI_SoloScorePos.Z}}}" scale="0">
	<frame posn="-40 43">
		<quad
			id="Quad_SoloScoreBgImage" posn="0 0 -1" sizen="80 86"
			image="file://Media/Manialinks/ShootMania/Common/ColoredScreen.dds"
		/>
		
		<label posn="40 -7" class="fontB" textsize="5" id="Label_CurrentMapName"/>
		<label posn="40 -12" halign="center" class="fontB" textsize="2" id="Label_CurrentMapAuthor"/>
		<quad posn="40 -16" sizen="26 26" halign="center" style="MedalsBig" substyle="MedalSlot" id="Quad_SoloScoreMedal"/>
		
		<label posn="40 -48" halign="center" class="fontB" textsize="8" id="Label_ScorePointsTotal"/>
		<label posn="40 -54" halign="center" class="fontB" textsize="2" id="Label_ScorePointsBest"/>
		
		<frame posn="40 -58">
			<quad posn="-21" sizen="10 10" halign="center" style="MedalsBig" substyle="MedalBronze"/>
			<label posn="-21 -12" halign="center" class="fontB" textsize="2" id="Label_ScoreBronze"/>
			<quad posn="-7" sizen="10 10" halign="center" style="MedalsBig" substyle="MedalSilver"/>
			<label posn="-7 -12" halign="center" class="fontB" textsize="2" id="Label_ScoreSilver"/>
			<quad posn="7" sizen="10 10" halign="center" style="MedalsBig" substyle="MedalGold"/>
			<label posn="7 -12" halign="center" class="fontB" textsize="2" id="Label_ScoreGold"/>
			<quad posn="21" sizen="10 10" halign="center" style="MedalsBig" substyle="MedalNadeo"/>
			<label posn="21 -12" halign="center" class="fontB" textsize="2" id="Label_ScoreAuthor"/>
		</frame>
		
		<label posn="40 -76" sizen="76 3" class="fontB" textsize="1" textprefix="$t" id="Label_Tip1"/>
		<label posn="40 -79" sizen="76 3" class="fontB" textsize="1" textprefix="$t" id="Label_Tip2"/>
	</frame>
</frame>

<script><!--
/**
 *	LibInvasionUI: SoloScore
 */

#Include "TextLib" as TL

#Const C_MedalColors [<.2, .2, .2>, <1., .6, 0.>, <.7, .7, .7>, <1., .8, 0.>, <.7, 1., 0.>]
#Const C_MedalStyles ["MedalSlot", "MedalBronze", "MedalSilver", "MedalGold", "MedalNadeo"]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Quad_SoloScoreBgImage	<=> (Page.GetFirstChild("Quad_SoloScoreBgImage")	as CMlQuad);
declare Quad_SoloScoreMedal		<=> (Page.GetFirstChild("Quad_SoloScoreMedal")		as CMlQuad);
declare Label_CurrentMapName	<=> (Page.GetFirstChild("Label_CurrentMapName")		as CMlLabel);
declare Label_CurrentMapAuthor	<=> (Page.GetFirstChild("Label_CurrentMapAuthor")	as CMlLabel);
declare Label_ScorePointsTotal	<=> (Page.GetFirstChild("Label_ScorePointsTotal")	as CMlLabel);
declare Label_ScorePointsBest	<=> (Page.GetFirstChild("Label_ScorePointsBest")	as CMlLabel);

declare Label_ScoreBronze	<=> (Page.GetFirstChild("Label_ScoreBronze")	as CMlLabel);
declare Label_ScoreSilver	<=> (Page.GetFirstChild("Label_ScoreSilver")	as CMlLabel);
declare Label_ScoreGold		<=> (Page.GetFirstChild("Label_ScoreGold")		as CMlLabel);
declare Label_ScoreAuthor	<=> (Page.GetFirstChild("Label_ScoreAuthor")	as CMlLabel);

// Translations
Translate("Label_Tip1", ["Press '%1' to try again", "Delete"]);
Translate("Label_Tip2", ["Press '%1' to go back to menu", "Esc"]);

// ---------------------------------- //
// Display current map information
Label_CurrentMapName.SetText(Map.MapName);
Label_CurrentMapAuthor.SetText(Map.AuthorLogin);
Label_ScoreBronze.SetText(Map.ObjectiveTextBronze);
Label_ScoreSilver.SetText(Map.ObjectiveTextSilver);
Label_ScoreGold.SetText(Map.ObjectiveTextGold);
Label_ScoreAuthor.SetText(Map.ObjectiveTextAuthor);

// ---------------------------------- //
// Persistent settings
declare persistent Integer[Text] Persistent_Invasion_MapBestScores for LocalUser;

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];

// ---------------------------------- //
// Variables
declare ShowSoloScore = False;

declare PrevSettingsUpdate = -1;
declare PrevShowSoloScore = False;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "ShowSoloScore" : ShowSoloScore = SettingValue == "True";
			
			// ---------------------------------- //
			// Display medal
			case "SoloScoreMedal" : {
				declare Medal = ML::Clamp(TL::ToInteger(SettingValue), 0, 4);
				Quad_SoloScoreBgImage.Colorize = C_MedalColors[Medal];
				Quad_SoloScoreMedal.Substyle = C_MedalStyles[Medal];
			}
			// ---------------------------------- //
			// Display map scores
			case "SoloScorePoints" : {
				declare SoloScore = ML::Max(TL::ToInteger(SettingValue), 0);
				declare MapID = Map.MapInfo.MapUid;
				
				// ---------------------------------- //
				// Save map best score
				if (
					!Persistent_Invasion_MapBestScores.existskey(MapID) ||
					Persistent_Invasion_MapBestScores[MapID] < SoloScore
				) 
					Persistent_Invasion_MapBestScores[MapID] = SoloScore;
				
				// ---------------------------------- //
				// Display scores
				Label_ScorePointsTotal.SetText(TL::ToText(SoloScore));
				Label_ScorePointsBest.SetText(TL::Compose(_("Best: %1"), ""^Persistent_Invasion_MapBestScores[MapID]));
			}
		}
	}
}

// ---------------------------------- //
// Set solo score visibility
if (PrevShowSoloScore != ShowSoloScore) {
	PrevShowSoloScore = ShowSoloScore;
	
	declare TargetScale = 1.;
	declare TargetEasing = "EaseOutBack";
	
	if (!ShowSoloScore) {
		TargetScale = 0.;
		TargetEasing = "EaseInBack";
	}
	
	LibManialink_Anim("<frame id='Frame_SoloScore' scale="^TargetScale^" />", 500, TargetEasing);
}

{{{Manialink::Animations(["EaseInBack", "EaseOutBack"])}}}
{{{Translations::InsertToManialink(["Press '%1' to try again", "Press '%1' to go back to menu"])}}}

main() {
	wait(Map != Null);
	---Main---
	sleep(1000);
	
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create the manialink for the boss health module
 *
 *	@return		The manialink
 */
Text Private_CreateMLBossHealth() {
	declare HealthFramesML = "";
	for (I, 0, C_LibInvasionUI_MaxBossesBars - 1) HealthFramesML ^= """<frameinstance
		posn="0 {{{-3.5 * I}}}"
		modelid="FrameModel_BossHealth"
		id="Frame_BossHealth{{{I}}}"
		hidden="1"
	/>""";
	
	return """
<manialink version="2" name="LibInvasionUI:BossHealth">
<framemodel id="FrameModel_BossHealth">
	<quad sizen="80 3.5" halign="center" image="{{{C_ImgBase}}}UiBossHealthRow.png"/>
	<quad posn="-37.5 0 -1" sizen="69 3.5" bgcolor="AF0" id="Quad_BossHealthGauge"/>
	<label posn="35 -1.75 1" sizen="6" halign="center" valign="center2" textsize="1" textfont="Eurostile_Bold" textemboss="1" textcolor="AAA" id="Label_BossArmor"/>
</framemodel>

<frame id="Frame_BossHealthWindow" posn="{{{C_LibInvasionUI_BossHealthPos.X^" "^C_LibInvasionUI_BossHealthPos.Y^" "^C_LibInvasionUI_BossHealthPos.Z}}}" hidden="1">
	<quad sizen="80 3.5" halign="center" valign="bottom" image="{{{C_ImgBase}}}UiBossHealthTop.png"/>
	{{{HealthFramesML}}}
	<quad sizen="80 3.5" halign="center" image="{{{C_ImgBase}}}UiBossHealthBottom.png" id="Quad_FrameBottomImage"/>
</frame>

<script><!--
/**
 *	LibInvasionUI: BossHealth
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_GaugeColors [0. => <1., 0., 0.>, .25 => <1., 1., 0.>, .5 => <1., 1., 0.>, 1. => <.5, 1., 0.>]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_BossHealthWindow <=> (Page.GetFirstChild("Frame_BossHealthWindow") as CMlFrame);
declare Quad_FrameBottomImage <=> (Page.GetFirstChild("Quad_FrameBottomImage") as CMlQuad);

declare CMlFrame[] Frame_BossHealthBars;
for (I, 0, {{{C_LibInvasionUI_MaxBossesBars - 1}}})
	Frame_BossHealthBars.add((Page.GetFirstChild("Frame_BossHealth"^I) as CMlFrame));

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInvasionUI_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInvasionUI_Settings for Teams[0];
declare netread Integer[][] Net_LibInvasionUI_BossesHealthInfo for Teams[0];

declare DisplayBossHealth = False;

declare PrevSettingsUpdate = -1;
declare PrevNbHealthFrames = 0;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***	
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInvasionUI_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInvasionUI_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibInvasionUI_Settings) {
		switch (SettingName) {
			case "DisplayInterface" : DisplayBossHealth = SettingValue == "True";
		}
	}
}
	
Frame_BossHealthWindow.Visible = DisplayBossHealth && Net_LibInvasionUI_BossesHealthInfo.count > 0;
if (!Frame_BossHealthWindow.Visible) continue;
		
// ---------------------------------- //
// Set health frames visibility
if (PrevNbHealthFrames != Net_LibInvasionUI_BossesHealthInfo.count) {
	PrevNbHealthFrames = Net_LibInvasionUI_BossesHealthInfo.count;
	
	// Background image positioning
	Quad_FrameBottomImage.RelativePosition.Y = -3.5 * Net_LibInvasionUI_BossesHealthInfo.count;
	
	foreach (I => Frame in Frame_BossHealthBars) {
		Frame.Visible = Net_LibInvasionUI_BossesHealthInfo.existskey(I);
		if (!Frame.Visible) continue;
	}
}

// ---------------------------------- //
// Update gauges ratios
foreach (I => Frame in Frame_BossHealthBars) {
	if (!Frame.Visible) continue;
	
	// ---------------------------------- //
	// Get the health of the boss
	declare BossHealthInfo = Net_LibInvasionUI_BossesHealthInfo[I];
	if (BossHealthInfo.count < 2) continue;
	
	declare BossArmor = BossHealthInfo[0];
	declare BossArmorMax = BossHealthInfo[1];
	
	// ---------------------------------- //
	// Update only on health amount change
	declare PrevBossArmor for Frame = -1;
	if (PrevBossArmor == BossArmor) continue;
	PrevBossArmor = BossArmor;
	
	// ---------------------------------- //
	// Update the gauge
	declare Quad_BossHealthGauge <=> (Frame.GetFirstChild("Quad_BossHealthGauge") as CMlQuad);
	declare Label_BossArmor <=> (Frame.GetFirstChild("Label_BossArmor") as CMlLabel);
	
	// Set gauge ratio
	declare GaugeRatio = 1.;
	if (BossArmorMax > 0) GaugeRatio = ML::Clamp(ML::ToReal(BossArmor) / BossArmorMax, 0., 1.);
	
	Quad_BossHealthGauge.Size.X = 69. * GaugeRatio;
	Quad_BossHealthGauge.BgColor = ColorTransition(GaugeRatio, C_GaugeColors);
	
	// Set gauge text
	Label_BossArmor.Value = TL::ToText(BossArmor / 100);
}
***

// ---------------------------------- //
/** Get the color depending on a ratio
 *
 *	@param	_Ratio			The ratio of the color
 *	@param	_ColorRatios	List of the colors for each ratio
 *
 *	@return		The Blend color according to the ratio
 */
Vec3 ColorTransition(Real _Ratio, Vec3[Real] _ColorRatios) {
	if (_ColorRatios.count <= 0) return <0., 0., 0.>;
	if (_ColorRatios.count == 1) foreach (Color in _ColorRatios) return Color;
	if (_ColorRatios.existskey(_Ratio)) return _ColorRatios[_Ratio];
	
	// Sort all colors ratios in ascending order
	declare Real[] SortedRatios;
	foreach (Ratio => Color in _ColorRatios) SortedRatios.add(Ratio);
	SortedRatios = SortedRatios.sort();
	
	// Get the lowest color ratio
	declare MinimumRatio = SortedRatios[0];
	foreach (Ratio in SortedRatios) if (Ratio > MinimumRatio && Ratio < _Ratio) MinimumRatio = Ratio;
	
	// Get the highest color ratio
	declare MaximumRatio = SortedRatios[SortedRatios.count - 1];
	foreach (Ratio in SortedRatios) if (Ratio < MaximumRatio && Ratio > _Ratio) MaximumRatio = Ratio;
	
	// Get the colors blend properties
	declare BlendRatio = (_Ratio - MinimumRatio) / (MaximumRatio - MinimumRatio);
	declare MinimumColor = _ColorRatios[MinimumRatio];
	declare MaximumColor = _ColorRatios[MaximumRatio];
	
	// Compute the final color
	declare Vec3 OutputColor;
	for (I, 0, 2) OutputColor[I] = MinimumColor[I] + (MaximumColor[I] - MinimumColor[I]) * BlendRatio;
	return OutputColor;
}

main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
 *
 *	@return		The version number of the script
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script
 *
 *	@return		The name of the script
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Load a module
 *
 *	@param	_ModuleId	The name of the module to load
 */
Void LoadModule(Text _ModuleId) {
	if (Private_ModuleIsLoaded(_ModuleId)) return;
	G_LibInvasionUI_ModulesLoaded.add(_ModuleId);
	
	Layers::Create(_ModuleId);
	declare ManialinkText = "";
	
	switch (_ModuleId) {
		case "CountdownInfo"	: ManialinkText = Private_CreateMLCountdownInfo();
		case "PoleGauge"		: ManialinkText = Private_CreateMLPoleGauge();
		case "ToadsArmor"		: ManialinkText = Private_CreateMLToadsArmor();
		case "Score"			: ManialinkText = Private_CreateMLScore();
		case "MedalScore"		: ManialinkText = Private_CreateMLMedalScore();
		case "Evolution"		: ManialinkText = Private_CreateMLEvolution();
		case "CustomWeaponBar"	: ManialinkText = Private_CreateMLCustomWeaponBar();
		case "SoloScore"		: ManialinkText = Private_CreateMLSoloScore();
		case "BossHealth"		: ManialinkText = Private_CreateMLBossHealth();
		case "GoldMarker" : {
			ManialinkText = Private_CreateMLGoldMarker();
			Layers::SetType(_ModuleId, CUILayer::EUILayerType::Markers);
		}
		case "ToadsCounter"	: {
			ManialinkText = Private_CreateMLToadsCounter();
			Layers::SetType(_ModuleId, CUILayer::EUILayerType::ScoresTable);
		}
	}
	
	Layers::Update(_ModuleId, ManialinkText);
	Layers::Attach(_ModuleId);
}

// ---------------------------------- //
/** Load several modules
 *
 *	@param	_ModulesIds		A list of modules to load with the library
 */
Void LoadModules(Text[] _ModulesIds) {
	foreach (ModuleId in _ModulesIds) LoadModule(ModuleId);
}

// ---------------------------------- //
/// Load all available modules
Void LoadAllModules() {
	LoadModules(C_AvailableModules);
}

// ---------------------------------- //
/** Unload a module
 *
 *	@param	_ModuleId		The name of the module to unload
 */
Void UnloadModule(Text _ModuleId) {
	declare Removed = G_LibInvasionUI_ModulesLoaded.remove(_ModuleId);
	if (!Removed) return;
	
	Layers::Detach(_ModuleId);
	Layers::Destroy(_ModuleId);
}

// ---------------------------------- //
/** Unload several modules
 *
 *	@param	_ModulesIds		A list of modules to unload
 */
Void UnloadModules(Text[] _ModulesIds) {
	foreach (ModuleId in _ModulesIds) UnloadModule(ModuleId);
}

// ---------------------------------- //
/// Unoad all loaded modules
Void UnloadAllModules() {
	UnloadModules(G_LibInvasionUI_ModulesLoaded);
}

// ---------------------------------- //
/** Set the interface visibility
 *
 *	@param	_DisplayInterface	Interface visibility
 */
Void SetDisplayInterface(Boolean _DisplayInterface) {
	Private_SetModuleSetting("DisplayInterface", ""^_DisplayInterface);
}

// ---------------------------------- //
/** Set the game start time
 *
 *	@param	_StartTime	Start time
 */
Void SetStartTime(Integer _StartTime) {
	Private_SetModuleSetting("StartTime", TL::ToText(_StartTime));
}

// ---------------------------------- //
/** Set the amount of waves remaining to the Invasion phase
 *
 *	@param	_WavesToInvasion	Amount of waves to Invasion phase
 */
Void SetNbWavesToInvasion(Integer _WavesToInvasion) {
	Private_SetModuleSetting("WavesToInvasion", TL::ToText(_WavesToInvasion));
}

// ---------------------------------- //
/** Set the pole limit
 *
 *	@param	_PoleLimit	Pole limit
 */
Void SetPoleLimit(Integer _PoleLimit) {
	Private_SetModuleSetting("PoleLimit", TL::ToText(_PoleLimit));
}

// ---------------------------------- //
/** Set the amount of Toads that reached pole
 *
 *	@param	_NbToadsReachedPole		Amount of Toads that reached pole
 */
Void SetNbToadsReachedPole(Integer _NbToadsReachedPole) {
	Private_SetModuleSetting("NbToadsReachedPole", TL::ToText(_NbToadsReachedPole));
}

// ---------------------------------- //
/** Set the current amount of Toads Armor points
 *
 *	@param	_ToadsArmor		Amount of Toads Armor points
 */
Void SetToadsArmor(Integer _ToadsArmor) {
	Private_SetModuleSetting("ToadsArmor", TL::ToText(_ToadsArmor));
}

// ---------------------------------- //
/** Define if the game is in campaign mode
 *
 *	@param	_IsSoloMode		True, if mode is played in solo campaign
 */
Void SetSoloMode(Boolean _IsSoloMode) {
	Private_SetModuleSetting("IsSoloMode", TL::ToText(_IsSoloMode));
}

// ---------------------------------- //
/** Define if the game is giving points for survived time in solo mode
 *
 *	@param	_TimeScoreCounting		Time score usage
 */
Void SetTimeScoreCounting(Boolean _TimeScoreCounting) {
	Private_SetModuleSetting("TimeScoreCounting", TL::ToText(_TimeScoreCounting));
}

// ---------------------------------- //
/** Set the Evolution system usage
 *
 *	@param	_UseEvolution	True, if the Evolution system is in use
 */
Void SetUseEvolution(Boolean _UseEvolution) {
	Private_SetModuleSetting("UseEvolution", TL::ToText(_UseEvolution));
}

// ---------------------------------- //
/** Display solo score summary window
 *
 *	@param	_DisplayWindow	Solo score visibility
 *	@param	_WonMedalType	Player solo medal score
 *	@param	_TotalPoints	Player solo points
 */
Void DisplaySoloScore(Boolean _DisplayWindow, ::EMedal _WonMedalType, Integer _TotalPoints) {
	declare Medal = 0;
	switch (_WonMedalType) {
		case ::EMedal::Bronze : Medal = 1;
		case ::EMedal::Silver : Medal = 2;
		case ::EMedal::Gold : Medal = 3;
		case ::EMedal::Author : Medal = 4;
	}
	
	Private_SetModuleSetting("ShowSoloScore", TL::ToText(_DisplayWindow));
	Private_SetModuleSetting("SoloScoreMedal", TL::ToText(Medal));
	Private_SetModuleSetting("SoloScorePoints", TL::ToText(_TotalPoints));
}

// ---------------------------------- //
/** Update the player Evolution information
 *
 *	@param	_Player					Player to update information
 *	@param	_EvolutionLevel			Evolution level
 *	@param	_CurrentLevelPoints		Current amount of points to next level
 *	@param	_PointsToNextLevel		Points required for next level
 */
Void SetPlayerEvolutionData(CSmPlayer _Player, Integer _EvolutionLevel, Integer _CurrentLevelPoints, Integer _PointsToNextLevel) {
	if (_Player == Null) return;
	declare netwrite Int3[Text] Net_LibInvasionUI_PlayerEvolutionData for Teams[0];
	Net_LibInvasionUI_PlayerEvolutionData[_Player.User.Login] = <_EvolutionLevel, _CurrentLevelPoints, _PointsToNextLevel>;
}

// ---------------------------------- //
/** Set if player is carrying a custom weapon
 *
 *	@param	_Player				Player to set data
 *	@param	_HasCustomWeapon	True if player has custom weapon
 */
Void SetPlayerHasCustomWeapon(CSmPlayer _Player, Boolean _HasCustomWeapon) {
	if (_Player == Null) return;
	declare netwrite Boolean[Text] Net_LibInvasionUI_PlayerHasCustomWeapon for Teams[0];
	Net_LibInvasionUI_PlayerHasCustomWeapon[_Player.User.Login] = _HasCustomWeapon;
}

// ---------------------------------- //
/** Set the spawn ID of the latest Gold item pickd by the player
 *
 *	@param	_Player			Player to set spawn ID
 *	@param	_GoldSpawnId	ID of the latest Gold item picked by the player
 */
Void SetPlayerGoldSpawnId(CSmPlayer _Player, Integer _GoldSpawnId) {
	if (_Player == Null) return;
	declare netwrite Integer[Text] Net_LibInvasionUI_PlayerGoldSpawnId for Teams[0];
	Net_LibInvasionUI_PlayerGoldSpawnId[_Player.User.Login] = _GoldSpawnId;
}

// ---------------------------------- //
/** Set the information about custom weapon used by the player
 *
 *	@param	_Player				Player to set weapon information
 *	@param	_WeaponStartTime	Custom weapon use start time
 *	@param	_WeaponDuration		Duration of the custom weapon (including Evolution bonus)
 *	@param	_EvolutionBonus		Additional time given from the Evolution levels (only UI cosmetic)
 */
Void SetPlayerWeaponData(CSmPlayer _Player, Integer _WeaponStartTime, Integer _WeaponDuration, Integer _EvolutionBonus) {
	if (_Player == Null) return;
	declare netwrite Int3[Text] Net_LibInvasionUI_PlayerWeaponData for Teams[0];
	Net_LibInvasionUI_PlayerWeaponData[_Player.User.Login] = <_WeaponStartTime, _WeaponDuration, _EvolutionBonus>;
}

// ---------------------------------- //
/** Set the name of a custom weapon used by the player
 *
 *	@param	_Player				Player to set weapon name
 *	@param	_CustomWeaponName	Name of the custom weapon used by the player
 */
Void SetPlayerWeaponName(CSmPlayer _Player, Text _CustomWeaponName) {
	if (_Player == Null) return;
	declare netwrite Text[Text] Net_LibInvasionUI_PlayerWeaponName for Teams[0];
	Net_LibInvasionUI_PlayerWeaponName[_Player.User.Login] = _CustomWeaponName;
}

// ---------------------------------- //
/** Set Gold item marker data
 *
 *	@param	_GoldPosition		Position of the Gold item
 *	@param	_GoldSpawnTime		Gold item spawn time
 *	@param	_GoldSpawnDuration	Gold item life duration
 *	@param	_GoldSpawnId		Gold item life id
 */
Void UpdateGoldMarker(Vec3 _GoldPosition, Integer _GoldSpawnTime, Integer _GoldSpawnDuration, Integer _GoldSpawnId) {
	Private_SetModuleSetting("GoldSpawnTime", TL::ToText(_GoldSpawnTime));
	Private_SetModuleSetting("GoldSpawnDuration", TL::ToText(_GoldSpawnDuration));
	Private_SetModuleSetting("GoldSpawnId", TL::ToText(_GoldSpawnId));
	
	// ---------------------------------- //
	// Create or destroy marker
	if (_GoldPosition != <0., 0., 0.>)
		UIManager.UIAll.MarkersXML = """
			<marker
				manialinkframeid="Frame_GoldMarker" box=".5 1.25 .5" visibility="WhenInFrustum"
				pos="{{{_GoldPosition.X^" "^_GoldPosition.Y^" "^_GoldPosition.Z}}}"
			/>
		""";
	else
		UIManager.UIAll.MarkersXML = "";
}

// ---------------------------------- //
/** Set the information about spawned bosses health
 *
 *	@param	_HealthHealthInfo	Bosses health
 */
Void SetBossesHealth(Integer[][] _HealthHealthInfo) {
	declare netwrite Integer[][] Net_LibInvasionUI_BossesHealthInfo for Teams[0];
	Net_LibInvasionUI_BossesHealthInfo = _HealthHealthInfo;
}

// ---------------------------------- //
/// Completely reset UI settings before a match start
Void InitializeMatch() {
	SetDisplayInterface(False);
	SetUseEvolution(False);
	SetTimeScoreCounting(False);
	SetNbToadsReachedPole(0);
	SetPoleLimit(0);
	SetToadsArmor(0);
	SetBossesHealth(Integer[][]);
	
	DisplaySoloScore(False, ::EMedal::None, 0);
	UpdateGoldMarker(Vec3, 0, 0, 0);
	
	// ---------------------------------- //
	// Clear arrays
	declare netwrite Int3[Text] Net_LibInvasionUI_PlayerEvolutionData for Teams[0];
	declare netwrite Boolean[Text] Net_LibInvasionUI_PlayerHasCustomWeapon for Teams[0];
	declare netwrite Integer[Text] Net_LibInvasionUI_PlayerGoldSpawnId for Teams[0];
	declare netwrite Int3[Text] Net_LibInvasionUI_PlayerWeaponData for Teams[0];
	declare netwrite Text[Text] Net_LibInvasionUI_PlayerWeaponName for Teams[0];
	
	Net_LibInvasionUI_PlayerEvolutionData.clear();
	Net_LibInvasionUI_PlayerHasCustomWeapon.clear();
	Net_LibInvasionUI_PlayerGoldSpawnId.clear();
	Net_LibInvasionUI_PlayerWeaponData.clear();
	Net_LibInvasionUI_PlayerWeaponName.clear();
}