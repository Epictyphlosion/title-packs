// -------------------------------------- //
//  LIBRARY INVENTORY by domino54         //
//  script version: 2017-07-19            //
// -------------------------------------- //

/**
 *	This library can manage simple inventories for the players.
 *	Inventory can handle consumable items, weapons amount and spells.
 *	Library can be used for easy switching between weapons on action keys.
 *	Hotbar manialink can be fully customized with several formatting functions.
 */

#Const Version		"2017-07-19"
#Const ScriptName	"Libs/domino54/ShootMania/Inventory.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_LibInventory_UIIconsPath "file://Media/Manialinks/ShootMania/Common/"
#Const C_LibInventory_UILayerID				"LibInventory:Interface"
#Const C_LibInventory_UINbItemsDisplayed	10
#Const C_LibInventory_UIHotbarPosition		<160., -90., 5.>
#Const C_LibInventory_UIHotbarItemSize		<10., 10.>
#Const C_LibInventory_UIHotbarScale			1.
#Const C_LibInventory_UIHotbarRotation		0.
#Const C_LibInventory_UIHotbarHAlign		"right"
#Const C_LibInventory_UIHotbarVAlign		"bottom"
#Const C_LibInventory_UIItemColorEmpty		<.5, .5, .5>
#Const C_LibInventory_UIItemColorDefault	<1., 1., 1.>
#Const C_LibInventory_UIItemColorCooldown	<.25, .25, .25>

/// Sort items depending on their hotkeys order
#Const C_LibInventory_OrganizedOrder [
	CSmModeEvent::EActionInput::Weapon,
	CSmModeEvent::EActionInput::Movement,
	CSmModeEvent::EActionInput::Activable1,
	CSmModeEvent::EActionInput::Activable2,
	CSmModeEvent::EActionInput::Activable3,
	CSmModeEvent::EActionInput::Activable4,
	CSmModeEvent::EActionInput::Consumable1,
	CSmModeEvent::EActionInput::Consumable2,
	CSmModeEvent::EActionInput::None
]

#Const C_LibInventory_Weapons [
	CSmMode::EWeapon::Laser,
	CSmMode::EWeapon::Nucleus,
	CSmMode::EWeapon::Arrow,
	CSmMode::EWeapon::Rocket,
	CSmMode::EWeapon::Missile
]

/// Default amount of ammo for each weapon
#Const C_LibInventory_WeaponsDefualtAmmo [
	CSmMode::EWeapon::Laser		=> 1,
	CSmMode::EWeapon::Nucleus	=> 2,
	CSmMode::EWeapon::Arrow		=> 3,
	CSmMode::EWeapon::Rocket	=> 4,
	CSmMode::EWeapon::Missile	=> 4
]

/// Get weapon from its number
#Const C_LibInventory_GetWeaponsFromNum [
	1 => CSmMode::EWeapon::Laser,
	2 => CSmMode::EWeapon::Rocket,
	3 => CSmMode::EWeapon::Nucleus,
	5 => CSmMode::EWeapon::Arrow,
	6 => CSmMode::EWeapon::Missile
]

/// Names of the items representing players weapons
#Const C_LibInventory_WeaponsPredefinedNames [
	CSmMode::EWeapon::Laser		=> "LInv_WpnLaser",
	CSmMode::EWeapon::Nucleus	=> "LInv_WpnNucleus",
	CSmMode::EWeapon::Arrow		=> "LInv_WpnArrow",
	CSmMode::EWeapon::Rocket	=> "LInv_WpnRocket",
	CSmMode::EWeapon::Missile	=> "LInv_WpnMissile"
]

/// Weapons switch keyboard keys
#Const C_LibInventory_GetWeaponHotkey [
	CSmMode::EWeapon::Laser		=> CSmModeEvent::EActionInput::Activable1,
	CSmMode::EWeapon::Nucleus	=> CSmModeEvent::EActionInput::Activable2,
	CSmMode::EWeapon::Arrow		=> CSmModeEvent::EActionInput::Activable3,
	CSmMode::EWeapon::Rocket	=> CSmModeEvent::EActionInput::Activable4,
	CSmMode::EWeapon::Missile	=> CSmModeEvent::EActionInput::None
]

/// Default icons of the weapons
#Const C_LibInventory_GetWeaponIcon [
	CSmMode::EWeapon::Laser		=> "LaserWhite.dds",
	CSmMode::EWeapon::Nucleus	=> "NucleusWhite.dds",
	CSmMode::EWeapon::Arrow		=> "ArrowWhite.dds",
	CSmMode::EWeapon::Rocket	=> "RocketWhite.dds",
	CSmMode::EWeapon::Missile	=> ""
]

/// Get the text coresponding to hotkey
#Const C_LibInventory_GetHotkeyText [
	CSmModeEvent::EActionInput::Weapon => "LMB",
	CSmModeEvent::EActionInput::Movement => "RMB",
	CSmModeEvent::EActionInput::Activable1 => "1",
	CSmModeEvent::EActionInput::Activable2 => "2",
	CSmModeEvent::EActionInput::Activable3 => "3",
	CSmModeEvent::EActionInput::Activable4 => "4",
	CSmModeEvent::EActionInput::Consumable1 => "Q",
	CSmModeEvent::EActionInput::Consumable2 => "E",
	CSmModeEvent::EActionInput::None => ""
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Boolean G_LibInventory_IsLoaded;	///< True, if the library has been loaded
declare Text[CSmMode::EWeapon] G_LibInventory_WeaponsIcons;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for the inventory module
 *
 *	@return		The inventory manialink
 */
Text Private_CreateManialinkInventory() {
	declare ItemsModels = "";
	for (I, 0, C_LibInventory_UINbItemsDisplayed - 1)
		ItemsModels ^= "<frameinstance modelid='FrameModel_InventoryItem' id='Frame_InventoryItem#"^I^"' hidden='1' />";
		
	return """
<manialink version="3" name="{{{C_LibInventory_UILayerID}}}">
<stylesheet>
	<style id="Quad_ItemBackground" style="UiSMSpectatorScoreBig" substyle="PlayerIconBg" />
	<style id="Label_ItemHotkey" style="TextValueSmallSm" textsize="1" textemboss="1" textcolor="888" />
	<style id="Label_ItemAmount" style="TextValueSmallSm" textsize="2" textemboss="1" textcolor="FFF" />
	<style id="Label_ItemCooldown" style="TextValueSmallSm" textsize="4" textemboss="1" textcolor="FFF" />
	<style id="Quad_ItemIsCurWeapon" style="Bgs1InRace" substyle="BgColorContour" />
</stylesheet>

<framemodel id="FrameModel_InventoryItem">
	<label halign="center" valign="center2" id="Label_ItemCooldown" opacity="0" />
	<label posn="4.5 -5.25" halign="right" valign="bottom" id="Label_ItemAmount" opacity="0" />
	<label posn="-4.25 4.25" id="Label_ItemHotkey" opacity="0" />
	<quad halign="center" valign="center" autoscale="0" sizen="7 7" id="Quad_ItemIcon" opacity="0" />
	<quad halign="center" valign="center" autoscale="0" sizen="10 10" id="Quad_ItemIsCurWeapon" opacity="0" hidden="1" />
	<quad halign="center" valign="center" autoscale="0" sizen="10.5 10" id="Quad_ItemBackground" opacity="0" />
</framemodel>

<frame id="Frame_InventoryHotbar"><frame id="Frame_HotbarItems">{{{ItemsModels}}}</frame></frame>

<script><!--
/**
 *	{{{C_LibInventory_UILayerID}}}
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_CountriesAZERTY ["France", "Belgium"]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_InventoryHotbar <=> (Page.GetFirstChild("Frame_InventoryHotbar") as CMlFrame);
declare Frame_HotbarItems <=> (Page.GetFirstChild("Frame_HotbarItems") as CMlFrame);

/// Load inventory items frames
declare CMlFrame[] Frame_InventoryItems;
for (I, 0, {{{C_LibInventory_UINbItemsDisplayed - 1}}})
	Frame_InventoryItems.add((Page.GetFirstChild("Frame_InventoryItem#"^I) as CMlFrame));

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibInventory_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibInventory_Settings for Teams[0];
declare netread Text Net_LibInventory_IconsPathPrefix for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayHotbar = True;
declare IsHotbarVisible = False;
declare UpdateHotbarItems = True;

// Update
declare PrevSettingsUpdate = -1;
declare PrevIsHotbarVisible = False;
declare PrevInterfaceColor = -1.;
declare PrevGUIPlayerLogin = "";
declare PrevPlayerUpdateTime = -1;

// Hotbar frame properties
Frame_InventoryHotbar.RelativePosition_V3 = <{{{C_LibInventory_UIHotbarPosition.X^", "^C_LibInventory_UIHotbarPosition.Y}}}>;
Frame_InventoryHotbar.ZIndex = {{{C_LibInventory_UIHotbarPosition.Z}}};
Frame_InventoryHotbar.RelativeScale = {{{C_LibInventory_UIHotbarScale}}};
Frame_InventoryHotbar.RelativeRotation =  {{{C_LibInventory_UIHotbarRotation}}};
declare HotbarItemSize = {{{C_LibInventory_UIHotbarItemSize}}};
declare HotbarHorizontalAlign = "{{{C_LibInventory_UIHotbarHAlign}}}";
declare HotbarVerticalAlign = "{{{C_LibInventory_UIHotbarVAlign}}}";
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibInventory_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibInventory_SettingsUpdate;
	foreach (SettingName => SettingValue in Net_LibInventory_Settings) {
		switch (SettingName) {
			// ---------------------------------- //
			// Set hotbar visibility
			case "DisplayHotbar" : DisplayHotbar = SettingValue == "True";
			
			// ---------------------------------- //
			// Change hotbar properties
			case "FormatInterfaceHotbar" : {
				// <0., 1., 2.>, <3., 4.>, 5., 6., "7", "8"
				declare Params = TL::Split(" ", SettingValue);
				if (Params.count == 9) {
					Frame_InventoryHotbar.RelativePosition_V3 = <TL::ToReal(Params[0]), TL::ToReal(Params[1])>;
					Frame_InventoryHotbar.ZIndex = TL::ToReal(Params[2]);
					Frame_InventoryHotbar.RelativeScale = TL::ToReal(Params[5]);
					Frame_InventoryHotbar.RelativeRotation = TL::ToReal(Params[6]);

					HotbarItemSize = <TL::ToReal(Params[3]), TL::ToReal(Params[4])>;
					HotbarHorizontalAlign = Params[7];
					HotbarVerticalAlign = Params[8];
					UpdateHotbarItems = True;
				}
			}
			// ---------------------------------- //
			// Format item amount label
			case "FormatLabelAmount" : {
				foreach (Frame in Frame_InventoryItems) FormatControl(Frame.GetFirstChild("Label_ItemAmount"), SettingValue);
			}
			// ---------------------------------- //
			// Format item hotkey label
			case "FormatLabelHotkey" : {
				foreach (Frame in Frame_InventoryItems) FormatControl(Frame.GetFirstChild("Label_ItemHotkey"), SettingValue);
			}
			// ---------------------------------- //
			// Format item background quad
			case "FormatQuadBackground" : {
				foreach (Frame in Frame_InventoryItems) FormatControl(Frame.GetFirstChild("Quad_ItemBackground"), SettingValue);
			}
			// ---------------------------------- //
			// Format item current weapon quad
			case "FormatQuadHighlight" : {
				foreach (Frame in Frame_InventoryItems) FormatControl(Frame.GetFirstChild("Quad_ItemIsCurWeapon"), SettingValue);
			}
			// ---------------------------------- //
			// Format item cooldown label
			case "FormatLabelCooldown" : {
				foreach (Frame in Frame_InventoryItems) FormatControl(Frame.GetFirstChild("Label_ItemCooldown"), SettingValue);
			}
		}
	}
}

// ---------------------------------- //
// Update the inventory hotbar visibility
IsHotbarVisible = DisplayHotbar && GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && GameTime >= GUIPlayer.StartTime - 1500;

if (PrevIsHotbarVisible != IsHotbarVisible) {
	PrevIsHotbarVisible = IsHotbarVisible;
	
	declare Opacity = 0.;
	declare Easing = CAnimManager::EAnimManagerEasing::SineIn;
	
	if (IsHotbarVisible) {
		Opacity = 1.;
		Easing = CAnimManager::EAnimManagerEasing::SineOut;
	}

	// ---------------------------------- //
	// Animate controls
	foreach (Frame in Frame_InventoryItems) foreach (Control in Frame.Controls) AnimMgr.Add(Control, "<quad opacity='"^Opacity^"' />", 250, Easing);
}

// Continue if the hotbar is not visible
if (!IsHotbarVisible) continue;

// ---------------------------------- //
// Update hotbar color on player color change
if (PrevInterfaceColor != GUIPlayer.GetLinearHue) {
	PrevInterfaceColor = GUIPlayer.GetLinearHue;

	declare Color = HsvToRgb(<GUIPlayer.GetLinearHue, 1., 1.>);
	foreach (I => Frame in Frame_InventoryItems) {
		declare Quads = [
			(Frame.GetFirstChild("Quad_ItemIsCurWeapon") as CMlQuad),
			(Frame.GetFirstChild("Quad_ItemBackground") as CMlQuad),
			(Frame.GetFirstChild("Quad_ItemIcon") as CMlQuad)
		];
		foreach (Quad in Quads) Quad.Colorize = Color;
	}
}

// ---------------------------------- //
// Trigger hotbar items update on player change
if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
	PrevGUIPlayerLogin = GUIPlayer.User.Login;
	UpdateHotbarItems = True;
}

// ---------------------------------- //
// Trigger hotbar items update on mode update
declare netread Integer Net_LibInventory_PlayerUpdate for GUIPlayer;

if (PrevPlayerUpdateTime != Net_LibInventory_PlayerUpdate) {
	PrevPlayerUpdateTime = Net_LibInventory_PlayerUpdate;
	UpdateHotbarItems = True;
}

// ---------------------------------- //
// Update the hotbar items
if (UpdateHotbarItems) {
	UpdateHotbarItems = False;

	// ---------------------------------- //
	// Get infrmation about the current player's items
	declare netread Text[] Net_LibInventory_PlayerItems for GUIPlayer;
	declare netread Text[Text] Net_LibInventory_PlayerItemIcon for GUIPlayer;
	declare netread Text[Text] Net_LibInventory_PlayerItemHotkey for GUIPlayer;
	declare netread Integer[Text] Net_LibInventory_PlayerItemAmount for GUIPlayer;
	declare netread Integer[Text] Net_LibInventory_PlayerItemWeaponNum for GUIPlayer;
	declare netread Integer[Text] Net_LibInventory_PlayerItemCooldownStart for GUIPlayer;
	declare netread Integer[Text] Net_LibInventory_PlayerItemCooldownDuration for GUIPlayer;
	declare netread Text[] Net_LibInventory_PlayerActiveItems for GUIPlayer;

	// ---------------------------------- //
	// Configure items slots
	foreach (I => Frame in Frame_InventoryItems) {
		Frame.Visible = Net_LibInventory_PlayerItems.existskey(I);
		if (!Frame.Visible) continue;
		declare CurItemId = Net_LibInventory_PlayerItems[I];

		// Set the frame position
		Frame.RelativePosition_V3.X = I * HotbarItemSize.X;

		// ---------------------------------- //
		// Load frame elements
		declare Label_ItemAmount <=> (Frame.GetFirstChild("Label_ItemAmount") as CMlLabel);
		declare Label_ItemHotkey <=> (Frame.GetFirstChild("Label_ItemHotkey") as CMlLabel);
		declare Quad_ItemIcon <=> (Frame.GetFirstChild("Quad_ItemIcon") as CMlQuad);

		// ---------------------------------- //
		// Set current item icon image
		declare CurItemIconPath = "";
		if (Net_LibInventory_PlayerItemIcon.existskey(CurItemId)) CurItemIconPath = Net_LibInventory_PlayerItemIcon[CurItemId];
		Quad_ItemIcon.ImageUrl = Net_LibInventory_IconsPathPrefix^CurItemIconPath;

		// ---------------------------------- //
		// Set current item hotkey label
		declare CurItemHotkey = "";
		if (Net_LibInventory_PlayerItemHotkey.existskey(CurItemId)) CurItemHotkey = Net_LibInventory_PlayerItemHotkey[CurItemId];

		// Special layouts check
		if (CurItemHotkey == "Q") {
			declare ExplodePath = TL::Split("|", LocalUser.ZonePath);
			declare Country = "";
			if (ExplodePath.existskey(2)) Country = ExplodePath[2];

			if (LocalUser.Language == "fr" || C_CountriesAZERTY.exists(Country)) CurItemHotkey = "A"; ///< AZERTY
			if (Country == "Lithuania") CurItemHotkey = "Ą"; ///< ĄŹERTY
		}

		// Set hotkey name
		Label_ItemHotkey.Value = TL::ToUpperCase(CurItemHotkey);

		// ---------------------------------- //
		// Set current item amount
		declare CurItemAmount = -1;
		if (Net_LibInventory_PlayerItemAmount.existskey(CurItemId)) CurItemAmount = Net_LibInventory_PlayerItemAmount[CurItemId];
		Label_ItemAmount.Visible = CurItemAmount >= 0;

		if (Label_ItemAmount.Visible) {
			Label_ItemAmount.Value = TL::ToText(CurItemAmount);
			if (CurItemAmount > 0) Label_ItemAmount.TextColor = {{{C_LibInventory_UIItemColorDefault}}};
			else Label_ItemAmount.TextColor = {{{C_LibInventory_UIItemColorEmpty}}};
		}

		// ---------------------------------- //
		// Save the item attributes in the frame
		declare Integer FrameItemAmount for Frame;
		declare Integer FrameItemWeaponNum for Frame;
		declare Integer FrameItemCooldownStart for Frame;
		declare Integer FrameItemCooldownDuration for Frame;
		declare Boolean FrameItemIsActive for Frame;

		FrameItemAmount = CurItemAmount;
		FrameItemWeaponNum = -1;
		FrameItemCooldownStart = -1;
		FrameItemCooldownDuration = 0;
		FrameItemIsActive = Net_LibInventory_PlayerActiveItems.exists(CurItemId);

		if (Net_LibInventory_PlayerItemWeaponNum.existskey(CurItemId)) FrameItemWeaponNum = Net_LibInventory_PlayerItemWeaponNum[CurItemId];
		if (Net_LibInventory_PlayerItemCooldownStart.existskey(CurItemId)) FrameItemCooldownStart = Net_LibInventory_PlayerItemCooldownStart[CurItemId];
		if (Net_LibInventory_PlayerItemCooldownDuration.existskey(CurItemId)) FrameItemCooldownDuration = Net_LibInventory_PlayerItemCooldownDuration[CurItemId];

		// Trigger amount update
		declare Integer PrevFrameItemAmount for Frame;
		PrevFrameItemAmount = -2;
	}

	// ---------------------------------- //
	// Calculate the hotbar size depending on displayed items count
	declare HotbarSize = <ML::Min(Net_LibInventory_PlayerItems.count, Frame_InventoryItems.count) * HotbarItemSize.X, HotbarItemSize.Y>;
	
	// Get the horizontal position of the items
	declare Position = <0., 0.>;
	switch (HotbarHorizontalAlign) {
		case "left"		: Position.X = HotbarItemSize.X / 2;
		case "center"	: Position.X = -(HotbarSize.X - HotbarItemSize.X) / 2;
		case "right"	: Position.X = -HotbarSize.X + HotbarItemSize.X / 2;
	}
	
	// Get the vertical position of the items
	switch (HotbarVerticalAlign) {
		case "top"		: Position.Y = -HotbarItemSize.Y / 2;
		case "bottom"	: Position.Y = HotbarItemSize.Y / 2;
	}
	
	// Set the items position
	Frame_HotbarItems.RelativePosition_V3 = Position;
}

// ---------------------------------- //
// Manage additional functions of items cards
foreach (I => Frame in Frame_InventoryItems) {
	if (!Frame.Visible) continue;

	// ---------------------------------- //
	// Data of the frame's item
	declare Integer FrameItemAmount for Frame;
	declare Integer FrameItemWeaponNum for Frame;
	declare Integer FrameItemCooldownStart for Frame;
	declare Integer FrameItemCooldownDuration for Frame;
	declare Boolean FrameItemIsActive for Frame;

	// Update
	declare PrevFrameItemIsCurWeapon for Frame = False;
	declare PrevFrameItemAmount for Frame = -2;
	declare PrevFrameItemIsCooling for Frame = False;

	// Check if the item is currently equipped weapon
	declare IsEquippedWeapon = FrameItemWeaponNum > 0 && FrameItemWeaponNum == GUIPlayer.CurWeapon || FrameItemIsActive;

	// ---------------------------------- //
	// On item weapon state change
	if (PrevFrameItemIsCurWeapon != IsEquippedWeapon) {
		PrevFrameItemIsCurWeapon = IsEquippedWeapon;

		declare Quad_ItemIsCurWeapon <=> (Frame.GetFirstChild("Quad_ItemIsCurWeapon") as CMlQuad);
		Quad_ItemIsCurWeapon.Visible = IsEquippedWeapon;
	}

	// Check if the current item is cooling down
	declare ItemIsCooling = FrameItemCooldownStart > 0 && GameTime < FrameItemCooldownStart + FrameItemCooldownDuration;

	// ---------------------------------- //
	// On item amount or cooling state change
	if (PrevFrameItemAmount != FrameItemAmount || PrevFrameItemIsCooling != ItemIsCooling) {
		PrevFrameItemAmount = FrameItemAmount;
		PrevFrameItemIsCooling = ItemIsCooling;

		// Get color depending on the item state
		declare ModulatedColor = {{{C_LibInventory_UIItemColorDefault}}};
		if (ItemIsCooling) ModulatedColor = {{{C_LibInventory_UIItemColorCooldown}}};
		else if (FrameItemAmount == 0) ModulatedColor = {{{C_LibInventory_UIItemColorEmpty}}};
		
		// Apply the color to the item icon
		declare Quad_ItemIcon <=> (Frame.GetFirstChild("Quad_ItemIcon") as CMlQuad);
		Quad_ItemIcon.ModulateColor = ModulatedColor;

		// Cooling label visibility
		declare Label_ItemCooldown <=> (Frame.GetFirstChild("Label_ItemCooldown") as CMlLabel);
		Label_ItemCooldown.Visible = ItemIsCooling;
	}

	// ---------------------------------- //
	// Set the cooldown label text
	if (ItemIsCooling) {
		declare Label_ItemCooldown <=> (Frame.GetFirstChild("Label_ItemCooldown") as CMlLabel);
		Label_ItemCooldown.Value = TL::ToText((FrameItemCooldownStart + FrameItemCooldownDuration - GameTime) / 1000 + 1);
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Format control with formatting saved in an XML tag.
 *
 *	@param	_Control	Control to change format.
 *	@param	_Format		XML tag containing control format.
 */
Void FormatControl(CMlControl _Control, Text _Format) {
	if (_Control == Null || _Format == "") return;
	
	// ---------------------------------- //
	// Create document containing format data
	declare XMLDocument = Xml.Create(_Format);
	if (XMLDocument == Null) return;
	if (XMLDocument.Root == Null) {
		Xml.Destroy(XMLDocument);
		return;
	}
	
	// ---------------------------------- //
	// Scale
	declare Scale = XMLDocument.Root.GetAttributeReal("scale", -1.);
	if (Scale != -1) _Control.RelativeScale = Scale;
	
	// ---------------------------------- //
	// Rotation
	declare Rotation = XMLDocument.Root.GetAttributeReal("rot", -1.);
	if (Rotation != -1) _Control.RelativeRotation = Rotation;
	
	// ---------------------------------- //
	// Position
	declare PositionText = TL::Split(" ", XMLDocument.Root.GetAttributeText("pos", ""));
	if (PositionText.count > 0) for (I, 0, 1) if (PositionText.existskey(I)) _Control.RelativePosition_V3[I] = TL::ToReal(PositionText[I]);
	
	// ---------------------------------- //
	// Size
	declare SizeText = TL::Split(" ", XMLDocument.Root.GetAttributeText("size", ""));
	if (SizeText.count > 0) for (I, 0, 1) if (SizeText.existskey(I)) _Control.Size[I] = TL::ToReal(SizeText[I]);
	
	// ---------------------------------- //
	// Horizontal align
	declare HorizontalAlign = XMLDocument.Root.GetAttributeText("halign", "");
	declare HAlign = CMlControl::AlignHorizontal::None;
	switch (HorizontalAlign) {
		case "left"		: HAlign = CMlControl::AlignHorizontal::Left;
		case "center"	: HAlign = CMlControl::AlignHorizontal::HCenter;
		case "right"	: HAlign = CMlControl::AlignHorizontal::Right;
	}
	if (HAlign != CMlControl::AlignHorizontal::None) _Control.HorizontalAlign = HAlign;
	
	// ---------------------------------- //
	// Vertical align
	declare VerticalAlign = XMLDocument.Root.GetAttributeText("valign", "");
	declare VAlign = CMlControl::AlignVertical::None;
	switch (VerticalAlign) {
		case "top"		: VAlign = CMlControl::AlignVertical::Top;
		case "center"	: VAlign = CMlControl::AlignVertical::VCenter;
		case "center2"	: VAlign = CMlControl::AlignVertical::VCenter2;
		case "bottom"	: VAlign = CMlControl::AlignVertical::Bottom;
	}
	if (VAlign != CMlControl::AlignVertical::None) _Control.VerticalAlign = VAlign;
	
	// ---------------------------------- //
	// Element specific attributes
	switchtype (_Control) {
		// ---------------------------------- //
		// Label
		case CMlLabel : {
			declare _Label = (_Control as CMlLabel);
			
			// ---------------------------------- //
			// Text size
			declare TextSize = XMLDocument.Root.GetAttributeReal("textsize", -1.);
			if (TextSize != -1) _Label.TextSizeReal = TextSize;
			
			// ---------------------------------- //
			// Text color
			declare TextColor = XMLDocument.Root.GetAttributeText("textcolor", "");
			if (TextColor != "") _Label.TextColor = TL::ToColor(TextColor);
			
			// ---------------------------------- //
			// Style
			declare Style = XMLDocument.Root.GetAttributeText("style", "");
			if (Style != "") _Label.Style = Style;
			
			// ---------------------------------- //
			// Text font
			declare TextFont = XMLDocument.Root.GetAttributeText("textfont", "");
			if (TextFont != "") _Label.TextFont = TextFont;
		}
		// ---------------------------------- //
		// Quad
		case CMlQuad : {
			declare _Quad = (_Control as CMlQuad);
			
			// ---------------------------------- //
			// Style
			declare Style = XMLDocument.Root.GetAttributeText("style", "");
			if (Style != "") _Quad.Style = Style;
			
			// ---------------------------------- //
			// Substyle
			declare Substyle = XMLDocument.Root.GetAttributeText("substyle", "");
			if (Substyle != "") _Quad.Substyle = Substyle;
			
			// ---------------------------------- //
			// ImageUrl
			declare ImageUrl = XMLDocument.Root.GetAttributeText("image", "");
			if (ImageUrl != "") _Quad.ImageUrl = ImageUrl;
			
			// ---------------------------------- //
			// Colorize
			declare Colorize = XMLDocument.Root.GetAttributeText("colorize", "");
			if (Colorize != "") _Quad.Colorize = TL::ToColor(Colorize);
		}
	}
	
	// Destroy document
	Xml.Destroy(XMLDocument);
}

{{{ManialinkTools::Functions(["HsvToRgb"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		yield;
		+++Yield+++
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Update the settings of the interface.
 *
 *	@param	_Name	The name of the setting.
 *	@param	_Value	The value of the setting.
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibInventory_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInventory_Settings for Teams[0] = Text[Text];
	Net_LibInventory_SettingsUpdate = Now;
	Net_LibInventory_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Update the net variables of a player and trigger hotbar update for them.
 *
 *	@param	_Player		The player to update interface.
 */
Void Private_UpdatePlayerUI(CSmPlayer _Player) {
	if (_Player == Null || _Player.IsBot) return;
	
	// ---------------------------------- //
	// Load all stored data about player items
	declare Text[] LibInventory_PlayerItems for _Player;
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	declare Text[Text] LibInventory_PlayerItemIcon for _Player;
	declare Integer[Text] LibInventory_PlayerItemAmount for _Player;
	declare Integer[Text] LibInventory_PlayerItemWeaponNum for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownStart for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownDuration for _Player;
	declare Text[] LibInventory_PlayerActiveItems for _Player;
	
	// ---------------------------------- //
	// Create net variables
	declare netwrite Text[] Net_LibInventory_PlayerItems for _Player;
	declare netwrite Text[Text] Net_LibInventory_PlayerItemHotkey for _Player;
	declare netwrite Text[Text] Net_LibInventory_PlayerItemIcon for _Player;
	declare netwrite Integer[Text] Net_LibInventory_PlayerItemAmount for _Player;
	declare netwrite Integer[Text] Net_LibInventory_PlayerItemWeaponNum for _Player;
	declare netwrite Integer[Text] Net_LibInventory_PlayerItemCooldownStart for _Player;
	declare netwrite Integer[Text] Net_LibInventory_PlayerItemCooldownDuration for _Player;
	declare netwrite Text[] Net_LibInventory_PlayerActiveItems for _Player;
	
	// ---------------------------------- //
	// Update player net data
	declare Text[Text] Hotkeys;
	foreach (ItemName => Hotkey in LibInventory_PlayerItemHotkey)
		Hotkeys[ItemName] = C_LibInventory_GetHotkeyText[Hotkey];
	
	Net_LibInventory_PlayerItems = LibInventory_PlayerItems;
	Net_LibInventory_PlayerItemHotkey = Hotkeys;
	Net_LibInventory_PlayerItemIcon = LibInventory_PlayerItemIcon;
	Net_LibInventory_PlayerItemAmount = LibInventory_PlayerItemAmount;
	Net_LibInventory_PlayerItemWeaponNum = LibInventory_PlayerItemWeaponNum;
	Net_LibInventory_PlayerItemCooldownStart = LibInventory_PlayerItemCooldownStart;
	Net_LibInventory_PlayerItemCooldownDuration = LibInventory_PlayerItemCooldownDuration;
	Net_LibInventory_PlayerActiveItems = LibInventory_PlayerActiveItems;
	
	// Trigger hotbar update in the player's interface
	declare netwrite Integer Net_LibInventory_PlayerUpdate for _Player;
	Net_LibInventory_PlayerUpdate = Now;
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Reorganize player's inventory items according to provided order.
 *
 *	@param	_Player			The player to reorganize inventory.
 *	@param	_ItemsOrder		Target order of the inventory items.
 */
Void SetItemsOrder(CSmPlayer _Player, Text[] _ItemsOrder) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemsOrder.count <= 0) return;
	declare Text[] LibInventory_PlayerItems for _Player;
	
	// Backup items names and clear items list
	declare RemainingItems = LibInventory_PlayerItems;
	LibInventory_PlayerItems.clear();
	
	// ---------------------------------- //
	// Sort items by provided order
	foreach (ItemName in _ItemsOrder) {
		if (!RemainingItems.exists(ItemName)) continue;
		LibInventory_PlayerItems.add(ItemName);
		declare Removed = RemainingItems.remove(ItemName);
	}
	
	// Add items that were omitted in target order
	if (RemainingItems.count > 0) {
		RemainingItems = RemainingItems.sort();
		foreach (ItemName in RemainingItems) LibInventory_PlayerItems.add(ItemName);
	}
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Automatically organize interface items by their hotkeys
 *
 *	@param	_Player		The player to organize inventory items.
 */
Void Organize(CSmPlayer _Player) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;
	declare Text[] LibInventory_PlayerItems for _Player;

	// ---------------------------------- //
	// Sort items with predefined order
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	declare Text[] TargetOrder;
	
	foreach (ActionInput in C_LibInventory_OrganizedOrder) {
		if (!LibInventory_PlayerItemHotkey.exists(ActionInput)) continue;
		
		foreach (ItemName in LibInventory_PlayerItems) {
			if (!LibInventory_PlayerItemHotkey.existskey(ItemName) || LibInventory_PlayerItemHotkey[ItemName] != ActionInput ||	TargetOrder.exists(ItemName)) continue;
			TargetOrder.add(ItemName);
		}
	}
	
	// Add remaining items if they somehow weren't added before
	if (TargetOrder.count != LibInventory_PlayerItems.count)
		foreach (ItemName in LibInventory_PlayerItems) if (!TargetOrder.exists(ItemName)) TargetOrder.add(ItemName);
	
	// Set new order (Illuminati /o\)
	SetItemsOrder(_Player, TargetOrder);
}

// ---------------------------------- //
/** Check if the given item exists in the player's inventory.
 *
 *	@param	_Player		The player to check if they've got the item.
 *	@param	_ItemName	Name of the item to check.
 *
 *	@return		True, if player has specified item in their inventory.
 */
Boolean ItemExists(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return False;
	declare Text[] LibInventory_PlayerItems for _Player;
	return LibInventory_PlayerItems.exists(_ItemName);
}

// ---------------------------------- //
/** Create a new item slot for the player, if doesn't exist yet.
 *
 *	@param	_Player		The player who the slot will be created for.
 *	@param	_ItemName	Name of the new item.
 *	@param	_Hotkey		Action key activating the item (cosmetic only).
 *	@param	_Amount		Initial amount of the item in player's inventory.
 *	@param	_IconImage	Path to the item icon image displayed in the hotbar.
 *	@param	_WeaponNum	item weapon number, used to highlight item if it's the currently equipped weapon.
 */
Void CreateItemSlot(CSmPlayer _Player, Text _ItemName, CSmModeEvent::EActionInput _Hotkey, Integer _Amount, Text _IconImage, Integer _WeaponNum) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (ItemExists(_Player, _ItemName)) return;
	
	// Create slot
	declare Text[] LibInventory_PlayerItems for _Player;
	LibInventory_PlayerItems.add(_ItemName);
	
	// ---------------------------------- //
	// Set item properties
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	declare Text[Text]		LibInventory_PlayerItemIcon for _Player;
	declare Integer[Text]	LibInventory_PlayerItemAmount for _Player;
	declare Integer[Text]	LibInventory_PlayerItemWeaponNum for _Player;
	
	LibInventory_PlayerItemHotkey		[_ItemName] = _Hotkey;
	LibInventory_PlayerItemIcon			[_ItemName] = _IconImage;
	LibInventory_PlayerItemAmount		[_ItemName] = ML::Max(-1, _Amount);
	LibInventory_PlayerItemWeaponNum	[_ItemName] = _WeaponNum;
	
	// Organize player inventory
	Organize(_Player);
}

// ---------------------------------- //
/** Create a new item slot for the player, if doesn't exist yet.
 *
 *	@param	_Player		The player who the slot will be created for.
 *	@param	_ItemName	Name of the new item.
 *	@param	_Hotkey		Action key activating the item (cosmetic only).
 *	@param	_Amount		Initial amount of the item in player's inventory.
 *	@param	_IconImage	Path to the item icon image displayed in the hotbar.
 */
Void CreateItemSlot(CSmPlayer _Player, Text _ItemName, CSmModeEvent::EActionInput _Hotkey, Integer _Amount, Text _IconImage) {
	CreateItemSlot(_Player, _ItemName, _Hotkey, _Amount, _IconImage, -1);
}

// ---------------------------------- //
/** Create a new item slot for the player, if doesn't exist yet.
 *
 *	@param	_Player		The player who the slot will be created for.
 *	@param	_ItemName	Name of the new item.
 *	@param	_Amount		Initial amount of the item in player's inventory.
 *	@param	_IconImage	Path to the item icon image displayed in the hotbar.
 */
Void CreateItemSlot(CSmPlayer _Player, Text _ItemName, Integer _Amount, Text _IconImage) {
	CreateItemSlot(_Player, _ItemName, CSmModeEvent::EActionInput::None, _Amount, _IconImage, -1);
}

// ---------------------------------- //
/** Destroy an item slot of a player.
 *
 *	@param	_Player		The player whose item slot will be destroyed.
 *	@param	_ItemName	Name of the item to destroy.
 */
Void DestroyItemSlot(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	declare Text[] LibInventory_PlayerItems for _Player;
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	declare Text[Text] LibInventory_PlayerItemIcon for _Player;
	declare Integer[Text] LibInventory_PlayerItemAmount for _Player;
	declare Integer[Text] LibInventory_PlayerItemWeaponNum for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownStart for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownDuration for _Player;
	declare Text[] LibInventory_PlayerActiveItems for _Player;

	// ---------------------------------- //
	// Completely remove the item from a player's inventory.
	declare Boolean Removed;
	Removed = LibInventory_PlayerItems.remove(_ItemName);
	Removed = LibInventory_PlayerItemHotkey.removekey(_ItemName);
	Removed = LibInventory_PlayerItemIcon.removekey(_ItemName);
	Removed = LibInventory_PlayerItemAmount.removekey(_ItemName);
	Removed = LibInventory_PlayerItemWeaponNum.removekey(_ItemName);
	Removed = LibInventory_PlayerItemCooldownStart.removekey(_ItemName);
	Removed = LibInventory_PlayerItemCooldownDuration.removekey(_ItemName);
	Removed = LibInventory_PlayerActiveItems.remove(_ItemName);
	
	// Organize player inventory
	Organize(_Player);
}

// ---------------------------------- //
/** Change action key of an item slot for a player (cosmetic only).
 *
 *	@param	_Player		The player to change given item hotkey.
 *	@param	_ItemName	Name of the item to set new hotkey.
 *	@param	_Hotkey		The new hotkey of the item.
 */
Void ChangeSlotHotkey(CSmPlayer _Player, Text _ItemName, CSmModeEvent::EActionInput _Hotkey) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	LibInventory_PlayerItemHotkey[_ItemName] = _Hotkey;
	
	// Organize player inventory
	Organize(_Player);
}

// ---------------------------------- //
/** Change icon image of an item for a player.
 *
 *	@param	_Player		The player, whose item icon will be changed.
 *	@param	_ItemName	Name of the item that will get its icon changed.
 *	@param	_IconImage	New image of the item icon.
 */
Void ChangeSlotIcon(CSmPlayer _Player, Text _ItemName, Text _IconImage) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	declare Text[Text] LibInventory_PlayerItemIcon for _Player;
	LibInventory_PlayerItemIcon[_ItemName] = _IconImage;
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Change the weapon number of an item for a player.
 *
 *	@param	_Player		The player to change their item weapon number.
 *	@param	_ItemName	Name of the item to set new weapon number.
 *	@param	_WeaponNum	New weapon number of the given item.
 */
Void ChangeSlotWeaponNum(CSmPlayer _Player, Text _ItemName, Integer _WeaponNum) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	declare Integer[Text] LibInventory_PlayerItemWeaponNum for _Player;
	LibInventory_PlayerItemWeaponNum[_ItemName] = _WeaponNum;
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Set the amount of specific item in player's inventory.
 *
 *	@param	_Player		The player to set their item amount.
 *	@param	_ItemName	Item, which amount will be changed (-1 for infinite).
 *	@param	_Amount		Amount of the given item.
 */
Void SetItemAmount(CSmPlayer _Player, Text _ItemName, Integer _Amount) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	// Set the item amount
	declare Integer[Text] LibInventory_PlayerItemAmount for _Player;
	LibInventory_PlayerItemAmount[_ItemName] = ML::Max(-1, _Amount);
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Get the amount of specific item in player's inventory.
 *
 *	@param	_Player		The player to get item amount.
 *	@param	_ItemName	Name of the item to get its amount.
 *
 *	@return		Amount of the specific item.
 */
Integer GetItemAmount(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return -1;
	if (!ItemExists(_Player, _ItemName)) return -1;
	
	// Get the item amount
	declare Integer[Text] LibInventory_PlayerItemAmount for _Player;
	if (LibInventory_PlayerItemAmount.existskey(_ItemName)) return ML::Max(-1, LibInventory_PlayerItemAmount[_ItemName]);
	return -1;
}

// ---------------------------------- //
/** Get the action key of an item slot.
 *
 *	@param	_Player		The player to get the given item hotkey.
 *	@param	_ItemName	Name of the item to get hotkey.
 *
 *	@return		The hotkey of the item slot.
 */
CSmModeEvent::EActionInput GetSlotHotkey(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return CSmModeEvent::EActionInput::None;
	if (!ItemExists(_Player, _ItemName)) return CSmModeEvent::EActionInput::None;
	
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	if (!LibInventory_PlayerItemHotkey.existskey(_ItemName)) return CSmModeEvent::EActionInput::None;
	return LibInventory_PlayerItemHotkey[_ItemName];
}

// ---------------------------------- //
/** Give the player specific items.
 *
 *	@param	_Player		The player to give items.
 *	@param	_ItemName	Name of the item to give.
 *	@param	_Amount		Amount of items to give.
 */
Void AddItems(CSmPlayer _Player, Text _ItemName, Integer _Amount) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "" || _Amount == 0) return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	if (GetItemAmount(_Player, _ItemName) < 0) return;
	
	// Set the item amount
	declare ItemAmount = GetItemAmount(_Player, _ItemName);
	ItemAmount += _Amount;
	SetItemAmount(_Player, _ItemName, ML::Max(0, ItemAmount));
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Remove specific item from the player.
 *
 *	@param	_Player		The player to remove items.
 *	@param	_ItemName	Name of the item to remove.
 *	@param	_Amount		Amount of items to remove.
 */
Void RemoveItems(CSmPlayer _Player, Text _ItemName, Integer _Amount) {
	AddItems(_Player, _ItemName, -_Amount);
}

// ---------------------------------- //
/** Set the cooldown on a specific item in a player's inventory.
 *
 *	@param	_Player				The player to set item cooldown.
 *	@param	_ItemName			Name of the item to set cooldown.
 *	@param	_CooldownStart		Time of the cooldown start.
 *	@param	_CooldownDuration	Duration of the cooldown.
 */
Void SetItemCooldown(CSmPlayer _Player, Text _ItemName, Integer _CooldownStart, Integer _CooldownDuration) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "" || _CooldownDuration <= 0) return;
	if (!ItemExists(_Player, _ItemName)) return;
	
	// Set the cooldown duration
	declare Integer[Text] LibInventory_PlayerItemCooldownStart for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownDuration for _Player;
	LibInventory_PlayerItemCooldownStart	[_ItemName] = ML::Max(-1, _CooldownStart);
	LibInventory_PlayerItemCooldownDuration	[_ItemName] = ML::Max(0, _CooldownDuration);
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Set the item's activity state.
 *
 *	@param	_Player		The player to set item activity state.
 *	@param	_ItemName	Name of the item to set activity state.
 *	@param	_IsActive	If True, the item will be seen as active.
 */
Void SetItemIsActive(CSmPlayer _Player, Text _ItemName, Boolean _IsActive) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return;
	if (!ItemExists(_Player, _ItemName)) return;

	declare Text[] LibInventory_PlayerActiveItems for _Player;
	if (_IsActive) {
		if (!LibInventory_PlayerActiveItems.exists(_ItemName)) LibInventory_PlayerActiveItems.add(_ItemName);
	} else if (LibInventory_PlayerActiveItems.exists(_ItemName)) {
		declare Removed = LibInventory_PlayerActiveItems.remove(_ItemName);
	}
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Set the only active item in a player's inventory.
 *
 *	@param	_Player		The player to set active item.
 *	@param	_ItemName	Name of the only active item in the inventory.
 */
Void SetActiveItem(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;

	declare Text[] LibInventory_PlayerActiveItems for _Player;
	if (ItemExists(_Player, _ItemName)) LibInventory_PlayerActiveItems = [_ItemName];
	else LibInventory_PlayerActiveItems.clear();
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Check if item can be used again after cooling down.
 *
 *	@param	_Player		The player to check if the item ha scooled down.
 *	@param	_ItemName	Name of the item to check.
 *
 *	@return		True, if the item is ready to use.
 */
Boolean CooldownIsReady(CSmPlayer _Player, Text _ItemName) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return False;
	if (!ItemExists(_Player, _ItemName)) return False;
	
	// Check the cooldown duration
	declare Integer[Text] LibInventory_PlayerItemCooldownStart for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownDuration for _Player;
	
	// Return True, if the item has no cooldown set
	if (!LibInventory_PlayerItemCooldownStart.existskey(_ItemName) || !LibInventory_PlayerItemCooldownDuration.existskey(_ItemName)) return True;
	
	// Return False, if the item is cooling down
	if (Now < LibInventory_PlayerItemCooldownStart[_ItemName] + LibInventory_PlayerItemCooldownDuration[_ItemName]) return False;
	
	// The item is ready to use
	return True;
}

// ---------------------------------- //
/** Use an item from a player's inventory.
 *
 *	@param	_Player				The player, who is using an item.
 *	@param	_ItemName			Name of the item to be used.
 *	@param	_Cooldown			Cooldown duration to set after the use.
 *	@param	_DestroyIfEmpty		Destroy item slot if player has used all items.
 *
 *	@return		True, if the item has been successfully used.
 */
Boolean UseItem(CSmPlayer _Player, Text _ItemName, Integer _Cooldown, Boolean _DestroyIfEmpty) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ItemName == "") return False;
	if (!ItemExists(_Player, _ItemName) || GetItemAmount(_Player, _ItemName) == 0 || !CooldownIsReady(_Player, _ItemName)) return False;
	
	RemoveItems(_Player, _ItemName, 1);
	if (_Cooldown > 0) SetItemCooldown(_Player, _ItemName, Now, _Cooldown);
	if (_DestroyIfEmpty && GetItemAmount(_Player, _ItemName) <= 0) DestroyItemSlot(_Player, _ItemName);
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
	
	return True;
}

// ---------------------------------- //
/** Load weapons as items for a player.
 *
 *	@param	_Player		The player to load weapon items.
 *	@param	_Weapons	List of weapons that will be loaded as item for the player.
 */
Void SetAvailableWeapons(CSmPlayer _Player, CSmMode::EWeapon[] _Weapons) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;

	// ---------------------------------- //
	// Remove previously added weapons
	foreach (Weapon in C_LibInventory_Weapons) {
		if (!C_LibInventory_WeaponsPredefinedNames.existskey(Weapon) || _Weapons.exists(Weapon)) continue;
		declare WeaponItemName = C_LibInventory_WeaponsPredefinedNames[Weapon];
		if (ItemExists(_Player, WeaponItemName)) DestroyItemSlot(_Player, WeaponItemName);
	}
	
	// ---------------------------------- //
	// Load weapons as items
	foreach (Weapon in _Weapons) {
		if (!C_LibInventory_WeaponsPredefinedNames.existskey(Weapon)) continue;
		
		// Load default weapon icon
		if (!G_LibInventory_WeaponsIcons.existskey(Weapon))
			G_LibInventory_WeaponsIcons[Weapon] = C_LibInventory_GetWeaponIcon[Weapon];
		
		declare WeaponName = C_LibInventory_WeaponsPredefinedNames[Weapon];
		declare WeaponHotkey = C_LibInventory_GetWeaponHotkey[Weapon];
		declare WeaponIcon = G_LibInventory_WeaponsIcons[Weapon];
		declare WeaponNum = GetWeaponNum(Weapon);
		
		CreateItemSlot(_Player, WeaponName, WeaponHotkey, 0, WeaponIcon, WeaponNum);
		SetPlayerAmmoMax(_Player, Weapon, 0);
	}
}

// ---------------------------------- //
/** Load all weapons as items for a player.
 *
 *	@param	_Player		The player to load all weapons as items.
 */
Void SetAllWeapons(CSmPlayer _Player) {
	SetAvailableWeapons(_Player, C_LibInventory_Weapons);
}

// ---------------------------------- //
/** Check if the player has certain weapon.
 *
 *	@param	_Player		The player to check if has the weapon.
 *	@param	_Weapon		The weapon to check if exists.
 *
 *	@return		True, if the player has certain weapon.
 */
Boolean HasWeapon(CSmPlayer _Player, CSmMode::EWeapon _Weapon) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return False;
	if (!C_LibInventory_WeaponsPredefinedNames.existskey(_Weapon)) return False;
	return ItemExists(_Player, C_LibInventory_WeaponsPredefinedNames[_Weapon]);
}

// ---------------------------------- //
/** Set the amount of slots for specific weapon in player's inventory.
 *
 *	@param	_Player		The player to set weapon slots.
 *	@param	_Weapon		The weapon to set slots amount.
 *	@param	_Amount		Amount of weapon slots to set.
 */
Void SetWeaponSlots(CSmPlayer _Player, CSmMode::EWeapon _Weapon, Integer _Amount) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;
	declare WeaponName = C_LibInventory_WeaponsPredefinedNames[_Weapon];
	if (!ItemExists(_Player, WeaponName)) return;
	
	declare SlotsAmount = ML::Max(0, _Amount);
	SetItemAmount(_Player, WeaponName, SlotsAmount);
	SetPlayerAmmoMax(_Player, _Weapon, SlotsAmount);
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Get amount of specific weapon slots in player's inventory.
 *
 *	@param	_Player		The player to get weapon slots amount.
 *	@param	_Weapon		The weapon to get slots amount.
 *
 *	@return		Amount of the weapon slots of a player.
 */
Integer GetWeaponSlots(CSmPlayer _Player, CSmMode::EWeapon _Weapon) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return 0;
	declare WeaponName = C_LibInventory_WeaponsPredefinedNames[_Weapon];
	if (!ItemExists(_Player, WeaponName)) return 0;
	return GetItemAmount(_Player, WeaponName);
}

// ---------------------------------- //
/** Add slots for a specific weapon in player's inventory.
 *
 *	@param	_Player		The player to add weapon slots.
 *	@param	_Weapon		The weapon to add slots.
 *	@param	_Amount		Amount of weapon slots to add.
 */
Void AddWeaponSlots(CSmPlayer _Player, CSmMode::EWeapon _Weapon, Integer _Amount) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _Amount == 0) return;
	declare WeaponName = C_LibInventory_WeaponsPredefinedNames[_Weapon];
	if (!ItemExists(_Player, WeaponName)) return;
	
	AddItems(_Player, WeaponName, _Amount);
	declare SlotsAmount = GetItemAmount(_Player, WeaponName);
	SetPlayerAmmoMax(_Player, _Weapon, SlotsAmount);
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/** Remove slots of a specific weapon in player's inventory.
 *
 *	@param	_Player		The player to remove weapon slots.
 *	@param	_Weapon		The weapon to remove slots.
 *	@param	_Amount		Amount of weapon slots to remove.
 */
Void RemoveWeaponSlots(CSmPlayer _Player, CSmMode::EWeapon _Weapon, Integer _Amount) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;
	AddWeaponSlots(_Player, _Weapon, -_Amount);
}

// ---------------------------------- //
/** Change action key of a weapon for a player.
 *
 *	@param	_Player		The player to change given weapon hotkey.
 *	@param	_Weapon		The weapon to change hotkey.
 *	@param	_Hotkey		The new hotkey of the weapon.
 */
Void ChangeWeaponHotkey(CSmPlayer _Player, CSmMode::EWeapon _Weapon, CSmModeEvent::EActionInput _Hotkey) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;

	// Get the name of the given weapon's item slot
	declare ItemName = "";
	switch (_Weapon) {
		case CSmMode::EWeapon::Laser	: ItemName = "LInv_WpnLaser";
		case CSmMode::EWeapon::Rocket	: ItemName = "LInv_WpnRocket";
		case CSmMode::EWeapon::Nucleus	: ItemName = "LInv_WpnNucleus";
		case CSmMode::EWeapon::Arrow	: ItemName = "LInv_WpnArrow";
		case CSmMode::EWeapon::Missile	: ItemName = "LInv_WpnMissile";
		default : return; ///< Just in case
	}
	if (!ItemExists(_Player, ItemName)) return;
	
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	LibInventory_PlayerItemHotkey[ItemName] = _Hotkey;
	
	// Organize player inventory
	Organize(_Player);
}

// ---------------------------------- //
/** Select first weapon when spawning, depending on weapons slots amount.
 *	Will set Rocket, if player has no weapons or weapons list includes Rocket.
 *	Otherwise last weapon from the list is selected.
 *
 *	@param	_Player		The player to set first weapon.
 */
Void SetFirstWeapon(CSmPlayer _Player) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;

	// Get previous weapon
	declare PrevWeapon = CSmMode::EWeapon::Rocket;
	if (C_LibInventory_GetWeaponsFromNum.existskey(_Player.CurWeapon))
		PrevWeapon = C_LibInventory_GetWeaponsFromNum[_Player.CurWeapon];
	
	// Previous weapon has ammo
	if (GetWeaponSlots(_Player, PrevWeapon) > 0) {
		SetPlayerWeapon(_Player, PrevWeapon, False);
		return;
	}
	
	// Get all weapons with at least one slot
	declare CSmMode::EWeapon[] PlayerWeapons;
	foreach (Weapon in C_LibInventory_Weapons) if (GetWeaponSlots(_Player, Weapon) > 0) PlayerWeapons.add(Weapon);

	// Select last weapon or set rocket
	declare WeaponToSet = CSmMode::EWeapon::Rocket;
	if (PlayerWeapons.count > 0) WeaponToSet = PlayerWeapons[PlayerWeapons.count - 1];
	if (_Player.AutoSwitchWeapon || _Player.CurWeapon != GetWeaponNum(WeaponToSet))
		SetPlayerWeapon(_Player, WeaponToSet, False);
}

// ---------------------------------- //
/** Switch the player's current weapon on action key press.
 *
 *	@param	_Player			The player who is switching weapon.
 *	@param	_ActionInput	Event pressed action key.
 */
Boolean SwitchWeapon(CSmPlayer _Player, CSmModeEvent::EActionInput _ActionInput) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return False;

	// Check if the player's inventory contains at least one item using the given hotkey
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	if (!LibInventory_PlayerItemHotkey.exists(_ActionInput)) return False;

	// Get the weapon to set
	declare HotkeyItemName = LibInventory_PlayerItemHotkey.keyof(_ActionInput);
	declare CSmMode::EWeapon Weapon;
	switch (HotkeyItemName) {
		case "LInv_WpnLaser"	: Weapon = CSmMode::EWeapon::Laser;
		case "LInv_WpnRocket"	: Weapon = CSmMode::EWeapon::Rocket;
		case "LInv_WpnNucleus"	: Weapon = CSmMode::EWeapon::Nucleus;
		case "LInv_WpnArrow"	: Weapon = CSmMode::EWeapon::Arrow;
		case "LInv_WpnMissile"	: Weapon = CSmMode::EWeapon::Missile;
		default : return False;
	}

	// Set weapon only if it has at least one ammo slot
	if (GetWeaponSlots(_Player, Weapon) <= 0) return False;
	
	SetPlayerWeapon(_Player, Weapon, False);
	return True;
}

// ---------------------------------- //
/** Switch the player's current weapon on mouse roll.
 *
 *	@param	_Player			The player who is scrolling through the weapons.
 *	@param	_ActionChange	Scrolling direction (-1 = down, 1 = up).
 */
Void ScrollWeapons(CSmPlayer _Player, Integer _ActionChange) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot || _ActionChange == 0) return;
	declare ActionChange = ML::Clamp(_ActionChange, -1, 1);
	declare WeaponNumToWeapon = [
		1 => CSmMode::EWeapon::Laser,
		2 => CSmMode::EWeapon::Rocket,
		3 => CSmMode::EWeapon::Nucleus,
		5 => CSmMode::EWeapon::Arrow,
		6 => CSmMode::EWeapon::Missile
	];
	
	// Get player weapons
	declare Text[] LibInventory_PlayerItems for _Player;
	declare CSmMode::EWeapon[] PlayerWeapons;

	foreach (ItemName in LibInventory_PlayerItems) {
		if (!C_LibInventory_WeaponsPredefinedNames.exists(ItemName)) continue;
		declare CSmMode::EWeapon Weapon;
		switch (ItemName) {
			case "LInv_WpnLaser"	: Weapon = CSmMode::EWeapon::Laser;
			case "LInv_WpnRocket"	: Weapon = CSmMode::EWeapon::Rocket;
			case "LInv_WpnNucleus"	: Weapon = CSmMode::EWeapon::Nucleus;
			case "LInv_WpnArrow"	: Weapon = CSmMode::EWeapon::Arrow;
			case "LInv_WpnMissile"	: Weapon = CSmMode::EWeapon::Missile;
			default : continue;
		}
		if (GetWeaponSlots(_Player, Weapon) > 0) PlayerWeapons.add(Weapon);
	}
	if (PlayerWeapons.count <= 1) return;
	
	// ---------------------------------- //
	// Select next weapon
	declare CurrentWeapon = CSmMode::EWeapon::Rocket;
	if (WeaponNumToWeapon.existskey(_Player.CurWeapon)) CurrentWeapon = WeaponNumToWeapon[_Player.CurWeapon];
	declare Key = PlayerWeapons.keyof(CurrentWeapon);
	Key += -_ActionChange;
	if (Key < 0) Key = PlayerWeapons.count - 1;
	if (Key > PlayerWeapons.count - 1) Key = 0;
	CurrentWeapon = PlayerWeapons[Key];
	
	// Set new weapon
	SetPlayerWeapon(_Player, CurrentWeapon, False);
}

// ---------------------------------- //
/** Reset the player's inventory.
 *
 *	@param	_Player		The player to reset their nventory.
 */
Void ResetInventory(CSmPlayer _Player) {
	if (!G_LibInventory_IsLoaded || _Player == Null || _Player.IsBot) return;
	
	declare Text[] LibInventory_PlayerItems for _Player;
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Player;
	declare Text[Text] LibInventory_PlayerItemIcon for _Player;
	declare Integer[Text] LibInventory_PlayerItemAmount for _Player;
	declare Integer[Text] LibInventory_PlayerItemWeaponNum for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownStart for _Player;
	declare Integer[Text] LibInventory_PlayerItemCooldownDuration for _Player;
	declare Text[] LibInventory_PlayerActiveItems for _Player;
	
	LibInventory_PlayerItems.clear();
	LibInventory_PlayerItemHotkey.clear();
	LibInventory_PlayerItemIcon.clear();
	LibInventory_PlayerItemAmount.clear();
	LibInventory_PlayerItemWeaponNum.clear();
	LibInventory_PlayerItemCooldownStart.clear();
	LibInventory_PlayerItemCooldownDuration.clear();
	LibInventory_PlayerActiveItems.clear();
	
	// Update interface
	Private_UpdatePlayerUI(_Player);
}

// ---------------------------------- //
/// Reset inventories of all players.
Void ResetAllInventories() {
	if (!G_LibInventory_IsLoaded) return;
	foreach (Player in AllPlayers) if (!Player.IsBot) ResetInventory(Player);
}

// ---------------------------------- //
/** Reset weapons of a player.
 *
 *	@param	_Player		The player to reset their weapons.
 */
Void ResetPlayerWeapons(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	// Reset player main weapon
	if (_Player.CurWeapon != GetWeaponNum(CSmMode::EWeapon::Rocket) || !_Player.AutoSwitchWeapon)
		SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, True);
	
	// Reset to default ammo max
	foreach (Weapon => MaxAmmo in C_LibInventory_WeaponsDefualtAmmo) SetPlayerAmmoMax(_Player, Weapon, MaxAmmo);
}

// ---------------------------------- //
/// Reset all settings and unload the library.
Void Unload() {
	ResetAllInventories();
	Layers::Detach(C_LibInventory_UILayerID);
	Layers::Destroy(C_LibInventory_UILayerID);
	
	declare netwrite Net_LibInventory_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibInventory_Settings for Teams[0] = Text[Text];
	declare netwrite Net_LibInventory_IconsPathPrefix for Teams[0] = "";
	Net_LibInventory_SettingsUpdate = -1;
	Net_LibInventory_Settings.clear();
	Net_LibInventory_IconsPathPrefix = C_LibInventory_UIIconsPath;
	
	G_LibInventory_IsLoaded = False;
}

// ---------------------------------- //
/// Load the library.
Void Load() {
	Unload();
	Layers::Create(C_LibInventory_UILayerID, Private_CreateManialinkInventory());
	Layers::Attach(C_LibInventory_UILayerID);
	G_LibInventory_IsLoaded = True;
}

// ---------------------------------- //
/** Set interface hotbar visibility.
 *
 *	@param _DisplayHotbar	Hotbar visibility.
 */
Void SetDisplayHotbar(Boolean _DisplayHotbar) {
	Private_SetModuleSetting("DisplayHotbar", TL::ToText(_DisplayHotbar));
}

// ---------------------------------- //
/** Format the interface hotbar frame.
 *
 *	@param	_Position	Hotbar frame position.
 *	@param	_ItemSize	Size of a single item in the hotbar.
 *	@param	_Scale		Scale of the hotbar frame.
 *	@param	_Rotation	Hotbar frame rotation.
 *	@param	_HAlign		Horizontal align of the hotbar frame.
 *	@param	_VAlign		Vertical align of the hotbar frame.
 */
Void FormatInterfaceHotbar(Vec3 _Position, Vec2 _ItemSize, Real _Scale, Real _Rotation, CMlControl::AlignHorizontal _HAlign, CMlControl::AlignVertical _VAlign) {
	// Translate horizontal align to text
	declare HAlign = "center";
	switch (_HAlign) {
		case CMlControl::AlignHorizontal::Left	: HAlign = "left";
		case CMlControl::AlignHorizontal::Right	: HAlign = "right";
	}
	
	// Translate vertical align to text
	declare VAlign = "center";
	switch (_VAlign) {
		case CMlControl::AlignVertical::Top		: HAlign = "top";
		case CMlControl::AlignVertical::Bottom	: HAlign = "bottom";
	}
	
	Private_SetModuleSetting(
		"FormatInterfaceHotbar", _Position.X^" "^_Position.Y^" "^_Position.Z^" "^_ItemSize.X^" "^_ItemSize.Y^" "^
		_Scale^" "^_Rotation^" "^HAlign^" "^VAlign
	);
}

// ---------------------------------- //
/** Format the item amount label.
 *
 *	@param	_Format		Formatting string, e.g. `<label textsize='3' />`.
 */
Void FormatLabelAmount(Text _Format) {
	if (_Format == "") return;
	Private_SetModuleSetting("FormatLabelAmount", _Format);
}

// ---------------------------------- //
/** Format the item hotkey label.
 *
 *	@param	_Format		Formatting string, e.g. `<label textsize='3' />`.
 */
Void FormatLabelHotkey(Text _Format) {
	if (_Format == "") return;
	Private_SetModuleSetting("FormatLabelHotkey", _Format);
}

// ---------------------------------- //
/** Format the item cooldown label.
 *
 *	@param	_Format		Formatting string, e.g. `<label textsize='3' />`.
 */
Void FormatLabelCooldown(Text _Format) {
	if (_Format == "") return;
	Private_SetModuleSetting("FormatLabelCooldown", _Format);
}

// ---------------------------------- //
/** Format the item background quad.
 *
 *	@param	_Format		Formatting string, e.g. `<quad size='8 8' />`.
 */
Void FormatQuadBackground(Text _Format) {
	if (_Format == "") return;
	Private_SetModuleSetting("FormatQuadBackground", _Format);
}

// ---------------------------------- //
/** Format the item current weapon quad.
 *
 *	@param	_Format		Formatting string, e.g. `<quad size='8 8' />`.
 */
Void FormatQuadHighlight(Text _Format) {
	if (_Format == "") return;
	Private_SetModuleSetting("FormatQuadHighlight", _Format);
}

// ---------------------------------- //
/** Set the base path for the inventory items icons.
 *
 *	@param	_ImgBase	Icons base path.
 */
Void SetIconsBasePath(Text _ImgBase) {
	declare netwrite Text Net_LibInventory_IconsPathPrefix for Teams[0];
	Net_LibInventory_IconsPathPrefix = _ImgBase;
}

// ---------------------------------- //
/** Change default images of the weapons icons.
 *
 *	@param	_Icons		Weapons icons images.
 */
Void SetWeaponsIcons(Text[CSmMode::EWeapon] _Icons) {
	if (_Icons.count <= 0) return;
	foreach (Weapon => Icon in _Icons) G_LibInventory_WeaponsIcons[Weapon] = Icon;
}

// ---------------------------------- //
/** Loop - cleaning up utilities.
 *
 *	@deprecated		No longer need to use this function.
 */
Void Loop() {}