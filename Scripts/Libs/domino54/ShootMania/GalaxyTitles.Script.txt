// -------------------------------------- //
//  LIBRARY GALAXYTITLES by domino54      //
//  script version: 2017-04-29            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library contains essential features for all
 *	game modes running in the GalaxyTitles title pack:
 *	-	Spawning and managing Fuel and Armor
 *	-	Spawning Combo weapon items and managing inventory
 *	-	Spawning and managing NPC Toads
 *	-	Managing players' reload boost
 */

#Const Version		"2017-04-29"
#Const ScriptName	"GalaxyTitles.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/domino54/MultiClans.Script.txt" as Clans
#Include "Libs/domino54/Statistics.Script.txt" as Statistics
#Include "Libs/domino54/TopScores.Script.txt" as TopScores
#Include "Libs/domino54/ShootMania/Interfancy.Script.txt" as Interfancy
#Include "Libs/domino54/ShootMania/Inventory.Script.txt" as Inventory
#Include "Libs/domino54/ShootMania/MiniMap.Script.txt" as MiniMap

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_LibGalaxyTitles_AcceptedObjects ["Armor", "Fuel", "Laser", "Nucleus", "Arrow", "Rocket", "Replie"]
#Const C_LibGalaxyTitles_WeaponItemsTags ["Laser", "Nucleus", "Arrow", "Rocket"]

/// Objects spawning
#Const C_LibGalaxyTitles_ObjectsRespawnTime		15000			///< Time before object is respawned
#Const C_LibGalaxyTitles_ObjectsDropLifetime	5000			///< Time for how long dropped weapons stay under player
#Const C_LibGalaxyTitles_ObjectsDropSpreadSize	<.5, .25, .5>	///< Size of the possible objects spread radius

/// Objects functions
#Const C_LibGalaxyTitles_ArmorPickupRadius		10.		///< Armor item healing radius
#Const C_LibGalaxyTitles_ArmorHealAmount		100		///< Armor item heal amount
#Const C_LibGalaxyTitles_FuelPickupRadius		10.		///< Fuel item bonus radius
#Const C_LibGalaxyTitles_FuelReloadMultipler	3.		///< Fuel reload bonus multipler
#Const C_LibGalaxyTitles_FuelReloadDuration		2000	///< Fuel reload bonus duration
#Const C_LibGalaxyTitles_DefaultPointsForPick	1		///< Default amount of points for affecting other player
#Const C_LibGalaxyTitles_NoteDisplayTime		1750	///< Duration of the notice display time
#Const C_LibGalaxyTitles_ReplieUseCooldown		2000	///< Time before Replie can be used again
#Const C_LibGalaxyTitles_DefaultMaxWeapons		2		///< Default maximum amount of each weapon in the Inventory
#Const C_LibGalaxyTitles_DefaultMaxReplies		3		///< Default maximum amount of Replies in the Inventory
#Const C_LibGalaxyTitles_ParticlesDuration		15		///< Duration of the Replie particles effect

/// Toads
#Const C_LibGalaxyTitles_ToadLandmarksRatio		.5		///< Minimal amount of landmark spawning Toads
#Const C_LibGalaxyTitles_ToadRespawnTime		60		///< Time before Toad is respawned
#Const C_LibGalaxyTitles_ToadChillingTime		5000	///< Toad wandering delay
#Const C_LibGalaxyTitles_ToadSaunterRadius		6.		///< Toad wandering area radius
#Const C_LibGalaxyTitles_ToadShootPeriod		1000	///< Toad shoot period
#Const C_LibGalaxyTitles_ToadSpeedPower			.25		///< Toad speed factor
#Const C_LibGalaxyTitles_ToadAmmoGain			.5		///< Toad ammo reload speed
#Const C_LibGalaxyTitles_ToadArmorMax			200		///< Amount of Toads armor points
#Const C_LibGalaxyTitles_ToadAggroRadius		8.		///< Distance within shoot provokes Toad
#Const C_LibGalaxyTitles_ToadPeaceDistance		16.		///< Distance within Toad will follow Player

/// Other
#Const C_LibGalaxyTitles_ReplieActionSlot	CSmMode::EActionSlot::Slot_H
#Const C_LibGalaxyTitles_ReplieItemId		"LibGT_Replie"

/// Colors of the weapons items shown in the Minimap library
#Const C_LibGalaxyTitles_MinimapColors [
	"Laser" => <1., 0., 1.>, "Nucleus" => <1., 0., .5>, "Arrow" => <1., 0., 0.>, "Rocket" => <1., 1., 0.>
]

/// Default amount of bullets in every weapon when player spawns
#Const C_LibGalaxyTitles_InitialWeaponsAmmoMax [
	CSmMode::EWeapon::Laser => 0,
	CSmMode::EWeapon::Nucleus => 0,
	CSmMode::EWeapon::Arrow => 0,
	CSmMode::EWeapon::Rocket => 4
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[Text] G_LibGalaxyTitles_Objects;
declare Ident[Text] G_LibGalaxyTitles_Actions;

/// Global conditions
declare Boolean G_LibGalaxyTitles_LibraryLoaded;
declare Ident[] G_LibGalaxyTitles_ToadsSpawns;
declare Boolean G_LibGalaxyTitles_WeaponItemsAvailable;
declare Text[] G_LibGalaxyTitles_AvailableWeapons;
declare Boolean G_LibGalaxyTitles_RepliesAvailable;

/// Library settings
declare Integer G_LibGalaxyTitles_ToadsArmorMax;
declare Integer G_LibGalaxyTitles_PointsForPick;
declare Boolean G_LibGalaxyTitles_ObjectsAffectEveryone;
declare Integer G_LibGalaxyTitles_ObjectsDropLifetime;
declare Integer G_LibGalaxyTitles_InventoryMaxWeapons;
declare Integer G_LibGalaxyTitles_InventoryMaxReplies;
declare Boolean G_LibGalaxyTitles_FuelGivesReloadBoost;

/// Elements created within library
declare Ident[] G_LibGalaxyTitles_CreatedObjects;
declare Ident[] G_LibGalaxyTitles_SpawnedToads;
declare Text[] G_LibGalaxyTitles_MinimapMarkers;
declare Ident[Integer] G_LibGalaxyTitles_DroppedObjects;

/// Update
declare Vec3[Integer] G_LibGalaxyTitles_PrevTeamsColors;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the third team color
 *
 *	@param	_Color1		Color of the first clan
 *	@param	_Color2		Color of the second clan
 *
 *	@return		Color of the third clan
 */
Vec3 Private_GetThirdClanColor(Vec3 _Color1, Vec3 _Color2) {
	declare Vec3 Sum;
	declare Real Max;
	for (I, 0, 2) {
		Sum[I] = _Color1[I] + _Color2[I];
		if (Sum[I] > Max) Max = Sum[I];
	}
	if (Max > 0) for (I, 0, 2) Sum[I] = 1. - (Sum[I] / Max);
	Max = 0.;
	for (I, 0, 2) if (Sum[I] > Max) Max = Sum[I];
	if (Max > 0) for (I, 0, 2) Sum[I] *= 1 / Max;
	return Sum;
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
 *
 *	@return		The version number of the script
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script
 *
 *	@return		The name of the script
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Remove reload boost from specific Player
 *
 *	@param	_Player		The Player to remove boost
 */
Void ClearReloadBoost(CSmPlayer _Player) {
	declare LibGalaxyTitles_BoostEndTime for _Player = -1;
	LibGalaxyTitles_BoostEndTime = -1;
}

// ---------------------------------- //
// Remove reload boost from all players
Void ClearReloadBoost() {
	foreach (Player in AllPlayers) ClearReloadBoost(Player);
}

// ---------------------------------- //
/** Destroy an object
 *
 *	@param	_Object		The object to destroy
 */
Boolean DestroyObject(CSmObject _Object) {
	if (_Object == Null || !G_LibGalaxyTitles_CreatedObjects.exists(_Object.Id)) return False;
	
	// Remove the object from the array
	declare Removed = G_LibGalaxyTitles_CreatedObjects.remove(_Object.Id);
	
	// Destroy object (unspawning the object gives a quiet sound)
	_Object.SetUnspawned();
	ObjectDestroy(_Object);
	return True;
}

// ---------------------------------- //
/// Destroy all objects 
Void DestroyLibObjects() {
	foreach (ObjectId in G_LibGalaxyTitles_CreatedObjects) {
		if (!Objects.existskey(Objects[ObjectId])) continue;
		declare Destroyed = DestroyObject(Objects[ObjectId]);
	}
	G_LibGalaxyTitles_CreatedObjects.clear();
	G_LibGalaxyTitles_DroppedObjects.clear();
	
	// Destroy markers
	foreach (MarkerTag in G_LibGalaxyTitles_MinimapMarkers) MiniMap::DestroyMarker(MarkerTag);
	G_LibGalaxyTitles_MinimapMarkers.clear();
}

// ---------------------------------- //
/// Destroy all Toads 
Void DestroyAllToads() {
	foreach (BotPlayerId in G_LibGalaxyTitles_SpawnedToads) {
		declare CSmPlayer BotPlayer;
		if (BotPlayers.existskey(BotPlayerId)) BotPlayer = BotPlayers[BotPlayerId];
		if (BotPlayer == Null) continue;
		
		UnspawnPlayer(BotPlayer);
		DestroyBotPlayer(BotPlayer);
	}
	G_LibGalaxyTitles_SpawnedToads.clear();
}

// ---------------------------------- //
/// Destroy everything
Void ResetAll() {
	ClearReloadBoost();
	DestroyLibObjects();
	DestroyAllToads();
	Inventory::ResetAllInventories();
}

// ---------------------------------- //
/// Unload library
Void Unload() {
	ResetAll();
	G_LibGalaxyTitles_ObjectsAffectEveryone = False;
	G_LibGalaxyTitles_PointsForPick = C_LibGalaxyTitles_DefaultPointsForPick;
	G_LibGalaxyTitles_ToadsArmorMax = C_LibGalaxyTitles_ToadArmorMax;
	G_LibGalaxyTitles_ObjectsDropLifetime = C_LibGalaxyTitles_ObjectsDropLifetime;
	G_LibGalaxyTitles_InventoryMaxWeapons = C_LibGalaxyTitles_DefaultMaxWeapons;
	G_LibGalaxyTitles_InventoryMaxReplies = C_LibGalaxyTitles_DefaultMaxReplies;
	G_LibGalaxyTitles_FuelGivesReloadBoost = True;
	G_LibGalaxyTitles_LibraryLoaded = False;
	
	// Unload libraries
	Inventory::Unload();
}

// ---------------------------------- //
/// Load library
Void Load() {
	Unload();
	G_LibGalaxyTitles_LibraryLoaded = True;
	
	// ---------------------------------- //
	// Load objects
	G_LibGalaxyTitles_Objects["Fuel"]		= ItemList_Add("SMCommon\\Collectibles\\Fuel.Item.gbx");
	G_LibGalaxyTitles_Objects["Armor"]		= ItemList_Add("SMCommon\\Pickups\\Armor.Item.gbx");
	G_LibGalaxyTitles_Objects["Laser"]		= ItemList_Add("SMCommon\\Pickups\\Laser.Item.gbx");
	G_LibGalaxyTitles_Objects["Nucleus"]	= ItemList_Add("SMCommon\\Pickups\\Nucleus.Item.gbx");
	G_LibGalaxyTitles_Objects["Arrow"]		= ItemList_Add("SMCommon\\Pickups\\Arrow.Item.gbx");
	G_LibGalaxyTitles_Objects["Rocket"]		= ItemList_Add("SMCommon\\Pickups\\Rocket.Item.gbx");
	G_LibGalaxyTitles_Objects["Replie"]		= ItemList_Add("HungerGames\\Replie.Item.gbx");
	G_LibGalaxyTitles_Objects["Toad"]		= ItemList_Add("Minion");
	
	// ---------------------------------- //
	// Load actions
	G_LibGalaxyTitles_Actions["Replie"] = ActionList_Add("HungerGames\\ReplieParticles.Action.gbx");
	
	// Minimap
	MiniMap::SetIconsBasePath(C_ImgBase^"Minimap/");
	
	// ---------------------------------- //
	// Load and format Inventory
	Inventory::Load();
	Inventory::FormatInterfaceHotbar(
		<158., -74., 5.>, <8., 8.>, 1., 2.,
		CMlControl::AlignHorizontal::Right, CMlControl::AlignVertical::VCenter
	);
	Inventory::FormatLabelAmount("<label pos='4 -2.5' valign='center2' textfont='Eurostile_Bold'/>");
	Inventory::FormatLabelHotkey("<label pos='-3.5 3' valign='center2' textfont='Eurostile_Bold'/>");
	Inventory::FormatLabelCooldown("<label textsize=3 textfont='Eurostile_Bold'/>");
	Inventory::FormatQuadBackground("<quad size='8 8' image='"^C_ImgBase^"UiItemShadow.png'/>");
	Inventory::FormatQuadHighlight("<quad size='10 10' image='"^C_ImgBase^"UiCurrentWeapon.png'/>");
	Inventory::SetIconsBasePath(C_ImgBase^"Icons/");
	Inventory::SetWeaponsIcons([
		CSmMode::EWeapon::Laser		=> "Laser.png",
		CSmMode::EWeapon::Nucleus	=> "Nucleus.png",
		CSmMode::EWeapon::Arrow		=> "Arrow.png",
		CSmMode::EWeapon::Rocket	=> "Rocket.png"
	]);
}

// ---------------------------------- //
/// Apply and remove reload boost to the Players
Void ReloadBoost() {
	if (Players.count <= 0 || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	foreach (Player in Players) {
		declare LibGalaxyTitles_BoostEndTime for Player = -1;
		declare LibGalaxyTitles_BoostMultipler for Player = 1.;
		declare LibGalaxyTitles_AmmoGainBase for Player = -1.;
		
		// ---------------------------------- //
		// Increase player reload speed
		if (Now < LibGalaxyTitles_BoostEndTime) {
			if (LibGalaxyTitles_AmmoGainBase < 0.) {
				LibGalaxyTitles_AmmoGainBase = Player.AmmoGain;
				Player.AmmoGain = ML::Clamp(LibGalaxyTitles_AmmoGainBase * LibGalaxyTitles_BoostMultipler, 0., 10.);
			}
		}
		// ---------------------------------- //
		// Reverse reload speed back to the old value
		else if (LibGalaxyTitles_AmmoGainBase >= 0) {
			Player.AmmoGain = ML::Clamp(LibGalaxyTitles_AmmoGainBase, 0., 10.);
			LibGalaxyTitles_AmmoGainBase = -1.;
		}
	}
}

// ---------------------------------- //
/** Give the Player reload boost for certain amount of time
 *
 *	@param	_Player			The Player to apply boost
 *	@param	_Duration		Reload boost duration
 *	@param	_Multipler		Reload boost multipler
 */
Void AddReloadBoost(CSmPlayer _Player, Integer _Duration, Real _Multipler) {
	if (_Player == Null || _Duration <= 0 || _Multipler <= 1. || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	declare LibGalaxyTitles_BoostEndTime for _Player = -1;
	declare LibGalaxyTitles_BoostMultipler for _Player = 1.;
	
	if (LibGalaxyTitles_BoostEndTime < Now) LibGalaxyTitles_BoostEndTime = Now + _Duration;
	else LibGalaxyTitles_BoostEndTime += _Duration;
	LibGalaxyTitles_BoostMultipler = _Multipler;
	Interfancy::SetPlayerReloadData(_Player, Now, LibGalaxyTitles_BoostEndTime - Now);
}

Void AddReloadBoost(CSmPlayer _Player, Integer _Duration) {
	AddReloadBoost(_Player, _Duration, C_LibGalaxyTitles_FuelReloadMultipler);
}

Void AddReloadBoost(CSmPlayer _Player, Real _Multipler) {
	AddReloadBoost(_Player, C_LibGalaxyTitles_FuelReloadDuration, _Multipler);
}

Void AddReloadBoost(CSmPlayer _Player) {
	AddReloadBoost(_Player, C_LibGalaxyTitles_FuelReloadDuration, C_LibGalaxyTitles_FuelReloadMultipler);
}

// ---------------------------------- //
/** Show healing particle effect
 *	Since MP4 uses ArmorReplenishGain as a flag to trigger
 *	particle effect in the ReplieParticles action.
 *
 *	@param	_Player		The player to show particles on
 */
Void ShowHealingParticles(CSmPlayer _Player) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return;
	declare Integer ReplieParticlesEndTime for _Player;
	ReplieParticlesEndTime = Now + C_LibGalaxyTitles_ParticlesDuration;
	ActionSetVariant(_Player, C_LibGalaxyTitles_ReplieActionSlot, 1);
}

// ---------------------------------- //
/** Give armor to a player
 *
 *	@param	_Player		The player to give armor
 *	@param	_Amount		The amount of armor points to give
 */
Void GivePlayerArmor(CSmPlayer _Player, Integer _Amount) {
	if (_Player == Null || _Amount <= 0) return;
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || _Player.Armor >= _Player.ArmorMax) return;
	
	AddPlayerArmor(_Player, _Amount, Null, 0);
	ShowHealingParticles(_Player);
}

// ---------------------------------- //
/** Destroy all objects and reset landmarks settings
 *
 *	@param	_UseWeapons		Enable weapons pickups (if available to be picked up on map)
 *	@param	_UseReplies		Evable Replies objects (if available to be picked up on map)
 */
Void InitObjects(Boolean _UseWeapons, Boolean _UseReplies) {
	DestroyLibObjects();
	G_LibGalaxyTitles_WeaponItemsAvailable = False;
	G_LibGalaxyTitles_RepliesAvailable = False;
	G_LibGalaxyTitles_AvailableWeapons.clear();
	
	if (!G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Reset landmarks
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
		declare Integer LibGalaxyTitles_ObjectNextSpawn for MapLandmark;
		LibGalaxyTitles_ObjectSpawned = False;
		LibGalaxyTitles_ObjectNextSpawn = Now;
		
		// Tell the library to use weapons
		if (
			_UseWeapons && G_LibGalaxyTitles_InventoryMaxWeapons != 0 &&
			C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)
		) {
			G_LibGalaxyTitles_WeaponItemsAvailable = True;
			if (!G_LibGalaxyTitles_AvailableWeapons.exists(MapLandmark.Tag))
				G_LibGalaxyTitles_AvailableWeapons.add(MapLandmark.Tag);
		}
		
		// Check if Replies are available
		if (_UseReplies && G_LibGalaxyTitles_InventoryMaxReplies != 0 && MapLandmark.Tag == "Replie")
			G_LibGalaxyTitles_RepliesAvailable = True;
	}

	// ---------------------------------- //
	// Clear players weapons
	foreach (Player in AllPlayers) {
		declare Ident[] PlayerWeaponsToDrop for Player;
		PlayerWeaponsToDrop.clear();
	}
}

// ---------------------------------- //
/** Destroy all objects and reset landmarks settings
 *
 *	@param	_UseWeaponsAndReplies	Enable weapons pickups and Replies objects (if available to be picked up on map)
 */
Void InitObjects(Boolean _UseWeaponsAndReplies) { InitObjects(_UseWeaponsAndReplies, _UseWeaponsAndReplies); }

// ---------------------------------- //
/// Destroy all objects and reset landmarks settings
Void InitObjects() { InitObjects(True); }

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag, Ident _AnchorId) {
	if (!C_LibGalaxyTitles_AcceptedObjects.exists(_ObjectTag)) return Null;
	
	// Check if the given id belongs to a real object anchor landmark
	declare AnchorId = NullId;
	if (MapLandmarks_ObjectAnchor.existskey(_AnchorId)) AnchorId = _AnchorId;
	
	// Incorrect attributes
	if (_Position == <0., 0., 0.> && AnchorId == NullId) return Null;
	
	// ---------------------------------- //
	// Create the object
	declare CSmObject Object;
	switch (_ObjectTag) {
		case "Armor"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Armor"]);
		case "Laser"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Laser"]);
		case "Nucleus"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Nucleus"]);
		case "Arrow"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Arrow"]);
		case "Rocket"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Rocket"]);
		case "Fuel"		: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Fuel"]);
		case "Replie"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Replie"]);
	}
	if (Object == Null) return Null;
	
	// ---------------------------------- //
	// Set object properties
	declare Ident LibGalaxyTitles_AnchorId for Object;
	declare Text LibGalaxyTitles_ObjectTag for Object;
	LibGalaxyTitles_AnchorId = AnchorId;
	LibGalaxyTitles_ObjectTag = _ObjectTag;
	
	// Spawn object
	if (_AnchorId != NullId) {
		declare MapLandmark <=> MapLandmarks[AnchorId];
		Object.SetAnchor(MapLandmark.ObjectAnchor);
	}
	else Object.SetPosition(_Position);
	G_LibGalaxyTitles_CreatedObjects.add(Object.Id);
	return Object;
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag) { return SpawnObject(_Position, _ObjectTag, NullId); }

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Ident _AnchorId, Text _ObjectTag) { return SpawnObject(Vec3, _ObjectTag, _AnchorId); }

// ---------------------------------- //
/** Spawn objects on landmarks
 *
 *	@param	_SpawnObjects	If False, objects won't be spawned
 */
Void SpawnObjects(Boolean _SpawnObjects) {
	if (!_SpawnObjects || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Drop weapons under eliminated players
	foreach (Player in Players) {
		// Discard drop when it's disabled by game mode
		if (G_LibGalaxyTitles_ObjectsDropLifetime <= 0) continue;
		
		declare Integer LastTimeInOffZone for Player;
		if (Player.IsInOffZone) LastTimeInOffZone = Now;
		
		// Don't drop items, when player is still alive (not in Portals) or if player was eliminated by OffZone
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned || Now < LastTimeInOffZone + 250) continue;
		
		// Get Ids of the object anchors
		declare Ident[] PlayerWeaponsToDrop for Player;
		if (PlayerWeaponsToDrop.count <= 0) continue;
		
		foreach (MapLandmarkId in PlayerWeaponsToDrop) {
			if (!MapLandmarks_ObjectAnchor.existskey(MapLandmarkId)) continue;
			declare MapLandmark <=> MapLandmarks_ObjectAnchor[MapLandmarkId];
			declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
			
			// Get the target position of an object
			declare Position = Player.Position;
			for (I, 0, 2) Position[I] += C_LibGalaxyTitles_ObjectsDropSpreadSize[I] * ML::Rand(-1., 1.);
			
			// ---------------------------------- //
			// Create object
			declare Object = SpawnObject(MapLandmarkId, MapLandmark.Tag);
			LibGalaxyTitles_ObjectSpawned = Object != Null;
			if (!LibGalaxyTitles_ObjectSpawned) continue;
			
			// Reset weapon carrier
			declare Ident LibGalaxyTitles_ObjectPlayerId for MapLandmark;
			LibGalaxyTitles_ObjectPlayerId = NullId;
			
			// Create weapon marker
			if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
				declare MarkerTag = "Object#"^MapLandmark.Id;
				MiniMap::SetMarker(
					MarkerTag, MapLandmark.Tag^".png",
					C_LibGalaxyTitles_MinimapColors[MapLandmark.Tag], Position
				);
				G_LibGalaxyTitles_MinimapMarkers.add(MarkerTag);
			}
			
			// Save object Id in dropped objects array
			declare SpawnTime = Now;
			while (G_LibGalaxyTitles_DroppedObjects.existskey(SpawnTime)) SpawnTime += 1;
			G_LibGalaxyTitles_DroppedObjects[SpawnTime] = Object.Id;
		}
	}
	
	// ---------------------------------- //
	// Get the timed out objects
	declare Ident[] ObjectsToDestroy;
	foreach (SpawnTime => ObjectId in G_LibGalaxyTitles_DroppedObjects)
		if (Now > SpawnTime + G_LibGalaxyTitles_ObjectsDropLifetime) ObjectsToDestroy.add(ObjectId);
	
	// ---------------------------------- //
	// Destroy timed out dropped objects
	foreach (ObjectId in ObjectsToDestroy) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object <=> Objects[ObjectId];
		declare Ident LibGalaxyTitles_AnchorId for Object;
		
		declare Destroyed = DestroyObject(Object);
		
		// Remove object from custom array
		declare Removed = G_LibGalaxyTitles_DroppedObjects.remove(ObjectId);
		
		// ---------------------------------- //
		// Update landmark information
		if (MapLandmarks_ObjectAnchor.existskey(LibGalaxyTitles_AnchorId)) {
			declare MapLandmark <=> MapLandmarks_ObjectAnchor[LibGalaxyTitles_AnchorId];
			declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
			LibGalaxyTitles_ObjectSpawned = False;
			
			// ---------------------------------- //
			// Destroy weapon marker
			declare MarkerTag = "Object#"^LibGalaxyTitles_AnchorId;
			MiniMap::DestroyMarker(MarkerTag);
			Removed = G_LibGalaxyTitles_MinimapMarkers.remove(MarkerTag);
		}
	}
	
	// ---------------------------------- //
	// Spawn objects on landmarks
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare LibGalaxyTitles_ObjectSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ObjectNextSpawn for MapLandmark = Now;
		declare LibGalaxyTitles_ObjectPlayerId for MapLandmark = NullId;
		
		// ---------------------------------- //
		// Continue if landmark has object, the object is dropped somewhere else or object can't be spawned
		if (LibGalaxyTitles_ObjectSpawned || LibGalaxyTitles_ObjectNextSpawn > Now) continue;
		
		// ---------------------------------- //
		// Continue if landmark spawns weapons when they're not available
		if (!G_LibGalaxyTitles_WeaponItemsAvailable && C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) continue;
		
		// ---------------------------------- //
		// Continue if landmark spawns Replie when they're not available
		if (!G_LibGalaxyTitles_RepliesAvailable && MapLandmark.Tag == "Replie") continue;
		
		// ---------------------------------- //
		// Continue if weapon is carried by the player
		if (
			LibGalaxyTitles_ObjectPlayerId != NullId &&
			Players.existskey(LibGalaxyTitles_ObjectPlayerId) &&
			Players[LibGalaxyTitles_ObjectPlayerId].SpawnStatus == CSmPlayer::ESpawnStatus::Spawned
		) continue;
		
		// ---------------------------------- //
		// Create object
		declare Object = SpawnObject(MapLandmark.Position, MapLandmark.Tag, MapLandmark.Id);
		LibGalaxyTitles_ObjectSpawned = Object != Null;
		if (LibGalaxyTitles_ObjectSpawned == False) continue;
		
		// Reset weapon carrier
		LibGalaxyTitles_ObjectPlayerId = NullId;
		
		// Create weapon marker
		if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
			declare MarkerTag = "Object#"^MapLandmark.Id;
			MiniMap::SetMarker(
				MarkerTag, MapLandmark.Tag^".png",
				C_LibGalaxyTitles_MinimapColors[MapLandmark.Tag], MapLandmark.Position
			);
			G_LibGalaxyTitles_MinimapMarkers.add(MarkerTag);
		}
	}
}

// ---------------------------------- //
/// Spawn objects on landmarks
Void SpawnObjects() { SpawnObjects(True); }

// ---------------------------------- //
/** Pick up object
 *
 *	@param	_Event			The event to proceed
 *	@param	_RespawnTime	Time before object will be spawned again after pick
 *	@param	_TrueIfPick		If True, event is not discarded and returns True only if item was picked up
 *
 *	@return		True, if the item is handled by the library
 */
Boolean PickUpObject(CSmModeEvent _Event, Integer _RespawnTime, Boolean _TrueIfPick) {
	if (
		_Event == Null || _Event.Type != CSmModeEvent::EType::OnPlayerTouchesObject ||
		_Event.Object == Null || _Event.Player == Null || _Event.Player.IsBot ||
		_Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned ||
		!G_LibGalaxyTitles_LibraryLoaded
	) return False;
	
	declare Text LibGalaxyTitles_ObjectTag for _Event.Object;
	declare Ident LibGalaxyTitles_AnchorId for _Event.Object;
	
	// Return False if object is not handled by GalaxyTitles library
	if (!C_LibGalaxyTitles_AcceptedObjects.exists(LibGalaxyTitles_ObjectTag)) return False;
	
	if (!_TrueIfPick) Discard(_Event);
	
	// ---------------------------------- //
	// Pick conditions
	declare CanPickUpObject = True;
	
	switch (LibGalaxyTitles_ObjectTag) {
		// ---------------------------------- //
		// Armor conditions
		case "Armor" : {
			CanPickUpObject = _Event.Player.Armor < _Event.Player.ArmorMax;
			
			// Check if players nearby can be healed
			if (!CanPickUpObject) foreach (Player in Players) {
				if (
					Player.Armor >= Player.ArmorMax ||
					ML::Distance(_Event.Player.Position, Player.Position) > C_LibGalaxyTitles_ArmorPickupRadius ||
					!(
						G_LibGalaxyTitles_ObjectsAffectEveryone ||
						(_Event.Player.CurrentClan != 0 && Player.CurrentClan == _Event.Player.CurrentClan) ||
						Clans::AreTeammates(Player, _Event.Player)
					)
				) continue;
				
				CanPickUpObject = True;
				break;
			}
		}
		// ---------------------------------- //
		// Replie conditions
		case "Replie" : {
			// Player can't hold any Replies
			if (G_LibGalaxyTitles_InventoryMaxReplies == 0) CanPickUpObject = False;
			
			// Limited Replies amount
			else if (G_LibGalaxyTitles_InventoryMaxReplies > 0) {
				declare PlayerReplies = Inventory::GetItemAmount(_Event.Player, C_LibGalaxyTitles_ReplieItemId);
				CanPickUpObject = PlayerReplies < G_LibGalaxyTitles_InventoryMaxReplies;
			}
		}
		// ---------------------------------- //
		// Weapons conditions
		default : if (C_LibGalaxyTitles_WeaponItemsTags.exists(LibGalaxyTitles_ObjectTag)) {
			// Player can't hold any additional weapons
			if (G_LibGalaxyTitles_InventoryMaxWeapons == 0) CanPickUpObject = False;
			
			// Limited weapons amount
			else if (G_LibGalaxyTitles_InventoryMaxWeapons > 0) {
				declare CSmMode::EWeapon Weapon;
				switch (LibGalaxyTitles_ObjectTag) {
					case "Laser" : Weapon = CSmMode::EWeapon::Laser;
					case "Nucleus" : Weapon = CSmMode::EWeapon::Nucleus;
					case "Arrow" : Weapon = CSmMode::EWeapon::Arrow;
					default : Weapon = CSmMode::EWeapon::Rocket;
				}
				
				declare PlayerWeaponAmmoMax = Inventory::GetWeaponSlots(_Event.Player, Weapon);
				CanPickUpObject = PlayerWeaponAmmoMax < C_LibGalaxyTitles_InitialWeaponsAmmoMax[Weapon] + G_LibGalaxyTitles_InventoryMaxWeapons;
			}
		}
	}
	
	// Continue, if the object can't be picked up
	if (!CanPickUpObject) return !_TrueIfPick;
	
	// ---------------------------------- //
	// Item respawn timer
	if (MapLandmarks_ObjectAnchor.existskey(LibGalaxyTitles_AnchorId)) {
		declare MapLandmark <=> MapLandmarks_ObjectAnchor[LibGalaxyTitles_AnchorId];
		declare LibGalaxyTitles_ObjectSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ObjectNextSpawn for MapLandmark = Now;
		declare LibGalaxyTitles_ObjectPlayerId for MapLandmark = NullId;
		
		LibGalaxyTitles_ObjectSpawned = False;
		LibGalaxyTitles_ObjectNextSpawn = Now + _RespawnTime;
		
		// ---------------------------------- //
		// Set weapon carrier
		if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
			LibGalaxyTitles_ObjectNextSpawn = Now;
			LibGalaxyTitles_ObjectPlayerId = _Event.Player.Id;
			
			// ---------------------------------- //
			// Destroy weapon marker
			declare MarkerTag = "Object#"^MapLandmark.Id;
			MiniMap::DestroyMarker(MarkerTag);
			declare Removed = G_LibGalaxyTitles_MinimapMarkers.remove(MarkerTag);
		}
	}
	
	// ---------------------------------- //
	// Apply effect
	declare NbOtherPlayersAffected = 0;
	declare Message = Text[];
	
	switch (LibGalaxyTitles_ObjectTag) {
		// ---------------------------------- //
		// Armor - heal players
		case "Armor" : {
			foreach (Player in Players) {
				declare Affected = Player == _Event.Player || G_LibGalaxyTitles_ObjectsAffectEveryone || (_Event.Player.CurrentClan != 0 && Player.CurrentClan == _Event.Player.CurrentClan) || Clans::AreTeammates(Player, _Event.Player);
				
				if (
					!Affected || Player.Armor >= Player.ArmorMax ||
					ML::Distance(_Event.Player.Position, Player.Position) > C_LibGalaxyTitles_FuelPickupRadius
				)
					continue;
				
				// Heal the player
				GivePlayerArmor(Player, C_LibGalaxyTitles_ArmorHealAmount);
				
				// ---------------------------------- //
				// Notify player about who healed them
				if (Player == _Event.Player) continue;
				NbOtherPlayersAffected += 1;
				
				Interfancy::SendCrosshairNote(
					Player, ["$<%1$> healed you!", _Event.Player.Name],
					C_LibGalaxyTitles_NoteDisplayTime
				);
			}
			
			// ---------------------------------- //
			// Notify player how many teammates they've healed
			if (NbOtherPlayersAffected > 0) {
				if (NbOtherPlayersAffected > 1) Message = ["Healed %1 players", TL::ToText(NbOtherPlayersAffected)];
				else Message = ["Healed 1 player"];
				Statistics::TrackEvent(_Event.Player, "PlayersHealed", NbOtherPlayersAffected);
			}
		}
		// ---------------------------------- //
		// Fuel - reload boost and stamina
		case "Fuel" : {
			foreach (Player in Players) {
				declare Affected = Player == _Event.Player || G_LibGalaxyTitles_ObjectsAffectEveryone || (_Event.Player.CurrentClan != 0 && Player.CurrentClan == _Event.Player.CurrentClan) || Clans::AreTeammates(Player, _Event.Player);
				
				if (!Affected || ML::Distance(_Event.Player.Position, Player.Position) > C_LibGalaxyTitles_FuelPickupRadius) continue;
				
				// ---------------------------------- //
				// Boost player
				if (G_LibGalaxyTitles_FuelGivesReloadBoost) AddReloadBoost(Player);
				Player.Stamina = ML::FloorInteger(Player.StaminaMax * 3600);
				
				// ---------------------------------- //
				// Notify player about who boosted them
				if (Player == _Event.Player) continue;
				NbOtherPlayersAffected += 1;
				
				Interfancy::SendCrosshairNote(
					Player, ["$<%1$> boosted you!", _Event.Player.Name],
					C_LibGalaxyTitles_NoteDisplayTime
				);
			}
			
			// ---------------------------------- //
			// Notify player how many teammates they've boosted
			if (NbOtherPlayersAffected > 0) {
				if (NbOtherPlayersAffected > 1) Message = ["Boosted %1 players", TL::ToText(NbOtherPlayersAffected)];
				else Message = ["Boosted 1 player"];
				Statistics::TrackEvent(_Event.Player, "PlayersBoosted", NbOtherPlayersAffected);
			}
		}
		// ---------------------------------- //
		// Give Laser weapon slot
		case "Laser" : Inventory::AddWeaponSlots(_Event.Player, CSmMode::EWeapon::Laser, 1);
		
		// ---------------------------------- //
		// Give Nucleus weapon slot
		case "Nucleus" : Inventory::AddWeaponSlots(_Event.Player, CSmMode::EWeapon::Nucleus, 1);
		
		// ---------------------------------- //
		// Give Arrow weapon slot
		case "Arrow" : Inventory::AddWeaponSlots(_Event.Player, CSmMode::EWeapon::Arrow, 1);
		
		// ---------------------------------- //
		// Give Rocket weapon slot
		case "Rocket" : Inventory::AddWeaponSlots(_Event.Player, CSmMode::EWeapon::Rocket, 1);
		
		// ---------------------------------- //
		// Give Replie consumable item
		case "Replie" : {
			Inventory::AddItems(_Event.Player, C_LibGalaxyTitles_ReplieItemId, 1);
			Interfancy::SendCrosshairNote(_Event.Player, ["+1 %1", "Replie"], C_LibGalaxyTitles_NoteDisplayTime);
		}
	}
	
	// ---------------------------------- //
	// Send notice and give points if player has affected somebody
	if (NbOtherPlayersAffected > 0) {
		Interfancy::SendCrosshairNote(_Event.Player, Message, C_LibGalaxyTitles_NoteDisplayTime);
		Score::AddPoints(_Event.Player, NbOtherPlayersAffected * G_LibGalaxyTitles_PointsForPick);
		TopScores::AddPoints(_Event.Player.Score, "Support", NbOtherPlayersAffected * G_LibGalaxyTitles_PointsForPick);
	}
	
	if (C_LibGalaxyTitles_WeaponItemsTags.exists(LibGalaxyTitles_ObjectTag)) {
		// ---------------------------------- //
		// Crosshair notice on weapon added
		Interfancy::SendCrosshairNote(_Event.Player, ["+1 %1", LibGalaxyTitles_ObjectTag], C_LibGalaxyTitles_NoteDisplayTime);
		
		// ---------------------------------- //
		// Add weapon to drop
		declare Ident[] PlayerWeaponsToDrop for _Event.Player;
		if (!PlayerWeaponsToDrop.exists(LibGalaxyTitles_AnchorId)) PlayerWeaponsToDrop.add(LibGalaxyTitles_AnchorId);
	}
	
	// Destroy the object
	declare Destroyed = DestroyObject(_Event.Object);
	return True;
}

Boolean PickUpObject(CSmModeEvent _Event, Boolean _TrueIfPick) {
	return PickUpObject(_Event, C_LibGalaxyTitles_ObjectsRespawnTime, _TrueIfPick);
}

Boolean PickUpObject(CSmModeEvent _Event, Integer _RespawnTime) {
	return PickUpObject(_Event, _RespawnTime, False);
}

Boolean PickUpObject(CSmModeEvent _Event) {
	return PickUpObject(_Event, C_LibGalaxyTitles_ObjectsRespawnTime, False);
}

// ---------------------------------- //
/** Initialize Toads spawn landmarks
 *
 *	@param	_ToadsSpawnRatio	Target ratio of landmarks spawning Toads to all landmarks
 */
Void InitToads(Real _ToadsSpawnRatio) {
	DestroyAllToads();
	G_LibGalaxyTitles_ToadsSpawns.clear();
	if (MapLandmarks_BotPath.count <= 0 || _ToadsSpawnRatio <= 0 || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Use only BotPaths with the default tag
	declare Ident[] CompatibleLandmarks;
	foreach (MapLandmark in MapLandmarks_BotPath) if (MapLandmark.Tag == "BotPath") CompatibleLandmarks.add(MapLandmark.Id);
	if (CompatibleLandmarks.count <= 0) return;
	
	// ---------------------------------- //
	// Reset Toads information in landmarks
	foreach (MapLandmark in MapLandmarks_BotPath) {
		if (!CompatibleLandmarks.exists(MapLandmark.Id)) continue;
		declare Boolean LibGalaxyTitles_ToadSpawned for MapLandmark;
		declare Integer LibGalaxyTitles_ToadNextSpawn for MapLandmark;
		LibGalaxyTitles_ToadSpawned = False;
		LibGalaxyTitles_ToadNextSpawn = Now;
	}
	
	// ---------------------------------- //
	// Select landmark what will spawn Toads
	declare LandmarksRatio = 0.;
	while (True) {
		declare Ident LandmarkId;
		LandmarkId = NullId;
		
		while (True) {
			LandmarkId = CompatibleLandmarks[ML::Rand(0, CompatibleLandmarks.count - 1)];
			if (!G_LibGalaxyTitles_ToadsSpawns.exists(LandmarkId)) break;
		}
		
		G_LibGalaxyTitles_ToadsSpawns.add(LandmarkId);
		LandmarksRatio = ML::ToReal(G_LibGalaxyTitles_ToadsSpawns.count) / CompatibleLandmarks.count;
		if (LandmarksRatio >= _ToadsSpawnRatio || G_LibGalaxyTitles_ToadsSpawns.count >= CompatibleLandmarks.count) break;
	}
}

// ---------------------------------- //
/// Initialize Toads spawn landmarks with default spawn ratio 
Void InitToads() { InitToads(C_LibGalaxyTitles_ToadLandmarksRatio); }

// ---------------------------------- //
/** Manage everything related to Toads
 *
 *	@param	_ToadsRespawnTime	Time before Toad will respawn after elimination
 */
Void ToadsLoop(Integer _ToadsRespawnTime) {
	if (!G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Spawn Toads
	if (OffZoneRadius <= 0) foreach (MapLandmark in MapLandmarks_BotPath) {
		if (_ToadsRespawnTime <= 0 || !G_LibGalaxyTitles_ToadsSpawns.exists(MapLandmark.Id)) continue;
		
		declare LibGalaxyTitles_ToadSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ToadNextSpawn for MapLandmark = Now;
		
		// ---------------------------------- //
		// Continue if landmark can't spawn Toad or if Toad is already spawned
		if (LibGalaxyTitles_ToadSpawned || LibGalaxyTitles_ToadNextSpawn > Now) continue;
		
		// ---------------------------------- //
		// Create Toad
		declare Toad <=> CreateBotPlayer(G_LibGalaxyTitles_Objects["Toad"], 0);
		
		// ---------------------------------- //
		// Define behaviour depending on amount of path points
		if (MapLandmark.BotPath.Path.count > 1) {
			Toad.Driver.Behaviour = CSmPlayerDriver::ESmDriverBehaviour::Patrol;
			if (
				MapLandmark.BotPath.Path.count >= 3 &&
				ML::Distance(MapLandmark.BotPath.Path[0], MapLandmark.BotPath.Path[MapLandmark.BotPath.Path.count-1]) <= 8.
			)
				Toad.Driver.Patrol_Mode = CSmPlayerDriver::ESmDriverPatrolMode::Loop;
			else
				Toad.Driver.Patrol_Mode = CSmPlayerDriver::ESmDriverPatrolMode::BackAndForth;
		} else
			Toad.Driver.Behaviour = CSmPlayerDriver::ESmDriverBehaviour::Saunter;
		
		// ---------------------------------- //
		// Configure Toad
		Toad.Driver.AttackFilter = CSmPlayerDriver::ESmAttackFilter::Nobody;
		Toad.Driver.Saunter_BaseChillingTime	= C_LibGalaxyTitles_ToadChillingTime;
		Toad.Driver.Saunter_ChillingTimeDelta	= 0;
		Toad.Driver.Saunter_Radius	= C_LibGalaxyTitles_ToadSaunterRadius;
		Toad.Driver.ShootPeriodMin	= C_LibGalaxyTitles_ToadShootPeriod;
		Toad.Driver.ShootPeriodMax	= C_LibGalaxyTitles_ToadShootPeriod;
		Toad.Driver.AggroRadius		= C_LibGalaxyTitles_ToadPeaceDistance;
		Toad.Driver.DisengageDistance	= C_LibGalaxyTitles_ToadPeaceDistance;
		Toad.SpeedPower	= C_LibGalaxyTitles_ToadSpeedPower;
		Toad.AmmoGain	= C_LibGalaxyTitles_ToadAmmoGain;
		Toad.ArmorMax	= G_LibGalaxyTitles_ToadsArmorMax;
		Toad.ForceColor	= Private_GetThirdClanColor(Teams[0].ColorPrimary, Teams[1].ColorPrimary);
		
		// ---------------------------------- //
		// Spawn Toad
		declare Ident LibGalaxyTitles_AnchorId for Toad;
		LibGalaxyTitles_AnchorId = MapLandmark.Id;
		
		SpawnBotPlayer(Toad, 0, Toad.ArmorMax, MapLandmark.BotPath, Now);
		G_LibGalaxyTitles_SpawnedToads.add(Toad.Id);
		LibGalaxyTitles_ToadSpawned = True;
	}
	
	// ---------------------------------- //
	// Manage events
	foreach (Event in PendingEvents) {
		// ---------------------------------- //
		// Respawn eliminated Toads
		if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id)) {
				declare Ident LibGalaxyTitles_AnchorId for Event.Victim;
				if (MapLandmarks_BotPath.existskey(LibGalaxyTitles_AnchorId)) {
					declare MapLandmark <=> MapLandmarks_BotPath[LibGalaxyTitles_AnchorId];
					declare Boolean LibGalaxyTitles_ToadSpawned for MapLandmark = False;
					declare Integer LibGalaxyTitles_ToadNextSpawn for MapLandmark = Now;
					LibGalaxyTitles_ToadSpawned = False;
					LibGalaxyTitles_ToadNextSpawn = Now + _ToadsRespawnTime;
				}
				
				// Destroy Toad
				declare Removed = G_LibGalaxyTitles_SpawnedToads.remove(Event.Victim.Id);
				DestroyBotPlayer(Event.Victim);
			}
		}
		// ---------------------------------- //
		// Make player who shoot the Toad its target
		else if (Event.Type == CSmModeEvent::EType::OnHit) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id))
				Event.Victim.Driver.ForcedTarget = Event.Shooter;
		}
		// ---------------------------------- //
		// Make the Player shooting near Toad its target
		else if (Event.Type == CSmModeEvent::EType::OnShoot) {
			if (Event.Shooter != Null && !Event.Shooter.IsBot) {
				foreach (BotPlayer in BotPlayers) {
					if (
						G_LibGalaxyTitles_SpawnedToads.exists(BotPlayer.Id) &&
						ML::Distance(BotPlayer.Position, Event.Shooter.Position) <= C_LibGalaxyTitles_ToadAggroRadius
					)
						BotPlayer.Driver.ForcedTarget = Event.Shooter;
				}
			}
		}
		// ---------------------------------- //
		// Attack the Player if missed a Toad
		else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id))
				Event.Victim.Driver.ForcedTarget = Event.Shooter;
		}
	}
	
	// ---------------------------------- //
	// Manage Toads functions
	foreach (BotPlayer in BotPlayers) {
		if (!G_LibGalaxyTitles_SpawnedToads.exists(BotPlayer.Id)) continue;
		
		// ---------------------------------- //
		// Make player touching Toad its target
		if (BotPlayer.Driver.ForcedTarget == Null) {
			foreach (Player in Players) {
				if (
					Player.Armor > 0 && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned &&
					ML::Distance(BotPlayer.Position, Player.Position) < 1.5
				)
					BotPlayer.Driver.ForcedTarget = Player;
			}
		}
		
		// ---------------------------------- //
		// Clear Toad target if out of range
		if (BotPlayer.Driver.ForcedTarget != Null) {
			declare Player <=> BotPlayer.Driver.ForcedTarget;
			if (
				Player.Armor <= 0 || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned ||
				ML::Distance(BotPlayer.Position, Player.Position) > BotPlayer.Driver.DisengageDistance
			)
				BotPlayer.Driver.ForcedTarget = Null;
		}
	}
	
	// ---------------------------------- //
	// Update Toads colour on team colour change
	foreach (I => Team in Teams) if (
		!G_LibGalaxyTitles_PrevTeamsColors.existskey(I) ||
		G_LibGalaxyTitles_PrevTeamsColors[I] != Team.ColorPrimary
	) {
		G_LibGalaxyTitles_PrevTeamsColors[I] = Team.ColorPrimary;
		declare NewToadsColor = Private_GetThirdClanColor(Teams[0].ColorPrimary, Teams[1].ColorPrimary);
		foreach (BotPlayer in BotPlayers) BotPlayer.ForceColor = NewToadsColor;
	}
}

// ---------------------------------- //
/// Manage everything related to Toads
Void ToadsLoop() { ToadsLoop(C_LibGalaxyTitles_ToadRespawnTime); }

// ---------------------------------- //
/** Initialize the library
 *
 *	@param	_UseWeapons			Enable weapons pickups (if available to be picked up on map)
 *	@param	_UseReplies			Enable Replies objects (if available to be picked up on map)
 *	@param	_ToadsSpawnRatio	Target ratio of landmarks spawning Toads to all landmarks
 */
Void Init(Boolean _UseWeapons, Boolean _UseReplies, Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects(_UseWeapons, _UseReplies);
	InitToads(_ToadsSpawnRatio);
}

Void Init(Boolean _UseWeaponsAndReplies, Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects(_UseWeaponsAndReplies);
	InitToads(_ToadsSpawnRatio);
}

Void Init(Boolean _UseWeaponsAndReplies) {
	ClearReloadBoost();
	InitObjects(_UseWeaponsAndReplies);
	InitToads();
}

Void Init(Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects();
	InitToads(_ToadsSpawnRatio);
}

Void Init() {
	ClearReloadBoost();
	InitObjects();
	InitToads();
}

// ---------------------------------- //
/** Automatic library loop
 *
 *	@param	_SpawnObjects		If False, objects won't be spawned
 *	@param	_ToadsRespawnTime	Time before Toad will respawn after elimination
 */
Void Loop(Boolean _SpawnObjects, Integer _ToadsRespawnTime) {
	ReloadBoost();
	SpawnObjects(_SpawnObjects);
	ToadsLoop(_ToadsRespawnTime);

	// ---------------------------------- //
	// Manage Replie particles action
	foreach (Player in Players) {
		declare Integer ReplieParticlesEndTime for Player;
		if (Now < ReplieParticlesEndTime) continue;
		ActionSetVariant(Player, C_LibGalaxyTitles_ReplieActionSlot, 0);
	}
}

Void Loop(Boolean _SpawnObjects) {
	ReloadBoost();
	SpawnObjects(_SpawnObjects);
	ToadsLoop();
}

Void Loop(Integer _ToadsRespawnTime) {
	ReloadBoost();
	SpawnObjects();
	ToadsLoop(_ToadsRespawnTime);
}

Void Loop() {
	ReloadBoost();
	SpawnObjects();
	ToadsLoop();
}

// ---------------------------------- //
/** Reset and load player weapons after player is respawned
 *	/!\ Must be called after player is spawned in the world /!\
 *
 *	@param	_Player		Player to set weapon
 */
Void InitPlayerInventory(CSmPlayer _Player) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	Inventory::ResetInventory(_Player);
	
	// ---------------------------------- //
	// Load Replies in the Inventory
	if (G_LibGalaxyTitles_RepliesAvailable) {
		Inventory::CreateItemSlot(_Player, C_LibGalaxyTitles_ReplieItemId, CSmModeEvent::EActionInput::Consumable1, 0, "Replie.png");
	}

	// Load action used to show particle effect on the player
	ActionLoad(_Player, C_LibGalaxyTitles_ReplieActionSlot, G_LibGalaxyTitles_Actions["Replie"]);
	ActionBind(_Player, C_LibGalaxyTitles_ReplieActionSlot, CSmMode::EActionInput::None);
	
	if (!G_LibGalaxyTitles_WeaponItemsAvailable) return;
	
	// ---------------------------------- //
	// Get the available weapons
	declare PlayerWeapons = [CSmMode::EWeapon::Rocket];
	declare TextToWeapon = ["Laser" => CSmMode::EWeapon::Laser, "Nucleus" => CSmMode::EWeapon::Nucleus, "Arrow" => CSmMode::EWeapon::Arrow];
	
	foreach (WeaponName in G_LibGalaxyTitles_AvailableWeapons) {
		if (!TextToWeapon.existskey(WeaponName)) continue;
		declare Weapon = TextToWeapon[WeaponName];
		if (!PlayerWeapons.exists(Weapon)) PlayerWeapons.add(Weapon);
	}
	
	Inventory::SetAvailableWeapons(_Player, PlayerWeapons);
	
	// ---------------------------------- //
	// Init weapons
	foreach (Weapon => Amount in C_LibGalaxyTitles_InitialWeaponsAmmoMax) Inventory::SetWeaponSlots(_Player, Weapon, Amount);
	Inventory::SetFirstWeapon(_Player);
	
	// Reset weapons to drop
	declare Ident[] PlayerWeaponsToDrop for _Player;
	PlayerWeaponsToDrop.clear();
}

// ---------------------------------- //
/** Initialize all settings of a player
 *
 *	@param	_Player		Player to initialize
 */
Void InitPlayer(CSmPlayer _Player) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	ClearReloadBoost(_Player);
	InitPlayerInventory(_Player);
}

// ---------------------------------- //
/** Autmatically manage consumable items usage
 *
 *	@param	_Event	The event to proceed
 */
Void UseConsumableItems(CSmModeEvent _Event) {
	if (_Event == Null || _Event.Type != CSmModeEvent::EType::OnActionEvent || _Event.Player == Null) return;
	
	declare NbOtherPlayersAffected = 0;
	declare Message = Text[];

	// Get the target item's id through the ugly way
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Event.Player;
	if (!LibInventory_PlayerItemHotkey.exists(_Event.ActionInput)) return;
	declare ItemName = LibInventory_PlayerItemHotkey.keyof(_Event.ActionInput);
	
	// ---------------------------------- //
	// Use a Replie
	if (ItemName == C_LibGalaxyTitles_ReplieItemId) {
		// ---------------------------------- //
		// Check if the replie can be used
		declare CanUseReplie = _Event.Player.Armor < _Event.Player.ArmorMax;
			
		// Check if players nearby can be healed
		if (!CanUseReplie) foreach (Player in Players) {
			if (
				Player.Armor >= Player.ArmorMax ||
				ML::Distance(_Event.Player.Position, Player.Position) > C_LibGalaxyTitles_ArmorPickupRadius ||
				!(
					G_LibGalaxyTitles_ObjectsAffectEveryone ||
					(_Event.Player.CurrentClan != 0 && Player.CurrentClan == _Event.Player.CurrentClan) ||
					Clans::AreTeammates(Player, _Event.Player)
				)
			) continue;
			
			CanUseReplie = True;
			break;
		}
		
		// Replie can't be used
		if (!CanUseReplie) return;
		
		// Use Replie
		if (!Inventory::UseItem(_Event.Player, ItemName, C_LibGalaxyTitles_ReplieUseCooldown, False)) return;
		Statistics::TrackEvent(_Event.Player, "RepliesUsedTotal", 1);
		
		// ---------------------------------- //
		// Heal player and their teammates
		foreach (Player in Players) {
			declare Affected = Player == _Event.Player || G_LibGalaxyTitles_ObjectsAffectEveryone || (_Event.Player.CurrentClan != 0 && Player.CurrentClan == _Event.Player.CurrentClan) || Clans::AreTeammates(Player, _Event.Player);
			
			if (
				!Affected || Player.Armor >= Player.ArmorMax ||
				ML::Distance(_Event.Player.Position, Player.Position) > C_LibGalaxyTitles_FuelPickupRadius
			)
				continue;
			
			// Heal the player
			GivePlayerArmor(Player, C_LibGalaxyTitles_ArmorHealAmount);
			
			// ---------------------------------- //
			// Notify player about who healed them
			if (Player == _Event.Player) continue;
			NbOtherPlayersAffected += 1;
			
			Interfancy::SendCrosshairNote(
				Player, ["$<%1$> healed you!", _Event.Player.Name],
				C_LibGalaxyTitles_NoteDisplayTime
			);
		}
		
		// ---------------------------------- //
		// Notify player how many teammates they've healed
		if (NbOtherPlayersAffected > 0) {
			if (NbOtherPlayersAffected > 1) Message = ["Healed %1 players", TL::ToText(NbOtherPlayersAffected)];
			else Message = ["Healed 1 player"];
			Statistics::TrackEvent(_Event.Player, "PlayersHealed", NbOtherPlayersAffected);
		}
	}
	
	// ---------------------------------- //
	// Send notice and give points if player has affected somebody
	if (NbOtherPlayersAffected > 0) {
		Interfancy::SendCrosshairNote(_Event.Player, Message, C_LibGalaxyTitles_NoteDisplayTime);
		Score::AddPoints(_Event.Player, NbOtherPlayersAffected * G_LibGalaxyTitles_PointsForPick);
		TopScores::AddPoints(_Event.Player.Score, "Support", NbOtherPlayersAffected * G_LibGalaxyTitles_PointsForPick);
	}
}

// ---------------------------------- //
/** Set if objects affect also enemy players
 *
 *	@param	_Setting	True, if objects may affect enemies
 */
Void SetObjectsAffectEveryone(Boolean _Setting) {
	G_LibGalaxyTitles_ObjectsAffectEveryone = _Setting;
}

// ---------------------------------- //
/** Set amount of points given for picking up object
 *
 *	@param	_Setting	Amount of points for picking up object
 */
Void SetPointsForPick(Integer _Setting) {
	G_LibGalaxyTitles_PointsForPick = _Setting;
}

// ---------------------------------- //
/** Set amount of Toads armor points
 *
 *	@param	_Setting	Toads armor points
 */
Void SetToadsArmorMax(Integer _Setting) {
	G_LibGalaxyTitles_ToadsArmorMax = _Setting;
}

// ---------------------------------- //
/** Set the time before dropped weapons reappear in spawners
 *
 *	@param	_Setting	Respawn duration
 */
Void SetDroppedWeaponsLifetime(Integer _Setting) {
	G_LibGalaxyTitles_ObjectsDropLifetime = _Setting;
}

// ---------------------------------- //
/** Set maximum amount of every additional weapon slot held in the inventory

 *	@param	_Setting	Additional slots amount
 */
Void SetMaxWeapons(Integer _Setting) {
	G_LibGalaxyTitles_InventoryMaxWeapons = _Setting;
}

// ---------------------------------- //
/** Set maximum amount of Replies held in the inventory
 *
 *	@param	_Setting	Maximum Replies amount
 */
Void SetMaxReplies(Integer _Setting) {
	G_LibGalaxyTitles_InventoryMaxReplies = _Setting;
}

// ---------------------------------- //
/** Set if Fuel gives reload boost
 *
 *	@param	_Setting	If True, Fuel will give reload boost
 */
Void SetFuelGivingBoost(Boolean _Setting) {
	G_LibGalaxyTitles_FuelGivesReloadBoost = _Setting;
}