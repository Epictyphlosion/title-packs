// -------------------------------------- //
//  LIBRARY GALAXYTITLES by domino54      //
//  script version: 2017-08-09            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library contains essential features for all
 *	game modes running in the GalaxyTitles title pack:
 *	-	Spawning and managing Fuel and Armor
 *	-	Spawning Combo weapon items and managing inventory
 *	-	Spawning and managing NPC Toads
 *	-	Managing players' reload boost
 */

#Const Version		"2017-08-09"
#Const ScriptName	"Libs/domino54/ShootMania/GalaxyTitles.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/domino54/MultiClans.Script.txt" as Clans
#Include "Libs/domino54/Statistics.Script.txt" as Statistics
#Include "Libs/domino54/TopScores.Script.txt" as TopScores
#Include "Libs/domino54/ShootMania/Interfancy.Script.txt" as Interfancy
#Include "Libs/domino54/ShootMania/Inventory.Script.txt" as Inventory
#Include "Libs/domino54/ShootMania/MiniMap.Script.txt" as MiniMap
#Include "Libs/domino54/ShootMania/PlayersToads.Script.txt" as Toads
#Include "Libs/domino54/ShootMania/PlayersTurrets.Script.txt" as Turrets

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_LibGalaxyTitles_AcceptedObjects ["Armor", "Fuel", "Laser", "Nucleus", "Arrow", "Rocket", "Replie"]
#Const C_LibGalaxyTitles_WeaponItemsTags ["Laser", "Nucleus", "Arrow", "Rocket"]

/// Objects spawning
#Const C_LibGalaxyTitles_ObjectsRespawnTime		15000			///< Time before object is respawned
#Const C_LibGalaxyTitles_ObjectsDropLifetime	5000			///< Time for how long dropped weapons stay under player
#Const C_LibGalaxyTitles_ObjectsDropSpreadSize	<.5, .25, .5>	///< Size of the possible objects spread radius

/// Objects functions
#Const C_LibGalaxyTitles_ArmorPickupRadius		10.		///< Armor item healing radius
#Const C_LibGalaxyTitles_ArmorHealAmount		100		///< Armor item heal amount
#Const C_LibGalaxyTitles_FuelPickupRadius		10.		///< Fuel item bonus radius
#Const C_LibGalaxyTitles_FuelReloadMultipler	3.		///< Fuel reload bonus multipler
#Const C_LibGalaxyTitles_FuelReloadDuration		2000	///< Fuel reload bonus duration
#Const C_LibGalaxyTitles_DefaultPointsForPick	1		///< Default amount of points for affecting other player
#Const C_LibGalaxyTitles_NoteDisplayTime		1750	///< Duration of the notice display time
#Const C_LibGalaxyTitles_ReplieUseCooldown		2000	///< Time before Replie can be used again
#Const C_LibGalaxyTitles_DefaultMaxWeapons		2		///< Default maximum amount of each weapon in the Inventory
#Const C_LibGalaxyTitles_DefaultMaxReplies		3		///< Default maximum amount of Replies in the Inventory
#Const C_LibGalaxyTitles_ParticlesDuration		15		///< Duration of the Replie particles effect

/// Toads
#Const C_LibGalaxyTitles_ToadLandmarksRatio		.5		///< Minimal amount of landmark spawning Toads
#Const C_LibGalaxyTitles_ToadRespawnTime		60		///< Time before Toad is respawned
#Const C_LibGalaxyTitles_ToadChillingTime		5000	///< Toad wandering delay
#Const C_LibGalaxyTitles_ToadSaunterRadius		6.		///< Toad wandering area radius
#Const C_LibGalaxyTitles_ToadShootPeriod		1000	///< Toad shoot period
#Const C_LibGalaxyTitles_ToadSpeedPower			.25		///< Toad speed factor
#Const C_LibGalaxyTitles_ToadAmmoGain			.5		///< Toad ammo reload speed
#Const C_LibGalaxyTitles_ToadArmorMax			200		///< Amount of Toads armor points
#Const C_LibGalaxyTitles_ToadAggroRadius		8.		///< Distance within shoot provokes Toad
#Const C_LibGalaxyTitles_ToadPeaceDistance		16.		///< Distance within Toad will follow Player

/// Other
#Const C_LibGalaxyTitles_ReplieActionSlot	CSmMode::EActionSlot::Slot_H
#Const C_LibGalaxyTitles_ReplieItemId		"LibGT_Replie"
#Const C_LibGalaxyTitles_FuelItemId			"LibGT_Fuel"

/// Colors of the weapons items shown in the Minimap library
#Const C_LibGalaxyTitles_MinimapColors [
	"Laser" => <1., 0., 1.>, "Nucleus" => <1., 0., .5>, "Arrow" => <1., 0., 0.>, "Rocket" => <1., 1., 0.>
]

/// Default amount of bullets in every weapon when player spawns
#Const C_LibGalaxyTitles_InitialWeaponsAmmoMax [
	CSmMode::EWeapon::Laser => 0,
	CSmMode::EWeapon::Nucleus => 0,
	CSmMode::EWeapon::Arrow => 0,
	CSmMode::EWeapon::Rocket => 4
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[Text] G_LibGalaxyTitles_Objects;
declare Ident[Text] G_LibGalaxyTitles_Actions;

/// Global conditions
declare Boolean G_LibGalaxyTitles_LibraryLoaded;
declare Ident[] G_LibGalaxyTitles_ToadsSpawns;
declare Boolean G_LibGalaxyTitles_WeaponItemsAvailable;
declare Text[] G_LibGalaxyTitles_AvailableWeapons;
declare Boolean G_LibGalaxyTitles_RepliesAvailable;
declare Integer G_LibGalaxyTitles_ObjectsSpawnTier;
declare Integer G_LibGalaxyTitles_PrevObjectsSpawnTier;

/// Library settings
declare Integer G_LibGalaxyTitles_ToadsArmorMax;
declare Integer G_LibGalaxyTitles_PointsForPick;
declare Boolean G_LibGalaxyTitles_ObjectsAffectEveryone;
declare Integer G_LibGalaxyTitles_ObjectsDropLifetime;
declare Integer G_LibGalaxyTitles_InventoryMaxWeapons;
declare Integer G_LibGalaxyTitles_InventoryMaxReplies;
declare Boolean G_LibGalaxyTitles_FuelGivesReloadBoost;

/// Elements created within library
declare Ident[] G_LibGalaxyTitles_CreatedObjects;
declare Ident[] G_LibGalaxyTitles_SpawnedToads;
declare Text[] G_LibGalaxyTitles_MinimapMarkers;
declare Ident[Integer] G_LibGalaxyTitles_DroppedObjects;

/// Update
declare Vec3[Integer] G_LibGalaxyTitles_PrevTeamsColors;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the third team color
 *
 *	@param	_Color1		Color of the first clan
 *	@param	_Color2		Color of the second clan
 *
 *	@return		Color of the third clan
 */
Vec3 Private_GetThirdClanColor(Vec3 _Color1, Vec3 _Color2) {
	declare Vec3 Sum;
	declare Real Max;
	for (I, 0, 2) {
		Sum[I] = _Color1[I] + _Color2[I];
		if (Sum[I] > Max) Max = Sum[I];
	}
	if (Max > 0) for (I, 0, 2) Sum[I] = 1. - (Sum[I] / Max);
	Max = 0.;
	for (I, 0, 2) if (Sum[I] > Max) Max = Sum[I];
	if (Max > 0) for (I, 0, 2) Sum[I] *= 1 / Max;
	return Sum;
}

// ---------------------------------- //
/** Check if the player can use the healing ability.
 *
 *	@param	_Player		The player to check.
 *
 *	@return		True, if the player can use the healing ability.
 */
Boolean Private_CanUseHealing(CSmPlayer _Player) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return False;

	// Player can heal themselves
	if (_Player.Armor < _Player.ArmorMax) return True;
	
	// ---------------------------------- //
	// Check if players nearby can be healed
	foreach (Player in Players) {
		if (Player == _Player || Player.Armor >= Player.ArmorMax) continue;
		if (ML::Distance(_Player.Position, Player.Position) > C_LibGalaxyTitles_ArmorPickupRadius) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (Clans::AreTeammates(_Player, Player)) return True;
			if (_Player.CurrentClan == 0 || Player.CurrentClan != _Player.CurrentClan) continue;
		}
		return True;
	}

	// ---------------------------------- //
	// Check if Toads nearby can be healed
	foreach (Toad in Toads::GetToads()) {
		if (Toad.Armor >= Toad.ArmorMax) continue;
		if (ML::Distance(_Player.Position, Toad.Position) > C_LibGalaxyTitles_ArmorPickupRadius) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (Toad.Driver.Owner == _Player) return True;
			if (Clans::AreTeammates(_Player, Toad)) return True;
			if (_Player.CurrentClan == 0 || Toad.CurrentClan != _Player.CurrentClan) continue;
		}
		return True;
	}

	// ---------------------------------- //
	// Check if turrets nearby can be repaired
	foreach (Turret in Turrets::GetTurrets()) {
		if (Turret.Armor >= Turret.ArmorMax) continue;

		declare TurretPosition = Turrets::GetTurretPosition(Turret);
		if (ML::Distance(_Player.Position, TurretPosition) > C_LibGalaxyTitles_ArmorPickupRadius) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			declare TurretOwner <=> Turrets::GetTurretOwner(Turret);
			if (TurretOwner == _Player) return True; 

			declare TurretClan = Turrets::GetTurretClan(Turret);
			if (_Player.CurrentClan == 0 || TurretClan != _Player.CurrentClan) continue;
		}
		return True;
	}

	return False;
}

// ---------------------------------- //
/** Check if the player can use the boost ability.
 *
 *	@param	_Player		The player to check.
 *
 *	@return		True, if the player can use the boost ability.
 */
Boolean Private_CanUseBoost(CSmPlayer _Player) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return False;

	// ---------------------------------- //
	// Check if players nearby can be boosted
	foreach (Player in Players) {
		if (Player == _Player) continue;
		if (ML::Distance(_Player.Position, Player.Position) > C_LibGalaxyTitles_FuelPickupRadius) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (Clans::AreTeammates(_Player, Player)) return True;
			if (_Player.CurrentClan == 0 || Player.CurrentClan != _Player.CurrentClan) continue;
		}
		return True;
	}

	// ---------------------------------- //
	// Check if Toads nearby can be boosted
	foreach (Toad in Toads::GetToads()) {
		if (ML::Distance(_Player.Position, Toad.Position) > C_LibGalaxyTitles_FuelPickupRadius) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (Toad.Driver.Owner == _Player) return True;
			if (Clans::AreTeammates(_Player, Toad)) return True;
			if (_Player.CurrentClan == 0 || Toad.CurrentClan != _Player.CurrentClan) continue;
		}
		return True;
	}

	return False;
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script
 *
 *	@return		The version number of the script
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script
 *
 *	@return		The name of the script
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Remove reload boost from specific Player
 *
 *	@param	_Player		The Player to remove boost
 */
Void ClearReloadBoost(CSmPlayer _Player) {
	declare LibGalaxyTitles_BoostEndTime for _Player = -1;
	LibGalaxyTitles_BoostEndTime = -1;
}

// ---------------------------------- //
// Remove reload boost from all players
Void ClearReloadBoost() {
	foreach (Player in AllPlayers) ClearReloadBoost(Player);
}

// ---------------------------------- //
/** Destroy an object
 *
 *	@param	_Object		The object to destroy
 */
Boolean DestroyObject(CSmObject _Object) {
	if (_Object == Null || !G_LibGalaxyTitles_CreatedObjects.exists(_Object.Id)) return False;
	
	// Remove the object from the array
	declare Removed = G_LibGalaxyTitles_CreatedObjects.remove(_Object.Id);
	
	// Destroy object (unspawning the object gives a quiet sound)
	_Object.SetUnspawned();
	ObjectDestroy(_Object);
	return True;
}

// ---------------------------------- //
/// Destroy all objects 
Void DestroyLibObjects() {
	foreach (ObjectId in G_LibGalaxyTitles_CreatedObjects) {
		if (!Objects.existskey(Objects[ObjectId])) continue;
		declare Destroyed = DestroyObject(Objects[ObjectId]);
	}
	G_LibGalaxyTitles_CreatedObjects.clear();
	G_LibGalaxyTitles_DroppedObjects.clear();
	
	// Destroy markers
	foreach (MarkerTag in G_LibGalaxyTitles_MinimapMarkers) MiniMap::DestroyMarker(MarkerTag);
	G_LibGalaxyTitles_MinimapMarkers.clear();
}

// ---------------------------------- //
/// Destroy all Toads 
Void DestroyAllToads() {
	foreach (BotPlayerId in G_LibGalaxyTitles_SpawnedToads) {
		declare CSmPlayer BotPlayer;
		if (BotPlayers.existskey(BotPlayerId)) BotPlayer = BotPlayers[BotPlayerId];
		if (BotPlayer == Null) continue;
		
		UnspawnPlayer(BotPlayer);
		DestroyBotPlayer(BotPlayer);
	}
	G_LibGalaxyTitles_SpawnedToads.clear();
}

// ---------------------------------- //
/// Destroy everything
Void ResetAll() {
	ClearReloadBoost();
	DestroyLibObjects();
	DestroyAllToads();
	Inventory::ResetAllInventories();
}

// ---------------------------------- //
/// Unload library
Void Unload() {
	ResetAll();
	G_LibGalaxyTitles_ObjectsAffectEveryone = False;
	G_LibGalaxyTitles_PointsForPick = C_LibGalaxyTitles_DefaultPointsForPick;
	G_LibGalaxyTitles_ToadsArmorMax = C_LibGalaxyTitles_ToadArmorMax;
	G_LibGalaxyTitles_ObjectsDropLifetime = C_LibGalaxyTitles_ObjectsDropLifetime;
	G_LibGalaxyTitles_InventoryMaxWeapons = C_LibGalaxyTitles_DefaultMaxWeapons;
	G_LibGalaxyTitles_InventoryMaxReplies = C_LibGalaxyTitles_DefaultMaxReplies;
	G_LibGalaxyTitles_FuelGivesReloadBoost = True;
	G_LibGalaxyTitles_ObjectsSpawnTier = -1;
	G_LibGalaxyTitles_PrevObjectsSpawnTier = -1;
	G_LibGalaxyTitles_LibraryLoaded = False;
	
	// Unload libraries
	Inventory::Unload();
}

// ---------------------------------- //
/// Load library
Void Load() {
	Unload();
	G_LibGalaxyTitles_LibraryLoaded = True;
	
	// ---------------------------------- //
	// Load objects
	G_LibGalaxyTitles_Objects["Fuel"]		= ItemList_Add("SMCommon\\Collectibles\\Fuel.Item.gbx");
	G_LibGalaxyTitles_Objects["Armor"]		= ItemList_Add("SMCommon\\Pickups\\Armor.Item.gbx");
	G_LibGalaxyTitles_Objects["Laser"]		= ItemList_Add("SMCommon\\Pickups\\Laser.Item.gbx");
	G_LibGalaxyTitles_Objects["Nucleus"]	= ItemList_Add("SMCommon\\Pickups\\Nucleus.Item.gbx");
	G_LibGalaxyTitles_Objects["Arrow"]		= ItemList_Add("SMCommon\\Pickups\\Arrow.Item.gbx");
	G_LibGalaxyTitles_Objects["Rocket"]		= ItemList_Add("SMCommon\\Pickups\\Rocket.Item.gbx");
	G_LibGalaxyTitles_Objects["Replie"]		= ItemList_Add("HungerGames\\Replie.Item.gbx");
	G_LibGalaxyTitles_Objects["Toad"]		= ItemList_Add("Characters\\ToadSample.Item.Gbx");
	
	// ---------------------------------- //
	// Load actions
	G_LibGalaxyTitles_Actions["Replie"] = ActionList_Add("HungerGames\\ReplieParticles.Action.gbx");
	
	// Minimap
	MiniMap::SetIconsBasePath(C_ImgBase^"Minimap/");
	
	// ---------------------------------- //
	// Load and format Inventory
	Inventory::Load();
	Inventory::FormatInterfaceHotbar(
		<158., -74., 5.>, <8., 8.>, 1., 2.,
		CMlControl::AlignHorizontal::Right, CMlControl::AlignVertical::VCenter
	);
	Inventory::FormatLabelAmount("<label pos='4 -2.5' valign='center2' textfont='Eurostile_Bold'/>");
	Inventory::FormatLabelHotkey("<label pos='-3.5 3' valign='center2' textfont='Eurostile_Bold'/>");
	Inventory::FormatLabelCooldown("<label textsize=3 textfont='Eurostile_Bold'/>");
	Inventory::FormatQuadBackground("<quad size='8 8' image='"^C_ImgBase^"UiItemShadow.png'/>");
	Inventory::FormatQuadHighlight("<quad size='10 10' image='"^C_ImgBase^"UiCurrentWeapon.png'/>");
	Inventory::SetIconsBasePath(C_ImgBase^"Icons/");
	Inventory::SetWeaponsIcons([
		CSmMode::EWeapon::Laser		=> "Laser.png",
		CSmMode::EWeapon::Nucleus	=> "Nucleus.png",
		CSmMode::EWeapon::Arrow		=> "Arrow.png",
		CSmMode::EWeapon::Rocket	=> "Rocket.png",
		CSmMode::EWeapon::Missile	=> "Missile.png"
	]);
}

// ---------------------------------- //
/// Apply and remove reload boost to the Players
Void ReloadBoost() {
	if (Players.count <= 0 || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	foreach (Player in Players) {
		declare LibGalaxyTitles_BoostEndTime for Player = -1;
		declare LibGalaxyTitles_BoostMultipler for Player = 1.;
		declare LibGalaxyTitles_AmmoGainBase for Player = -1.;
		
		// ---------------------------------- //
		// Increase player reload speed
		if (Now < LibGalaxyTitles_BoostEndTime) {
			if (LibGalaxyTitles_AmmoGainBase < 0.) {
				LibGalaxyTitles_AmmoGainBase = Player.AmmoGain;
				Player.AmmoGain = ML::Clamp(LibGalaxyTitles_AmmoGainBase * LibGalaxyTitles_BoostMultipler, 0., 10.);
			}
		}
		// ---------------------------------- //
		// Reverse reload speed back to the old value
		else if (LibGalaxyTitles_AmmoGainBase >= 0) {
			Player.AmmoGain = ML::Clamp(LibGalaxyTitles_AmmoGainBase, 0., 10.);
			LibGalaxyTitles_AmmoGainBase = -1.;
		}
	}
}

// ---------------------------------- //
/** Give the Player reload boost for certain amount of time
 *
 *	@param	_Player			The Player to apply boost
 *	@param	_Duration		Reload boost duration
 *	@param	_Multipler		Reload boost multipler
 */
Void AddReloadBoost(CSmPlayer _Player, Integer _Duration, Real _Multipler) {
	if (_Player == Null || _Duration <= 0 || _Multipler <= 1. || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	declare LibGalaxyTitles_BoostEndTime for _Player = -1;
	declare LibGalaxyTitles_BoostMultipler for _Player = 1.;
	
	if (LibGalaxyTitles_BoostEndTime < Now) LibGalaxyTitles_BoostEndTime = Now + _Duration;
	else LibGalaxyTitles_BoostEndTime += _Duration;
	LibGalaxyTitles_BoostMultipler = _Multipler;
	Interfancy::SetPlayerReloadData(_Player, Now, LibGalaxyTitles_BoostEndTime - Now);
}

Void AddReloadBoost(CSmPlayer _Player, Integer _Duration) {
	AddReloadBoost(_Player, _Duration, C_LibGalaxyTitles_FuelReloadMultipler);
}

Void AddReloadBoost(CSmPlayer _Player, Real _Multipler) {
	AddReloadBoost(_Player, C_LibGalaxyTitles_FuelReloadDuration, _Multipler);
}

Void AddReloadBoost(CSmPlayer _Player) {
	AddReloadBoost(_Player, C_LibGalaxyTitles_FuelReloadDuration, C_LibGalaxyTitles_FuelReloadMultipler);
}

// ---------------------------------- //
/** Show healing particle effect
 *
 *	@param	_Player		The player to show particles on
 */
Void ShowHealingParticles(CSmPlayer _Player) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return;
	declare Integer ReplieParticlesEndTime for _Player;
	ReplieParticlesEndTime = Now + C_LibGalaxyTitles_ParticlesDuration;
	ActionSetVariant(_Player, C_LibGalaxyTitles_ReplieActionSlot, 1);
}

// ---------------------------------- //
/** Give armor to a player
 *
 *	@param	_Player		The player to give armor
 *	@param	_Amount		The amount of armor points to give
 */
Void GivePlayerArmor(CSmPlayer _Player, Integer _Amount) {
	if (_Player == Null || _Amount <= 0) return;
	if (_Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || _Player.Armor >= _Player.ArmorMax) return;
	
	AddPlayerArmor(_Player, _Amount, Null, 0);
	ShowHealingParticles(_Player);
}

// ---------------------------------- //
/** Load Replie particles for a player.
 *
 *	@param	_Player		The player to load particles.
 */
Void LoadReplieParticles(CSmPlayer _Player) {
	if (_Player == Null || _Player.IsBot) return;
	ActionLoad(_Player, C_LibGalaxyTitles_ReplieActionSlot, G_LibGalaxyTitles_Actions["Replie"]);
	ActionBind(_Player, C_LibGalaxyTitles_ReplieActionSlot, CSmMode::EActionInput::None);
}

// ---------------------------------- //
/** Use the healing ability of a player.
 *
 *	@param	_Player		The player who is healing.
 *
 *	@return		Amount of other entities affected by healing.
 */
Integer UseHealing(CSmPlayer _Player) {
	if (_Player == Null || !Private_CanUseHealing(_Player)) return -1;

	// Amount of each entity type
	declare NbAffected_Total = 0;
	declare Text[] AffectedPlayers;
	declare Text[] AffectedTurrets;
	declare Text[] AffectedToads;

	// Heal the player themself
	if (_Player.Armor < _Player.ArmorMax) GivePlayerArmor(_Player, C_LibGalaxyTitles_ArmorHealAmount);

	// ---------------------------------- //
	// Heal player's teammates
	foreach (Player in Players) {
		if (Player == _Player || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || Player.Armor >= Player.ArmorMax) continue;

		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (_Player.CurrentClan == 0 && !Clans::AreTeammates(Player, _Player)) continue;
			if (Player.CurrentClan != _Player.CurrentClan) continue;
		}
		if (ML::Distance(_Player.Position, Player.Position) > C_LibGalaxyTitles_ArmorPickupRadius) continue;

		// Heal the player
		GivePlayerArmor(Player, C_LibGalaxyTitles_ArmorHealAmount);
		AffectedPlayers.add(Player.User.Name);
		
		// Notify player about who healed them
		Interfancy::SendCrosshairNote(
			Player, ["$<%1$> healed you!", _Player.User.Name],
			C_LibGalaxyTitles_NoteDisplayTime
		);
	}

	// ---------------------------------- //
	// Heal Toads nearby
	foreach (Toad in Toads::GetToads()) {
		if (Toad.Armor >= Toad.ArmorMax) continue;
		if (Toad.Driver.Owner != _Player && !G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (_Player.CurrentClan == 0 && !Clans::AreTeammates(Toad, _Player)) continue;
			if (Toad.CurrentClan != _Player.CurrentClan) continue;
		}
		if (ML::Distance(_Player.Position, Toad.Position) > C_LibGalaxyTitles_ArmorPickupRadius) continue;
		
		// Heal the Toad
		GivePlayerArmor(Toad, C_LibGalaxyTitles_ArmorHealAmount);
		AffectedToads.add(Toad.Driver.Owner.User.Name);
	}

	// ---------------------------------- //
	// Repair nearby turrets
	foreach (Turret in Turrets::GetTurrets()) {
		if (Turret.Armor >= Turret.ArmorMax) continue;

		declare TurretPosition = Turrets::GetTurretPosition(Turret);
		if (ML::Distance(_Player.Position, TurretPosition) > C_LibGalaxyTitles_ArmorPickupRadius) continue;
		declare TurretOwner <=> Turrets::GetTurretOwner(Turret);

		if (TurretOwner != _Player && !G_LibGalaxyTitles_ObjectsAffectEveryone) {
			declare TurretClan = Turrets::GetTurretClan(Turret);
			if (TurretOwner == Null || TurretClan != _Player.CurrentClan) continue;
		}

		Turret.Armor += C_LibGalaxyTitles_ArmorHealAmount;
		AffectedTurrets.add(TurretOwner.User.Name);

		// Notify th eowner their turret was healed
		if (TurretOwner != _Player) Interfancy::SendCrosshairNote(
			TurretOwner, ["$<%1$> healed your turret!", _Player.User.Name],
			C_LibGalaxyTitles_NoteDisplayTime
		);
	}
	
	// ---------------------------------- //
	// Notify player how many entities they've healed
	NbAffected_Total = AffectedPlayers.count + AffectedTurrets.count + AffectedToads.count;
	if (NbAffected_Total > 0) {
		declare Message = Text[];

		// Healed only players
		if (AffectedPlayers.count == NbAffected_Total) {
			if (AffectedPlayers.count == 1) Message = ["Healed $<%1$>", AffectedPlayers[0]];
			else Message = ["Healed %1 players", TL::ToText(AffectedPlayers.count)];
		}

		// Healed only turrets
		else if (AffectedTurrets.count == NbAffected_Total) {
			if (AffectedTurrets.count == 1) {
				if (AffectedTurrets[0] == _Player.User.Name) Message = ["Healed your turret"];
				else Message = ["Healed turret of $<%1$>", AffectedTurrets[0]];
			}
			else Message = ["Healed %1 turrets", TL::ToText(AffectedTurrets.count)];
		}

		// Healed only toads
		else if (AffectedToads.count == NbAffected_Total) {
			if (AffectedToads.count == 1) {
				if (AffectedToads[0] == _Player.User.Name) Message = ["Healed your Toad"];
				else Message = ["Healed Toad of $<%1$>", AffectedToads[0]];
			}
			else Message = ["Healed %1 Toads", TL::ToText(AffectedToads.count)];
		}

		// Healed multiple types of entities
		else Message = ["Healed %1 entities", TL::ToText(NbAffected_Total)];

		Interfancy::SendCrosshairNote(_Player, Message, C_LibGalaxyTitles_NoteDisplayTime);
		Statistics::TrackEvent(_Player, "PlayersHealed", NbAffected_Total);
	}

	return NbAffected_Total;
}

// ---------------------------------- //
/** Use the boost ability of a player.
 *
 *	@param	_Player		The player who is boosting.
 *
 *	@return		Amount of other entities affected by the boost.
 */
Integer UseBoost(CSmPlayer _Player) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return -1;
	declare Integer LibGalaxyTitles_SuppliesCooldown for _Player;

	// Amount of each entity type
	declare NbAffected_Total = 0;
	declare Text[] AffectedPlayers;
	declare Text[] AffectedToads;

	// Boost the player themself
	if (LibGalaxyTitles_SuppliesCooldown <= 0) {
		if (G_LibGalaxyTitles_FuelGivesReloadBoost) AddReloadBoost(_Player);
		_Player.Stamina = ML::FloorInteger(_Player.StaminaMax * 3600);
	}

	// ---------------------------------- //
	// Boost player's teammates
	foreach (Player in Players) {
		if (Player == _Player || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
		if (!G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (_Player.CurrentClan == 0 && !Clans::AreTeammates(Player, _Player)) continue;
			if (Player.CurrentClan != _Player.CurrentClan) continue;
		}
		if (ML::Distance(_Player.Position, Player.Position) > C_LibGalaxyTitles_FuelPickupRadius) continue;

		// Boost the player
		if (G_LibGalaxyTitles_FuelGivesReloadBoost) AddReloadBoost(Player);
		Player.Stamina = ML::FloorInteger(Player.StaminaMax * 3600);
		AffectedPlayers.add(Player.User.Name);
		
		// Notify player about who boosted them
		Interfancy::SendCrosshairNote(
			Player, ["$<%1$> boosted you!", _Player.User.Name],
			C_LibGalaxyTitles_NoteDisplayTime
		);
	}

	// ---------------------------------- //
	// Boost Toads nearby
	foreach (Toad in Toads::GetToads()) {
		if (Toad.Driver.Owner != _Player && !G_LibGalaxyTitles_ObjectsAffectEveryone) {
			if (_Player.CurrentClan == 0 && !Clans::AreTeammates(Toad, _Player)) continue;
			if (Toad.CurrentClan != _Player.CurrentClan) continue;
		}
		if (ML::Distance(_Player.Position, Toad.Position) > C_LibGalaxyTitles_FuelPickupRadius) continue;

		// Noost the Toad
		if (G_LibGalaxyTitles_FuelGivesReloadBoost) AddReloadBoost(Toad);
		Toad.Stamina = ML::FloorInteger(Toad.StaminaMax * 3600);
		AffectedToads.add(Toad.Driver.Owner.User.Name);
	}

	// ---------------------------------- //
	// Notify player how many entities they've boosted
	NbAffected_Total = AffectedPlayers.count + AffectedToads.count;
	if (NbAffected_Total > 0) {
		declare Message = Text[];

		// Boosted only players
		if (AffectedPlayers.count == NbAffected_Total) {
			if (AffectedPlayers.count == 1) Message = ["Boosted $<%1$>", AffectedPlayers[0]];
			else Message = ["Boosted %1 players", TL::ToText(AffectedPlayers.count)];
		}

		// Boosted only toads
		else if (AffectedToads.count == NbAffected_Total) {
			if (AffectedToads.count == 1) {
				if (AffectedToads[0] == _Player.User.Name) Message = ["Boosted your Toad"];
				else Message = ["Boosted Toad of $<%1$>", AffectedToads[0]];
			}
			else Message = ["Boosted %1 Toads", TL::ToText(AffectedToads.count)];
		}

		// Boosted multiple types of entities
		else Message = ["Boosted %1 entities", TL::ToText(NbAffected_Total)];

		Interfancy::SendCrosshairNote(_Player, Message, C_LibGalaxyTitles_NoteDisplayTime);
		Statistics::TrackEvent(_Player, "PlayersBoosted", NbAffected_Total);
	}

	return NbAffected_Total;
}

// ---------------------------------- //
/** Destroy all objects and reset landmarks settings
 *
 *	@param	_UseWeapons		Enable weapons pickups (if available to be picked up on map)
 *	@param	_UseReplies		Evable Replies objects (if available to be picked up on map)
 */
Void InitObjects(Boolean _UseWeapons, Boolean _UseReplies) {
	DestroyLibObjects();
	G_LibGalaxyTitles_WeaponItemsAvailable = False;
	G_LibGalaxyTitles_RepliesAvailable = False;
	G_LibGalaxyTitles_AvailableWeapons.clear();
	
	if (!G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Reset landmarks
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
		declare Integer LibGalaxyTitles_ObjectNextSpawn for MapLandmark;
		declare Ident LibGalaxyTitles_ObjectPlayerId for MapLandmark;
		LibGalaxyTitles_ObjectSpawned = False;
		LibGalaxyTitles_ObjectNextSpawn = Now;
		LibGalaxyTitles_ObjectPlayerId = NullId;
		
		// Tell the library to use weapons
		if (
			_UseWeapons && G_LibGalaxyTitles_InventoryMaxWeapons != 0 &&
			C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)
		) {
			G_LibGalaxyTitles_WeaponItemsAvailable = True;
			if (!G_LibGalaxyTitles_AvailableWeapons.exists(MapLandmark.Tag))
				G_LibGalaxyTitles_AvailableWeapons.add(MapLandmark.Tag);
		}

		// Check if Replies are available
		if (_UseReplies && G_LibGalaxyTitles_InventoryMaxReplies != 0 && MapLandmark.Tag == "Replie")
			G_LibGalaxyTitles_RepliesAvailable = True;
	}

	// ---------------------------------- //
	// Clear players weapons
	foreach (Player in AllPlayers) {
		declare Ident[] PlayerWeaponsToDrop for Player;
		PlayerWeaponsToDrop.clear();
	}
}

// ---------------------------------- //
/** Destroy all objects and reset landmarks settings
 *
 *	@param	_UseWeaponsAndReplies	Enable weapons pickups and Replies objects (if available to be picked up on map)
 */
Void InitObjects(Boolean _UseWeaponsAndReplies) { InitObjects(_UseWeaponsAndReplies, _UseWeaponsAndReplies); }

// ---------------------------------- //
/// Destroy all objects and reset landmarks settings
Void InitObjects() { InitObjects(True); }

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag, Ident _AnchorId) {
	if (!C_LibGalaxyTitles_AcceptedObjects.exists(_ObjectTag)) return Null;
	
	// Check if the given id belongs to a real object anchor landmark
	declare AnchorId = NullId;
	if (MapLandmarks_ObjectAnchor.existskey(_AnchorId)) AnchorId = _AnchorId;
	
	// Incorrect attributes
	if (_Position == <0., 0., 0.> && AnchorId == NullId) return Null;
	
	// ---------------------------------- //
	// Create the object
	declare CSmObject Object;
	switch (_ObjectTag) {
		case "Armor"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Armor"]);
		case "Laser"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Laser"]);
		case "Nucleus"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Nucleus"]);
		case "Arrow"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Arrow"]);
		case "Rocket"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Rocket"]);
		case "Fuel"		: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Fuel"]);
		case "Replie"	: Object = ObjectCreate(G_LibGalaxyTitles_Objects["Replie"]);
	}
	if (Object == Null) return Null;
	
	// ---------------------------------- //
	// Set object properties
	declare Ident LibGalaxyTitles_AnchorId for Object;
	declare Text LibGalaxyTitles_ObjectTag for Object;
	LibGalaxyTitles_AnchorId = AnchorId;
	LibGalaxyTitles_ObjectTag = _ObjectTag;
	
	// Spawn object
	if (_AnchorId != NullId) {
		declare MapLandmark <=> MapLandmarks[AnchorId];
		Object.SetAnchor(MapLandmark.ObjectAnchor);
	}
	else Object.SetPosition(_Position);
	G_LibGalaxyTitles_CreatedObjects.add(Object.Id);
	return Object;
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag) { return SpawnObject(_Position, _ObjectTag, NullId); }

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Ident _AnchorId, Text _ObjectTag) { return SpawnObject(Vec3, _ObjectTag, _AnchorId); }

// ---------------------------------- //
/** Spawn objects on landmarks
 *
 *	@param	_SpawnObjects	If False, objects won't be spawned
 */
Void SpawnObjects(Boolean _SpawnObjects) {
	if (!_SpawnObjects || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Drop weapons under eliminated players
	foreach (Player in Players) {
		// Discard drop when it's disabled by game mode
		if (G_LibGalaxyTitles_ObjectsDropLifetime <= 0) continue;
		
		declare Integer LastTimeInOffZone for Player;
		if (Player.IsInOffZone) LastTimeInOffZone = Now;
		
		// Don't drop items, when player is still alive (not in Portals) or if player was eliminated by OffZone
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned || Now < LastTimeInOffZone + 250) continue;
		
		// Get Ids of the object anchors
		declare Ident[] PlayerWeaponsToDrop for Player;
		if (PlayerWeaponsToDrop.count <= 0) continue;

		foreach (MapLandmarkId in PlayerWeaponsToDrop) {
			if (!MapLandmarks_ObjectAnchor.existskey(MapLandmarkId)) continue;
			declare MapLandmark <=> MapLandmarks_ObjectAnchor[MapLandmarkId];
			declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
			
			// Get the target position of an object
			declare Position = Player.Position;
			for (I, 0, 2) Position[I] += C_LibGalaxyTitles_ObjectsDropSpreadSize[I] * ML::Rand(-1., 1.);
			
			// ---------------------------------- //
			// Create object
			declare Object = SpawnObject(Position, MapLandmark.Tag);
			LibGalaxyTitles_ObjectSpawned = Object != Null;
			if (!LibGalaxyTitles_ObjectSpawned) continue;
			
			// Reset weapon carrier
			declare Ident LibGalaxyTitles_ObjectPlayerId for MapLandmark;
			LibGalaxyTitles_ObjectPlayerId = NullId;

			// Save anchor id in the object
			declare Ident LibGalaxyTitles_AnchorId for Object;
			LibGalaxyTitles_AnchorId = MapLandmarkId;
			
			// Create weapon marker
			if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
				declare MarkerTag = "Object#"^MapLandmark.Id;
				MiniMap::SetMarker(
					MarkerTag, MapLandmark.Tag^".png",
					C_LibGalaxyTitles_MinimapColors[MapLandmark.Tag], Position
				);
				G_LibGalaxyTitles_MinimapMarkers.add(MarkerTag);
			}
			
			// Save object Id in dropped objects array
			declare SpawnTime = Now;
			while (G_LibGalaxyTitles_DroppedObjects.existskey(SpawnTime)) SpawnTime += 1;
			G_LibGalaxyTitles_DroppedObjects[SpawnTime] = Object.Id;
		}
	}
	
	// ---------------------------------- //
	// Get the timed out objects
	declare Ident[] ObjectsToDestroy;
	foreach (SpawnTime => ObjectId in G_LibGalaxyTitles_DroppedObjects)
		if (Now > SpawnTime + G_LibGalaxyTitles_ObjectsDropLifetime) ObjectsToDestroy.add(ObjectId);
	
	// ---------------------------------- //
	// Destroy objects on tier change
	if (G_LibGalaxyTitles_PrevObjectsSpawnTier != G_LibGalaxyTitles_ObjectsSpawnTier) {
		G_LibGalaxyTitles_PrevObjectsSpawnTier = G_LibGalaxyTitles_ObjectsSpawnTier;

		foreach (ObjectId in G_LibGalaxyTitles_CreatedObjects) {
			if (G_LibGalaxyTitles_ObjectsSpawnTier < 0) break;
			if (!Objects.existskey(ObjectId)) continue;
			declare Object <=> Objects[ObjectId];

			declare Ident LibGalaxyTitles_AnchorId for Object;
			if (LibGalaxyTitles_AnchorId == NullId || !MapLandmarks.existskey(LibGalaxyTitles_AnchorId)) continue;
			declare MapLandmark <=> MapLandmarks[LibGalaxyTitles_AnchorId];

			if (MapLandmark.Order != G_LibGalaxyTitles_ObjectsSpawnTier) ObjectsToDestroy.add(ObjectId);
		}
	}

	// ---------------------------------- //
	// Destroy timed out dropped objects
	foreach (ObjectId in ObjectsToDestroy) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object <=> Objects[ObjectId];
		declare Ident LibGalaxyTitles_AnchorId for Object;
		
		// Remove object from custom array
		declare Removed = G_LibGalaxyTitles_DroppedObjects.remove(ObjectId);
		
		// ---------------------------------- //
		// Update landmark information
		if (MapLandmarks_ObjectAnchor.existskey(LibGalaxyTitles_AnchorId)) {
			declare MapLandmark <=> MapLandmarks_ObjectAnchor[LibGalaxyTitles_AnchorId];
			declare Boolean LibGalaxyTitles_ObjectSpawned for MapLandmark;
			declare Ident LibGalaxyTitles_ObjectPlayerId for MapLandmark;
			LibGalaxyTitles_ObjectSpawned = False;
			LibGalaxyTitles_ObjectPlayerId = NullId;

			// ---------------------------------- //
			// Destroy weapon marker
			declare MarkerTag = "Object#"^LibGalaxyTitles_AnchorId;
			MiniMap::DestroyMarker(MarkerTag);
			Removed = G_LibGalaxyTitles_MinimapMarkers.remove(MarkerTag);
		}

		declare Destroyed = DestroyObject(Object);
	}
	
	// ---------------------------------- //
	// Spawn objects on landmarks
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare LibGalaxyTitles_ObjectSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ObjectNextSpawn for MapLandmark = Now;
		declare LibGalaxyTitles_ObjectPlayerId for MapLandmark = NullId;
		
		// ---------------------------------- //
		// Continue if landmark has object, the object is dropped somewhere else or object can't be spawned
		if (LibGalaxyTitles_ObjectSpawned || LibGalaxyTitles_ObjectNextSpawn > Now) continue;

		// ---------------------------------- //
		// Continue if object doesn't  belong to the current tier
		if (G_LibGalaxyTitles_ObjectsSpawnTier >= 0 && MapLandmark.Order != G_LibGalaxyTitles_ObjectsSpawnTier) continue;
		
		// ---------------------------------- //
		// Continue if landmark spawns weapons when they're not available
		if (!G_LibGalaxyTitles_WeaponItemsAvailable && C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) continue;
		
		// ---------------------------------- //
		// Continue if landmark spawns Replie when they're not available
		if (!G_LibGalaxyTitles_RepliesAvailable && MapLandmark.Tag == "Replie") continue;
		
		// ---------------------------------- //
		// Continue if weapon is carried by the player
		if (
			LibGalaxyTitles_ObjectPlayerId != NullId &&
			Players.existskey(LibGalaxyTitles_ObjectPlayerId) &&
			Players[LibGalaxyTitles_ObjectPlayerId].SpawnStatus == CSmPlayer::ESpawnStatus::Spawned
		) continue;
		
		// ---------------------------------- //
		// Create object
		declare Object = SpawnObject(MapLandmark.Id, MapLandmark.Tag);
		LibGalaxyTitles_ObjectSpawned = Object != Null;
		if (LibGalaxyTitles_ObjectSpawned == False) continue;
		
		// Reset weapon carrier
		LibGalaxyTitles_ObjectPlayerId = NullId;
		
		// Create weapon marker
		if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
			declare MarkerTag = "Object#"^MapLandmark.Id;
			MiniMap::SetMarker(
				MarkerTag, MapLandmark.Tag^".png",
				C_LibGalaxyTitles_MinimapColors[MapLandmark.Tag], MapLandmark.Position
			);
			G_LibGalaxyTitles_MinimapMarkers.add(MarkerTag);
		}
	}
}

// ---------------------------------- //
/// Spawn objects on landmarks
Void SpawnObjects() { SpawnObjects(True); }

// ---------------------------------- //
/** Set the objects spawn tier. Objects will only spawn on
 *	landmark with order specified by this function.
 *
 *	@param	_SpawnTier		Order of the landmarks that will spawn objects.
 */
Void SetObjectsSpawnTier(Integer _SpawnTier) {
	G_LibGalaxyTitles_ObjectsSpawnTier = ML::Max(_SpawnTier, -1);
}

// ---------------------------------- //
/// Reset the objects spawn tier.
Void ResetObjectsSpawnTier() {
	SetObjectsSpawnTier(-1);
}

// ---------------------------------- //
/** Pick up object
 *
 *	@param	_Event			The event to proceed
 *	@param	_RespawnTime	Time before object will be spawned again after pick
 *	@param	_TrueIfPick		If True, event is not discarded and returns True only if item was picked up
 *
 *	@return		True, if the item is handled by the library
 */
Boolean PickUpObject(CSmModeEvent _Event, Integer _RespawnTime, Boolean _TrueIfPick) {
	if (
		_Event == Null || _Event.Type != CSmModeEvent::EType::OnPlayerTouchesObject ||
		_Event.Object == Null || !G_LibGalaxyTitles_LibraryLoaded || _Event.Player == Null
	) return False;
	
	declare Text LibGalaxyTitles_ObjectTag for _Event.Object;
	declare Ident LibGalaxyTitles_AnchorId for _Event.Object;
	
	// Return False if object is not handled by GalaxyTitles library
	if (!C_LibGalaxyTitles_AcceptedObjects.exists(LibGalaxyTitles_ObjectTag)) return False;
	
	if (!_TrueIfPick) Discard(_Event);

	if (_Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return !_TrueIfPick;

	// ---------------------------------- //
	// Get the player (if Toad has owner, pick up the item for the owner)
	declare Player <=> _Event.Player;
	if (Player.IsBot) {
		if (Player.Driver.Owner == Null || Player.Driver.Owner.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) return !_TrueIfPick;
		else Player <=> Player.Driver.Owner;
	}

	// ---------------------------------- //
	// Pick conditions
	declare Boolean LibGalaxyTitles_DisablePickUpWeapons for Player;
	declare Boolean LibGalaxyTitles_DisablePickUpSupplies for Player;
	declare CanPickUpObject = True;
	
	switch (LibGalaxyTitles_ObjectTag) {
		// ---------------------------------- //
		// Armor conditions
		case "Armor" : CanPickUpObject = Private_CanUseHealing(Player);
		
		// ---------------------------------- //
		// Replie conditions
		case "Replie" : {
			// Player can't hold any Replies
			if (G_LibGalaxyTitles_InventoryMaxReplies == 0 || LibGalaxyTitles_DisablePickUpSupplies) CanPickUpObject = False;
			
			// Limited Replies amount
			else if (G_LibGalaxyTitles_InventoryMaxReplies > 0) {
				declare PlayerReplies = Inventory::GetItemAmount(Player, C_LibGalaxyTitles_ReplieItemId);
				CanPickUpObject = PlayerReplies < G_LibGalaxyTitles_InventoryMaxReplies;
			}
		}
		// ---------------------------------- //
		// Fuel conditions
		case "Fuel" : CanPickUpObject = !LibGalaxyTitles_DisablePickUpSupplies;

		// ---------------------------------- //
		// Weapons conditions
		default : if (C_LibGalaxyTitles_WeaponItemsTags.exists(LibGalaxyTitles_ObjectTag)) {
			// Player can't hold any additional weapons
			if (G_LibGalaxyTitles_InventoryMaxWeapons == 0 || LibGalaxyTitles_DisablePickUpWeapons) CanPickUpObject = False;
			
			// Limited weapons amount
			else if (G_LibGalaxyTitles_InventoryMaxWeapons > 0) {
				declare CSmMode::EWeapon Weapon;
				switch (LibGalaxyTitles_ObjectTag) {
					case "Laser" : Weapon = CSmMode::EWeapon::Laser;
					case "Nucleus" : Weapon = CSmMode::EWeapon::Nucleus;
					case "Arrow" : Weapon = CSmMode::EWeapon::Arrow;
					default : Weapon = CSmMode::EWeapon::Rocket;
				}
				
				declare PlayerHasWeapon = Inventory::HasWeapon(Player, Weapon);
				declare PlayerWeaponAmmoMax = Inventory::GetWeaponSlots(Player, Weapon);
				CanPickUpObject = PlayerHasWeapon && PlayerWeaponAmmoMax < C_LibGalaxyTitles_InitialWeaponsAmmoMax[Weapon] + G_LibGalaxyTitles_InventoryMaxWeapons;
			}
		}
	}
	
	// Continue, if the object can't be picked up
	if (!CanPickUpObject) return !_TrueIfPick;
	
	// ---------------------------------- //
	// Item respawn timer
	if (MapLandmarks_ObjectAnchor.existskey(LibGalaxyTitles_AnchorId)) {
		declare MapLandmark <=> MapLandmarks_ObjectAnchor[LibGalaxyTitles_AnchorId];
		declare LibGalaxyTitles_ObjectSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ObjectNextSpawn for MapLandmark = Now;
		declare LibGalaxyTitles_ObjectPlayerId for MapLandmark = NullId;
		
		LibGalaxyTitles_ObjectSpawned = False;
		LibGalaxyTitles_ObjectNextSpawn = Now + _RespawnTime;
		
		// ---------------------------------- //
		// Set weapon carrier
		if (C_LibGalaxyTitles_WeaponItemsTags.exists(MapLandmark.Tag)) {
			LibGalaxyTitles_ObjectNextSpawn = Now;
			LibGalaxyTitles_ObjectPlayerId = Player.Id;
			
			// ---------------------------------- //
			// Destroy weapon marker
			declare MarkerTag = "Object#"^MapLandmark.Id;
			MiniMap::DestroyMarker(MarkerTag);
			declare Removed = G_LibGalaxyTitles_MinimapMarkers.remove(MarkerTag);
		}
	}
	
	// ---------------------------------- //
	// Apply effect
	declare NbAffected_Total = 0;
	declare NbAffected_Players = 0;
	declare NbAffected_Turrets = 0;
	declare Message = Text[];
	
	switch (LibGalaxyTitles_ObjectTag) {
		// Armor - heal players
		case "Armor" : NbAffected_Total = UseHealing(Player);

		// Fuel - reload boost and stamina
		case "Fuel" : NbAffected_Total = UseBoost(Player);
		
		// Give Laser weapon slot
		case "Laser" : Inventory::AddWeaponSlots(Player, CSmMode::EWeapon::Laser, 1);
		
		// Give Nucleus weapon slot
		case "Nucleus" : Inventory::AddWeaponSlots(Player, CSmMode::EWeapon::Nucleus, 1);
		
		// Give Arrow weapon slot
		case "Arrow" : Inventory::AddWeaponSlots(Player, CSmMode::EWeapon::Arrow, 1);
		
		// Give Rocket weapon slot
		case "Rocket" : Inventory::AddWeaponSlots(Player, CSmMode::EWeapon::Rocket, 1);
		
		// Give Replie consumable item
		case "Replie" : {
			Inventory::AddItems(Player, C_LibGalaxyTitles_ReplieItemId, 1);
			Interfancy::SendCrosshairNote(Player, ["+1 $<%1$>", "Replie"], C_LibGalaxyTitles_NoteDisplayTime);
		}
	}
	
	// ---------------------------------- //
	// Send notice and give points if player has affected somebody
	if (NbAffected_Total > 0) {
		Score::AddPoints(Player, NbAffected_Total * G_LibGalaxyTitles_PointsForPick);
		TopScores::AddPoints(Player.Score, "Support", NbAffected_Total * G_LibGalaxyTitles_PointsForPick);
	}
	
	if (C_LibGalaxyTitles_WeaponItemsTags.exists(LibGalaxyTitles_ObjectTag)) {
		// ---------------------------------- //
		// Crosshair notice on weapon added
		Interfancy::SendCrosshairNote(Player, ["+1 $<%1$>", LibGalaxyTitles_ObjectTag], C_LibGalaxyTitles_NoteDisplayTime);
		
		// ---------------------------------- //
		// Add weapon to drop
		declare Ident[] PlayerWeaponsToDrop for Player;
		if (!PlayerWeaponsToDrop.exists(LibGalaxyTitles_AnchorId)) PlayerWeaponsToDrop.add(LibGalaxyTitles_AnchorId);
	}
	
	// Destroy the object
	declare Destroyed = DestroyObject(_Event.Object);
	return True;
}

Boolean PickUpObject(CSmModeEvent _Event, Boolean _TrueIfPick) {
	return PickUpObject(_Event, C_LibGalaxyTitles_ObjectsRespawnTime, _TrueIfPick);
}

Boolean PickUpObject(CSmModeEvent _Event, Integer _RespawnTime) {
	return PickUpObject(_Event, _RespawnTime, False);
}

Boolean PickUpObject(CSmModeEvent _Event) {
	return PickUpObject(_Event, C_LibGalaxyTitles_ObjectsRespawnTime, False);
}

// ---------------------------------- //
/** Get the Toad player model.
 *
 *	@preturn	Toad player model.
 */
Ident GetToadModel() {
	if (!G_LibGalaxyTitles_Objects.existskey("Toad")) return NullId;
	return G_LibGalaxyTitles_Objects["Toad"];
}

// ---------------------------------- //
/** Initialize Toads spawn landmarks
 *
 *	@param	_ToadsSpawnRatio	Target ratio of landmarks spawning Toads to all landmarks
 */
Void InitToads(Real _ToadsSpawnRatio) {
	DestroyAllToads();
	G_LibGalaxyTitles_ToadsSpawns.clear();
	if (MapLandmarks_BotPath.count <= 0 || _ToadsSpawnRatio <= 0 || !G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Use only BotPaths with the default tag
	declare Ident[] CompatibleLandmarks;
	foreach (MapLandmark in MapLandmarks_BotPath) if (MapLandmark.Tag == "BotPath") CompatibleLandmarks.add(MapLandmark.Id);
	if (CompatibleLandmarks.count <= 0) return;
	
	// ---------------------------------- //
	// Reset Toads information in landmarks
	foreach (MapLandmark in MapLandmarks_BotPath) {
		if (!CompatibleLandmarks.exists(MapLandmark.Id)) continue;
		declare Boolean LibGalaxyTitles_ToadSpawned for MapLandmark;
		declare Integer LibGalaxyTitles_ToadNextSpawn for MapLandmark;
		LibGalaxyTitles_ToadSpawned = False;
		LibGalaxyTitles_ToadNextSpawn = Now;
	}
	
	// ---------------------------------- //
	// Select landmark what will spawn Toads
	declare LandmarksRatio = 0.;
	while (True) {
		declare Ident LandmarkId;
		LandmarkId = NullId;
		
		while (True) {
			LandmarkId = CompatibleLandmarks[ML::Rand(0, CompatibleLandmarks.count - 1)];
			if (!G_LibGalaxyTitles_ToadsSpawns.exists(LandmarkId)) break;
		}
		
		G_LibGalaxyTitles_ToadsSpawns.add(LandmarkId);
		LandmarksRatio = ML::ToReal(G_LibGalaxyTitles_ToadsSpawns.count) / CompatibleLandmarks.count;
		if (LandmarksRatio >= _ToadsSpawnRatio || G_LibGalaxyTitles_ToadsSpawns.count >= CompatibleLandmarks.count) break;
	}
}

// ---------------------------------- //
/// Initialize Toads spawn landmarks with default spawn ratio 
Void InitToads() { InitToads(C_LibGalaxyTitles_ToadLandmarksRatio); }

// ---------------------------------- //
/** Manage everything related to Toads
 *
 *	@param	_ToadsRespawnTime	Time before Toad will respawn after elimination
 */
Void ToadsLoop(Integer _ToadsRespawnTime) {
	if (!G_LibGalaxyTitles_LibraryLoaded) return;
	
	// ---------------------------------- //
	// Spawn Toads
	if (OffZoneRadius <= 0) foreach (MapLandmark in MapLandmarks_BotPath) {
		if (_ToadsRespawnTime <= 0 || !G_LibGalaxyTitles_ToadsSpawns.exists(MapLandmark.Id)) continue;
		
		declare LibGalaxyTitles_ToadSpawned for MapLandmark = False;
		declare LibGalaxyTitles_ToadNextSpawn for MapLandmark = Now;
		
		// ---------------------------------- //
		// Continue if landmark can't spawn Toad or if Toad is already spawned
		if (LibGalaxyTitles_ToadSpawned || LibGalaxyTitles_ToadNextSpawn > Now) continue;
		
		// ---------------------------------- //
		// Create Toad
		declare Toad <=> CreateBotPlayer(GetToadModel(), 0);
		
		// ---------------------------------- //
		// Define behaviour depending on amount of path points
		if (MapLandmark.BotPath.Path.count > 1) {
			Toad.Driver.Behaviour = CSmPlayerDriver::ESmDriverBehaviour::Patrol;
			if (
				MapLandmark.BotPath.Path.count >= 3 &&
				ML::Distance(MapLandmark.BotPath.Path[0], MapLandmark.BotPath.Path[MapLandmark.BotPath.Path.count-1]) <= 8.
			)
				Toad.Driver.Patrol_Mode = CSmPlayerDriver::ESmDriverPatrolMode::Loop;
			else
				Toad.Driver.Patrol_Mode = CSmPlayerDriver::ESmDriverPatrolMode::BackAndForth;
		} else
			Toad.Driver.Behaviour = CSmPlayerDriver::ESmDriverBehaviour::Saunter;
		
		// ---------------------------------- //
		// Configure Toad
		Toad.Driver.AttackFilter = CSmPlayerDriver::ESmAttackFilter::Nobody;
		Toad.Driver.Saunter_BaseChillingTime	= C_LibGalaxyTitles_ToadChillingTime;
		Toad.Driver.Saunter_ChillingTimeDelta	= 0;
		Toad.Driver.Saunter_Radius	= C_LibGalaxyTitles_ToadSaunterRadius;
		Toad.Driver.ShootPeriodMin	= C_LibGalaxyTitles_ToadShootPeriod;
		Toad.Driver.ShootPeriodMax	= C_LibGalaxyTitles_ToadShootPeriod;
		Toad.Driver.AggroRadius		= C_LibGalaxyTitles_ToadPeaceDistance;
		Toad.Driver.DisengageDistance	= C_LibGalaxyTitles_ToadPeaceDistance;
		Toad.SpeedPower	= C_LibGalaxyTitles_ToadSpeedPower;
		Toad.AmmoGain	= C_LibGalaxyTitles_ToadAmmoGain;
		Toad.ArmorMax	= G_LibGalaxyTitles_ToadsArmorMax;
		Toad.ForceColor	= Private_GetThirdClanColor(Teams[0].ColorPrimary, Teams[1].ColorPrimary);
		
		// ---------------------------------- //
		// Spawn Toad
		declare Ident LibGalaxyTitles_AnchorId for Toad;
		LibGalaxyTitles_AnchorId = MapLandmark.Id;
		
		SpawnBotPlayer(Toad, 0, Toad.ArmorMax, MapLandmark.BotPath, Now);
		G_LibGalaxyTitles_SpawnedToads.add(Toad.Id);
		LibGalaxyTitles_ToadSpawned = True;
	}
	
	// ---------------------------------- //
	// Manage events
	foreach (Event in PendingEvents) {
		// ---------------------------------- //
		// Respawn eliminated Toads
		if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id)) {
				declare Ident LibGalaxyTitles_AnchorId for Event.Victim;
				if (MapLandmarks_BotPath.existskey(LibGalaxyTitles_AnchorId)) {
					declare MapLandmark <=> MapLandmarks_BotPath[LibGalaxyTitles_AnchorId];
					declare Boolean LibGalaxyTitles_ToadSpawned for MapLandmark = False;
					declare Integer LibGalaxyTitles_ToadNextSpawn for MapLandmark = Now;
					LibGalaxyTitles_ToadSpawned = False;
					LibGalaxyTitles_ToadNextSpawn = Now + _ToadsRespawnTime;
				}
				
				// Destroy Toad
				declare Removed = G_LibGalaxyTitles_SpawnedToads.remove(Event.Victim.Id);
				DestroyBotPlayer(Event.Victim);
			}
		}
		// ---------------------------------- //
		// Make player who shoot the Toad its target
		else if (Event.Type == CSmModeEvent::EType::OnHit) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id))
				Event.Victim.Driver.ForcedTarget = Event.Shooter;
		}
		// ---------------------------------- //
		// Make the Player shooting near Toad its target
		else if (Event.Type == CSmModeEvent::EType::OnShoot) {
			if (Event.Shooter != Null && !Event.Shooter.IsBot) {
				foreach (BotPlayer in BotPlayers) {
					if (
						G_LibGalaxyTitles_SpawnedToads.exists(BotPlayer.Id) &&
						ML::Distance(BotPlayer.Position, Event.Shooter.Position) <= C_LibGalaxyTitles_ToadAggroRadius
					)
						BotPlayer.Driver.ForcedTarget = Event.Shooter;
				}
			}
		}
		// ---------------------------------- //
		// Attack the Player if missed a Toad
		else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
			if (Event.Victim != Null && G_LibGalaxyTitles_SpawnedToads.exists(Event.Victim.Id))
				Event.Victim.Driver.ForcedTarget = Event.Shooter;
		}
	}
	
	// ---------------------------------- //
	// Manage Toads functions
	foreach (BotPlayer in BotPlayers) {
		if (!G_LibGalaxyTitles_SpawnedToads.exists(BotPlayer.Id)) continue;
		
		// ---------------------------------- //
		// Make player touching Toad its target
		if (BotPlayer.Driver.ForcedTarget == Null) {
			foreach (Player in Players) {
				if (
					Player.Armor > 0 && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned &&
					ML::Distance(BotPlayer.Position, Player.Position) < 1.5
				)
					BotPlayer.Driver.ForcedTarget = Player;
			}
		}
		
		// ---------------------------------- //
		// Clear Toad target if out of range
		if (BotPlayer.Driver.ForcedTarget != Null) {
			declare Player <=> BotPlayer.Driver.ForcedTarget;
			if (
				Player.Armor <= 0 || Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned ||
				ML::Distance(BotPlayer.Position, Player.Position) > BotPlayer.Driver.DisengageDistance
			)
				BotPlayer.Driver.ForcedTarget = Null;
		}
	}
	
	// ---------------------------------- //
	// Update Toads colour on team colour change
	foreach (I => Team in Teams) if (
		!G_LibGalaxyTitles_PrevTeamsColors.existskey(I) ||
		G_LibGalaxyTitles_PrevTeamsColors[I] != Team.ColorPrimary
	) {
		G_LibGalaxyTitles_PrevTeamsColors[I] = Team.ColorPrimary;
		declare NewToadsColor = Private_GetThirdClanColor(Teams[0].ColorPrimary, Teams[1].ColorPrimary);
		foreach (BotPlayer in BotPlayers) {
			if (!G_LibGalaxyTitles_SpawnedToads.exists(BotPlayer.Id)) continue;
			BotPlayer.ForceColor = NewToadsColor;
		}
	}
}

// ---------------------------------- //
/// Manage everything related to Toads
Void ToadsLoop() { ToadsLoop(C_LibGalaxyTitles_ToadRespawnTime); }

// ---------------------------------- //
/** Initialize the library
 *
 *	@param	_UseWeapons			Enable weapons pickups (if available to be picked up on map)
 *	@param	_UseReplies			Enable Replies objects (if available to be picked up on map)
 *	@param	_ToadsSpawnRatio	Target ratio of landmarks spawning Toads to all landmarks
 */
Void Init(Boolean _UseWeapons, Boolean _UseReplies, Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects(_UseWeapons, _UseReplies);
	InitToads(_ToadsSpawnRatio);
}

Void Init(Boolean _UseWeaponsAndReplies, Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects(_UseWeaponsAndReplies);
	InitToads(_ToadsSpawnRatio);
}

Void Init(Boolean _UseWeaponsAndReplies) {
	ClearReloadBoost();
	InitObjects(_UseWeaponsAndReplies);
	InitToads();
}

Void Init(Real _ToadsSpawnRatio) {
	ClearReloadBoost();
	InitObjects();
	InitToads(_ToadsSpawnRatio);
}

Void Init() {
	ClearReloadBoost();
	InitObjects();
	InitToads();
}

// ---------------------------------- //
/** Automatic library loop
 *
 *	@param	_SpawnObjects		If False, objects won't be spawned
 *	@param	_ToadsRespawnTime	Time before Toad will respawn after elimination
 */
Void Loop(Boolean _SpawnObjects, Integer _ToadsRespawnTime) {
	ReloadBoost();
	SpawnObjects(_SpawnObjects);
	ToadsLoop(_ToadsRespawnTime);

	// ---------------------------------- //
	// Manage Replie particles action
	foreach (Player in Players) {
		declare Integer ReplieParticlesEndTime for Player;
		if (Now < ReplieParticlesEndTime) continue;
		ActionSetVariant(Player, C_LibGalaxyTitles_ReplieActionSlot, 0);
	}
}

Void Loop(Boolean _SpawnObjects) {
	ReloadBoost();
	SpawnObjects(_SpawnObjects);
	ToadsLoop();
}

Void Loop(Integer _ToadsRespawnTime) {
	ReloadBoost();
	SpawnObjects();
	ToadsLoop(_ToadsRespawnTime);
}

Void Loop() {
	ReloadBoost();
	SpawnObjects();
	ToadsLoop();
}

// ---------------------------------- //
/** Set if the player is able to pick up weapons.
 *
 *	@param	_Player		Player to update setting.
 *	@param	_CanPickUp	If True, player will be able to pick up weapons.
 */
Void SetPlayerCanPickUpWeapons(CSmPlayer _Player, Boolean _CanPickUp) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	declare Boolean LibGalaxyTitles_DisablePickUpWeapons for _Player;
	LibGalaxyTitles_DisablePickUpWeapons = !_CanPickUp;
}

// ---------------------------------- //
/** Set if the player is able to pick up supplies.
 *
 *	@param	_Player		Player to update setting.
 *	@param	_CanPickUp	If True, player will be able to pick up supplies.
 */
Void SetPlayerCanPickUpSupplies(CSmPlayer _Player, Boolean _CanPickUp) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	declare Boolean LibGalaxyTitles_DisablePickUpSupplies for _Player;
	LibGalaxyTitles_DisablePickUpSupplies = !_CanPickUp;
}

// ---------------------------------- //
/** Load infinite supplies for a player.
 *
 *	@param	_Player		Player to load supplies.
 *	@param	_Cooldown	Time after which a supply can be used again.
 */
Void LoadInfiniteSupplies(CSmPlayer _Player, Integer _Cooldown) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;

	// Destroy existing slots
	Inventory::DestroyItemSlot(_Player, C_LibGalaxyTitles_ReplieItemId);
	Inventory::DestroyItemSlot(_Player, C_LibGalaxyTitles_FuelItemId);

	// Creates inventory slots for infinite Replies and Fuels
	Inventory::CreateItemSlot(_Player, C_LibGalaxyTitles_ReplieItemId, CSmModeEvent::EActionInput::Consumable1, -1, "ArmorBoost.png");
	Inventory::CreateItemSlot(_Player, C_LibGalaxyTitles_FuelItemId, CSmModeEvent::EActionInput::Consumable2, -1, "Fuel.png");

	// Set the cooldown
	declare Integer LibGalaxyTitles_SuppliesCooldown for _Player;
	LibGalaxyTitles_SuppliesCooldown = ML::Max(0, _Cooldown);
}

// ---------------------------------- //
/** Reset and load player weapons after player is respawned
 *	/!\ Must be called after player is spawned in the world /!\
 *
 *	@param	_Player		Player to set weapon
 */
Void InitPlayerInventory(CSmPlayer _Player) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	Inventory::ResetInventory(_Player);
	
	// Load action used to show particle effect on the player
	LoadReplieParticles(_Player);

	// Item picking settings
	SetPlayerCanPickUpWeapons(_Player, True);
	SetPlayerCanPickUpSupplies(_Player, True);

	// Reset cooldown
	declare Integer LibGalaxyTitles_SuppliesCooldown for _Player;
	LibGalaxyTitles_SuppliesCooldown = -1;
	
	// Reset weapons to drop
	declare Ident[] PlayerWeaponsToDrop for _Player;
	PlayerWeaponsToDrop.clear();

	// ---------------------------------- //
	// Load Replies in the Inventory
	if (G_LibGalaxyTitles_RepliesAvailable) {
		Inventory::CreateItemSlot(_Player, C_LibGalaxyTitles_ReplieItemId, CSmModeEvent::EActionInput::Consumable1, 0, "ArmorBoost.png");
	}

	// ---------------------------------- //
	// Get the available weapons
	if (G_LibGalaxyTitles_WeaponItemsAvailable) {
		declare PlayerWeapons = [CSmMode::EWeapon::Rocket];
		declare TextToWeapon = [
			"Laser" => CSmMode::EWeapon::Laser,
			"Nucleus" => CSmMode::EWeapon::Nucleus,
			"Arrow" => CSmMode::EWeapon::Arrow,
			"Missile" => CSmMode::EWeapon::Missile
		];
		
		foreach (WeaponName in G_LibGalaxyTitles_AvailableWeapons) {
			if (!TextToWeapon.existskey(WeaponName)) continue;
			declare Weapon = TextToWeapon[WeaponName];
			if (!PlayerWeapons.exists(Weapon)) PlayerWeapons.add(Weapon);
		}
		
		Inventory::SetAvailableWeapons(_Player, PlayerWeapons);
		
		// Init weapons
		foreach (Weapon => Amount in C_LibGalaxyTitles_InitialWeaponsAmmoMax) Inventory::SetWeaponSlots(_Player, Weapon, Amount);
	}
}

// ---------------------------------- //
/** Initialize all settings of a player
 *
 *	@param	_Player		Player to initialize
 */
Void InitPlayer(CSmPlayer _Player) {
	if (_Player == Null || !G_LibGalaxyTitles_LibraryLoaded) return;
	ClearReloadBoost(_Player);
	InitPlayerInventory(_Player);
}

// ---------------------------------- //
/** Autmatically manage consumable items usage
 *
 *	@param	_Event	The event to proceed
 */
Void UseConsumableItems(CSmModeEvent _Event) {
	if (_Event == Null || _Event.Type != CSmModeEvent::EType::OnActionEvent || _Event.Player == Null) return;

	declare NbAffected_Total = 0;
	
	// Get the target item's id through the ugly way
	declare CSmModeEvent::EActionInput[Text] LibInventory_PlayerItemHotkey for _Event.Player;
	if (!LibInventory_PlayerItemHotkey.exists(_Event.ActionInput)) return;
	declare ItemName = LibInventory_PlayerItemHotkey.keyof(_Event.ActionInput);

	// Return if the item is not ready
	if (Inventory::GetItemAmount(_Event.Player, ItemName) == 0) return;
	if (!Inventory::CooldownIsReady(_Event.Player, ItemName)) return;

	// Check if the player has infinite supplies
	declare IsUnlimited = Inventory::GetItemAmount(_Event.Player, ItemName) < 0;
	declare Integer LibGalaxyTitles_SuppliesCooldown for _Event.Player;

	switch (ItemName) {
		// ---------------------------------- //
		// Use a Replie
		case C_LibGalaxyTitles_ReplieItemId : {
			if (!Private_CanUseHealing(_Event.Player)) return;
			NbAffected_Total = UseHealing(_Event.Player);
			Statistics::TrackEvent(_Event.Player, "RepliesUsedTotal", 1);
			
			declare ItemCooldown = C_LibGalaxyTitles_ReplieUseCooldown;
			if (IsUnlimited) ItemCooldown = LibGalaxyTitles_SuppliesCooldown + NbAffected_Total * 1000;
			declare Used = Inventory::UseItem(_Event.Player, ItemName, ItemCooldown, False);
		}
		// ---------------------------------- //
		// Use a Fuel
		case C_LibGalaxyTitles_FuelItemId : {
			if (!Private_CanUseBoost(_Event.Player)) return;
			NbAffected_Total = UseBoost(_Event.Player);

			declare ItemCooldown = C_LibGalaxyTitles_ReplieUseCooldown;
			if (IsUnlimited) ItemCooldown = LibGalaxyTitles_SuppliesCooldown + NbAffected_Total * 1000;
			declare Used = Inventory::UseItem(_Event.Player, ItemName, LibGalaxyTitles_SuppliesCooldown, False);
		}
	}

	// Give support points for affecting somebody
	if (NbAffected_Total > 0) {
		Score::AddPoints(_Event.Player, NbAffected_Total * G_LibGalaxyTitles_PointsForPick);
		TopScores::AddPoints(_Event.Player.Score, "Support", NbAffected_Total * G_LibGalaxyTitles_PointsForPick);
	}
}

// ---------------------------------- //
/** Set if objects affect also enemy players
 *
 *	@param	_Setting	True, if objects may affect enemies
 */
Void SetObjectsAffectEveryone(Boolean _Setting) {
	G_LibGalaxyTitles_ObjectsAffectEveryone = _Setting;
}

// ---------------------------------- //
/** Set amount of points given for picking up object
 *
 *	@param	_Setting	Amount of points for picking up object
 */
Void SetPointsForPick(Integer _Setting) {
	G_LibGalaxyTitles_PointsForPick = _Setting;
}

// ---------------------------------- //
/** Set amount of Toads armor points
 *
 *	@param	_Setting	Toads armor points
 */
Void SetToadsArmorMax(Integer _Setting) {
	G_LibGalaxyTitles_ToadsArmorMax = _Setting;
}

// ---------------------------------- //
/** Set the time before dropped weapons reappear in spawners
 *
 *	@param	_Setting	Respawn duration
 */
Void SetDroppedWeaponsLifetime(Integer _Setting) {
	G_LibGalaxyTitles_ObjectsDropLifetime = _Setting;
}

// ---------------------------------- //
/** Set maximum amount of every additional weapon slot held in the inventory

 *	@param	_Setting	Additional slots amount
 */
Void SetMaxWeapons(Integer _Setting) {
	G_LibGalaxyTitles_InventoryMaxWeapons = _Setting;
}

// ---------------------------------- //
/** Set maximum amount of Replies held in the inventory
 *
 *	@param	_Setting	Maximum Replies amount
 */
Void SetMaxReplies(Integer _Setting) {
	G_LibGalaxyTitles_InventoryMaxReplies = _Setting;
}

// ---------------------------------- //
/** Set if Fuel gives reload boost
 *
 *	@param	_Setting	If True, Fuel will give reload boost
 */
Void SetFuelGivingBoost(Boolean _Setting) {
	G_LibGalaxyTitles_FuelGivesReloadBoost = _Setting;
}