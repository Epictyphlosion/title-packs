// -------------------------------------- //
//  LIBRARY MINIMAP by domino54           //
//  script version: 2017-04-18            //
// -------------------------------------- //

/**
 *	Works only in the title pack "GalaxyTitles@domino54".
 *	This library will load and attach customized minimap,
 *	which can display currently played map from bird's eye
 *	view, radar with view of currently spectated player,
 *	markers of all nearby players and custom made markers.
 */

#Const Version		"2017-04-18"
#Const ScriptName	"MiniMap.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/Minimap/"
#Const C_LibMinimap_LayerWindowId		"LibMinimap:Window"
#Const C_LibMinimap_WindowPosition		<-137.5, 67.5>
#Const C_LibMinimap_WindowHideOffset	<-50., 0.>
#Const C_LibMinimap_WindowMinimapSize	<40., 40.>
#Const C_LibMinimap_NbPlayersMarkers	48
#Const C_LibMinimap_NbCustomMarkers		24

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Update the settings for a module
 *
 *	@param	_Name		The name of the setting
 *	@param	_Value		The value of the setting
 */
Void Private_SetModuleSetting(Text _Name, Text _Value) {
	declare netwrite Net_LibMinimap_SettingsUpdate for Teams[0] = 0;
	declare netwrite Net_LibMinimap_Settings for Teams[0] = Text[Text];
	Net_LibMinimap_SettingsUpdate = Now;
	Net_LibMinimap_Settings[_Name] = _Value;
}

// ---------------------------------- //
/** Create manialink for the minimap window module
 *
 *	@return		The minimap window manialink
 */
Text Private_CreateManialinkMinimapWindow() {
	// ---------------------------------- //
	// Generate players markers
	declare Text PlayerMarkers;
	for (I, 0, C_LibMinimap_NbPlayersMarkers - 1)
		PlayerMarkers ^= "<frameinstance modelid='FrameModel_PlayerMarker' id='Frame_PlayerMarker#"^I^"' hidden='1' />";
	
	// ---------------------------------- //
	// Generate custom markers
	declare Text CustomMarkers;
	for (I, 0, C_LibMinimap_NbCustomMarkers - 1)
		CustomMarkers ^= "'<quad size='6 6' halign='center' valign='center' id='Quad_CustomMarker#"^I^"' hidden='1' />";
	
	// ---------------------------------- //
	// Initial window position
	declare Text InitialPosition;
	for (I, 0, 1) InitialPosition ^= C_LibMinimap_WindowPosition[I] + C_LibMinimap_WindowHideOffset[I]^" ";
	
	// Compute map size
	declare MapSize = C_LibMinimap_WindowMinimapSize;
	declare ShadowSize = MapSize;
	for (I, 0, 1) ShadowSize[I] = ShadowSize[I] * 2 + 10;
	
	// ---------------------------------- //
	// Create manialink
	return """
<manialink version="3" name="{{{C_LibMinimap_LayerWindowId}}}">
<stylesheet>
	<style id="Label_MarkerText" textsize=".5" textemboss="1" textcolor="FFF" />
</stylesheet>

<framemodel id="FrameModel_PlayerMarker">
	<quad size="3.5 3.5" halign="center" valign="center" image="{{{C_ImgBase}}}Player.png" id="Quad_MarkerIcon" />
	<label pos="0 -2" size="16" halign="center" valign="center2" id="Label_MarkerText" />
	<quad size="14 14" halign="center" valign="center" image="{{{C_ImgBase}}}PlayerFov.png" id="Quad_MarkerCone" />
	<quad size="5.5 5.5" halign="center" valign="center" image="{{{C_ImgBase}}}Vehicle.png" id="Quad_MarkerVehicle" hidden="1" />
</framemodel>

<frame id="Frame_HMDClip" size="320 180" halign="center" valign="center">

<frame id="Frame_MinimapWindow" pos="{{{InitialPosition}}}" hidden="1">
	<quad size="{{{MapSize.X + 5^" "^MapSize.Y + 5}}}" halign="center" valign="center" image="{{{C_ImgBase}}}Overlay.png" />

	<quad size="7 7" halign="center" valign="center" image="{{{C_ImgBase}}}GUIPlayer.png" id="Quad_MarkerGUIPlayer" hidden="1" />
	<frame id="Frame_MarkersClip" size="{{{MapSize.X^" "^MapSize.Y}}}" halign="center" valign="center">
		<frame id="Frame_MarkersRotation"><frame id="Frame_MarkersPosition">
			{{{PlayerMarkers}}}
			{{{CustomMarkers}}}
		</frame></frame>
	</frame>

	<minimap size="{{{MapSize.X^" "^MapSize.Y}}}" halign="center" valign="center" id="Minimap_Main" />
	<quad size="{{{MapSize.X^" "^MapSize.Y}}}" halign="center" valign="center" bgcolor="000" opacity=".5" />
	<quad size="{{{MapSize.X^" "^MapSize.Y}}}" halign="center" valign="center" style="Bgs1" substyle="BgDialogBlur" opacity="0" />
</frame>

</frame>

<label id="Label_Debug" scale="5" />

<script><!--
/**
 *	{{{ScriptName}}}
 *	{{{Version}}}
 *	{{{C_LibMinimap_LayerWindowId}}}
 *	domino54
 */

#Include "AnimLib" as AL
#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_EnvironmentSize ["Storm" => 384.]
#Const C_MapZoomWhenSpawned		5.
#Const C_MapZoomInVehicles		3.75
#Const C_MapWeightedSizeOffset	12.
#Const C_PlayerSpawnDelay		1500

#Const C_MarkerScaleDefault		1.
#Const C_MarkerScaleOverview	.75
#Const C_MarkerScaleBotPlayer	.75
#Const C_MarkerTunnelsOpacity	{{{1/3.}}}
#Const C_MarkersDistances [
	"Teammates"	=> [32., 48.],
	"Enemies"	=> [26., 42.],
	"InVehicle"	=> [48., 56.]
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Real G_EnvironmentSize;
declare Real[][Text] G_MarkersDistances;

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_MinimapWindow <=> (Page.GetFirstChild("Frame_MinimapWindow") as CMlFrame);
declare Minimap_Main <=> (Page.GetFirstChild("Minimap_Main") as CMlMinimap);
declare Quad_MarkerGUIPlayer <=> (Page.GetFirstChild("Quad_MarkerGUIPlayer") as CMlQuad);
declare Frame_MarkersRotation <=> (Page.GetFirstChild("Frame_MarkersRotation") as CMlFrame);
declare Label_Debug <=> (Page.GetFirstChild("Label_Debug") as CMlLabel);

declare Frame_MarkersPosition <=> (Page.GetFirstChild("Frame_MarkersPosition") as CMlFrame);

declare CMlFrame[] Frame_PlayerMarkers;
for (I, 0, {{{C_LibMinimap_NbPlayersMarkers - 1}}})
	Frame_PlayerMarkers.add((Page.GetFirstChild("Frame_PlayerMarker#"^I) as CMlFrame));

foreach (Frame in Frame_PlayerMarkers) {
	declare Quad_MarkerIcon for Frame <=> (Frame.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
	declare Label_MarkerText for Frame <=> (Frame.GetFirstChild("Label_MarkerText") as CMlLabel);
	declare Quad_MarkerCone for Frame <=> (Frame.GetFirstChild("Quad_MarkerCone") as CMlQuad);
	declare Quad_MarkerVehicle for Frame <=> (Frame.GetFirstChild("Quad_MarkerVehicle") as CMlQuad);
}

declare CMlQuad[] Quad_CustomMarkers;
for (I, 0, {{{C_LibMinimap_NbCustomMarkers - 1}}})
	Quad_CustomMarkers.add((Page.GetFirstChild("Quad_CustomMarker#"^I) as CMlQuad));

// ---------------------------------- //
// Persistent settings
declare persistent Boolean Persistent_LibMinimap_HideMinimap for LocalUser;
declare persistent Boolean Persistent_LibMinimap_HideImage for LocalUser;
declare persistent Boolean Persistent_LibMinimap_HidePlayers for LocalUser;
declare persistent Boolean Persistent_LibMinimap_HideNames for LocalUser;
declare persistent Boolean Persistent_LibMinimap_HideCones for LocalUser;
declare persistent Boolean Persistent_LibMinimap_HideHeight for LocalUser;
declare persistent Boolean Persistent_LibMinimap_DisableUGView for LocalUser;
declare persistent Integer Persistent_LibMinimap_RenderSmoothness for LocalUser = 2;

Persistent_LibMinimap_RenderSmoothness = ML::Clamp(Persistent_LibMinimap_RenderSmoothness, 1, 60);

// ---------------------------------- //
// Netcode
declare netread Integer Net_LibMinimap_SettingsUpdate for Teams[0];
declare netread Text[Text] Net_LibMinimap_Settings for Teams[0];
declare netread Text Net_LibMinimap_IconsPathPrefix for Teams[0];
declare netread Integer Net_LibMinimap_MarkersUpdate for Teams[0];

// ---------------------------------- //
// Variables
declare DisplayMinimap = False;
declare DisplayTeammates = True;
declare DisplayOpponents = True;
declare MinimapVisible = False;
declare MinimapPosition = Vec3;
declare IsOverviewMode = True;
declare IsPlayerSpawned = False;
declare AdjustMarkersPositions = True;
declare UpdateMarkersPositions = True;
declare UpdateGUIPlayerMarker = True;
declare MarkersPositioning = Vec2;
declare ReassignPlayersMarkers = True;
declare NbPlayersDisplayed = 0;
declare NbCustomDisplayed = 0;
declare GUIPlayerIsInVehicle = False;

/// Update
declare PrevSettingsUpdate = -1;
declare PrevMinimapVisible = False;
declare PrevMinimapPosition = Vec3;
declare PrevMinimapYaw = -1.;
declare PrevMinimapZoom = -1.;

declare PrevZoomState = 0;
declare PrevIsOverviewMode = False;
declare PrevNbPlayers = 0;
declare PrevMarkersUpdate = -1;

declare PrevGUIPlayerColor = -1.;
declare PrevGUIPlayerIsInVehicle = False;
declare PrevGUIPlayerVehicleType = -1;
declare PrevGUIPlayerId = NullId;

// ---------------------------------- //
// Initialize manialink
if (C_EnvironmentSize.existskey(Map.CollectionName)) G_EnvironmentSize = C_EnvironmentSize[Map.CollectionName];
G_MarkersDistances = C_MarkersDistances;

// ---------------------------------- //
// Get the landmarks weighted center
declare LandmarksWeightedCenter = <0., 0., 0.>;
declare LandmarksWeightedZoom = 5.;

if (MapLandmarks.count > 0) {
	declare LandmarkPosMin = MapLandmarks[0].Position;
	declare LandmarkPosMax = LandmarkPosMin;

	// ---------------------------------- //
	// Get minimum and maximum landmark positions
	foreach (MapLandmark in MapLandmarks) for (I, 0, 2) {
		if (MapLandmark.Position[I] < LandmarkPosMin[I]) LandmarkPosMin[I] = MapLandmark.Position[I];
		if (MapLandmark.Position[I] > LandmarkPosMax[I]) LandmarkPosMax[I] = MapLandmark.Position[I];
	}

	// Center to the only landmark on the map
	if (LandmarkPosMin == LandmarkPosMax) LandmarksWeightedCenter = LandmarkPosMin;

	// ---------------------------------- //
	// Compute landmarks weighted center
	else {
		LandmarksWeightedCenter = LandmarkPosMin + LandmarkPosMax;
		for (I, 0, 2) LandmarksWeightedCenter[I] /= 2;

		// ---------------------------------- //
		// Compute the landmarks weighted zoom
		declare MaxDist = ML::Max(
			Distance1D(LandmarkPosMin.X, LandmarkPosMax.X),
			Distance1D(LandmarkPosMin.Z, LandmarkPosMax.Z)
		);
		if (MaxDist > 0) LandmarksWeightedZoom = ML::Clamp(G_EnvironmentSize / (MaxDist + C_MapWeightedSizeOffset), 1., 5.);
	}
}

// Initialize minimap properties
MinimapPosition = LandmarksWeightedCenter;
Minimap_Main.ZoomFactor = LandmarksWeightedZoom;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	if (Event.Type == CMlEvent::Type::KeyPress) {
		if (Event.KeyName == "N") Persistent_LibMinimap_HideMinimap = !Persistent_LibMinimap_HideMinimap;
	}
}

// Reduce the CPU usage by updating minimap only 30 times per second
if (Ticks % Persistent_LibMinimap_RenderSmoothness != 0) continue;

// ---------------------------------- //
// Update settings
if (PrevSettingsUpdate != Net_LibMinimap_SettingsUpdate) {
	PrevSettingsUpdate = Net_LibMinimap_SettingsUpdate;
	
	foreach (SettingName => SettingValue in Net_LibMinimap_Settings) {
		switch (SettingName) {
			case "DisplayMinimap" : DisplayMinimap = SettingValue == "True";
			case "DisplayTeammates" : DisplayTeammates = SettingValue == "True";
			case "DisplayOpponents" : DisplayOpponents = SettingValue == "True";
		}
	}
}

// ---------------------------------- //
// Set the minimap visibility
MinimapVisible = !Persistent_LibMinimap_HideMinimap && DisplayMinimap;
if (PrevMinimapVisible != MinimapVisible) {
	PrevMinimapVisible = MinimapVisible;
	
	declare Position = {{{C_LibMinimap_WindowPosition}}};
	declare Easing = CAnimManager::EAnimManagerEasing::CircOut;
	
	if (!MinimapVisible) {
		Position += {{{C_LibMinimap_WindowHideOffset}}};
		Easing = CAnimManager::EAnimManagerEasing::CircIn;
	}
	
	AnimMgr.Add(Frame_MinimapWindow, "<frame pos='"^Position.X^" "^Position.Y^"' />", 500, Easing);
}
Frame_MinimapWindow.Visible = Frame_MinimapWindow.RelativePosition_V3 != {{{C_LibMinimap_WindowPosition + C_LibMinimap_WindowHideOffset}}};

// Continue, if the minimap is not visible
if (!MinimapVisible) continue;

// Update minimap image visibility
if (Minimap_Main.Visible != !Persistent_LibMinimap_HideImage) Minimap_Main.Visible = !Persistent_LibMinimap_HideImage;

// Check if the player is spawned
IsPlayerSpawned = GUIPlayer != Null && GUIPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned && GUIPlayer.Position != <0., 0., 0.>;

// Set the player marker visibility
if (Quad_MarkerGUIPlayer.Visible != IsPlayerSpawned) Quad_MarkerGUIPlayer.Visible = IsPlayerSpawned;

// Set the underground mode
Minimap_Main.Underground = IsPlayerSpawned && GUIPlayer.IsUnderground && !Persistent_LibMinimap_DisableUGView;

// ---------------------------------- //
// Set the player position as the minimap center
if (IsPlayerSpawned) {
	MinimapPosition = GUIPlayer.Position;
	Minimap_Main.MapYaw = GUIPlayer.AimYaw;
	
	// ---------------------------------- //
	// Reduced zoom in vehicles
	if (GUIPlayerIsInVehicle) {
		if (PrevZoomState != 3) {
			PrevZoomState = 3;
			AnimMgr.Add(Label_Debug, "<label scale='"^C_MapZoomInVehicles^"' />", 250, CAnimManager::EAnimManagerEasing::SineInOut);
		}
	}
	// ---------------------------------- //
	// Reduced map zoom on Laser and Arrow pads
	else if (GUIPlayer.IsOnTechLaser || GUIPlayer.IsOnTechArrow) {
		if (PrevZoomState != 2) {
			PrevZoomState = 2;
			AnimMgr.Add(Label_Debug, "<label scale='"^C_MapZoomWhenSpawned / 2^"' />", 250, CAnimManager::EAnimManagerEasing::SineInOut);
		}
	}
	// ---------------------------------- //
	// Normal map zoom
	else if (PrevZoomState != 1) {
		PrevZoomState = 1;
		AnimMgr.Add(Label_Debug, "<label scale='"^C_MapZoomWhenSpawned^"' />", 250, CAnimManager::EAnimManagerEasing::SineInOut);
	}
	
	// Apply the animated zoom change
	if (Minimap_Main.ZoomFactor != Label_Debug.RelativeScale) Minimap_Main.ZoomFactor = Label_Debug.RelativeScale;
}
// ---------------------------------- //
// Compute weighted minimap position
else {
	// ---------------------------------- //
	// Get the players weighted center
	declare PlayersWeightedCenter = LandmarksWeightedCenter;
	declare PlayersWeightedZoom = LandmarksWeightedZoom;

	if (Players.count > 0) {
		declare Vec3 PlayerPosMin;
		declare Vec3 PlayerPosMax;

		// ---------------------------------- //
		// Get minimum and maximum players positions
		foreach (Player in Players) {
			if (Player.RequestsSpectate || Player.Position == <0., 0., 0.>) continue;
			for (I, 0, 2) if (PlayerPosMin[I] == 0. || Player.Position[I] < PlayerPosMin[I]) PlayerPosMin[I] = Player.Position[I];
			for (I, 0, 2) if (PlayerPosMax[I] == 0. || Player.Position[I] > PlayerPosMax[I]) PlayerPosMax[I] = Player.Position[I];
		}

		if (PlayerPosMin != <0., 0., 0.>) {
			// Center to the only player on the map
			if (PlayerPosMin == PlayerPosMax) PlayersWeightedCenter = PlayerPosMin;

			// ---------------------------------- //
			// Compute players weighted center
			else {
				PlayersWeightedCenter = PlayerPosMin + PlayerPosMax;
				for (I, 0, 2) PlayersWeightedCenter[I] /= 2;

				// ---------------------------------- //
				// Compute the players weighted zoom
				declare MaxDist = ML::Max(
					Distance1D(PlayerPosMin.X, PlayerPosMax.X),
					Distance1D(PlayerPosMin.Z, PlayerPosMax.Z)
				);
				if (MaxDist > 0) PlayersWeightedZoom = ML::Clamp(G_EnvironmentSize / (MaxDist + C_MapWeightedSizeOffset), 1., 5.);
			}
		}
	}

	// Set the weighted properties
	MinimapPosition = PlayersWeightedCenter;
	Minimap_Main.ZoomFactor = PlayersWeightedZoom;
	Minimap_Main.MapYaw = 0.;
}

// ---------------------------------- //
// Update minimap position
if (!PositionsMatch(PrevMinimapPosition, MinimapPosition)) {
	PrevMinimapPosition = MinimapPosition;
	Minimap_Main.WorldPosition = MinimapPosition;
	AdjustMarkersPositions = True;
}

// ---------------------------------- //
// Trigger markers update on zoom change
if (PrevMinimapZoom != Minimap_Main.ZoomFactor) {
	PrevMinimapZoom = Minimap_Main.ZoomFactor;
	AdjustMarkersPositions = True;
	MarkersPositioning = <
		Minimap_Main.Size.X / (G_EnvironmentSize / Minimap_Main.ZoomFactor),
		Minimap_Main.Size.Y / (G_EnvironmentSize / Minimap_Main.ZoomFactor)
	>;
}

// Reset the trigger
if (UpdateMarkersPositions) UpdateMarkersPositions = False;

// ---------------------------------- //
// Adjust markers position
if (AdjustMarkersPositions) {
	AdjustMarkersPositions = False;
	UpdateMarkersPositions = True;
	Frame_MarkersPosition.RelativePosition_V3 = <
		MinimapPosition.X * MarkersPositioning.X,
		-MinimapPosition.Z * MarkersPositioning.Y
	>;
}

// ---------------------------------- //
// Adjust markers rotation
if (PrevMinimapYaw != Minimap_Main.MapYaw) {
	PrevMinimapYaw = Minimap_Main.MapYaw;
	Frame_MarkersRotation.RelativeRotation = RadToDeg(Minimap_Main.MapYaw);
}

// ---------------------------------- //
// Update current player color
if (GUIPlayer != Null && PrevGUIPlayerColor != GUIPlayer.GetLinearHue) {
	PrevGUIPlayerColor = GUIPlayer.GetLinearHue;
	Quad_MarkerGUIPlayer.Colorize = HsvToRgb(<ML::Clamp(GUIPlayer.GetLinearHue, 0., 1.), 1., 1.>);
}

// Check if the player is in a vehicle (in quite ugly way)
GUIPlayerIsInVehicle =
	GUIPlayer != Null && GUIPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned &&
	GUIPlayer.Position != <0., 0., 0.> && GUIPlayer.Armor > 0 &&
	GameTime >= GUIPlayer.StartTime - 1500 && !GUIPlayer.IsInAir && !GUIPlayer.IsTouchingGround;

// ---------------------------------- //
// Update player icon on vehicle status change
if (PrevGUIPlayerIsInVehicle != GUIPlayerIsInVehicle) {
	PrevGUIPlayerIsInVehicle = GUIPlayerIsInVehicle;
	UpdateGUIPlayerMarker = True;
}

// ---------------------------------- //
// Update player icon on vehicle type change
if (GUIPlayer != Null) {
	declare netread Integer Net_LibMinimap_VehicleType for GUIPlayer;
	if (PrevGUIPlayerVehicleType != Net_LibMinimap_VehicleType) {
		PrevGUIPlayerVehicleType = Net_LibMinimap_VehicleType;
		UpdateGUIPlayerMarker = True;
	}
}

// ---------------------------------- //
// Update player icon on player change
if (GUIPlayer != Null && PrevGUIPlayerId != GUIPlayer.Id) {
	PrevGUIPlayerId = GUIPlayer.Id;
	UpdateGUIPlayerMarker = True;
}

// ---------------------------------- //
// Update current player icon
if (UpdateGUIPlayerMarker) {
	UpdateGUIPlayerMarker = False;

	// Player is on foot
	declare MarkerImage = "GUIPlayer.png";

	// ---------------------------------- //
	// Use current vehicle's icon
	if (GUIPlayerIsInVehicle) {
		declare netread Integer Net_LibMinimap_VehicleType for GUIPlayer;
		switch (Net_LibMinimap_VehicleType) {
			case 2 : MarkerImage = "ValleyCar.png";
			case 1 : MarkerImage = "StadiumCar.png";
			default : MarkerImage = "CanyonCar.png";
		}
	}

	Quad_MarkerGUIPlayer.ImageUrl = "{{{C_ImgBase}}}"^MarkerImage;
}

// ---------------------------------- //
// Update the overview mode
IsOverviewMode = !IsPlayerSpawned || GUIPlayer.IsOnTechLaser || GUIPlayer.IsOnTechArrow;

// ---------------------------------- //
// Update markers scales on overview mode change
if (PrevIsOverviewMode != IsOverviewMode) {
	PrevIsOverviewMode = IsOverviewMode;

	declare MarkersScale = C_MarkerScaleDefault;
	if (IsOverviewMode) MarkersScale *= C_MarkerScaleOverview;
	foreach (Frame in Frame_PlayerMarkers) Frame.RelativeScale = MarkersScale;
	foreach (Quad in Quad_CustomMarkers) Quad.RelativeScale = MarkersScale;
}

// ---------------------------------- //
// Reassign players markers on players amount change
if (PrevNbPlayers != Players.count) {
	PrevNbPlayers = Players.count;
	ReassignPlayersMarkers = True;
}

// ---------------------------------- //
// Reassign players markers when a player changes their spawn status
foreach (Player in Players) {
	if (ReassignPlayersMarkers) break;

	declare PrevIsSpawned for Player = False;
	declare PlayerIsSpawned = !Player.RequestsSpectate && Player.Position != <0., 0., 0.>;

	if (PrevIsSpawned != PlayerIsSpawned) {
		PrevIsSpawned = PlayerIsSpawned;
		ReassignPlayersMarkers = True;
	}
}

// ---------------------------------- //
// Reassign markers of all players
if (ReassignPlayersMarkers) {
	ReassignPlayersMarkers = False;
	NbPlayersDisplayed = 0;

	// ---------------------------------- //
	// Unbind players from all markers
	foreach (Frame in Frame_PlayerMarkers) {
		if (!Frame.Visible) continue;
		declare Ident FramePlayer for Frame;
		FramePlayer = NullId;
		Frame.Visible = False;
	}

	// ---------------------------------- //
	// Assign markers to the players
	foreach (Player in Players) {
		if (!IsOverviewMode && Persistent_LibMinimap_HidePlayers) break;
		if (NbPlayersDisplayed >= Frame_PlayerMarkers.count) break;
		if (Player == GUIPlayer) continue;

		// ---------------------------------- //
		// Check if the player is spawned
		declare Boolean PrevIsSpawned for Player;
		if (!PrevIsSpawned) continue;

		// ---------------------------------- //
		// Check if the player can be displayed
		if (!IsOverviewMode) {
			declare IsOpponent = GUIPlayer.CurrentClan == 0 || Player.CurrentClan != GUIPlayer.CurrentClan;
			if ((!IsOpponent && !DisplayTeammates) || (IsOpponent && !DisplayOpponents)) continue;
		}

		// Get a frame for the player
		declare Frame = Frame_PlayerMarkers[NbPlayersDisplayed];
		declare Ident FramePlayer for Frame;
		FramePlayer = Player.Id;

		// Increment players amount
		NbPlayersDisplayed += 1;
	}
}

// ---------------------------------- //
// Manage the players markers
foreach (I => Frame in Frame_PlayerMarkers) {
	if (I >= NbPlayersDisplayed) break;

	// Get the player of the frame
	declare Ident FramePlayer for Frame;
	if (!Players.existskey(FramePlayer)) continue;
	declare Player <=> Players[FramePlayer];

	// Don't bother showing the player outside of the visible area
	if (!IsOverviewMode && Distance2D(GUIPlayer.Position, Player.Position) > 60.) {
		if (Frame.Visible) Frame.Visible = False;
		continue;
	}

	// Show the marker
	Frame.Visible = True;

	// ---------------------------------- //
	// Get the marker opacity
	declare MarkerOpacity = 1.;
	if (!IsOverviewMode) {
		declare Real[] Distances;
		if (!Player.IsBot) {
			if (GUIPlayerIsInVehicle) Distances = G_MarkersDistances["InVehicle"];
			else if (GUIPlayer.CurrentClan == 0 || Player.CurrentClan != GUIPlayer.CurrentClan) Distances = G_MarkersDistances["Enemies"];
			else Distances = G_MarkersDistances["Teammates"];
		}
		MarkerOpacity = GetMarkerFade(Distance2D(GUIPlayer.Position, Player.Position), Distances);
	}

	// Hide frame if the player is too far away
	if (MarkerOpacity <= 0) {
		if (Frame.Visible) Frame.Visible = False;
		continue;
	}
	
	// A bit transparent markers for players under the ground
	if (GUIPlayer != Null && GUIPlayer.IsUnderground != Player.IsUnderground) MarkerOpacity *= C_MarkerTunnelsOpacity;

	// ---------------------------------- //
	// Update the marker position
	declare Vec3 PreviousPosition for Frame;
	if (UpdateMarkersPositions || !PositionsMatch(PreviousPosition, Player.Position)) {
		PreviousPosition = Player.Position;
		Frame.RelativePosition_V3 = <
			-PreviousPosition.X * MarkersPositioning.X,
			PreviousPosition.Z * MarkersPositioning.Y
		>;
	}

	// Frame rotation
	Frame.RelativeRotation = -Frame_MarkersRotation.RelativeRotation;

	// ---------------------------------- //
	// Update the marker icon
	declare CMlQuad Quad_MarkerIcon for Frame;
	declare Boolean PlayerHasCustomMarker for Player;
	declare IsInVehicle = Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned && Player.Armor > 0 && GameTime >= Player.StartTime - 1500 && Player.IsInAir == Player.IsTouchingGround;
	declare Boolean PrevIsInVehicle for Player;

	Quad_MarkerIcon.Visible = !PlayerHasCustomMarker && !IsInVehicle;
	if (Quad_MarkerIcon.Visible) {
		Quad_MarkerIcon.Opacity = MarkerOpacity;

		// ---------------------------------- //
		// Marker icon depending on the height difference
		declare PlayerIconImage = "Player.png";
		declare IsEliminated = Player.StartTime > 0 && (Player.Armor <= 0 || GameTime < Player.StartTime - C_PlayerSpawnDelay);

		// Cross icon for eliminated players
		if (IsEliminated) PlayerIconImage = "Eliminated.png";

		else if (IsPlayerSpawned && !Persistent_LibMinimap_HideHeight) {
			declare HeightDifference = Player.Position.Y - GUIPlayer.Position.Y;
			declare MaxDiff = 11.875;

			// Low height difference limit if underground
			if (GUIPlayer.IsUnderground || Player.IsUnderground) MaxDiff = 1.875;
			
			if (HeightDifference >= MaxDiff) PlayerIconImage = "PlayerUp.png";
			if (HeightDifference <= -MaxDiff) PlayerIconImage = "PlayerDown.png";
		}
		Quad_MarkerIcon.ImageUrl = "{{{C_ImgBase}}}"^PlayerIconImage;
	}

	// ---------------------------------- //
	// Setup field of view cone image
	declare CMlQuad Quad_MarkerCone for Frame;
	Quad_MarkerCone.Visible = !IsOverviewMode && !IsInVehicle && !Persistent_LibMinimap_HideCones;
	
	if (Quad_MarkerCone.Visible) {
		Quad_MarkerCone.Opacity = MarkerOpacity / 2;
		Quad_MarkerCone.RelativeRotation = RadToDeg(-Player.AimYaw) - Frame.RelativeRotation;
	}

	// ---------------------------------- //
	// Setup marker label text
	declare CMlLabel Label_MarkerText for Frame;
	Label_MarkerText.Visible = !IsOverviewMode && !Player.IsBot && !Persistent_LibMinimap_HideNames;
	
	if (Label_MarkerText.Visible) {
		Label_MarkerText.Opacity = MarkerOpacity;
		Label_MarkerText.Value = Player.User.Name;
	}

	// ---------------------------------- //
	// Update the vehicle icon
	declare CMlQuad Quad_MarkerVehicle for Frame;
	Quad_MarkerVehicle.Visible = IsInVehicle;

	Label_MarkerText.RelativePosition_V3.Y = -2.;
	if (IsInVehicle) Label_MarkerText.RelativePosition_V3.Y -= 1.;

	if (Quad_MarkerVehicle.Visible) {
		Quad_MarkerVehicle.Opacity = MarkerOpacity;
		Quad_MarkerVehicle.RelativeRotation = RadToDeg(-Player.AimYaw) - Frame.RelativeRotation;

		// ---------------------------------- //
		// Show the correct model
		declare netread Integer Net_LibMinimap_VehicleType for Player;
		declare MarkerImage = "CanyonCar.png";
		switch (Net_LibMinimap_VehicleType) {
			case 2 : MarkerImage = "ValleyCar.png";
			case 1 : MarkerImage = "StadiumCar.png";
		}
		Quad_MarkerVehicle.ImageUrl = "{{{C_ImgBase}}}"^MarkerImage;
	}

	declare PrevPlayerIsBot for Frame = False;
	declare PrevMarkerColor for Frame = -1.;

	// ---------------------------------- //
	// Ckeck if the player is bot
	if (PrevPlayerIsBot != Player.IsBot) {
		PrevPlayerIsBot = Player.IsBot;
		PrevMarkerColor = -1.;
		
		declare MarkerScale = C_MarkerScaleDefault;
		if (Player.IsBot) MarkerScale *= C_MarkerScaleBotPlayer;
		Quad_MarkerIcon.RelativeScale = MarkerScale;
		Quad_MarkerCone.RelativeScale = MarkerScale;
	}

	// ---------------------------------- //
	// Set marker icon color
	if (PrevMarkerColor != Player.GetLinearHue) {
		PrevMarkerColor = Player.GetLinearHue;
		declare Volume = 1.;
		if (Player.IsBot) Volume /= 2;
		Quad_MarkerIcon.Colorize = HsvToRgb(<ML::Clamp(PrevMarkerColor, 0., 1.), 1., Volume>);
		Quad_MarkerVehicle.Colorize = Quad_MarkerIcon.Colorize;
	}
}

// ---------------------------------- //
// Update the custom markers
if (PrevMarkersUpdate != Net_LibMinimap_MarkersUpdate) {
	PrevMarkersUpdate = Net_LibMinimap_MarkersUpdate;
	NbCustomDisplayed = 0;

	// ---------------------------------- //
	// Get the markers data
	declare netread Vec3[Text] Net_LibMinimap_CustomMarkers for Teams[0];
	declare netread Text[Text] Net_LibMinimap_MarkersImages for Teams[0];
	declare netread Vec3[Text] Net_LibMinimap_MarkersColors for Teams[0];
	declare netread Text[Text] Net_LibMinimap_MarkersPlayer for Teams[0];

	// Reset the custom markers
	foreach (I => Quad in Quad_CustomMarkers) {
		if (!Quad.Visible) continue;
		declare Ident QuadPlayer for Quad;
		QuadPlayer = NullId;
		Quad.Visible = False;
	}

	// ---------------------------------- //
	// Configure the custom markers
	foreach (MarkerId => Position in Net_LibMinimap_CustomMarkers) {
		if (NbCustomDisplayed >= Quad_CustomMarkers.count) break;
		declare Quad = Quad_CustomMarkers[NbCustomDisplayed];

		// Save position in the quad
		declare Vec3 MarkerPosition for Quad;
		MarkerPosition = Position;

		// ---------------------------------- //
		// Set the marker image
		declare MarkerImage = "";
		if (Net_LibMinimap_MarkersImages.existskey(MarkerId)) MarkerImage = Net_LibMinimap_MarkersImages[MarkerId]; 
		Quad.ImageUrl = Net_LibMinimap_IconsPathPrefix^MarkerImage;

		// ---------------------------------- //
		// Set the marker color
		declare MarkerColor = <1., 1., 1.>;
		if (Net_LibMinimap_MarkersColors.existskey(MarkerId)) MarkerColor = Net_LibMinimap_MarkersColors[MarkerId]; 
		Quad.Colorize = MarkerColor;

		// ---------------------------------- //
		// Get the marker player
		declare Ident QuadPlayer for Quad;
		if (Net_LibMinimap_MarkersPlayer.existskey(MarkerId)) QuadPlayer = GetPlayer(Net_LibMinimap_MarkersPlayer[MarkerId]); 
		else QuadPlayer = NullId;

		// Increment markers amount
		NbCustomDisplayed += 1;
	}

	// ---------------------------------- //
	// Save custom marker status in player
	foreach (Player in Players) {
		declare Boolean PlayerHasCustomMarker for Player;
		PlayerHasCustomMarker = Net_LibMinimap_MarkersPlayer.exists(Player.User.Login);
	}
}

// ---------------------------------- //
// Manage custom markers
foreach (I => Quad in Quad_CustomMarkers) {
	if (I >= NbCustomDisplayed) break;

	declare Vec3 MarkerPosition for Quad;
	declare QuadPosition = MarkerPosition;

	// ---------------------------------- //
	// Get position of the marker player
	declare Ident QuadPlayer for Quad;
	declare IsUnderground = False;

	if (QuadPlayer != NullId && Players.existskey(QuadPlayer)) {
		declare Player <=> Players[QuadPlayer];
		QuadPosition = Player.Position;

		// A bit transparent markers for players under the ground
		IsUnderground = GUIPlayer != Null && GUIPlayer.IsUnderground != Player.IsUnderground;
	}

	// Don't bother showing the marker outside of the visible area
	if (!IsOverviewMode && Distance2D(GUIPlayer.Position, QuadPosition) > 60.) {
		if (Quad.Visible) Quad.Visible = False;
		continue;
	}

	// ---------------------------------- //
	// Get the markar opacity
	declare MarkerOpacity = 1.;
	if (QuadPosition == <0., 0., 0.>) MarkerOpacity = 0.;
	else if (!IsOverviewMode) MarkerOpacity = GetMarkerFade(Distance2D(GUIPlayer.Position, QuadPosition), Real[]);
	if (IsUnderground) MarkerOpacity *= C_MarkerTunnelsOpacity;

	// Hide quad if the marker is too far away
	if (MarkerOpacity <= 0) {
		if (Quad.Visible) Quad.Visible = False;
		continue;
	}

	// Set the opacity
	Quad.Opacity = MarkerOpacity;
	Quad.Visible = True;
	
	// ---------------------------------- //
	// Update the marker position
	declare Vec3 PreviousPosition for Quad;
	if (UpdateMarkersPositions || !PositionsMatch(PreviousPosition, QuadPosition)) {
		PreviousPosition = QuadPosition;
		Quad.RelativePosition_V3 = <
			-PreviousPosition.X * MarkersPositioning.X,
			PreviousPosition.Z * MarkersPositioning.Y
		>;
	}

	// Quad rotation
	Quad.RelativeRotation = -Frame_MarkersRotation.RelativeRotation;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get player from their login
 *	
 *	@param	_Login		Login of the player to get
 *
 *	@return		Id of the player
 */
Ident GetPlayer(Text _Login) {
	if (_Login == "") return NullId;
	foreach (Player in Players) if (Player.User.Login == _Login) return Player.Id;
	return NullId;
}

// ---------------------------------- //
/** Convert Radians to Degree
 *	
 *	@param	_Radians	The value in radians
 *
 *	@return		The value in degree
 */
Real RadToDeg(Real _Radians) { return _Radians * 180. / ML::PI(); }

// ---------------------------------- //
/** Get distance between two anchors in 1 dimension
 *	
 *	@param _Pos1	1st anchor point
 *	@param _Pos2	2nd anchor point
 *
 *	@return		Distance between anchors
 */
Real Distance1D(Real _Pos1, Real _Pos2) { return ML::Sqrt(ML::Pow(_Pos2 - _Pos1, 2.)); }

// ---------------------------------- //
/** Get distance between two anchors in 2 dimensions
 *	
 *	@param _Pos1	1st anchor point
 *	@param _Pos2	2nd anchor point
 *
 *	@return		Distance between anchors
 */
Real Distance2D(Vec3 _Pos1, Vec3 _Pos2) { return ML::Sqrt(ML::Pow(_Pos2.X - _Pos1.X, 2.) + ML::Pow(_Pos2.Z - _Pos1.Z, 2.)); }

// ---------------------------------- //
/** Get custom marker opacity depending on player distance
 *	
 *	@param _Distance		Distance to the item
 *	@param _DistStep		Distance visibility steps
 *
 *	0 => Visible if distance is smaller
 *	1 => Fade out if distance is smaller / hide if greater
 *
 *	@return		Marker opacity
 */
Real GetMarkerFade(Real _Distance, Real[] _DistStep) {
	declare DistStep = [1., 4.];
	foreach (Step in _DistStep) DistStep.add(Step);
	
	// Too close - hide
	if (_Distance <= DistStep[0]) return 0.;
	
	// Close - fade
	else if (_Distance <= DistStep[1]) return (_Distance - DistStep[0]) / (DistStep[1] - DistStep[0]);
	
	// Visible
	else if (DistStep.count == 2 || _Distance <= DistStep[2]) return 1.;
	
	// Away - fade
	else if (_Distance <= DistStep[3]) return 1. - ((_Distance - DistStep[2]) / (DistStep[3] - DistStep[2]));
	
	// Too far away - hide
	return 0.;
}

// ---------------------------------- //
/** Check if two positions match
 *
 *	@param	_Pos1	First position
 *	@param	_Pos2	Second position
 *
 *	@return		True, if the positions match
 */
Boolean PositionsMatch(Vec3 _Pos1, Vec3 _Pos2) { return _Pos1.X == _Pos2.X && _Pos1.Z == _Pos2.Z; }

{{{ManialinkTools::Functions(["HsvToRgb"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	yield;
	declare Ticks = 0;
	+++Main+++
	while (True) {
		yield;
		Ticks += 1;
		+++Yield+++
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/** Set the minimap visibility.
 *
 *	@param	_MinimapVisible		Minimap visibility.
 */
Void SetVisibility(Boolean _MinimapVisible) {
	Private_SetModuleSetting("DisplayMinimap", TL::ToText(_MinimapVisible));
}

// ---------------------------------- //
/// Show the minimap on the interface.
Void Show() { SetVisibility(True); }

// ---------------------------------- //
/// Hide minimap.
Void Hide() { SetVisibility(False); }

// ---------------------------------- //
/** Set the teammates visibility.
 *
 *	@param	_DisplayTeammates		Teammates visibility.
 */
Void SetTeammatesVisibility(Boolean _DisplayTeammates) {
	Private_SetModuleSetting("DisplayTeammates", TL::ToText(_DisplayTeammates));
}

// ---------------------------------- //
/** Set the opponents visibility.
 *
 *	@param	_DisplayOpponents		Opponents visibility.
 */
Void SetOpponentsVisibility(Boolean _DisplayOpponents) {
	Private_SetModuleSetting("DisplayOpponents", TL::ToText(_DisplayOpponents));
}

// ---------------------------------- //
/** Set the base path for the minimap icons.
 *
 *	@param	_ImgBase	Icons base path.
 */
Void SetIconsBasePath(Text _ImgBase) {
	declare netwrite Text Net_LibMinimap_IconsPathPrefix for Teams[0];
	Net_LibMinimap_IconsPathPrefix = _ImgBase;
}

// ---------------------------------- //
/** Create or update a custom marker.
 *
 *	@param	_MarkerId			Id of the marker.
 *	@param	_MarkerIcon			Icon image of the marker.
 *	@param	_Colorize			Color of the marker.
 *	@param	_MarkerPosition		Position of the marker.
 *	@param	_PlayerLogin		Player to which the marker will be attached.
 */
Void SetMarker(Text _MarkerId, Text _MarkerIcon, Vec3 _Colorize, Vec3 _MarkerPosition, Text _PlayerLogin) {
	if (_MarkerId == "" || _MarkerIcon == "") return;
	
	declare netwrite Vec3[Text] Net_LibMinimap_CustomMarkers for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersImages for Teams[0];
	declare netwrite Vec3[Text] Net_LibMinimap_MarkersColors for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersPlayer for Teams[0];
	
	Net_LibMinimap_CustomMarkers[_MarkerId] = _MarkerPosition;
	Net_LibMinimap_MarkersImages[_MarkerId] = _MarkerIcon;
	if (_Colorize != <0., 0., 0.>) Net_LibMinimap_MarkersColors[_MarkerId] = _Colorize;
	if (_PlayerLogin != "") Net_LibMinimap_MarkersPlayer[_MarkerId] = _PlayerLogin;

	// Trigger client-side manialink update
	declare netwrite Integer Net_LibMinimap_MarkersUpdate for Teams[0];
	Net_LibMinimap_MarkersUpdate = Now;
}

Void SetMarker(Text _MarkerId, Text _MarkerIcon, Vec3 _Colorize, Vec3 _MarkerPosition) {
	SetMarker(_MarkerId, _MarkerIcon, _Colorize, _MarkerPosition, "");
}

Void SetMarker(Text _MarkerId, Text _MarkerIcon, Vec3 _Colorize, Text _PlayerLogin) {
	SetMarker(_MarkerId, _MarkerIcon, _Colorize, Vec3, _PlayerLogin);
}

// ---------------------------------- //
/** Destroy a custom marker.
 *
 *	@param	_MarkerId	Id of the marker to destroy.
 */
Void DestroyMarker(Text _MarkerId) {
	if (_MarkerId == "") return;
	
	declare netwrite Vec3[Text] Net_LibMinimap_CustomMarkers for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersImages for Teams[0];
	declare netwrite Vec3[Text] Net_LibMinimap_MarkersColors for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersPlayer for Teams[0];
	
	declare Boolean Removed;
	Removed = Net_LibMinimap_CustomMarkers.removekey(_MarkerId);
	Removed = Net_LibMinimap_MarkersImages.removekey(_MarkerId);
	Removed = Net_LibMinimap_MarkersColors.removekey(_MarkerId);
	Removed = Net_LibMinimap_MarkersPlayer.removekey(_MarkerId);

	// Trigger client-side manialink update
	declare netwrite Integer Net_LibMinimap_MarkersUpdate for Teams[0];
	Net_LibMinimap_MarkersUpdate = Now;
}

// ---------------------------------- //
/// Destroy all custom markers.
Void DestroyMarkers() {
	declare netwrite Vec3[Text] Net_LibMinimap_CustomMarkers for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersImages for Teams[0];
	declare netwrite Vec3[Text] Net_LibMinimap_MarkersColors for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_MarkersPlayer for Teams[0];
	
	Net_LibMinimap_CustomMarkers.clear();
	Net_LibMinimap_MarkersImages.clear();
	Net_LibMinimap_MarkersColors.clear();
	Net_LibMinimap_MarkersPlayer.clear();
	
	// Trigger client-side manialink update
	declare netwrite Integer Net_LibMinimap_MarkersUpdate for Teams[0];
	Net_LibMinimap_MarkersUpdate = Now;
}

// ---------------------------------- //
/** Set the type of a player's vehicle.
 *
 *	@param	_Player			The player to set vehicle type.
 *	@param	_VehicleType	Type of the vehicle [0 => CanyonCar, 1 => StadiumCar, 2 => ValleyCar].
 */
Void SetVehicleType(CSmPlayer _Player, Integer _VehicleType) {
	if (_Player == Null) return;
	declare netwrite Integer Net_LibMinimap_VehicleType for _Player;
	Net_LibMinimap_VehicleType = ML::Clamp(_VehicleType, 0, 2);
}

// ---------------------------------- //
/// Unload the library.
Void Unload() {
	DestroyMarkers();
	
	Layers::Detach(C_LibMinimap_LayerWindowId);
	Layers::Destroy(C_LibMinimap_LayerWindowId);
	
	UseMinimap = False;
	
	declare netwrite Integer Net_LibMinimap_SettingsUpdate for Teams[0];
	declare netwrite Text[Text] Net_LibMinimap_Settings for Teams[0];
	Net_LibMinimap_SettingsUpdate = -1;
	Net_LibMinimap_Settings.clear();
}

// ---------------------------------- //
/// Load the library (only before map is loaded).
Void Load() {
	Unload();
	Layers::Create(C_LibMinimap_LayerWindowId, Private_CreateManialinkMinimapWindow());
	Layers::Attach(C_LibMinimap_LayerWindowId);
	UseMinimap = True;
}
