// -------------------------------------- //
//  LIBRARY STORAGE PLAYER by domino54    //
//  script version: 2017-10-09            //
// -------------------------------------- //

#Const Version		"2017-10-09"
#Const ScriptName	"Libs/domino54/StoragePlayer.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/domino54/Bindings.Script.txt" as Bindings
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/Translations.Script.txt" as Translations

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "http://dominolink.aq.pl/music/"
#Const C_LibStoragePlayer_NbPlaylistRows	14		///< Amount of tracks displayed at one playlist page

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Text G_LibStoragePlayer_DefaultPlaylistURL;
declare Text G_LibStoragePlayer_PreviousPlaylistURL;

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
// Private
// ---------------------------------- //

// ---------------------------------- //
/** Create manialink for the music player layer
 *
 *	@param	_MediaBasePath		Base URL for the interface icons
 *	@param	_ThinTextFont		Font used on thin text
 *	@param	_ThickTextFont		Font used on thick text
 *
 *	@return		The music player layer
 */
Text Private_CreateManialinkMusicPlayer(Text _MediaBasePath, Text _ThinTextFont, Text _ThickTextFont) {
	declare MediaBasePath = C_ImgBase;
	if (_MediaBasePath != "" && Http.IsValidUrl(_MediaBasePath)) MediaBasePath = _MediaBasePath;

	declare PlaylistCards = "";
	for (I, 0, C_LibStoragePlayer_NbPlaylistRows - 1) {
		PlaylistCards ^= "<frameinstance modelid='FrameModel_PlaylistItem' id='Frame_PlaylistItem#"^I^"' hidden='1' pos='0 "^I * -5.5^"' />";
	}
	
	return """
<manialink version="3" name="LibStorage:Window">
<stylesheet>
	<style class="FontM" valign="center2" textemboss="1" textcolor="FFF" textfont="{{{TL::MLEncode(_ThinTextFont)}}}" />
	<style class="FontB" valign="center2" style="TextValueSmallSm" textcolor="FFF" textfont="{{{TL::MLEncode(_ThickTextFont)}}}" />
	<style class="timeLabel" valign="center2" style="TextRaceChrono" textemboss="1" textsize="2.5" textfont="{{{TL::MLEncode(_ThickTextFont)}}}" />
</stylesheet>

<frame id="Frame_StorageInGameMenu" z-index="10" hidden="1">

<!-- Global music plugin window -->
<frame id="Frame_StoragePlayerWindow" pos="-93 48">
	<!-- Window header -->
	<frame id="Frame_StoragePlayerHeader" pos="0 -2">
		<label pos="2" class="FontM" id="Label_WindowTitleText" textsize="4" textprefix="$t" />

		<!-- Total amount of tracks -->
		<frame id="Frame_TotalNbTracks" pos="178">
			<label pos="-2.75" halign="right" class="FontB" textsize="4" id="Label_PlaylistNbTracks" text="0" />
			<label pos="0 .375" class="FontM" halign="center" valign="center" text="♫" />
		</frame>

		<!-- Close window button -->
		<quad pos="182.5" size="7 7" halign="center" valign="center" style="Icons64x64_1" substyle="QuitRace" id="Quad_PlayerControlClose" ScriptEvents="1" />
	</frame>

	<!-- Separator -->
	<quad pos="0 -6" size="186 .5" valign="center" bgcolor="FFF" opacity=".5" />

	<frame pos="2 -8">
		<quad size="60 60" id="Quad_CurrentTrackCover" />

		<!-- track information -->
		<frame id="Frame_CurrentTrackInfo" pos="0 -62">
			<label pos="0 -2" size="60 3" class="FontB" textsize="2.5" text="???" id="Label_CurrentTrackAuthor" />
			<label pos="0 -5.75" size="50 3" class="FontM" textsize="1.5" text="???" id="Label_CurrentTrackTitle" />
			<label pos="60 -6.25" size="10 3" halign="right" class="FontB" textsize="1" textcolor="FFF" text="0/0" id="Label_CurrentTrackOrder" />
		</frame>

		<!-- track navigation bar -->
		<frame id="Frame_Navigation" pos="0 -71.25">
			<quad size="60 3" valign="center" id="Quad_TrackNavBarTrigger" ScriptEvents="1" />
			<quad size="0 .5" valign="center" bgcolor="FFF" id="Quad_TrackNavBarHover" hidden="1" />
			<quad size="0 .5" valign="center" bgcolor="FFF" id="Quad_TrackNavBarCur" />
			<quad size="60 .5" valign="center" bgcolor="000" opacity=".25" />
		</frame>

		<!-- Timer and controllers -->
		<frame id="Frame_PlayControls" pos="0 -74.75">
			<label pos="-.25" class="timeLabel" textcolor="BBB" text="0:00" id="Label_CurrentTrackTime" />
			<label pos="60.25" halign="right" class="timeLabel" textcolor="FFF" text="0:00" id="Label_CurrentTrackLength" />
			<quad
				pos="24" size="3.5 3.5" halign="center" valign="center" id="Quad_PlayerControlPrev" ScriptEvents="1"
				class="focus valid" image="{{{MediaBasePath}}}MusicNext.png" imagefocus="{{{MediaBasePath}}}MusicNextHover.png" rot="180"
			/>
			<quad
				pos="29" size="3.5 3.5" halign="center" valign="center" id="Quad_PlayerControlPlay" ScriptEvents="1"
				class="focus valid" image="{{{MediaBasePath}}}MusicPlay.png" imagefocus="{{{MediaBasePath}}}MusicPlayHover.png"
			/>
			<quad
				pos="29" size="3.5 3.5" halign="center" valign="center" id="Quad_PlayerControlPause" ScriptEvents="1" hidden="1"
				class="focus valid" image="{{{MediaBasePath}}}MusicPause.png" imagefocus="{{{MediaBasePath}}}MusicPauseHover.png"
			/>
			<quad
				pos="34" size="3.5 3.5" halign="center" valign="center" id="Quad_PlayerControlNext" ScriptEvents="1"
				class="focus valid" image="{{{MediaBasePath}}}MusicNext.png" imagefocus="{{{MediaBasePath}}}MusicNextHover.png"
			/>
		</frame>

		<!-- Playlist tracks items -->
		<frame id="Frame_PlaylistItems" pos="62">
			<!-- Model of the playlist item -->
			<framemodel id="FrameModel_PlaylistItem">
				<label pos="1 -2.5" size="108" class="FontM" textsize="1.5" id="Label_ListItemTitle" />
				<label pos="119 -2.5" class="FontM" halign="right" textsize="1.5" id="Label_ListItemDuration" />
				<quad size="120 5" opacity=".25" id="Quad_ListItemBackground" ScriptEvents="1" />
				<quad size="120 5" bgcolor="FFF" opacity=".25" id="Quad_IsCurrentlyPlaying" hidden="1" />
				<quad size="120 5" bgcolor="FFF" opacity=".125" />
			</framemodel>
			{{{PlaylistCards}}}
		</frame>
	</frame>

	<!-- Separator -->
	<quad pos="0 -86.5" size="186 .5" valign="center" bgcolor="FFF" opacity=".5" />

	<!-- Custom playlist setup row -->
	<frame id="Frame_CustomPlaylistEnter" pos="2 -90">
		<label class="FontB" textsize="1" textprefix="$t$s" id="Label_CustomPlaylist" />
		<entry
			size="80 4" valign="center2" id="Entry_CustomPlaylistURL" focusareacolor1="0000" focusareacolor2="0002"
			textsize="1" textcolor="FFF" textfont="{{{TL::MLEncode(_ThinTextFont)}}}"
		/>
	</frame>

	<!-- Page switch -->
	<frame id="Frame_PlaylistPageSwitch" pos="181.5 -90.75">
		<label pos="-9.5 .25" halign="right" class="FontB" textsize="2" text="1/1" id="Label_CurPlaylistPage" />
		<frame pos="-6">
			<label halign="center" valign="center2" textsize="2" text="►" textcolor="FFF" rot="-180" />
			<label pos=".125 -.125" halign="center" valign="center2" textsize="2" text="►" textcolor="000" rot="-180" />
			<quad size="5 5" halign="center" valign="center" bgcolor="FFF2" bgcolorfocus="FFF4" id="Quad_PlaylistPagePrev" ScriptEvents="1" hidden="1" />
		</frame>
		<frame>
			<label halign="center" valign="center2" textsize="2" text="►" textcolor="FFF" />
			<label pos=".125 -.125" halign="center" valign="center2" textsize="2" text="►" textcolor="000" />
			<quad size="5 5" halign="center" valign="center" bgcolor="FFF2" bgcolorfocus="FFF4" id="Quad_PlaylistPageNext" ScriptEvents="1" hidden="1" />
		</frame>
	</frame>
</frame>

<!-- Background blur -->
<quad size="320 180" halign="center" valign="center" image="file://Media/Images/Effects/Vignette.dds" />
<quad size="320 180" halign="center" valign="center" style="Bgs1" substyle="BgDialogBlur" opacity="0" />
<quad size="320 180" halign="center" valign="center" bgcolor="000" opacity=".5" />

</frame>

<script><!--

#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_Storage_RequestTimeOut			15000	///< Time before unfinished request is destroyed
#Const C_Storage_DefaultPlayerColor		<.75, .75, .75>
#Const C_Storage_PostCountdownTime		5000
#Const C_Storage_CountdownFadeIn		5000
#Const C_Storage_CountdownFadeOut		3000

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare CHttpRequest G_PlaylistRequest;	///< HTTP request pointing the current playlist file
declare CAudioSource G_CurrentTrack;		///< Currently played track item
declare Boolean G_ForceTrackChange;		///< Force script to change currently played track

// ---------------------------------- //
// Current playlist data
declare Text G_PlaylistMusicPath;		///< URL of the directory containing playlist music files
declare Text G_PlaylistImagePath;		///< URL of the directory containing playlist albums covers images
declare Text G_PlaylistDefaultImage;	///< Address of default cover image
declare Integer G_PlaylistNbTracks;	///< Total amount of tracks in current playlist
declare Integer G_PlaylistNbAlbums;	///< Total amount of albums in current playlist

// ---------------------------------- //
// Available tracks information
declare Text[Integer] G_TrackInfoTitle;		///< tracks titles
declare Text[Integer] G_TrackInfoAuthor;	///< tracks authors
declare Text[Integer] G_TrackInfoAlbum;	///< tracks albums
declare Text[Integer] G_TrackInfoGenere;	///< tracks generes
declare Vec3[Integer] G_TrackInfoColor;	///< tracks colors
declare Text[Integer] G_TrackInfoFileName;	///< tracks files names
declare Real[Integer] G_TrackInfoDuration;	///< tracks duration

// ---------------------------------- //
// Available albums information
declare Text[Integer] G_AlbumInfoName;		///< Titles of albums
declare Text[Integer] G_AlbumInfoImage;	///< Cover file name

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_StorageInGameMenu	<=> (Page.GetFirstChild("Frame_StorageInGameMenu") as CMlFrame);
declare Label_PlaylistNbTracks	<=> (Page.GetFirstChild("Label_PlaylistNbTracks") as CMlLabel);
declare Label_CustomPlaylist	<=> (Page.GetFirstChild("Label_CustomPlaylist") as CMlLabel);
declare Entry_CustomPlaylistURL	<=> (Page.GetFirstChild("Entry_CustomPlaylistURL") as CMlEntry);
declare Label_CurPlaylistPage	<=> (Page.GetFirstChild("Label_CurPlaylistPage") as CMlLabel);
declare Quad_PlaylistPagePrev	<=> (Page.GetFirstChild("Quad_PlaylistPagePrev") as CMlQuad);
declare Quad_PlaylistPageNext	<=> (Page.GetFirstChild("Quad_PlaylistPageNext") as CMlQuad);

/// Current track information
declare Quad_CurrentTrackCover		<=> (Page.GetFirstChild("Quad_CurrentTrackCover") as CMlQuad);
declare Label_CurrentTrackAuthor	<=> (Page.GetFirstChild("Label_CurrentTrackAuthor") as CMlLabel);
declare Label_CurrentTrackTitle		<=> (Page.GetFirstChild("Label_CurrentTrackTitle") as CMlLabel);
declare Label_CurrentTrackOrder		<=> (Page.GetFirstChild("Label_CurrentTrackOrder") as CMlLabel);
declare Label_CurrentTrackTime		<=> (Page.GetFirstChild("Label_CurrentTrackTime") as CMlLabel);
declare Label_CurrentTrackLength	<=> (Page.GetFirstChild("Label_CurrentTrackLength") as CMlLabel);

/// Music player controls
declare Quad_TrackNavBarCur		<=> (Page.GetFirstChild("Quad_TrackNavBarCur") as CMlQuad);
declare Quad_TrackNavBarTrigger	<=> (Page.GetFirstChild("Quad_TrackNavBarTrigger") as CMlQuad);
declare Quad_TrackNavBarHover	<=> (Page.GetFirstChild("Quad_TrackNavBarHover") as CMlQuad);
declare Quad_PlayerControlPrev	<=> (Page.GetFirstChild("Quad_PlayerControlPrev") as CMlQuad);
declare Quad_PlayerControlPlay	<=> (Page.GetFirstChild("Quad_PlayerControlPlay") as CMlQuad);
declare Quad_PlayerControlPause	<=> (Page.GetFirstChild("Quad_PlayerControlPause") as CMlQuad);
declare Quad_PlayerControlNext	<=> (Page.GetFirstChild("Quad_PlayerControlNext") as CMlQuad);

// Load playlist cards
declare CMlFrame[] Frame_PlaylistItems;
for (I, 0, {{{C_LibStoragePlayer_NbPlaylistRows - 1}}}) Frame_PlaylistItems.add((Page.GetFirstChild("Frame_PlaylistItem#"^I) as CMlFrame));

// ---------------------------------- //
// Netcode
declare netread Text Net_LibStoragePlayer_ServerPlaylistURL for Teams[0];

// ---------------------------------- //
// Persistent settings
declare persistent Persistent_Storage_CustomPlaylistURL for LocalUser = "";
declare persistent Persistent_Storage_CurrentPlaylistURL for LocalUser = "";
declare persistent Persistent_Storage_PreviousPlaylistURL for LocalUser = "";
declare persistent Persistent_Storage_IsPlaying for LocalUser = True;
declare persistent Persistent_Storage_CurrentTrackIndex for LocalUser = 0;
declare persistent Persistent_Storage_PreviousPlayPoint for LocalUser = 0.;
declare persistent Persistent_Storage_InGameWindowVisible for LocalUser = False;

// ---------------------------------- //
// Shared variables
declare LibStoragePlayer_ToggleShowWindow for This = False;
declare LibStoragePlayer_CurSongAlbumImage for This = "";

// ---------------------------------- //
// Variables
declare JumpToLatestPlayPoint = True;		///< Forces script to skip newly loaded track to the latests listening point
declare CurrentTrackIsDownloading = True;	///< Disallows script to skip just downloaded track
declare ClearTrackInformation = True;		///< Forces script to clear all information in player
declare DisplayStoragePlayer = False;		///< Current plugin window visibility
declare StartNewRequest = True;			///< Forces script to load another playlist
declare PlaylistRequestStartTime = -1;	///< Time of the request start used to determine timeout

declare UpdatePlaylistItems = True;
declare InterfaceColor = C_Storage_DefaultPlayerColor;
declare PlaylistCurPage = 1;
declare PlaylistNbPages = 1;

// Update
declare PrevInterfaceColor = Vec3;
declare PrevCustomPlaylistURL = Persistent_Storage_CustomPlaylistURL;
declare PrevIsPlaying = False;

// ---------------------------------- //
// Initialize music plugin
Translate("Label_WindowTitleText", "Storage Music Player");
Translate("Label_CustomPlaylist", "Custom playlist URL:");

Entry_CustomPlaylistURL.RelativePosition_V3.X = Label_CustomPlaylist.RelativePosition_V3.X + ComputeWidth(Label_CustomPlaylist) + 1.;
Entry_CustomPlaylistURL.Value = Persistent_Storage_CustomPlaylistURL;

EnableMenuNavigation(False, False, Null, 0);
LibStoragePlayer_CurSongAlbumImage = "";
JumpToLatestPlayPoint = True;
StartNewRequest = True;
G_ForceTrackChange = True;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Events management
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// On mouse click
	if (Event.Type == CMlEvent::Type::MouseClick) {
		// ---------------------------------- //
		// Play sound
		if (Event.Control.HasClass("valid")) Audio.PlaySoundEvent(CAudioManager::ELibSound::Valid, 1, 0.);
		
		// ---------------------------------- //
		// Do action
		switch (Event.ControlId) {
			// ---------------------------------- //
			// Resume playback
			case "Quad_PlayerControlPlay" : Persistent_Storage_IsPlaying = True;
			
			// ---------------------------------- //
			// Pause playback
			case "Quad_PlayerControlPause" : Persistent_Storage_IsPlaying = False;
			
			// ---------------------------------- //
			// Previous track button
			case "Quad_PlayerControlPrev" : {
				if (G_CurrentTrack != Null && G_CurrentTrack.PlayCursor > 10)
					G_CurrentTrack.PlayCursor = 0.;

				// Go to the next track
				else PrevTrack();
			}
			// ---------------------------------- //
			// Next track button
			case "Quad_PlayerControlNext" : NextTrack();
			
			// ---------------------------------- //
			// Travel to selected play point
			case "Quad_TrackNavBarTrigger" : {
				if (G_CurrentTrack == Null || G_CurrentTrack.PlayLength <= 0) continue;
				declare Ratio = (Input.MousePos.X - Event.Control.AbsolutePosition_V3.X) / Event.Control.Size.X / Event.Control.AbsoluteScale;
				G_CurrentTrack.PlayCursor = G_CurrentTrack.PlayLength * Ratio;
			}
			// ---------------------------------- //
			// Play track from the playlist
			case "Quad_ListItemBackground" : {
				declare Integer CurrentTrackOrder for Event.Control;
				if (CurrentTrackOrder < 0 || CurrentTrackOrder == Persistent_Storage_CurrentTrackIndex) continue;
				GoToTrack(CurrentTrackOrder);
			}
			// ---------------------------------- //
			// Previous playlist page
			case "Quad_PlaylistPagePrev" : {
				if (PlaylistCurPage <= 1) continue;
				PlaylistCurPage -= 1; 
				UpdatePlaylistItems = True;
			}
			// ---------------------------------- //
			// Next playlist page
			case "Quad_PlaylistPageNext" : {
				if (PlaylistCurPage >= PlaylistNbPages) continue;
				PlaylistCurPage += 1;
				UpdatePlaylistItems = True;
			}
			// ---------------------------------- //
			// Close the music player interface
			case "Quad_PlayerControlClose" : Persistent_Storage_InGameWindowVisible = False;
		}
	}
	// ---------------------------------- //
	// On mouse over
	else if (Event.Type == CMlEvent::Type::MouseOver) {
		// ---------------------------------- //
		// Play sound
		if (Event.Control.HasClass("focus")) Audio.PlaySoundEvent(CAudioManager::ELibSound::Focus, 1, 0.);
		
		// ---------------------------------- //
		// Show navigation bar
		if (Event.ControlId == "Quad_TrackNavBarTrigger") Quad_TrackNavBarHover.Show();
	}
	// ---------------------------------- //
	// On mouse out
	else if (Event.Type == CMlEvent::Type::MouseOut) {
		// ---------------------------------- //
		// Hide navigation bar
		if (Event.ControlId == "Quad_TrackNavBarTrigger") Quad_TrackNavBarHover.Hide();
	}
	// ---------------------------------- //
	// On menu navigation
	else if (Event.Type == CMlEvent::Type::MenuNavigation) {
		if (Event.MenuNavAction == CMlEvent::EMenuNavAction::Cancel) {
			Persistent_Storage_InGameWindowVisible = False;
		}
	}
}

// ---------------------------------- //
// Toggle music widget visibility
if (Bindings_Listener("LibStoragePlayer_Open", "F4")) {
	Persistent_Storage_InGameWindowVisible = !Persistent_Storage_InGameWindowVisible;
}

// ---------------------------------- //
// Toggle play / pause
if (Bindings_Listener("LibStoragePlayer_Play", "K")) {
	Persistent_Storage_IsPlaying = !Persistent_Storage_IsPlaying;
}

// ---------------------------------- //
// Go to the previous track
if (Bindings_Listener("LibStoragePlayer_Prev", "J")) {
	if (G_CurrentTrack != Null && G_CurrentTrack.PlayCursor > 10)
		G_CurrentTrack.PlayCursor = 0.;
	else PrevTrack();
}

// ---------------------------------- //
// Go to the next track
if (Bindings_Listener("LibStoragePlayer_Next", "L")) NextTrack();

// ---------------------------------- //
// Toggle show Storage Player
if (LibStoragePlayer_ToggleShowWindow) {
	LibStoragePlayer_ToggleShowWindow = False;
	Persistent_Storage_InGameWindowVisible = True;
}

// ---------------------------------- //
// Update window visibility
DisplayStoragePlayer = Persistent_Storage_InGameWindowVisible && !IsInGameMenuDisplayed;

if (Frame_StorageInGameMenu.Visible != DisplayStoragePlayer) {
	Frame_StorageInGameMenu.Visible = DisplayStoragePlayer;
	EnableMenuNavigation(DisplayStoragePlayer, False, Null, 0);
	
	// Hide scores table while using music plugin
	if (Frame_StorageInGameMenu.Visible) ClientUI.ScoreTableVisibility = CUIConfig::EVisibility::ForcedHidden;
	else ClientUI.ScoreTableVisibility = CUIConfig::EVisibility::None;
	ClientUI.AltMenuNoCustomScores = Frame_StorageInGameMenu.Visible;
	
	// Play sound
	declare Sound = CAudioManager::ELibSound::HideDialog;
	if (Frame_StorageInGameMenu.Visible) Sound = CAudioManager::ELibSound::ShowDialog;
	Audio.PlaySoundEvent(Sound, 0, 0.);
}

// ---------------------------------- //
// Update playlist currently played by server
if (Persistent_Storage_PreviousPlaylistURL != Net_LibStoragePlayer_ServerPlaylistURL) {
	Persistent_Storage_PreviousPlaylistURL = Net_LibStoragePlayer_ServerPlaylistURL;

	if (Persistent_Storage_CustomPlaylistURL == "") {
		Persistent_Storage_CurrentPlaylistURL = Net_LibStoragePlayer_ServerPlaylistURL;
		ClearPlaylist();
		StartNewRequest = True;
		ClearTrackInformation = True;
	}
}

// ---------------------------------- //
// Load new custom playlist specified by user
if (Persistent_Storage_CustomPlaylistURL != Entry_CustomPlaylistURL.Value) {
	Persistent_Storage_CustomPlaylistURL = Entry_CustomPlaylistURL.Value;
	
	if (Persistent_Storage_CustomPlaylistURL != "" && Http.IsValidUrl(Persistent_Storage_CustomPlaylistURL))
		Persistent_Storage_CurrentPlaylistURL = Persistent_Storage_CustomPlaylistURL;
	else
		Persistent_Storage_CurrentPlaylistURL = Net_LibStoragePlayer_ServerPlaylistURL;
	
	ClearPlaylist();
	StartNewRequest = True;
	ClearTrackInformation = True;
}

// ---------------------------------- //
// Start the new playlist HTTP request
if (StartNewRequest) {
	StartNewRequest = False;
	
	// ---------------------------------- //
	// Check if the URL is valid and create request
	if (Http.IsValidUrl(Persistent_Storage_CurrentPlaylistURL)) {
		if (G_PlaylistRequest != Null) Http.Destroy(G_PlaylistRequest);
		G_PlaylistRequest = Http.CreateGet(Persistent_Storage_CurrentPlaylistURL, False);
		PlaylistRequestStartTime = Now;
	}
}

// ---------------------------------- //
// Manage ongoing playlist HTTP request
if (G_PlaylistRequest != Null) {
	// ---------------------------------- //
	// Read information from successful request
	if (G_PlaylistRequest.IsCompleted) {
		declare PlaylistDocument = Xml.Create(G_PlaylistRequest.Result);
		LoadPlaylist(PlaylistDocument);
		Xml.Destroy(PlaylistDocument);
		
		// ---------------------------------- //
		// Switch to a random track, unless player loads previous playlist
		if (!JumpToLatestPlayPoint) Persistent_Storage_CurrentTrackIndex = ML::Rand(0, G_PlaylistNbTracks - 1);
		
		UpdatePlaylistItems = True;
		PlaylistCurPage = 1;
		PlaylistNbPages = (G_PlaylistNbTracks - 1) / {{{C_LibStoragePlayer_NbPlaylistRows}}} + 1;
		Label_PlaylistNbTracks.Value = TL::ToText(G_PlaylistNbTracks);
		
		// Destroy request
		Http.Destroy(G_PlaylistRequest);
		G_PlaylistRequest = Null;
	}
	
	// ---------------------------------- //
	// Destroy request if it timed out
	else if (Now > PlaylistRequestStartTime + C_Storage_RequestTimeOut) {
		Http.Destroy(G_PlaylistRequest);
		G_PlaylistRequest = Null;
	}
}

// ---------------------------------- //
// Change the currently played track
if (G_ForceTrackChange && G_PlaylistNbTracks > 0) {
	G_ForceTrackChange = False;
	UpdatePlaylistItems = True;

	declare I = Persistent_Storage_CurrentTrackIndex;
	Label_CurrentTrackOrder.Value = I + 1^"/"^G_PlaylistNbTracks;
	
	// Change the currently shown playlist page
	PlaylistCurPage = I / {{{C_LibStoragePlayer_NbPlaylistRows}}} + 1;
	
	// ---------------------------------- //
	// Load track from URL
	if (G_TrackInfoFileName.existskey(I)) {
		// ---------------------------------- //
		// Destroy previous sound
		if (G_CurrentTrack != Null) {
			G_CurrentTrack.Stop();
			Audio.DestroySound(G_CurrentTrack);
			G_CurrentTrack = Null;
		}
		
		// ---------------------------------- //
		// Create new sound
		declare TrackFileURL = G_PlaylistMusicPath^G_TrackInfoFileName[I];
		if (Http.IsValidUrl(TrackFileURL)) {
			G_CurrentTrack = Audio.CreateSound(TrackFileURL, 0., True, False, False);
			Label_CurrentTrackLength.Value = TL::TimeToText(ML::FloorInteger(G_CurrentTrack.PlayLength * 1000));
			G_CurrentTrack.Play();
		}
		
		// Set the current track name
		declare CurTrackName = "???";
		if (G_TrackInfoTitle.existskey(I)) CurTrackName = G_TrackInfoTitle[I];
		Label_CurrentTrackTitle.Value = CurTrackName;
		
		// Set the current track autor
		declare CurTrackAuthor = "???";
		if (G_TrackInfoAuthor.existskey(I)) CurTrackAuthor = G_TrackInfoAuthor[I];
		Label_CurrentTrackAuthor.Value = TL::ToUpperCase(CurTrackAuthor);
		
		// Set the player controls color
		if (G_TrackInfoColor.existskey(I)) InterfaceColor = G_TrackInfoColor[I];
		else InterfaceColor = C_Storage_DefaultPlayerColor;
		
		// Set the current track album cover image
		declare CurTrackImage = G_PlaylistDefaultImage;
		if (G_TrackInfoAlbum.existskey(I)) {
			declare AlbumIndex = G_AlbumInfoName.keyof(G_TrackInfoAlbum[I]);
			if (AlbumIndex != -1 && G_AlbumInfoImage.existskey(AlbumIndex)) CurTrackImage = G_PlaylistImagePath^G_AlbumInfoImage[AlbumIndex];
		}
		Quad_CurrentTrackCover.ImageUrl = CurTrackImage;
	}
}

// ---------------------------------- //
// Manage currently loaded track item
if (G_CurrentTrack != Null) {
	// ---------------------------------- //
	// Travel to the latest moment if music player has just started
	if (JumpToLatestPlayPoint && G_CurrentTrack.IsPlaying && G_CurrentTrack.PlayCursor != 0.) {
		JumpToLatestPlayPoint = False;
		G_CurrentTrack.PlayCursor = Persistent_Storage_PreviousPlayPoint;
	}
	
	// ---------------------------------- //
	// Track is playing
	if (Persistent_Storage_IsPlaying) {
		if (!G_CurrentTrack.IsPlaying) {
			G_CurrentTrack.Play();
			G_CurrentTrack.PlayCursor = Persistent_Storage_PreviousPlayPoint;
		}
		else if (G_CurrentTrack.PlayCursor != 0) Persistent_Storage_PreviousPlayPoint = G_CurrentTrack.PlayCursor;
	}
	// ---------------------------------- //
	// Track is paused
	else if (G_CurrentTrack.IsPlaying) G_CurrentTrack.Stop();
	
	// ---------------------------------- //
	// Somg volume depending on game countdown
	if (G_CurrentTrack.IsPlaying) G_CurrentTrack.Volume = GetCountdownVolume();
	
	// ---------------------------------- //
	// Current track is being downloaded
	if (G_CurrentTrack.PlayLength <= 0) {
		if (!CurrentTrackIsDownloading) {
			CurrentTrackIsDownloading = True;
			Label_CurrentTrackTime.SetText("0:00");
			Label_CurrentTrackLength.SetText("0:00");
		}

		// ---------------------------------- //
		// Blink the progress bar to represent downloading status
		declare Sinus = ML::Sin(Now / 125.) / 2 + .5;
		Quad_TrackNavBarCur.Opacity = Sinus;
		Quad_TrackNavBarCur.Size.X = Quad_TrackNavBarTrigger.Size.X;
	}
	// ---------------------------------- //
	// Current track is downloaded and playable
	else {
		// ---------------------------------- //
		// Start playing the track if it just downloaded
		if (CurrentTrackIsDownloading && G_CurrentTrack.PlayLength >= 5) {
			CurrentTrackIsDownloading = False;
			Label_CurrentTrackLength.SetText(TL::TimeToText(ML::FloorInteger(G_CurrentTrack.PlayLength * 1000)));
			G_CurrentTrack.Play();
		}
		
		// ---------------------------------- //
		// Set the progress bar size
		if (PageIsVisible) {
			declare Real PercentageProgress;
			if (G_CurrentTrack.PlayLength == 0) PercentageProgress = 0.;
			else PercentageProgress = ML::Max(0., Persistent_Storage_PreviousPlayPoint / G_CurrentTrack.PlayLength);
			
			if (Quad_TrackNavBarCur.Opacity != 1) Quad_TrackNavBarCur.Opacity = 1.;
			Quad_TrackNavBarCur.Size.X =  Quad_TrackNavBarTrigger.Size.X * PercentageProgress;
			
			// ---------------------------------- //
			// Display current track play time
			Label_CurrentTrackTime.Value = TL::TimeToText(ML::FloorInteger(Persistent_Storage_PreviousPlayPoint * 1000));
		}
	}
	
	// Switch to the next track if current one is over
	if (G_CurrentTrack.PlayLength >= 5 && G_CurrentTrack.PlayCursor >= G_CurrentTrack.PlayLength - .25) NextTrack();
	
	// Force script to clear current track information when there is no track
	if (ClearTrackInformation) ClearTrackInformation = True;
}

// ---------------------------------- //
// Update current track cover image
if (PrevIsPlaying != (G_CurrentTrack != Null && G_CurrentTrack.IsPlaying)) {
	PrevIsPlaying = G_CurrentTrack != Null && G_CurrentTrack.IsPlaying;

	if (PrevIsPlaying) LibStoragePlayer_CurSongAlbumImage = Quad_CurrentTrackCover.ImageUrl;
	else LibStoragePlayer_CurSongAlbumImage = "";
}

if (!Frame_StorageInGameMenu.Visible) continue;

// ---------------------------------- //
// Update the tracks list window frame
if (UpdatePlaylistItems) {
	UpdatePlaylistItems = False;
	
	// ---------------------------------- //
	// Update the playlist page switch
	Quad_PlaylistPagePrev.Visible = PlaylistCurPage > 1;
	Quad_PlaylistPageNext.Visible = PlaylistCurPage < PlaylistNbPages;
	Label_CurPlaylistPage.Value = PlaylistCurPage^"/"^PlaylistNbPages;
	
	// ---------------------------------- //
	// Configure playlist rows
	foreach (I => Frame in Frame_PlaylistItems) {
		declare TrackIndex = I + (PlaylistCurPage - 1) * Frame_PlaylistItems.count;
		Frame.Visible = TrackIndex < G_PlaylistNbTracks;
		if (!Frame.Visible) continue;
		
		declare Label_ListItemTitle <=> (Frame.GetFirstChild("Label_ListItemTitle") as CMlLabel);
		declare Label_ListItemDuration <=> (Frame.GetFirstChild("Label_ListItemDuration") as CMlLabel);
		declare Quad_ListItemBackground <=> (Frame.GetFirstChild("Quad_ListItemBackground") as CMlQuad);
		declare Quad_IsCurrentlyPlaying <=> (Frame.GetFirstChild("Quad_IsCurrentlyPlaying") as CMlQuad);
		
		// Track name
		declare CurTrackName = "???";
		if (G_TrackInfoTitle.existskey(TrackIndex)) CurTrackName = G_TrackInfoTitle[TrackIndex];
		
		// Track autor
		declare CurTrackAuthor = "???";
		if (G_TrackInfoAuthor.existskey(TrackIndex)) CurTrackAuthor = G_TrackInfoAuthor[TrackIndex];
		
		// Track duration
		declare CurTrackDuration = 0.;
		if (G_TrackInfoDuration.existskey(TrackIndex)) CurTrackDuration = G_TrackInfoDuration[TrackIndex];
		Label_ListItemDuration.Value = TL::TimeToText(ML::FloorInteger(CurTrackDuration));
		
		// Set the item label value
		Label_ListItemTitle.Value = TrackIndex + 1^". "^CurTrackAuthor^" - "^CurTrackName;
		
		// Set the item elements colors
		Quad_IsCurrentlyPlaying.Visible = TrackIndex == Persistent_Storage_CurrentTrackIndex;
		
		// Set the track index
		declare Integer CurrentTrackOrder for Quad_ListItemBackground;
		CurrentTrackOrder = TrackIndex;
	}
}

// ---------------------------------- //
// Clear current track information if there is no track playing
if (ClearTrackInformation && G_CurrentTrack == Null) {
	ClearTrackInformation = False;
	UpdatePlaylistItems = True;
	
	Label_CurrentTrackTitle.Value = "???";
	Label_CurrentTrackAuthor.Value = "???";
	Label_CurrentTrackTime.Value = "0:00";
	Label_CurrentTrackLength.Value = "0:00";
	
	Quad_TrackNavBarCur.Size.X = 0.;
	Quad_CurrentTrackCover.ImageUrl = G_PlaylistDefaultImage;
	
	// Update index
	Label_CurrentTrackOrder.Value = "0/"^G_PlaylistNbTracks;
}

// ---------------------------------- //
// Update color of the interface
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	
	Quad_TrackNavBarCur.BgColor		= InterfaceColor;
	Quad_TrackNavBarHover.BgColor	= InterfaceColor;
	Label_CurrentTrackTime.TextColor	= InterfaceColor;
	Quad_PlayerControlPrev.Colorize		= InterfaceColor;
	Quad_PlayerControlPlay.Colorize		= InterfaceColor;
	Quad_PlayerControlPause.Colorize	= InterfaceColor;
	Quad_PlayerControlNext.Colorize		= InterfaceColor;
	
	foreach (Frame in Frame_PlaylistItems) {
		declare Quad_ListItemBackground <=> (Frame.GetFirstChild("Quad_ListItemBackground") as CMlQuad);
		Quad_ListItemBackground.BgColorFocus = InterfaceColor;
	}
}

// ---------------------------------- //
// Update play and pause buttons visibility
Quad_PlayerControlPause.Visible = G_CurrentTrack != Null && Persistent_Storage_IsPlaying;
Quad_PlayerControlPlay.Visible = !Quad_PlayerControlPause.Visible;

// ---------------------------------- //
// Show the target play point while hovering navigation bar
if (Quad_TrackNavBarHover.Visible) {
	declare Ratio = (Input.MousePos.X - Quad_TrackNavBarTrigger.AbsolutePosition_V3.X) / Quad_TrackNavBarTrigger.AbsoluteScale;
	if (Quad_TrackNavBarHover.Size.X != Ratio) Quad_TrackNavBarHover.Size.X = Ratio;
	
	// ---------------------------------- //
	// Progress bar opacity before play point
	if (Quad_TrackNavBarHover.Size.X < Quad_TrackNavBarCur.Size.X) {
		Quad_TrackNavBarCur.Opacity = .5;
		Quad_TrackNavBarHover.Opacity = 1.;
	}
	// ---------------------------------- //
	// Progress bar opacity after play point
	else {
		Quad_TrackNavBarHover.Opacity = .5;
		Quad_TrackNavBarCur.Opacity = 1.;
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/// Reset the currently loaded playlist information.
Void ClearPlaylist() {
	// ---------------------------------- //
	// Stop playing current track
	if (G_CurrentTrack != Null) {
		Audio.DestroySound(G_CurrentTrack);
		G_CurrentTrack = Null;
	}
	
	// Clear index
	declare persistent Integer Persistent_Storage_CurrentTrackIndex for LocalUser;
	Persistent_Storage_CurrentTrackIndex = 0;
	
	// Reset playlist data
	G_PlaylistMusicPath = "";
	G_PlaylistImagePath = "";
	G_PlaylistDefaultImage = "";
	G_PlaylistNbTracks = 0;
	G_PlaylistNbAlbums = 0;
	
	// Reset tracks info
	G_TrackInfoTitle.clear();
	G_TrackInfoAuthor.clear();
	G_TrackInfoAlbum.clear();
	G_TrackInfoGenere.clear();
	G_TrackInfoColor.clear();
	G_TrackInfoFileName.clear();
	
	// Reset albums info
	G_AlbumInfoName.clear();
	G_AlbumInfoImage.clear();
}

// ---------------------------------- //
/** Read the information from playlist XML file.
 *	
 *	@param	_Document	XML document with data of the playlist.
 */
Void LoadPlaylist(CXmlDocument _Document) {
	if (_Document == Null || _Document.Root == Null || _Document.Root.Name != "playlist") return;

	foreach (Node in _Document.Root.Children) {
		// ---------------------------------- //
		// Get the playlist information
		if (Node.Name == "musicurl") G_PlaylistMusicPath = Node.TextContents;
		if (Node.Name == "coverurl") G_PlaylistImagePath = Node.TextContents;
		if (Node.Name == "defaultcover") G_PlaylistDefaultImage = Node.TextContents;
		
		// ---------------------------------- //
		// Get the tracks list
		if (Node.Name == "songs") {
			G_PlaylistNbTracks = 0;

			foreach (Track in Node.Children) {
				if (Track.Name != "song") continue;
				declare I = G_PlaylistNbTracks;

				// Name of the track
				declare CurTrackTitle = Track.GetAttributeText("name", "");
				if (CurTrackTitle != "") G_TrackInfoTitle[I] = CurTrackTitle;
				
				// Author of the track
				declare CurTrackAuthor = Track.GetAttributeText("author", "");
				if (CurTrackAuthor != "") G_TrackInfoAuthor[I] = CurTrackAuthor;
				
				// Name of the track album
				declare CurTrackAlbum = Track.GetAttributeText("album", "");
				if (CurTrackAlbum != "") G_TrackInfoAlbum[I] = CurTrackAlbum;
				
				// Genere of the track
				declare CurTrackGenere = Track.GetAttributeText("genere", "");
				if (CurTrackGenere != "") G_TrackInfoGenere[I] = CurTrackGenere;
				
				// Color of the track
				declare TrackColorText = Track.GetAttributeText("color", "");
				if (TrackColorText != "") {
					declare SplitRGB = TL::Split(" ", TrackColorText);
					if (SplitRGB.count == 3) {
						declare Color = <0., 0., 0.>;
						for (Axis, 0, 2) Color[Axis] = TL::ToReal(SplitRGB[Axis]);
						if (Color != <0., 0., 0.>) G_TrackInfoColor[I] = Color;
					}
				}
				
				// Get name of the track file
				declare TrackFileName = Track.GetAttributeText("url", "");
				if (TrackFileName != "") G_TrackInfoFileName[I] = TrackFileName;
				
				// Get track duration
				declare TrackDuration = Track.GetAttributeReal("duration", 0.);
				if (TrackDuration > 0) G_TrackInfoDuration[I] = TrackDuration;
				
				G_PlaylistNbTracks += 1;
			}
		}
		
		// ---------------------------------- //
		// Load all albums
		else if (Node.Name == "albums") {
			G_PlaylistNbAlbums = 0;
			
			foreach (Album in Node.Children) {
				if (Album.Name != "album") continue;
				declare I = G_PlaylistNbAlbums;
				
				// Name of the album
				declare Text AlbumName = Album.GetAttributeText("name", "");
				if (AlbumName != "") G_AlbumInfoName[I] = AlbumName;
				
				// URL of the album image
				declare Text AlbumCoverURL = Album.GetAttributeText("coverurl", "");
				if (AlbumCoverURL != "") G_AlbumInfoImage[I] = AlbumCoverURL;

				G_PlaylistNbAlbums += 1;
			}
		}
	}
	
	// Force track change
	G_ForceTrackChange = True;
}

// ---------------------------------- //
/// Go to the previous track in the playlist.
Void PrevTrack() {
	if (G_PlaylistNbTracks <= 0) return;
	G_ForceTrackChange = True;
	
	// Set higher index
	declare persistent Integer Persistent_Storage_CurrentTrackIndex for LocalUser;
	Persistent_Storage_CurrentTrackIndex -= 1;
	if (Persistent_Storage_CurrentTrackIndex < 0) Persistent_Storage_CurrentTrackIndex = G_PlaylistNbTracks - 1;
	
	// Set preloaded time to 0
	declare persistent Real Persistent_Storage_PreviousPlayPoint for LocalUser;
	Persistent_Storage_PreviousPlayPoint = 0.;
}

// ---------------------------------- //
/// Go to the next track in the playlist.
Void NextTrack() {
	if (G_PlaylistNbTracks <= 0) return;
	G_ForceTrackChange = True;
	
	// Set higher index
	declare persistent Integer Persistent_Storage_CurrentTrackIndex for LocalUser;
	Persistent_Storage_CurrentTrackIndex += 1;
	if (Persistent_Storage_CurrentTrackIndex > G_PlaylistNbTracks - 1) Persistent_Storage_CurrentTrackIndex = 0;
	
	// Set preloaded time to 0
	declare persistent Real Persistent_Storage_PreviousPlayPoint for LocalUser;
	Persistent_Storage_PreviousPlayPoint = 0.;
}

// ---------------------------------- //
/** Change current track to specific one one in the playlist.
 *
 *	@param	_TrackIndex		Index of the track.
 */
Void GoToTrack(Integer _TrackIndex) {
	if (_TrackIndex < 0 || _TrackIndex >= G_PlaylistNbTracks) return;
	G_ForceTrackChange = True;
	
	// Set higher index
	declare persistent Integer Persistent_Storage_CurrentTrackIndex for LocalUser;
	Persistent_Storage_CurrentTrackIndex = _TrackIndex;
	
	// Set preloaded time to 0
	declare persistent Real Persistent_Storage_PreviousPlayPoint for LocalUser;
	Persistent_Storage_PreviousPlayPoint = 0.;
}

// ---------------------------------- //
/** Get the music volume factor depending on the countdown time.
 *
 *	@return		The music volume factor.
 */
Real GetCountdownVolume() {
	declare persistent Boolean Persistent_LibInterfancy_DisableCountdownSong for LocalUser;
	if (Persistent_LibInterfancy_DisableCountdownSong) return 1.;
	
	declare netread Integer Net_LibStoragePlayer_EndTime for Teams[0];
	declare netread Integer Net_LibStoragePlayer_CountdownDuration for Teams[0];
	if (Net_LibStoragePlayer_EndTime <= 0 || Net_LibStoragePlayer_CountdownDuration <= 0) return 1.;
	
	// ---------------------------------- //
	// Time above the limit
	if (GameTime >= Net_LibStoragePlayer_EndTime) {
		if (GameTime <= Net_LibStoragePlayer_EndTime + C_Storage_PostCountdownTime) return 0.;
		
		// Coutdown music stopped
		if (GameTime >= Net_LibStoragePlayer_EndTime + C_Storage_PostCountdownTime + C_Storage_CountdownFadeOut) return 1.;
		
		// Fade in the Storage music
		return ML::ToReal(GameTime - Net_LibStoragePlayer_EndTime - C_Storage_PostCountdownTime) / C_Storage_CountdownFadeOut;
	}
	
	// ---------------------------------- //
	// Time below the limit
	if (GameTime <= Net_LibStoragePlayer_EndTime - Net_LibStoragePlayer_CountdownDuration - C_Storage_CountdownFadeIn) return 1.;
	
	// Countdown music is playing
	if (GameTime >= Net_LibStoragePlayer_EndTime - Net_LibStoragePlayer_CountdownDuration) return 0.;
	
	// Fade out the Storage music
	return ML::ToReal(Net_LibStoragePlayer_EndTime - Net_LibStoragePlayer_CountdownDuration - GameTime) / C_Storage_CountdownFadeIn;
}

{{{Translations::InsertToManialink(["Storage Music Player", "Custom playlist URL:"])}}}
{{{ManialinkTools::Function("ComputeWidth")}}}
{{{Bindings::Functions()}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Public
// ---------------------------------- //

// ---------------------------------- //
/** Return the version number of the script.
 *
 *	@return		The version number of the script.
 */
Text GetScriptVersion() { return Version; }

// ---------------------------------- //
/** Return the name of the script.
 *
 *	@return		The name of the script.
 */
Text GetScriptName() { return ScriptName; }

// ---------------------------------- //
/// Unload the library
Void Unload() {
	Layers::Detach("LibStoragePlayer");
	Layers::Destroy("LibStoragePlayer");
}

// ---------------------------------- //
/** Load the library.
 *
 *	@param	_MediaBasePath		Base URL for the interface icons.
 *	@param	_ThinTextFont		Font used on thin text.
 *	@param	_ThickTextFont		Font used on thick text.
 */
Void Load(Text _MediaBasePath, Text _ThinTextFont, Text _ThickTextFont) {
	Unload();
	Layers::Create("LibStoragePlayer", Private_CreateManialinkMusicPlayer(_MediaBasePath, _ThinTextFont, _ThickTextFont));
	Layers::Attach("LibStoragePlayer");
}

// ---------------------------------- //
/** Set the default mode playlist URL.
 *
 *	@param	_PlaylistURL	URL of the playlist file.
 */
Void SetDefaultPlaylistURL(Text _PlaylistURL) {
	if (_PlaylistURL == "" || !Http.IsValidUrl(_PlaylistURL)) return;
	G_LibStoragePlayer_DefaultPlaylistURL = _PlaylistURL;
	G_LibStoragePlayer_PreviousPlaylistURL = "<update>";
}

// ---------------------------------- //
/** Update the server forced playlist URL.
 *
 *	@param	_PlaylistURL	URL of the playlist file.
 */
Void UpdatePlaylistURL(Text _PlaylistURL) {
	if (_PlaylistURL == G_LibStoragePlayer_PreviousPlaylistURL) return;
	
	declare PlaylistURL = G_LibStoragePlayer_DefaultPlaylistURL;
	if (Http.IsValidUrl(_PlaylistURL)) PlaylistURL = _PlaylistURL;
	
	declare netwrite Text Net_LibStoragePlayer_ServerPlaylistURL for Teams[0];
	Net_LibStoragePlayer_ServerPlaylistURL = PlaylistURL;
}

// ---------------------------------- //
/** Update countdown properties.
 *
 *	@param	_NewEndTime		The games end time.
 *	@param	_Duration		Duration of the countdown.
 */
Void SetCountdown(Integer _NewEndTime, Integer _Duration) {
	declare netwrite Integer Net_LibStoragePlayer_EndTime for Teams[0];
	declare netwrite Integer Net_LibStoragePlayer_CountdownDuration for Teams[0];
	Net_LibStoragePlayer_EndTime = ML::Max(_NewEndTime, -1);
	Net_LibStoragePlayer_CountdownDuration = ML::Max(_Duration, 0);
}