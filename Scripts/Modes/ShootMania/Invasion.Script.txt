// -------------------------------------- //
//  INVASION by domino54                  //
//  script version: 2.0.14                //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeBase.Script.txt"

#Const CompatibleMapTypes	"InvasionArena, HordeArena"
#Const Version				"2.0.14"
#Const ScriptName			"Invasion.Script.txt"

#Include "MathLib" as MathLib
#Include "TextLib" as TextLib
#Include "Libs/Nadeo/Layers2.Script.txt" as Layers
#Include "Libs/Nadeo/Manialink.Script.txt" as Manialink
#Include "Libs/Nadeo/Message.Script.txt" as Message
#Include "Libs/Nadeo/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/ShootMania/SM.Script.txt" as SM
#Include "Libs/Nadeo/ShootMania/Score.Script.txt" as Score
#Include "Libs/Nadeo/ShootMania/SpawnScreen.Script.txt" as SpawnScreen
#Include "Libs/Nadeo/ShootMania/WeaponSwitch.Script.txt" as WeaponSwitch

// Custom libraries
#Include "Libs/Domino/Graph.Script.txt" as Graph
#Include "Libs/Domino/ShootMania/HG.Script.txt" as HG

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_PoleLimit				20		as _("Pole limit")
#Setting S_WavesBeforeInvasion		15		as _("Waves before Invasion mode")
#Setting S_ToadsPerWave				6		as _("Toads amount per wave")
#Setting S_ProgressiveToadCount		True	as _("Progressive Toads count (+1 Toad every 2 players)")
#Setting S_TimeBetweenWaves			20		as _("Time between each wave")
#Setting S_UseEvolution				False	as _("Use Evolution levels")
#Setting S_FriendlyFire				False	as _("Friendly Fire (damage teammates)")
#Setting S_UseClans					False	as _("Team mode")
#Setting S_ToadAggroRadiusMax		80.		as _("Maximum Toad reaction distance")
#Setting S_RespawnTimeItems			15		as _("Fuel and Armor items respawn time")
#Setting S_FakeUsersCount			0		as _("Number of fake players (bots)")

// Max bot players count (dedicated)
#Setting S_MaxBotPlayersCount		60		as "<hidden>"

// Clublinks settings
#Setting S_UsePlayerClublinks		False	as _("Use players clublinks")	///< Use the players clublinks, or otherwise use the default teams
#Setting S_ForceClublinkTeam1		""		as "<hidden>"	///< Force the Clublink of team 1 (format: http://www.example.com/MyTeam.Club.xml)
#Setting S_ForceClublinkTeam2		""		as "<hidden>"	///< Force the Clublink of team 2 (format: http://www.example.com/MyTeam.Club.xml)

// ---------------------------------- //
// Spawn Rules
// ---------------------------------- //
#Const C_ModeObjectives _("$<%11. $>Player has to protect Pole from Toads attack as long as it's possible.\n$<%12. $>Toads spawn in waves near huge crystals.\n$<%13. $>Over time Toads become stronger and start to appear constantly.\n$<%14. $>In singleplayer mode player must have enough points to get medal.\n$<%15. $>In multiplayer mode player or team with most points wins.")

#Const C_ModeConditions _("$<%11. $>Players can switch their weapons with mouse roll and 1 - 4 keys.\n$<%12. $>Blue Crystal increases reload speed on pick for some seconds.\n$<%13. $>Gold Crystal gives random special weapon for short amount of time.")

#Const C_ModeEvolution _("$<%11. $>With Evolution mode on, increase armor with Evolution level.\n$<%12. $>To earn Evolution points, just shoot the Toads.")

// ---------------------------------- //
// Mode Help
// ---------------------------------- //
#Const Description _("$<$f00$tObjectives$>\n1. Player has to protect Pole from Toads attack as long as it's possible.\n2. Toads spawn in waves near huge crystals and become stronger over time.\n3. Player or Team with most points wins the match.\n\n$<$f00$tConditions$>\n1. Players can switch their weapons with mouse roll and 1 - 4 keys.\n2. Picking small Crystals gives various buffs for the player.\n\n$<$f00$tEvolution$>\n1. Increase armor with Evolution level. Earn points by shooting Toads.")

#Const C_ModeStatusMessage _("Protect Pole from Toads attack as long as it's possible. Switch weapons with mouse roll and 1 - 4 keys.")

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/Invasion/"

#Const C_ActionNames ["Energy Charge", "Frozen Arrow", "Plasma Grenade", "Torpede", "Wide Rail"]

#Const C_RequiredPlayersNb		1		///< Number of connected players required to start a match

// Waves
#Const C_FirstWaveDelay			10000	///< Time before deploying first wave
#Const C_ArmorBonusWavesStep	3		///< Amount of waves between increasing Toad Armor
#Const C_WavesToadsMaxDelay		1000	///< Maximum time between spawning Toads in single wave
#Const C_ArmorGrowthDelay		45000	///< Time to next Toad Armor increasion in Invasion mode

// Toads
#Const C_ToadShootPeriodMin		350		///< Minimal Toad fire rate
#Const C_ToadShootPeriodMax		2500	///< Maximal Toad fire rate
#Const C_ToadSpeedMin			.15		///< Minimal Toad speed
#Const C_ToadSpeedMax			.5		///< Maximal Toad speed
#Const C_ToadAggroRadiusMin		8.		///< Toad aggressivity radius at beginning
#Const C_ToadDisengageSurplus	20.		///< Toad stops attack after this distance
#Const C_ToadArmorMax			1000	///< Maximum Toad Armor
#Const C_ToadIdleDuration		10000	///< Time before stuck Toad is eliminated
#Const C_ZombieSearchRadius		30.		///< Zombie player detection sphere

// Miscelanous
#Const C_PlayerMaxArmor			400		///< Default player Armor
#Const C_PlayerStaminaMax		2.		///< Amount of player Stamina
#Const C_FuelDropChance			10		///< Chance that Gimp Toad will drop Fuel on elimination
#Const C_FuelBoostDuration		3		///< Duration of reload boost
#Const C_FuelBoostMultipler		3.		///< Strength of reload boost
#Const C_GoldRespawnDelay		20000	///< Time before Gold spawns again
#Const C_GoldMultiLifetime		20000	///< Maximal Gold presence on map
#Const C_GoldBuffDuration		10000	///< Standard duration of custom weapon
#Const C_StealthLiveDuration	120000	///< Minimal player life duration to earn Stealth
#Const C_StealthFinalMultipler	.2		///< Percentage value of final Stealth bonus
#Const C_StealthIdleDuration	60000	///< Player can't earn Stealth if idles 60 seconds

#Const C_HitCritChance			75		///< Chance of performing a critical hit

#Const C_BlinkDurationGimp		75		///< Gimp blink frequency
#Const C_BlinkDurationZombie	1500	///< Zombie blink frequency

// Custom ammo hit bonus
#Const C_EventHitAmmoBonus [
	1 => .5,
	2 => .333,
	3 => .1,
	5 => .1
]

// List of weapons used by WeaponSwitch Library
#Const C_PlayerWeapons [
	CSmMode::EWeapon::Laser		=> 1.5,
	CSmMode::EWeapon::Nucleus	=> 1.5,
	CSmMode::EWeapon::Arrow		=> 1.5,
	CSmMode::EWeapon::Rocket	=> 1.5
]

// Amount of ammo per weapon
#Const C_PlayerMaxAmmo [
	CSmMode::EWeapon::Laser		=> 1,
	CSmMode::EWeapon::Nucleus	=> 2,
	CSmMode::EWeapon::Arrow		=> 3,
	CSmMode::EWeapon::Rocket	=> 5
]

// List of all weapons
#Const C_Weapons [
	CSmMode::EWeapon::Laser,
	CSmMode::EWeapon::Nucleus,
	CSmMode::EWeapon::Arrow,
	CSmMode::EWeapon::Rocket
]

// Get weapon type from its number
#Const C_GetWeaponFromNum [
	1 => CSmMode::EWeapon::Laser,
	2 => CSmMode::EWeapon::Rocket,
	3 => CSmMode::EWeapon::Nucleus,
	5 => CSmMode::EWeapon::Arrow
]

// Special Toads colors
#Const C_Colors ["Normal" => <0., 1., 0.>, "Nucleus" => <0., .5, 1.>, "Laser" => <1., 0., 0.>, "Torpede" => <.5, 0., 1.>, "Arrow" => <1., .75, 0.>, "Gimp" => <0., 1., 0.>, "Zombie" => <1., .5, 0.>]

// Variables used to determine Toad type
#Const C_GetToadType_Weapon		[7 => "Nucleus", 19 => "Laser", 31 => "Torpede", 43 => "Arrow"]
#Const C_GetToadType_Gimp		[6 => "Gimp"]
#Const C_GetToadType_Zombie		[17 => "Zombie"]

#Const C_MaxSpawnedToads_Weapon		48
#Const C_MaxSpawnedToads_Gimp		6
#Const C_MaxSpawnedToads_Zombie		18

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[]			G_SpawnsList;			///< Ids of all the landmarks with a player spawn on the map
declare Ident			G_LatestSpawnId;		///< Id of the last landmark used
declare Ident[Text]		G_ObjectId;				///< Ids of items used
declare Ident[Integer]	G_ActionId;				///< Ids of actions used
declare Ident[]			G_GoldItemsSpawners;	///< All landmarks with Gold item anchor
declare Integer[]		G_PointsPerLevel;		///< Evolution levels

declare Boolean G_IsSolo;				///< If server runs solo mode

declare Real	G_Difficulty;			///< Percentage value of Toads difficulty
declare Boolean G_InvasionMode;			///< Game phase, where Toads spawn one-by-one
declare Integer G_NbToadsReachedPole;	///< Number of Toads that touched pole
declare Integer G_NbWavesSpawned;		///< Number of waves spawned

declare Integer G_SpawnedToads_Weapon;	///< Used to determine special weapon for Toad
declare Integer G_SpawnedToads_Gimp;	///< Used to select Toad as Gimp
declare Integer G_SpawnedToads_Zombie;	///< Used to select Toad to be a Zombie

// ---------------------------------- //
// Extend
// ---------------------------------- //
***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Layers::GetScriptName(), Layers::GetScriptVersion());
MB_LogVersion(Manialink::GetScriptName(), Manialink::GetScriptVersion());
MB_LogVersion(Message::GetScriptName(), Message::GetScriptVersion());
MB_LogVersion(Sound::GetScriptName(), Sound::GetScriptVersion());
MB_LogVersion(SM::GetScriptName(), SM::GetScriptVersion());
MB_LogVersion(Score::GetScriptName(), Score::GetScriptVersion());
MB_LogVersion(SpawnScreen::GetScriptName(), SpawnScreen::GetScriptVersion());
MB_LogVersion(WeaponSwitch::GetScriptName(), WeaponSwitch::GetScriptVersion());
MB_LogVersion(Graph::GetScriptName(), Graph::GetScriptVersion());
MB_LogVersion(HG::GetScriptName(), HG::GetScriptVersion());
***

// ---------------------------------- //
// Create the rules in the spawn screen
// ---------------------------------- //
***Rules***
***
declare ModeName = "Invasion";
SpawnScreen::ResetRulesSection();
SpawnScreen::AddSubsection(_("Type"), _("Cooperation"), 0.);
SpawnScreen::AddSubsection(
	_("Objectives"), 
	TextLib::Compose(C_ModeObjectives, "$"^SpawnScreen::GetModeColor()), 
	20.
);
SpawnScreen::AddSubsection(
	_("Conditions"), 
	TextLib::Compose(C_ModeConditions, "$"^SpawnScreen::GetModeColor()), 
	67.5
);
SpawnScreen::AddSubsection(
	_("Evolution"), 
	TextLib::Compose(C_ModeEvolution, "$"^SpawnScreen::GetModeColor()), 
	102.
);
SpawnScreen::CreatePrettyRules(ModeName);
ModeStatusMessage = C_ModeStatusMessage;
***

// ---------------------------------- //
// Create the scores table
// ---------------------------------- //
***ScoresTable***
***
declare Text ST2TeamStyle;
switch (UseClans) {
	case False : ST2TeamStyle = "LibST_SMBaseSolo";
	case True : ST2TeamStyle = "LibST_SMBaseTeams";
}

// Set design
ST2::SetStyle(ST2TeamStyle);
ST2::SetStyle("LibST_SMBasePoints");
ST2::SetStyle("LibST_SMWithLegends");
ST2::SetSize(<-1., -1.>, <184., -1.>, <-1., -1.>);
ST2::SetFormat(2, 6);
ST2::SetTextScale(.875);

// Set default columns
ST2::SetColWidth("LibST_Avatar", 2.);
ST2::SetColWidth("LibST_Tags", 0.);
ST2::SetColWidth("LibST_ManiaStars", 2.);

ST2::SetColWidth("LibST_SMRoundPoints", 0.);
ST2::SetColWidth("LibST_SMPoints", 4.);
ST2::SetColLegend("LibST_SMPoints", _("Total"));
ST2::SetColScript("LibST_SMPoints", """
declare Score <=> (_Score as CSmScore);
Label_Col.SetText(TL::ToText(Score.Points * 10));
""");

// Custom columns
ST2::CreateCol("Invasion_Evolution", _("Evo"), "", 3., 90.);

// Finalize
MB_SetScoresTableStyleFromXml(S_ScoresTableStylePath);
ST2::Build("SM");
UpdateScoresTableFooter(S_PoleLimit, 1);
***

// ---------------------------------- //
// Debug: Graph
// ---------------------------------- //
***Graph***
***
Graph::SetGraphTitle("BotPlayers count");
Graph::SetValueDisplayMode(1);
Graph::SetMinMaxValues(0., S_MaxBotPlayersCount * 1.);
Graph::SetValueScript("""
declare BotPlayersCount = 0;
foreach (Player in Players) 
	if (Player.IsBot && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned)
		BotPlayersCount += 1;	
OutputReal = ML::ToReal(BotPlayersCount);
""");
Graph::Build();
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***StartServer***
***
// ---------------------------------- //
// Set mode options
UseClans = S_UseClans;
ForceNavMapsComputation = True;
UseAmmoBonusOnHit = False;
UseLaserSkewering = False;

// Neutral emblem
MB_NeutralEmblemUrl = C_ImgBase^"NeutralEmblem.dds";
MB_UsePlayerClublinks = S_UsePlayerClublinks;

// Load solo mode
G_IsSolo = False;
+++InvasionSoloStartServer+++

---Rules---
if (!G_IsSolo) ---ScoresTable---
---Graph---

// ---------------------------------- //
// Load items
ItemList_Begin();
G_ObjectId["ToadSample"]	= ItemList_Add("Characters\\ToadSample.Item.gbx");
G_ObjectId["Zombie"]		= ItemList_Add("Characters\\Zombie.Item.gbx");
G_ObjectId["Armor"]		= ItemList_Add("SMCommon\\Pickups\\Armor.Item.gbx");
G_ObjectId["Fuel"]		= ItemList_Add("SMCommon\\Collectibles\\Fuel.Item.gbx");
G_ObjectId["Gold"]		= ItemList_Add("SMCommon\\Collectibles\\Gold.Item.gbx");
ItemList_End();

// ---------------------------------- //
// Load actions
ActionList_Begin();
G_ActionId[0] = ActionList_Add("Invasion\\EnergyCharge.Action.gbx");
G_ActionId[1] = ActionList_Add("Invasion\\FrozenArrow.Action.gbx");
G_ActionId[2] = ActionList_Add("Invasion\\PlasmaGrenade.Action.gbx");
G_ActionId[3] = ActionList_Add("Invasion\\Torpede.Action.gbx");
G_ActionId[4] = ActionList_Add("Invasion\\WideRail.Action.gbx");
ActionList_End();

// ---------------------------------- //
// Prepare user interface
if (!G_IsSolo) SpawnScreen::CreateScores("Score.Points * 10");
SpawnScreen::CreateMapInfo();
Sound::Load();
Sound::Attach();
UIManager.UIAll.OverlayHideCountdown = True;
Layers::Create("Invasion_Interface", CreateInterface());
Layers::Attach("Invasion_Interface");
Layers::Create("Markers", CreateMarkers());
Layers::SetType("Markers", CUILayer::EUILayerType::Markers);
Layers::Attach("Markers");
Layers::Create("Solo_EndMenu");

// UI
UI_SetVisibility(False);
***

***InitMap***
***
declare Integer ClanMapWinner;
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***StartMap***
***
// ---------------------------------- //
// Misc init
ST2::ClearScores();
Score::MatchBegin();
Score::RoundBegin();
ClanMapWinner		= 0;
ClanScores[1]		= 0;
ClanScores[2]		= 0;
ClearScores();
UI_ResetAll();

G_SpawnsList.clear();
G_LatestSpawnId = NullId;
G_GoldItemsSpawners.clear();

SM::SetupDefaultVisibility();
Marker_SetVisibilityAll(False);

// ---------------------------------- //
// Turn the lights on
foreach (Base in MapBases) {
	Base.Clan = 0;
	Base.IsActive = True;
}

// ---------------------------------- //
// Gold spawn anchors
foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	if (MapLandmark.Tag == "Gold") {
		G_GoldItemsSpawners.add(MapLandmark.Id);
	}
}

// ---------------------------------- //
// Reset Evolution points
foreach (Score in Scores) {
	declare Integer PlayerEvolutionPoints for Score;
	PlayerEvolutionPoints = 0;
}

// ---------------------------------- //
// Wait for enough players
HG::WaitForPlayers(C_RequiredPlayersNb);

// ---------------------------------- //
// Update the players clublinks
if (S_ForceClublinkTeam1 == "" && S_ForceClublinkTeam2 == "") Clublink::DefineTeamAuto();
else Clublink::DefineTeamFromUrl(S_ForceClublinkTeam1, S_ForceClublinkTeam2);
Clublink::SyncUpdate();

// ---------------------------------- //
// Init scores
MB_Sleep(1); ///< Allow the scores array to be sorted
declare LeadId = NullId;
if (Scores.existskey(0)) LeadId = Scores[0].User.Id;

// ---------------------------------- //
// Initialize objects
ObjectDestroyAll();
foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	ObjectNextSpawn = Now + C_FirstWaveDelay;
}

// ---------------------------------- //
// Set mode variables
G_Difficulty			= 0.;
G_InvasionMode			= False;
G_NbToadsReachedPole	= 0;
G_NbWavesSpawned		= 0;
G_SpawnedToads_Weapon	= 0;
G_SpawnedToads_Gimp		= 0;
G_SpawnedToads_Zombie	= 0;
G_PointsPerLevel.clear();

declare CSmObject GoldItem;
declare NextWaveSpawnTime		= 0;
declare ToadArmorBonus			= 0;
declare ArmorIncreasionWaveNb	= 0;
declare NextToadSpawnTime		= 0;
declare ArmorGrowthTickStart	= Now + C_FirstWaveDelay;
declare NextGoldSpawnTime		= Now + C_FirstWaveDelay + S_TimeBetweenWaves * 1000;

// ---------------------------------- //
// Last variables
declare Boolean Last_UseEvolution		= False;
declare Integer Last_ClanMapWinner		= -1;
declare Integer Last_GoldSpawnTime		= -1;
declare Integer Last_PoleLimit			= -1;
declare Integer Last_ToadsReachedPole	= -1;

// ---------------------------------- //
// Gimps and Zombies blink animation
declare Gimp_BlinkStartTime = Now;
declare Gimp_BlinkPhase = False;

declare Zombie_BlinkStartTime = Now;
declare Zombie_BlinkPhase = False;
declare Zombie_BlinkDuration = 0;

// ---------------------------------- //
// New map sound
if (!G_IsSolo) UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::StartRound, 0);
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
StartTime = Now;

// Turn off collisions and weapons during preparation
UsePvPCollisions = False;
UsePvPWeapons = False;

// UI
UI_SetVisibility(True);
UI_SetMatchStatus(False);
***

// ---------------------------------- //
// Player joins the game
// ---------------------------------- //
***OnNewPlayer***
***
declare Boolean CanReachStealth		for Player;
declare Boolean HasStealth			for Player;
CanReachStealth		= True;
HasStealth			= False;
***

// ---------------------------------- //
// Global loop
// ---------------------------------- //
***Yield***
***
Message::Loop();
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
EvolutionLoop();
Combo_SpawnObjects();
Clublink::DefineTeamAuto();
SM::UnspawnPlayersChangingClan();
Users_SetNbFakeUsers(S_FakeUsersCount/2, S_FakeUsersCount-(S_FakeUsersCount/2));

// ---------------------------------- //
// Manage ongoing events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// On armor empty
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (Event.Shooter == Event.Victim || Event.Shooter == Null) {
			AddPoints(Event.Victim, -1);
		}
		
		// Rare Fuel drop from Gimps
		if (Event.Victim.IsBot && Event.Shooter != Null) {
			declare Text BotType for Event.Victim;
			
			if (BotType == "Gimp") {
				declare Chance = MathLib::Rand(0, C_FuelDropChance-1);
				
				if (Chance == 0) {
					declare Object = ObjectCreate(G_ObjectId["Fuel"]);
					declare FuelLifeStartTime for Object = Now;
					declare Text Tag for Object;
					Tag = "Fuel";
					Object.SetPosition(Event.Victim.Position);
				}
			}
		}
		
		// Lose stealth
		else {
			declare Boolean CanReachStealth for Event.Victim;
			if (Now >= StartTime + C_FirstWaveDelay) CanReachStealth = False;
		}
		
		PassOn(Event);
	}
	// ---------------------------------- //
	// On standard hit
	else if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Event.Victim == Null || Event.Shooter == Null) {
			Discard(Event);
		} else if (Event.Shooter == Event.Victim) {
			Discard(Event);
		} else {
			Event.Damage = 100;
			if (Event.Victim.IsBot) HG::CriticalHit(Event, C_HitCritChance);
			declare Points = Event.Damage / 100;
			Event.ShooterPoints = Points;
			
			// Shooter is Toad
			if (Event.Shooter.IsBot) {
				if (Event.Victim.IsBot) Discard(Event);
				else PassOn(Event);
			}
			
			// Shooter is Player
			else {
				// Toad hit
				if (Event.Victim.IsBot) {
					// Add points
					AddPoints(Event.Shooter, Points);
					if (UseClans) ClanScores[Event.Shooter.CurrentClan] += Points;
					
					// Evolution
					if (Event.Shooter.Score != Null) {
						declare Integer PlayerEvolutionPoints for Event.Shooter.Score;
						PlayerEvolutionPoints += Points;
					}
					
					// Custom reload
					if (Event.Shooter.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) AddPlayerAmmo(Event.Shooter, C_GetWeaponFromNum[Event.WeaponNum], C_EventHitAmmoBonus[Event.WeaponNum]);
					
					PassOn(Event);
				}
				
				// Friendly Fire
				else if (S_FriendlyFire) {
					// Add points
					AddPoints(Event.Shooter, -Points);
					AddPoints(Event.Victim, Points);
					Event.ShooterPoints *= -1;
					
					// Warning
					Message::SendStatusMessage(Event.Shooter, _("$F00Friendly fire!"), 2000, 1, CUIConfig::EUISound::Warning, 0);
					
					PassOn(Event);
				}
				
				// Player hit
				else {
					Discard(Event);
				}
			}
		}
	}
	// ---------------------------------- //
	// On action hit
	else if (Event.Type == CSmModeEvent::EType::OnActionCustomEvent) {
		if (Event.Victim == Null || Event.Shooter == Null) {
			Discard(Event);
		} else if (Event.Shooter == Event.Victim) {
			Discard(Event);
		} else if (Event.Param1 == "damage") {
			declare Damage = TextLib::ToInteger(Event.Param2[0]);
			declare Points = Damage / 100;
			
			// Shooter is Toad
			if (Event.Shooter.IsBot) {
				if (!Event.Victim.IsBot) {
					RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
					PassOn(Event);
				} else {
					Discard(Event);
				}
			}
			
			// Shooter is Player
			else {
				// Toad hit
				if (Event.Victim.IsBot) {
					// Add points
					AddPoints(Event.Shooter, Points);
					if (UseClans) ClanScores[Event.Shooter.CurrentClan] += Points;
					
					// Evolution
					if (Event.Shooter.Score != Null) {
						declare Integer PlayerEvolutionPoints for Event.Shooter.Score;
						PlayerEvolutionPoints += Points;
					}
					
					RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, Points);
					PassOn(Event);
				}
				
				// Friendly Fire
				else if (S_FriendlyFire) {
					// Add points
					AddPoints(Event.Shooter, -Points);
					AddPoints(Event.Victim, Points);
					
					// Warning
					Message::SendStatusMessage(Event.Shooter, _("$F00Friendly fire!"), 2000, 1, CUIConfig::EUISound::Warning, 0);
					
					RemovePlayerArmor(Event.Victim, Damage, Event.Shooter, -Points);
					PassOn(Event);
				}
				
				// Player hit
				else {
					Discard(Event);
				}
			}
		}
	}
	// ---------------------------------- //
	// On near miss
	else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
		if (Event.Victim != Null) {
			// Zombie near miss
			if (Event.Victim.ForceModelId == G_ObjectId["Zombie"] && Event.WeaponNum == GetWeaponNum(CSmMode::EWeapon::Laser)) HG::LaserNearMiss(Event);
		}
	}
	// ---------------------------------- //
	// On player request respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		AddPoints(Event.Player, -1);
		
		// Lose stealth
		declare Boolean CanReachStealth for Event.Player;
		if (Now >= StartTime + C_FirstWaveDelay) CanReachStealth = False;
		
		PassOn(Event);
	}
	// ---------------------------------- //
	// On player touches object
	else if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject) {
		if (Event.Player != Null && Event.Object != Null && !Event.Player.IsBot && Event.Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			declare Text Tag for Event.Object;
			declare Boolean CanPickGold for Event.Player;
			declare Boolean HasWeaponBuff for Event.Player;
			
			switch (Tag) {
				case "Armor" : {
					if (Event.Player.Armor < Event.Player.ArmorMax) {
						PickUpObject(Event.Player, Event.Object);
						PassOn(Event);
					} else {
						Discard(Event);
					}
				}
				case "Gold" : {
					if (CanPickGold && !HasWeaponBuff) {
						PickUpObject(Event.Player, Event.Object);
						Marker_SetVisibility(Event.Player, False);
					}
					Discard(Event);
				}
				case "Fuel" : {
					PickUpObject(Event.Player, Event.Object);
					PassOn(Event);
				}
			}
		} else {
			Discard(Event);
		}
	}
	// ---------------------------------- //
	// Action hotkeys
	else if (Event.Type == CSmModeEvent::EType::OnActionEvent) {
		declare Boolean HasWeaponBuff for Event.Player;
		if (!HasWeaponBuff) WeaponSwitch::SwitchWeapon(Event.Player, Event.ActionInput);
	}
	// ---------------------------------- //
	// Mouse roll
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestActionChange) {
		declare Boolean HasWeaponBuff for Event.Player;
		if (!HasWeaponBuff) WeaponSwitch::CycleWeapon(Event.Player, Event.ActionChange);
	}
	// ---------------------------------- //
	// Other
	else {
		PassOn(Event);
	}
}

// ---------------------------------- //
// Spawn waves
if (Now >= StartTime + C_FirstWaveDelay) {
	declare Integer NbToadsToSpawn;
	
	// Turn on collisions and weapons after preparation
	if (!UsePvPWeapons) {
		UsePvPCollisions = True;
		UsePvPWeapons = True;
	}
	
	// ---------------------------------- //
	/** Progressive Toads count
	 *
	 * Each 2 players on server = 1 extra Toad
	 */
	if (S_ProgressiveToadCount) {
		NbToadsToSpawn = S_ToadsPerWave + (Players.count / 2);
	} else {
		NbToadsToSpawn = S_ToadsPerWave;
	}
	
	// Check if we can send a wave
	declare CanSendWave = (BotPlayers.count <= S_MaxBotPlayersCount - (MapLandmarks_BotPath.count * NbToadsToSpawn));
	
	// ---------------------------------- //
	// Invasion mode
	if (G_NbWavesSpawned >= S_WavesBeforeInvasion && Now >= NextWaveSpawnTime) {
		if (Now >= ArmorGrowthTickStart + C_ArmorGrowthDelay && ToadArmorBonus + 100 < C_ToadArmorMax) {
			ToadArmorBonus += 100;
			ArmorGrowthTickStart = Now;
			UI_SetToadArmorBonus(ToadArmorBonus);
			UpdateScoresTableFooter(S_PoleLimit, ToadArmorBonus/100 + 1);
		}
		
		G_Difficulty = .55 + ToadArmorBonus / 2. / C_ToadArmorMax;
		
		if (!G_InvasionMode) {
			Message::SendBigMessage(_("$tInvasion!"), 4000, 1, CUIConfig::EUISound::StartMatch, 1);
			G_InvasionMode = True;
			G_NbWavesSpawned = S_WavesBeforeInvasion + 1;
			UI_SetWavesToInvasion(0);
		}
		
		// ---------------------------------- //
		// Spawn toads
		if (BotPlayers.count <= S_MaxBotPlayersCount - MapLandmarks_BotPath.count && Now >= NextToadSpawnTime) {
			NextToadSpawnTime = Now + MathLib::NearestInteger(C_WavesToadsMaxDelay - (C_WavesToadsMaxDelay / (C_ToadSpeedMax / C_ToadSpeedMin)));
			
			foreach (MapLandmark in MapLandmarks_BotPath) {	
				SpawnToad(MapLandmark.BotPath, 0, ToadArmorBonus);
			}
		}
	}
	
	// ---------------------------------- //
	// Regular waves
	if (!G_InvasionMode && G_NbWavesSpawned < S_WavesBeforeInvasion && S_WavesBeforeInvasion > 0 && Now >= NextWaveSpawnTime && BotPlayers.count < 60) {
		// ---------------------------------- //
		// Increase Toad armor each second wave
		if (G_NbWavesSpawned == 0) ArmorIncreasionWaveNb = 0;
		else ArmorIncreasionWaveNb += 1;
		
		if (ArmorIncreasionWaveNb >= C_ArmorBonusWavesStep && ToadArmorBonus + 100 < C_ToadArmorMax) {
			ToadArmorBonus += 100;
			ArmorIncreasionWaveNb = 0;
			UI_SetToadArmorBonus(ToadArmorBonus);
			UpdateScoresTableFooter(S_PoleLimit, ToadArmorBonus/100 + 1);
		}
		
		// Growing difficulty
		if (S_WavesBeforeInvasion > 0) G_Difficulty = (G_NbWavesSpawned + 1) / 2. / S_WavesBeforeInvasion;
		else G_Difficulty = .5;
		
		// ---------------------------------- //
		// Spawn toads
		foreach (MapLandmark in MapLandmarks_BotPath) {				
			for (I, 0, NbToadsToSpawn - 1) {
				SpawnToad(MapLandmark.BotPath, I, ToadArmorBonus);
			}
		}
		
		NextWaveSpawnTime = Now + (S_TimeBetweenWaves * 1000);
		ArmorGrowthTickStart = NextWaveSpawnTime;
		G_NbWavesSpawned += 1;
		UI_SetWavesToInvasion(S_WavesBeforeInvasion - G_NbWavesSpawned + 1);
		
		// ---------------------------------- //
		// Send message
		declare CUIConfig::EUISound Sound;
		declare Text Message;
		
		if (G_NbWavesSpawned == S_WavesBeforeInvasion) {
			Sound = CUIConfig::EUISound::Warning;
			Message = _("Incoming last wave!");
		} else {
			Sound = CUIConfig::EUISound::PhaseChange;
			Message = _("Incoming wave!");
		}
		
		Message::SendBigMessage(Message, 4000, 1, Sound, 0);
	}
}

// ---------------------------------- //
// Manage BotPlayers
foreach (Bot in BotPlayers) {
	// ---------------------------------- //
	// Select kind of toad
	declare Text BotType for Bot;
	
	// ---------------------------------- //
	// Destroy Unspawned Bots
	if (Bot.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
		DestroyBotPlayer(Bot);
	}
	
	// ---------------------------------- //
	// Falling out of Arena
	if (Bot.Position.Y < -50. || Bot.IsInWater) {
		UnspawnPlayer(Bot);
	}
	
	// ---------------------------------- //
	// Score if Toad touched Goal
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Gate == Null && MapLandmark.Sector.PlayersIds.exists(Bot.Id)) {
			// Gimps score double
			if (BotType == "Gimp") G_NbToadsReachedPole += 2;
			else G_NbToadsReachedPole += 1;
			
			if (G_NbToadsReachedPole > S_PoleLimit && S_PoleLimit > 0) G_NbToadsReachedPole = S_PoleLimit;
			UI_SetNbReached(G_NbToadsReachedPole);
			UnspawnPlayer(Bot);
			
			// ---------------------------------- //
			// Set Pole indicator
			foreach (MapLandmark in MapLandmarks_Gauge) {
				if (MapLandmark.Gate == Null) {
					if (S_PoleLimit > 0 && S_PoleLimit >= G_NbToadsReachedPole) MapLandmark.Gauge.ValueReal = MathLib::ToReal(G_NbToadsReachedPole) / S_PoleLimit;
					else MapLandmark.Gauge.ValueReal = 1.;
				}
			}
		}
	}
	
	// ---------------------------------- //
	// Make Gimps blinking
	if (BotType == "Gimp") {
		if (Gimp_BlinkPhase) {
			Bot.EnergyLevel = 0.;
			Bot.ForceColor = C_Colors["Gimp"];
		} else {
			Bot.EnergyLevel = 1.;
			Bot.ForceColor = C_Colors["Normal"];
		}
	}
	
	if (Now >= Gimp_BlinkStartTime + C_BlinkDurationGimp) {
		Gimp_BlinkStartTime = Now;
		Gimp_BlinkPhase = !Gimp_BlinkPhase;
	}
	
	// ---------------------------------- //
	// Zombies
	if (Now >= Zombie_BlinkStartTime + Zombie_BlinkDuration) {
		Zombie_BlinkStartTime = Now;
		Zombie_BlinkPhase = !Zombie_BlinkPhase;
		
		if (Zombie_BlinkPhase) Zombie_BlinkDuration = 100;
		else Zombie_BlinkDuration = C_BlinkDurationZombie - 100;
	}
	
	if (BotType == "Zombie") {
		Bot.HasShield = Zombie_BlinkPhase;
		
		// ---------------------------------- //
		// Find nearby target for Zombie
		if (Bot.Driver.ForcedTarget == Null) {
			declare Ident[] PlayersIds;
			declare Ident TargetId;
			
			if (PlayersIds.count > 0) PlayersIds.clear();
			if (TargetId != NullId) TargetId = NullId;
			
			foreach (Player in Players) {
				if (MathLib::Distance(Bot.Position, Player.Position) <= C_ZombieSearchRadius && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) PlayersIds.add(Player.Id);
			}
			
			if (PlayersIds.count > 0) TargetId = PlayersIds[MathLib::Rand(0, 0)];
			
			if (Players.existskey(TargetId)) {
				Bot.Driver.ForcedTarget = Players[TargetId];
				Bot.ForceColor = C_Colors[BotType];
			}
		}
		// ---------------------------------- //
		// Reset target
		else {
			if (Bot.Driver.ForcedTarget.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || MathLib::Distance(Bot.Driver.ForcedTarget.Position, Bot.Position) > C_ZombieSearchRadius) {
				Bot.Driver.Behaviour		= CSmPlayerDriver::ESmDriverBehaviour::Patrol;
				Bot.Driver.ForcedTarget		= Null;
				Bot.ForceColor				= C_Colors["Normal"];
			}
		}
	}
	
	// ---------------------------------- //
	// Unspawn idling Toads
	declare Integer IdleStartTime for Bot;
	declare Vec3 LastIdlePosition for Bot;
	
	if (Bot.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		if (MathLib::Distance(LastIdlePosition, Bot.Position) >= 1.) {
			LastIdlePosition = Bot.Position;
			IdleStartTime = Now;
		} else if (LastIdlePosition != <0., 0., 0.> && Now >= IdleStartTime + C_ToadIdleDuration) {
			UnspawnPlayer(Bot);
		}
	}
}


// ---------------------------------- //
// Players functions
foreach (Player in Players) {
	// ---------------------------------- //
	// Private variables
	declare Boolean HasWeaponBuff		for Player;
	declare Integer WeaponBuffStartTime	for Player;
	declare Integer PreviousWeapon		for Player;
	declare Boolean SetPrevWeapon		for Player;
	declare Boolean CanPickGold			for Player;
	declare Integer GoldEvolutionBonus	for Player;
	declare Integer ReloadBoostEndTime	for Player;
	
	// Evolution
	declare Integer PlayerEvolutionLevel for Player;
	
	// Stealth
	declare Boolean CanReachStealth		for Player;
	declare Boolean HasStealth			for Player;
	declare Integer StealthStartTime	for Player;
	
	HasStealth = (CanReachStealth && Now >= StealthStartTime + C_StealthLiveDuration + C_FirstWaveDelay);
	if (Player.IdleDuration >= C_StealthIdleDuration) CanReachStealth = False;
	
	// ---------------------------------- //
	// Update armor on Evolution state change
	if (Last_UseEvolution != S_UseEvolution) {
		Last_UseEvolution = S_UseEvolution;
		
		declare netwrite Boolean Net_UseEvolution for Teams[0];
		Net_UseEvolution = S_UseEvolution;
		
		if (!S_UseEvolution && Player.Armor < C_PlayerMaxArmor) {
			Player.ArmorMax = C_PlayerMaxArmor;
			Player.Armor = Player.ArmorMax;
		}
	}
	
	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate) {
		// ---------------------------------- //
		// Fake players
		if (Player.IsFakePlayer) {
			Player.Driver.Behaviour		= CSmPlayerDriver::ESmDriverBehaviour::IA;
			Player.Driver.AttackFilter	= CSmPlayerDriver::ESmAttackFilter::AllBots;
			Player.Driver.Accuracy 			= MathLib::Rand(.875, 1.);
			Player.Driver.ShootPeriodMin 	= 200;
			Player.Driver.ShootPeriodMax 	= 300;
			Player.Driver.ReactionTime		= MathLib::Rand(0, 250);
			Player.Driver.AggroRadius		= MathLib::Rand(80., 120.);
			Player.Driver.DisengageDistance = Player.Driver.AggroRadius + MathLib::Rand(10., 40.);
			Player.Driver.ForcedTarget		= Null;
		}
		
		// Set max ammo
		foreach (Weapon in C_Weapons) {
			SetPlayerAmmoMax(Player, Weapon, C_PlayerMaxAmmo[Weapon]);
		}
		
		// Player is always in his favorite color
		Player.ForceColor = Player.User.Color;
		
		// Special parameters
		if (!S_UseEvolution) Player.ArmorMax = C_PlayerMaxArmor;
		
		Player.Armor		= Player.ArmorMax;
		Player.StaminaMax	= C_PlayerStaminaMax;
		
		WeaponSwitch::SetAvailableWeapons(Player, C_PlayerWeapons);
		SetPlayerReloadAllWeapons(Player, True);
		
		StealthStartTime = Now;
		
		// Call the spawn function
		MeleeSpawnPlayer(Player);
	}
	
	// ---------------------------------- //
	// Weapon buffs
	if (HasWeaponBuff) {
		SetPrevWeapon = False;
		
		if (Now >= WeaponBuffStartTime + C_GoldBuffDuration + GoldEvolutionBonus) {
			HasWeaponBuff = False;
		}
	} else {
		if (!SetPrevWeapon) {
			ActionBind(Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::None);
			if (PreviousWeapon != 0) {
				SetPlayerWeapon(Player, C_GetWeaponFromNum[PreviousWeapon], False);
				Player.AmmoGain = C_PlayerWeapons[C_GetWeaponFromNum[PreviousWeapon]];
			}
			SetPrevWeapon = True;
		}
		
		if (S_UseEvolution && PlayerEvolutionLevel >= 1) GoldEvolutionBonus = 2 * (PlayerEvolutionLevel-1) * 1000;
		else GoldEvolutionBonus = 0;
	}
	
	// ---------------------------------- //
	// Reload boost
	if (Player.CurWeapon != 0) {
		if (Now <= ReloadBoostEndTime) {
			Player.AmmoGain = C_PlayerWeapons[C_GetWeaponFromNum[Player.CurWeapon]] * C_FuelBoostMultipler;
		} else {
			Player.AmmoGain = C_PlayerWeapons[C_GetWeaponFromNum[Player.CurWeapon]];
		}
	}
	
	// ---------------------------------- //
	// Net variables
	declare UI <=> UIManager.GetUI(Player);
	if (UI != Null) {
		declare netwrite Boolean Net_HasStealth for UI;
		Net_HasStealth = HasStealth;
		
		declare netwrite Boolean Net_HasWeaponBuff for UI;
		Net_HasWeaponBuff = HasWeaponBuff;
		
		declare netwrite Integer Net_GoldBuffBonus for UI;
		Net_GoldBuffBonus = GoldEvolutionBonus;
	}
	
	// ---------------------------------- //
	// Falling out of Arena
	if (Player.Position.Y < -50.) {
		UnspawnPlayer(Player);
	}
	
	// ---------------------------------- //
	// Force Toad as fake player target
	if (Player.IsFakePlayer) {
		if (BotPlayers.count > 0) {
			if (Player.Driver.ForcedTarget == Null) {
				Player.Driver.ForcedTarget = BotPlayers[MathLib::Rand(0, BotPlayers.count - 1)];
			}
			if (Player.Driver.ForcedTarget != Null && Player.Driver.ForcedTarget.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
				Player.Driver.ForcedTarget = Null;
			}
		}
	}
}

// ---------------------------------- //
// Check winner (teams)
if (UseClans) {
	if ((ClanScores[1] == 0 && ClanScores[2] == 0) || ClanScores[1] == ClanScores[2]) ClanMapWinner = 0;
	else if (ClanScores[1] > ClanScores[2]) ClanMapWinner = 1;
	else ClanMapWinner = 2;
}

// ---------------------------------- //
// Play sound and notice if someone is taking the lead
if (!UseClans) {
	if (Scores.existskey(0) && Scores[0].User.Id != LeadId) {
		LeadId = Scores[0].User.Id;
		Message::SendStatusMessage(TextLib::Compose(_("$<%1$> takes the lead!"), Scores[0].User.Name), 3000, 1, CUIConfig::EUISound::Custom4, 0);
	}
}

// ---------------------------------- //
// Play sound and notice if team is taking the lead
else {
	if (Last_ClanMapWinner != ClanMapWinner) {
		Last_ClanMapWinner = ClanMapWinner;
		declare Text LeadMessage;
		if (ClanMapWinner != 0) {
			Message::SendStatusMessage(TextLib::Compose(_("$<%1$> takes the lead!"), Teams[ClanMapWinner - 1].ColorizedName), 3000, 1, CUIConfig::EUISound::Custom4, 0);
		}
	}
}

// ---------------------------------- //
// Spawn the Gold item
if (G_GoldItemsSpawners.count > 0) {
	if (Now >= NextGoldSpawnTime) {
		if (GoldItem != Null) ObjectDestroy(GoldItem);
		GoldItem = ObjectCreate(G_ObjectId["Gold"]);
		
		declare GoldAnchor = MathLib::Rand(0, G_GoldItemsSpawners.count - 1);
		GoldItem.SetAnchor(MapLandmarks_ObjectAnchor[G_GoldItemsSpawners[GoldAnchor]].ObjectAnchor);
		
		declare Text Tag for GoldItem;
		Tag = "Gold";
		
		foreach (Player in Players) {
			declare Boolean CanPickGold for Player;
			CanPickGold = True;
		}
		
		// Update marker
		declare Vec3 GoldAnchorPosition;
		GoldAnchorPosition = MapLandmarks_ObjectAnchor[G_GoldItemsSpawners[GoldAnchor]].Position;
		
		Marker_Update(GoldAnchorPosition);
		Marker_SetVisibilityAll(True);
		
		// Next spawn
		NextGoldSpawnTime = Now + C_GoldMultiLifetime + C_GoldRespawnDelay;
		Last_GoldSpawnTime = Now;
	}
	
	// Unspawn after lifetime
	if (Now >= Last_GoldSpawnTime + C_GoldMultiLifetime) {
		if (GoldItem != Null && GoldItem.Status != CSmObject::EStatus::Unspawned) {
			GoldItem.SetUnspawned();
		}
	}
}

// ---------------------------------- //
// Update pole limit
if (Last_PoleLimit != S_PoleLimit) {
	Last_PoleLimit = S_PoleLimit;
	UI_SetPoleLimit(S_PoleLimit);
	UpdateScoresTableFooter(S_PoleLimit, ToadArmorBonus / 100 + 1);
}

// ---------------------------------- //
// Game end conditions
if (S_PoleLimit > 0 && G_NbToadsReachedPole >= S_PoleLimit) MB_StopMap = True;
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMap***
***
DestroyEverything();
UI_SetMatchStatus(True);
Marker_SetVisibilityAll(False);

G_NbToadsReachedPole = S_PoleLimit;
UI_SetNbReached(G_NbToadsReachedPole);

// ---------------------------------- //
// Set Pole indicator
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Gate == Null) {
		MapLandmark.Gauge.ValueReal = 1.;
		MapLandmark.Gauge.Captured = True;
	}
}

declare Integer TimeScore;
if (Now - StartTime - C_FirstWaveDelay < 0) TimeScore = 0;
else TimeScore = Now - StartTime - C_FirstWaveDelay;

Message::CleanBigMessages();
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessage = "Game over";
UIManager.UIAll.StatusMessage = TextLib::Compose("%1 "^TextLib::TimeToText(TimeScore, True), _("Your time:"));

MB_Sleep(5000);

UI_SetVisibility(False);

if (UseClans) {
	if (ClanMapWinner == 0) UIManager.UIAll.BigMessage = _("|Match|Draw");
	else UIManager.UIAll.BigMessage = TextLib::Compose(_("$<%1$> wins the match!"), Teams[ClanMapWinner-1].Name);
	UIManager.UIAll.StatusMessage = "";	
	MB_Sleep(5000);
}

foreach (Player in Players) {
	// ---------------------------------- //
	// Solo time points
	if (G_IsSolo) {
		declare netread Integer Net_SoloTimeScore for Teams[0];
		AddPoints(Player, Net_SoloTimeScore / 10);
	}
	
	// ---------------------------------- //
	// Stealth final bonus
	declare Boolean HasStealth for Player;
	if (HasStealth && Player.Score != Null) {
		AddPoints(Player, MathLib::NearestInteger(Player.Score.Points * C_StealthFinalMultipler));
	}
}

Score::RoundEnd();
Score::MatchEnd();

if (G_IsSolo) {
	+++InvasionSoloEndSequence+++
	while (!ServerShutdownRequested) MB_Yield();
}

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;

while (!ServerShutdownRequested && !UIManager.UIAll.UISequenceIsCompleted) {
	MB_Yield();
}

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
// ---------------------------------- //
// Clean the UI
SpawnScreen::DestroyRules();
SpawnScreen::DestroyScores();
SpawnScreen::DestroyMapInfo();
Graph::Destroy();
Layers::Detach("Invasion_Interface");
Layers::Destroy("Invasion_Interface");
Layers::Detach("Markers");
Layers::Destroy("Markers");
Layers::Detach("Solo_EndMenu");
Layers::Destroy("Solo_EndMenu");
UIManager.ResetAll();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/// Unspawn everyone and destroy bots & objects
Void DestroyEverything() {
	foreach (Player in Players) UnspawnPlayer(Player);
	DestroyAllBotPlayers();
	ObjectDestroyAll();
}

/* ------------------------------------- */
/** Add points
 *
 * @param	_Player		The player which receives points
 * @param	_Points		Amount of points
 */
Void AddPoints(CSmPlayer _Player, Integer _Points) {	
	if (_Player != Null && _Player.Score != Null) {
		if (_Player.Score.Points + _Points > 0) {
			_Player.Score.Points += _Points;
		} else {
			_Player.Score.Points = 0;
		}
	}
}

/* ------------------------------------- */
/** Update ST2 footer
 *
 * @param	_PoleLimit		Pole limit
 * @param	_ToadArmor		Toad armor
 */
Void UpdateScoresTableFooter(Integer _PoleLimit, Integer _ToadArmor) {
	ST2::SetFooterText(TextLib::Compose(_("Pole limit: %1	Toad Armor: %2"), TextLib::ToText(_PoleLimit), TextLib::ToText(_ToadArmor)));
}

/* ------------------------------------- */
/** Spawn a player
 *
 * @param	_Player		The player to spawn
 */
Void MeleeSpawnPlayer(CSmPlayer _Player) {
	if (G_SpawnsList.count == 0) {
		foreach (MapLandmark in MapLandmarks_PlayerSpawn) G_SpawnsList.add(MapLandmark.Id);
	}
	
	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[MathLib::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId) break;
		if (G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	
	declare Integer TargetClan;
	if (UseClans) TargetClan = _Player.RequestedClan;
	else TargetClan = 0;
	
	SM::SpawnPlayer(_Player, TargetClan, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);
	declare Removed = G_SpawnsList.remove(SpawnId);
}

/* ------------------------------------- */
/** Spawn Toad
 *
 * @param	_BotPath		The BotPath where Toad spawns
 * @param	_Order			Id of the Toad
 * @param	_ArmorBonus		Additional Toad armor
 */
Void SpawnToad(CSmMapBotPath _BotPath, Integer _Order, Integer _ArmorBonus) {
	// Create a bot
	declare BotPlayer = CreateBotPlayer(G_ObjectId["ToadSample"], 0);
	
	G_SpawnedToads_Weapon	+= 1;
	G_SpawnedToads_Gimp		+= 1;
	G_SpawnedToads_Zombie	+= 1;
	
	// ---------------------------------- //
	// Select kind of toad
	declare Text BotType for BotPlayer;
	BotType = "Normal";
	
	if (C_GetToadType_Weapon.existskey(G_SpawnedToads_Weapon)) BotType = C_GetToadType_Weapon[G_SpawnedToads_Weapon];
	
	if (C_GetToadType_Gimp.existskey(G_SpawnedToads_Gimp)) BotType = C_GetToadType_Gimp[G_SpawnedToads_Gimp];
	
	if (C_GetToadType_Zombie.existskey(G_SpawnedToads_Zombie)) BotType = C_GetToadType_Zombie[G_SpawnedToads_Zombie];
	
	// ---------------------------------- //
	// Prepare Toad behavior
	declare ToadSpeedBonus		= 0.;
	declare ToadAggroRadius		= (S_ToadAggroRadiusMax - C_ToadAggroRadiusMin) * G_Difficulty;
	declare ToadShootPeriod		= MathLib::NearestInteger((C_ToadShootPeriodMax - C_ToadShootPeriodMin) * (1-G_Difficulty));
	
	if (G_Difficulty <= .5) ToadSpeedBonus = (C_ToadSpeedMax - C_ToadSpeedMin) * G_Difficulty * 2.;
	else ToadSpeedBonus = C_ToadSpeedMax - C_ToadSpeedMin;
	
	BotPlayer.Driver.Behaviour		= CSmPlayerDriver::ESmDriverBehaviour::Patrol;
	BotPlayer.Driver.AttackFilter	= CSmPlayerDriver::ESmAttackFilter::AllPlayers;
	
	BotPlayer.Driver.ShootPeriodMax = C_ToadShootPeriodMin + ToadShootPeriod;
	BotPlayer.Driver.ShootPeriodMin = BotPlayer.Driver.ShootPeriodMax;
	BotPlayer.Driver.Accuracy 		= MathLib::Rand(.9, 1.);
	BotPlayer.Driver.ReactionTime	= MathLib::Rand(75, 125);
	
	BotPlayer.Driver.AggroRadius		= C_ToadAggroRadiusMin + ToadAggroRadius;
	BotPlayer.Driver.DisengageDistance	= BotPlayer.Driver.AggroRadius + C_ToadDisengageSurplus;
	
	BotPlayer.AmmoGain 			= 1.25;
	BotPlayer.ArmorMax			= 100 + _ArmorBonus;
	BotPlayer.ForceColor		= C_Colors[BotType];
	BotPlayer.SpeedPower		= C_ToadSpeedMin + ToadSpeedBonus;
	
	// ---------------------------------- //
	// Apply special abilities
	switch (BotType) {
		// ---------------------------------- //
		// Nucleus
		case "Nucleus" : {
			SetPlayerWeapon(BotPlayer, CSmMode::EWeapon::Nucleus, False);
			SetPlayerAmmoMax(BotPlayer, CSmMode::EWeapon::Nucleus, 1);
			
			BotPlayer.EnergyLevel = 1.;
		}
		
		// ---------------------------------- //
		// Laser
		case "Laser" : {
			SetPlayerWeapon(BotPlayer, CSmMode::EWeapon::Laser, False);
			SetPlayerAmmoMax(BotPlayer, CSmMode::EWeapon::Laser, 1);
			
			BotPlayer.EnergyLevel = 1.;
		}
		
		// ---------------------------------- //
		// Torpede
		case "Torpede" : {
			ActionLoad(BotPlayer, CSmMode::EActionSlot::Slot_A, G_ActionId[3]);
			ActionBind(BotPlayer, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			BotPlayer.EnergyLevel = 1.;
		}
		
		// ---------------------------------- //
		// Arrow
		case "Arrow" : {
			SetPlayerWeapon(BotPlayer, CSmMode::EWeapon::Arrow, False);
			SetPlayerAmmoMax(BotPlayer, CSmMode::EWeapon::Arrow, 1);
			
			BotPlayer.EnergyLevel = 1.;
		}
		
		// ---------------------------------- //
		// Gimp
		case "Gimp" : {
			BotPlayer.UseAlternateWeaponVisual = True;
		}
		
		// ---------------------------------- //
		// Zombie
		case "Zombie" : {
			BotPlayer.ForceModelId		= G_ObjectId["Zombie"];
			BotPlayer.EnergyLevel		= 1.;
			BotPlayer.ForceColor		= C_Colors["Normal"];
		}
		
		// ---------------------------------- //
		// Normal
		default : {
			SetPlayerWeapon(BotPlayer, CSmMode::EWeapon::Rocket, False);
			SetPlayerAmmoMax(BotPlayer, CSmMode::EWeapon::Rocket, 3);
			
			BotPlayer.EnergyLevel = 0.;
		}
	}
	
	// ---------------------------------- //
	// Spawn bot player
	declare ActivationTime = MathLib::NearestInteger(C_WavesToadsMaxDelay - (C_WavesToadsMaxDelay / (C_ToadSpeedMax / C_ToadSpeedMin) * G_Difficulty)) * _Order;
	
	SpawnBotPlayer(BotPlayer, 0, 100 + _ArmorBonus, _BotPath, ActivationTime + Now + 3000);
	
	// Reset counters
	if (G_SpawnedToads_Weapon == C_MaxSpawnedToads_Weapon) G_SpawnedToads_Weapon = 0;
	if (G_SpawnedToads_Gimp == C_MaxSpawnedToads_Gimp) G_SpawnedToads_Gimp = 0;
	if (G_SpawnedToads_Zombie == C_MaxSpawnedToads_Zombie) G_SpawnedToads_Zombie = 0;
}

// ---------------------------------- //
/// Spawn objects
Void Combo_SpawnObjects() {
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		if (MapLandmark.ObjectAnchor == Null) continue;
		
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		declare ObjectCanSpawn for MapLandmark = True;
		if (ObjectSpawned) continue;
		if (ObjectNextSpawn > Now) continue;
		if (!ObjectCanSpawn) continue;
		
		declare CSmObject Object;
		switch (MapLandmark.Tag) {
			case "Armor" :	Object = ObjectCreate(G_ObjectId["Armor"]);
			case "Fuel" :	Object = ObjectCreate(G_ObjectId["Fuel"]);
		}
		
		if (Object != Null) {
			declare Ident AnchorId for Object;
			declare Text Tag for Object;
			AnchorId = MapLandmark.Id;
			Tag = MapLandmark.Tag;
			ObjectSpawned = True;
			Object.SetAnchor(MapLandmark.ObjectAnchor);
		}
	}
}

/* ------------------------------------- */
/** Pick up object
 *
 *	@param	_Player		The player who picked up the item
 *	@param	_Object		The item picked up by the player
 */
Void PickUpObject(CSmPlayer _Player, CSmObject _Object) {
	if (_Player == Null || _Object == Null) return;
	
	declare Text Tag for _Object;
	declare Ident AnchorId for _Object;
	
	// ---------------------------------- //
	// Item respawn timer
	if (Tag != "Gold" && MapLandmarks_ObjectAnchor.existskey(AnchorId)) {
		declare MapLandmark <=> MapLandmarks_ObjectAnchor[AnchorId];
		declare Boolean ObjectSpawned for MapLandmark = False;
		declare Integer ObjectNextSpawn for MapLandmark = Now;
		
		ObjectSpawned = False;
		ObjectNextSpawn = Now + S_RespawnTimeItems * 1000;
	}
	
	// ---------------------------------- //
	// Apply effect
	switch (Tag) {
		// ---------------------------------- //
		// Armor
		case "Armor" : {
			_Player.Armor += 100;
			ObjectDestroy(_Object);
		}
		
		// ---------------------------------- //
		// Fuel
		case "Fuel" : {
			declare Integer ReloadBoostEndTime for _Player;
			ReloadBoostEndTime = Now + C_FuelBoostDuration * 1000;
			
			declare netwrite Integer[Text] Net_ReloadBoostEndTime for Teams[0];
			Net_ReloadBoostEndTime[_Player.Login] = ReloadBoostEndTime;
			
			_Player.Stamina = MathLib::FloorInteger(3600 * C_PlayerStaminaMax);
			
			ObjectDestroy(_Object);
		}
		
		// ---------------------------------- //
		// Gold
		case "Gold" : {
			declare Boolean HasWeaponBuff		for _Player;
			declare Integer WeaponBuffStartTime	for _Player;
			declare Boolean CanPickGold			for _Player;
			declare Integer PreviousWeapon		for _Player;
			
			HasWeaponBuff		= True;
			WeaponBuffStartTime	= Now;
			CanPickGold			= False;
			PreviousWeapon		= _Player.CurWeapon;
			
			Sound::PlaySound(C_ImgBase^"PickUp.ogg", 6., _Player);
			
			SetPlayerWeapon(_Player, CSmMode::EWeapon::Rocket, False);
			
			declare ActionId = MathLib::Rand(0, G_ActionId.count - 1);
			
			declare UI <=> UIManager.GetUI(_Player);
			if (UI != Null) {
				declare netwrite Text Net_BonusWeaponName for UI;
				Net_BonusWeaponName = C_ActionNames[ActionId];
			}
			
			ActionLoad(_Player, CSmMode::EActionSlot::Slot_A, G_ActionId[ActionId]);
			ActionBind(_Player, CSmMode::EActionSlot::Slot_A, CSmMode::EActionInput::Weapon);
			
			if (G_IsSolo) _Object.SetUnspawned();
		}
	}
}

// ---------------------------------- //
/// Do Evolution
Void EvolutionLoop() {
	if (!S_UseEvolution) return;
	
	// Add requirement for first level
	if (!G_PointsPerLevel.exists(0)) G_PointsPerLevel.add(0);
	
	foreach (Player in Players) {
		// Determine current player level
		declare Integer PlayerEvolutionPoints for Player.Score;
		declare Integer PlayerEvolutionLevel for Player;
		
		if (PlayerEvolutionPoints >= G_PointsPerLevel[G_PointsPerLevel.count - 1]) {
			declare Integer NextLevelPoints;
			NextLevelPoints = G_PointsPerLevel[G_PointsPerLevel.count - 1] + MathLib::FloorInteger(MathLib::Pow(2., G_PointsPerLevel.count + 1.));
			
			if (!G_PointsPerLevel.exists(NextLevelPoints)) {
				G_PointsPerLevel.add(NextLevelPoints);
			}
		}
		
		for (I, 1, G_PointsPerLevel.count) {
			if (PlayerEvolutionPoints >= G_PointsPerLevel[I-1]) {
				PlayerEvolutionLevel = I;
			}
		}
		
		// Increase player armor on level growth
		declare Integer EvolutionLevel_Last for Player;
		Player.ArmorMax = PlayerEvolutionLevel * 100;
		
		if (PlayerEvolutionLevel != EvolutionLevel_Last) {
			Player.Armor += (PlayerEvolutionLevel - EvolutionLevel_Last) * 100;
			EvolutionLevel_Last = PlayerEvolutionLevel;
			
			// Update scores table
			if (PlayerEvolutionLevel >= 2) {
				ST2::SetColValue("Invasion_Evolution", Player.Score, TextLib::ToText(PlayerEvolutionLevel));
			}
		}
		
		// Create progress variables
		declare Integer LevelPointsCurrent for Player;
		declare Integer LevelPointsToNext for Player;
		
		if (PlayerEvolutionLevel < G_PointsPerLevel.count) {
			LevelPointsCurrent = PlayerEvolutionPoints - G_PointsPerLevel[PlayerEvolutionLevel-1];
			LevelPointsToNext = MathLib::FloorInteger(MathLib::Pow(2., (PlayerEvolutionLevel + 1) * 1.));
		}
		
		// Send progress information to interface
		declare CUIConfig UI <=> UIManager.GetUI(Player);
		if (UI != Null) {
			declare netwrite Int3[Text] Net_PlayerEvolutionData for Teams[0];
			Net_PlayerEvolutionData[Player.Login] = <
				PlayerEvolutionLevel,	///< X
				LevelPointsCurrent,		///< Y
				LevelPointsToNext		///< Z
			>;
		}
	}
}

// ---------------------------------- //
// Interface
// ---------------------------------- //

/* ------------------------------------- */
/** Set interface visibility
 *
 *	@param	_Visibility		Is the HUD visible?
 */
Void UI_SetVisibility(Boolean _Visibility) {
	declare netwrite Boolean Net_Invasion_InterfaceVisibility for Teams[0];
	Net_Invasion_InterfaceVisibility = _Visibility;
}

/* ------------------------------------- */
/** Set interface match status
 *
 *	@param	_IsMatchOver	Stop counting time points?
 */
Void UI_SetMatchStatus(Boolean _IsMatchOver) {
	declare netwrite Boolean Net_Invasion_IsMatchOver for Teams[0];
	declare netwrite Integer Net_GameStartTime for Teams[0];
	Net_Invasion_IsMatchOver = _IsMatchOver;
	Net_GameStartTime = Now + C_FirstWaveDelay;
}

/* ------------------------------------- */
/** Set pole limit
 *
 *	@param	_PoleLimit		Pole limit
 */
Void UI_SetPoleLimit(Integer _PoleLimit) {
	declare netwrite Integer Net_PoleLimit for Teams[0];
	Net_PoleLimit = _PoleLimit;
}

/* ------------------------------------- */
/** Set number of Toads reached pole
 *
 *	@param	_NbReached		Number of Toads
 */
Void UI_SetNbReached(Integer _NbReached) {	
	declare netwrite Integer Net_NbToadsReachedPole for Teams[0];
	Net_NbToadsReachedPole = _NbReached;
}

/* ------------------------------------- */
/** Set Toad armor bonus
 *
 *	@param	_ArmorBonus		Armor bonus
 */
Void UI_SetToadArmorBonus(Integer _ArmorBonus) {
	declare netwrite Integer Net_ToadArmorBonus for Teams[0];
	Net_ToadArmorBonus = _ArmorBonus;
}

/* ------------------------------------- */
/** Set waves to Invasion
 *
 *	@param	_WavesToInvasion	Waves to Invasion
 */
Void UI_SetWavesToInvasion(Integer _WavesToInvasion) {	
	declare netwrite Integer Net_NbWavesToInvasion for Teams[0];
	Net_NbWavesToInvasion = _WavesToInvasion;
}

// ---------------------------------- //
/// Reset UI
Void UI_ResetAll() {
	UI_SetPoleLimit(S_PoleLimit);
	UI_SetNbReached(0);
	UI_SetToadArmorBonus(1);
	UI_SetWavesToInvasion(S_WavesBeforeInvasion);
}

/* ------------------------------------- */
/** Return interface
 *
 *	@return		The Invasion Interface
 */
Text CreateInterface() {
	declare Text OutputManialink;
	
	// ---------------------------------- //
	// Reload boost
	declare Text ReloadBoostIndicators;
	declare Index = -1;
	declare HeightStep = 0;
	
	for (I, 0, C_FuelBoostDuration - 1) {
		Index += 1;
		if (Index > 4) {
			Index = 0;
			HeightStep += 4;
		}
		
		ReloadBoostIndicators ^= """
			<quad posn="{{{Index*-8.5}}} {{{HeightStep}}}" sizen="10 4" halign="right" valign="bottom" image="{{{C_ImgBase}}}ReloadBoostStep.dds" id="Quad_ReloadBoost{{{I}}}"/>
		""";
	}
	
	// ---------------------------------- //
	// Create
	OutputManialink = """
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<manialink version="2" name="Invasion:Interface">
<stylesheet>
	<style id="Label_MedalTargetPoints" textfont="Eurostile" scale=".7" textcolor="AAA"/>
	<style id="Label_PlayerScorePoints" textfont="Eurostile_Bold" textsize="8" textemboss="1" textcolor="AAA"/>
	<style class="score-name" textfont="Eurostile_Bold" textsize="2" textemboss="1" textcolor="AAA" textprefix="$T"/>
	<style class="evolution-name" textfont="Eurostile_Bold" textsize="1" textemboss="1" textcolor="FFF" textprefix="$T"/>
	<style id="Label_EvolutionLevel" textfont="Eurostile_Bold" scale="1.75" textemboss="1" textcolor="FFF"/>
	<style id="Label_EvolutionPointsCurrent" textfont="Eurostile_Bold" scale=".85" textemboss="1"/>
	<style id="Label_EvolutionPointsToNext" textfont="Eurostile_Bold" scale=".7" textemboss="1"/>
	<style class="gauge-name" textfont="Eurostile_Bold" textsize="1" textcolor="666" textprefix="$T"/>
	<style id="Label_PoleCaptureMax" textfont="Eurostile_Bold" textsize="2" textemboss="1" textcolor="888"/>
	<style id="Label_PoleCaptureCurrent" textfont="Eurostile_Bold" textsize="4" textemboss="1" textcolor="FFF"/>
	<style id="Label_ArmorBonusCount" textfont="Eurostile_Bold" scale="0.7" textcolor="000"/>
	<style id="Label_TimerStatus" textfont="Eurostile" textsize="1" textcolor="FFF"/>
	<style id="Label_TimerChrono" textfont="Eurostile" textemboss="1" textcolor="FD0"/>
	<style id="Label_CritMsg" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF" textprefix="$T"/>
	<style id="Label_BuffName" textfont="Eurostile_Bold" scale=".7" textcolor="777" textprefix="$T"/>
	<style id="Label_BuffEvoBonus" textfont="Eurostile_Bold" textemboss="1" textcolor="FFF"/>
	<style class="buff-bonus2" textfont="Eurostile_Bold" textsize="1" textemboss="1" textcolor="FFF"/>
</stylesheet>

<frame id="Frame_GlobalInterface" hidden="1">
	<quad posn="-160 90 -2" sizen="320 180" image="{{{C_ImgBase}}}Vignette.dds" opacity="0" id="Quad_BuffOverlay"/>
	<label posn="0 -15" scale="0" halign="center" valign="center2" text="Critical hit!" opacity="0" id="Label_CritMsg"/>
	
	<frame id="Frame_PersonalElements" posn="-160 90">
		<quad posn="0 0 -1" sizen="90 90" image="{{{C_ImgBase}}}CornerVignette.dds"/>
		
		<frame id="Frame_MedalProgressBar" posn="0 0" hidden="{{{!G_IsSolo}}}">
			<quad posn="0 0 1" sizen="80 10" image="{{{C_ImgBase}}}MedalProgressBar_Bg.dds"/>
			<label posn="72.75 -5 2" halign="center" valign="center2" text="0" id="Label_MedalTargetPoints"/>
			<quad posn="17 -3" sizen="50 4" bgcolor="DF0" id="Quad_MedalProgressGauge"/>
			<quad posn="0 0 2" sizen="20 10" image="{{{C_ImgBase}}}MedalScore_Bronze.dds" id="Quad_MedalIconBronze"/>
			<quad posn="0 0 2" sizen="20 10" image="{{{C_ImgBase}}}MedalScore_Silver.dds" id="Quad_MedalIconSilver"/>
			<quad posn="0 0 2" sizen="20 10" image="{{{C_ImgBase}}}MedalScore_Gold.dds" id="Quad_MedalIconGold"/>
			<quad posn="0 0 2" sizen="20 10" image="{{{C_ImgBase}}}MedalScore_Nadeo.dds" id="Quad_MedalIconNadeo"/>
		</frame>
		
		<frame id="Frame_PlayerScore" posn="0 -16">
			<label posn=".8 5.75" text="000000" id="Label_PlayerScorePoints"/>
			<label posn="1 -2" class="score-name" text="Score"/>
		</frame>
		
		<frame id="Frame_StealthIcon" posn="0 -23">
			<quad posn="7 -3" sizen="13 13" halign="center" valign="center" rot="-180" opacity="0" image="{{{C_ImgBase}}}StealthIcon.png" id="Quad_StealthIcon"/>
		</frame>
		
		<frame id="Frame_Evolution" posn="0 -30.5" hidden="1">
			<quad posn="0 0 1" sizen="20 20" image="{{{C_ImgBase}}}Evolution_Bg.dds"/>
			<quad posn="3.5 -19" sizen="2.25 18" rot="180" bgcolor="0F0" id="Quad_EvolutionGauge"/>
			<label posn="4.5 -2 1" class="evolution-name" text="Evolution"/>
			<label posn="4.35 -4.5 1" text="1" id="Label_EvolutionLevel"/>
			<label posn="4.3 -11.75 1" textcolor="080" text="0" id="Label_EvolutionPointsCurrent"/>
			<label posn="4.3 -15.25 1" textcolor="080" text="/0" id="Label_EvolutionPointsToNext"/>
		</frame>
		
		<frame id="Frame_ReloadBoost" posn="133 -169" hidden="1">
			{{{ReloadBoostIndicators}}}
		</frame>
	</frame>
	
	<frame id="Frame_GlobalInformation" posn="160 -90">
		<quad posn="0 0 -1" sizen="90 90" rot="180" image="{{{C_ImgBase}}}CornerVignette.dds"/>
		<frame id="Frame_ToadsReachedPole" posn="-68 14">
			<quad posn="0 0 1" sizen="68 14" image="{{{C_ImgBase}}}PoleCapture_Bg.png"/>
			<quad posn="66 -12" sizen="64 7.5" rot="180" bgcolor="DF0" id="Quad_PoleCaptureGauge"/>
			<label posn="65.5 -3 2" halign="right" valign="center2" class="gauge-name" text="Toads reached pole"/>
			<label posn="4 -8 2" valign="center2" text="0" id="Label_PoleCaptureMax"/>
			<label posn="64 -8 2" halign="right" valign="center2" text="0" id="Label_PoleCaptureCurrent"/>
		</frame>
		
		<frame id="Frame_ToadArmorBonus" posn="-5.75 18">
			<quad sizen="7 7" halign="center" valign="center" image="{{{C_ImgBase}}}ToadArmors.png" colorize="777" id="Quad_ArmorBonusIcon"/>
			<label posn="0 0.4 1" halign="center" valign="center2" text="1" id="Label_ArmorBonusCount"/>
		</frame>
	</frame>
	
	<frame id="Frame_Timer" posn="0 90">
		<quad posn="-15" sizen="30 15" image="{{{C_ImgBase}}}Timer_Bg.dds"/>
		<label posn="0 -2 1" halign="center" valign="center2" text="15 waves to Invasion" id="Label_TimerStatus"/>
		<label posn="0 -5 1" halign="center" text="0:00" id="Label_TimerChrono"/>
		
		<frame id="Frame_ScoreSummary" hidden="1">
			<quad posn="0 -14" sizen="14 14" halign="center" valign="center" image="{{{C_ImgBase}}}MinimapArrow.png" colorize="777" id="Quad_WinnerArrow"/>
			<frame posn="-14.5 -.25">
				<quad sizen="20 10" halign="right" valign="top" image="{{{C_ImgBase}}}SummaryLeft2.png" colorize="00F" id="Quad_SummaryLeft"/>
				<label posn="-1 -1" halign="right" valign="top" textfont="Eurostile_Bold" textsize="4" textcolor="$FFF" textemboss="1" text="0" id="Label_SummaryTeam0"/>
			</frame>
			<frame posn="14.5 -.25">
				<quad sizen="20 10" halign="left" valign="top" image="{{{C_ImgBase}}}SummaryRight2.png" colorize="F00" id="Quad_SummaryRight"/>
				<label posn="1 -1" halign="left" valign="top" textfont="Eurostile_Bold" textsize="4" textcolor="$FFF" textemboss="1" text="0" id="Label_SummaryTeam1"/>
			</frame>
		</frame>
	</frame>
	
	<frame id="Frame_BuffGauge" posn="0 -60 1" scale="0">
		<quad posn="-48 6" sizen="96 12" image="{{{C_ImgBase}}}BuffGauge.png"/>
		<quad posn="-45 4 -1" sizen="90 4" bgcolor="0F0" id="Quad_BuffGauge"/>
		<label posn="0 -2.5 1" halign="center" valign="center2" text="Plasma Grenade" id="Label_BuffName"/>
		<frame id="Frame_BuffEvoBonus" posn="53 6">
			<label posn="0 -.75" halign="center" text="+2s" id="Label_BuffEvoBonus"/>
			<label posn="0 -5.25" halign="center" class="buff-bonus2" text="EVO"/>
		</frame>
	</frame>
</frame>

<script><!--
// -------------------------------------- //
//  INVASION INTERFACE by domino54        //
//  script version: {{{Version}}}                //
// -------------------------------------- //

{{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}

#Const C_MedalColors [<1., .6, .2>, <.85, .85, .85>, <1., .9, 0.>, <.8, 1., 0.>]

// ---------------------------------- //
// Start manialink
// ---------------------------------- //
***StartManialink***
***
// ---------------------------------- //
// Interface elements
declare Frame_GlobalInterface	<=> (Page.GetFirstChild("Frame_GlobalInterface") as CMlFrame);
declare Frame_PersonalElements	<=> (Page.GetFirstChild("Frame_PersonalElements") as CMlFrame);

// Pole limit bar
declare Label_PoleCaptureCurrent	<=> (Page.GetFirstChild("Label_PoleCaptureCurrent") as CMlLabel);
declare Label_PoleCaptureMax		<=> (Page.GetFirstChild("Label_PoleCaptureMax") as CMlLabel);
declare Label_ArmorBonusCount		<=> (Page.GetFirstChild("Label_ArmorBonusCount") as CMlLabel);

// Timer & score
declare Label_TimerStatus		<=> (Page.GetFirstChild("Label_TimerStatus") as CMlLabel);
declare Label_TimerChrono		<=> (Page.GetFirstChild("Label_TimerChrono") as CMlLabel);
declare Label_PlayerScorePoints	<=> (Page.GetFirstChild("Label_PlayerScorePoints") as CMlLabel);
declare Quad_StealthIcon		<=> (Page.GetFirstChild("Quad_StealthIcon") as CMlQuad);

// Evolution
declare Frame_Evolution					<=> (Page.GetFirstChild("Frame_Evolution") as CMlFrame);
declare Label_EvolutionLevel			<=> (Page.GetFirstChild("Label_EvolutionLevel") as CMlLabel);
declare Label_EvolutionPointsCurrent	<=> (Page.GetFirstChild("Label_EvolutionPointsCurrent") as CMlLabel);
declare Label_EvolutionPointsToNext		<=> (Page.GetFirstChild("Label_EvolutionPointsToNext") as CMlLabel);
declare Quad_EvolutionGauge				<=> (Page.GetFirstChild("Quad_EvolutionGauge") as CMlQuad);

// Summary
declare Frame_ScoreSummary	<=> (Page.GetFirstChild("Frame_ScoreSummary") as CMlFrame);
declare Quad_WinnerArrow	<=> (Page.GetFirstChild("Quad_WinnerArrow") as CMlQuad);
declare Quad_SummaryLeft	<=> (Page.GetFirstChild("Quad_SummaryLeft") as CMlQuad);
declare Quad_SummaryRight	<=> (Page.GetFirstChild("Quad_SummaryRight") as CMlQuad);
declare Label_SummaryTeam0	<=> (Page.GetFirstChild("Label_SummaryTeam0") as CMlLabel);
declare Label_SummaryTeam1	<=> (Page.GetFirstChild("Label_SummaryTeam1") as CMlLabel);

// Weapon power-up
declare Quad_BuffGauge		<=> (Page.GetFirstChild("Quad_BuffGauge") as CMlQuad);
declare Label_BuffName		<=> (Page.GetFirstChild("Label_BuffName") as CMlLabel);
declare Quad_BuffOverlay	<=> (Page.GetFirstChild("Quad_BuffOverlay") as CMlQuad);
declare Label_CritMsg		<=> (Page.GetFirstChild("Label_CritMsg") as CMlLabel);
declare Frame_BuffEvoBonus	<=> (Page.GetFirstChild("Frame_BuffEvoBonus") as CMlFrame);
declare Label_BuffEvoBonus	<=> (Page.GetFirstChild("Label_BuffEvoBonus") as CMlLabel);

// Reload Boost
declare Frame_ReloadBoost	<=> (Page.GetFirstChild("Frame_ReloadBoost") as CMlFrame);
declare CMlQuad[] Quad_ReloadBoost;
for (I, 0, {{{C_FuelBoostDuration}}} - 1) Quad_ReloadBoost.add((Page.GetFirstChild("Quad_ReloadBoost"^I) as CMlQuad));

// Medal progress bar
declare Frame_MedalProgressBar	<=> (Page.GetFirstChild("Frame_MedalProgressBar") as CMlFrame);
declare Quad_MedalIconBronze	<=> (Page.GetFirstChild("Quad_MedalIconBronze") as CMlQuad);
declare Quad_MedalIconSilver	<=> (Page.GetFirstChild("Quad_MedalIconSilver") as CMlQuad);
declare Quad_MedalIconGold		<=> (Page.GetFirstChild("Quad_MedalIconGold") as CMlQuad);
declare Quad_MedalIconNadeo		<=> (Page.GetFirstChild("Quad_MedalIconNadeo") as CMlQuad);
declare Quad_MedalProgressGauge	<=> (Page.GetFirstChild("Quad_MedalProgressGauge") as CMlQuad);
declare Label_MedalTargetPoints	<=> (Page.GetFirstChild("Label_MedalTargetPoints") as CMlLabel);

Quad_MedalIconBronze.Opacity	= 0.;
Quad_MedalIconSilver.Opacity	= 0.;
Quad_MedalIconGold.Opacity		= 0.;
Quad_MedalIconNadeo.Opacity		= 0.;
Quad_MedalProgressGauge.Size.X	= 0.;

// ---------------------------------- //
// Net variables
declare netread Boolean Net_Invasion_InterfaceVisibility	for Teams[0];
declare netread Boolean Net_Invasion_IsMatchOver			for Teams[0];
declare netread Integer Net_GameStartTime					for Teams[0];
declare netread Integer Net_NbToadsReachedPole	for Teams[0];
declare netread Integer Net_PoleLimit			for Teams[0];
declare netread Integer Net_NbWavesToInvasion	for Teams[0];
declare netread Integer Net_ToadArmorBonus		for Teams[0];

// Personal
declare netread Boolean Net_HasStealth		for UI;
declare netread Boolean Net_HasWeaponBuff	for UI;
declare netread Integer Net_HG_LastCritTime for UI;
declare netread Text	Net_BonusWeaponName	for UI;
declare netread Integer Net_GoldBuffBonus	for UI;

declare netread Integer[Text] Net_ReloadBoostEndTime for Teams[0];

// Solo
declare netwrite Integer Net_SoloTimeScore for Teams[0];

// ---------------------------------- //
// Evolution
declare netread Boolean 	Net_UseEvolution		for Teams[0];
declare netread Int3[Text]	Net_PlayerEvolutionData	for Teams[0]; ///< [1 => Level, 2 => Current, 3 => To next]

declare Integer PlayerScore				= 0;
declare Integer TotalPlayerScore		= 0;
declare Vec3	InterfaceColor			= <0., 0., 0.>;
declare Integer PlayerBuffDuration		= 0;
declare Integer PlayerBuffPickTime		= 0;
declare Boolean ReloadBoostVisible		= False;

declare Integer CurrentLeadClan		= -1;
declare Text	SumArrowColor		= "";
declare Real	SumArrowRotation	= 0.;

declare Integer SoloTimePoints			= 0;
declare Integer SoloScoringTickEnd		= -1;
declare Boolean MedalTriggeredBlinking	= False;

// ---------------------------------- //
/** LAST variables
 *
 * Used to save client performance by avoiding
 * repeating actions every script tick (10 ms).
 */
declare Integer Last_NbWavesToInvasion		= -1;
declare Integer Last_NbToadsReachedPole 	= -1;
declare Integer	Last_PoleLimit				= -1;
declare Boolean Last_InterfaceVisibility	= False;
declare Integer Last_ToadArmorBonus			= -1;
declare Integer Last_PlayerScore			= 0;
declare Integer Last_TotalPlayerScore		= -1;
declare Vec3	Last_InterfaceColor			= <-1., -1., -1.>;
declare Integer Last_EvolutionDataCurrent	= -1;
declare Integer Last_EvolutionDataToNext	= -1;
declare Integer Last_CurrentLeadClan		= -1;
declare Boolean Last_ReloadBoostVisible		= False;
declare Integer Last_ReloadBoostTime		= -1;
declare Boolean Last_HasWeaponBuff			= False;
declare Boolean Last_HasStealth				= False;
declare Integer Last_InterfaceCritTime		= 0;
declare Integer Last_CurrentMedal			= -1;
declare Integer Last_MedalScore				= -1;

declare Integer[] Last_ClanScores;
for (I, 0, 2) Last_ClanScores.add(-1);

declare Vec3[] Last_TeamsColors;
for (I, 0, 1) Last_TeamsColors.add(<-1., -1., -1.>);

Last_HasStealth = Net_HasStealth;

// ---------------------------------- //
// Solo mode
declare ObjectiveAuthor		= TL::ToInteger(Map.ObjectiveTextAuthor);
declare ObjectiveGold		= TL::ToInteger(Map.ObjectiveTextGold);
declare ObjectiveSilver		= TL::ToInteger(Map.ObjectiveTextSilver);
declare ObjectiveBronze		= TL::ToInteger(Map.ObjectiveTextBronze);

// Prepare UI and attach it
Frame_GlobalInterface.RelativeScale = 1.5;
Frame_GlobalInterface.Show();
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Fade in/out HUD
if (Net_Invasion_InterfaceVisibility != Last_InterfaceVisibility) {
	Last_InterfaceVisibility = Net_Invasion_InterfaceVisibility;
	
	SoloTimePoints = 0;
	SoloScoringTickEnd = -1;
	
	declare Real TargetScale;
	declare Text TargetAnim;
	
	if (Net_Invasion_InterfaceVisibility) {
		TargetScale = 1.;
		TargetAnim = "EaseOutSine";
	} else {
		TargetScale = 1.5;
		TargetAnim = "EaseInSine";
	}
	
	LibManialink_Anim("<frame scale=\""^TargetScale^"\" id=\"Frame_GlobalInterface\"/>", 2000, TargetAnim);
}

// ---------------------------------- //
// Update timer status
if (GameTime < Net_GameStartTime) {
	Label_TimerChrono.Value = TL::TimeToText(Net_GameStartTime - GameTime + 1000, False);
	if (Last_NbWavesToInvasion != -2) {
		Last_NbWavesToInvasion = -2;
		Label_TimerStatus.SetText("Preparation time");
	}
} else {
	Label_TimerChrono.Value = TL::TimeToText(GameTime - Net_GameStartTime, False);
	
	if (Last_NbWavesToInvasion != Net_NbWavesToInvasion) {
		Last_NbWavesToInvasion = Net_NbWavesToInvasion;
		
		if (Net_NbWavesToInvasion > 1) {
			Label_TimerStatus.SetText(TL::Compose(_("%1 waves to Invasion"), TL::ToText(Net_NbWavesToInvasion)));
		} else if (Net_NbWavesToInvasion == 1) {
			Label_TimerStatus.SetText("1 wave to Invasion");
		} else {
			Label_TimerStatus.SetText("Invasion Mode!");
		}
	}
}

// ---------------------------------- //
// Pole limit gauge
if (Last_NbToadsReachedPole != Net_NbToadsReachedPole || Last_PoleLimit != Net_PoleLimit) {
	declare Real Size;
	if (Net_PoleLimit > 0) Size = 64. * (ML::ToReal(Net_NbToadsReachedPole) / Net_PoleLimit);
	else Size = 0.;
	
	LibManialink_Anim("<quad sizen=\""^Size^" 6.5\" id=\"Quad_PoleCaptureGauge\"/>", 250, "EaseInOutCirc");
	
	Label_PoleCaptureCurrent.SetText(TL::ToText(Net_NbToadsReachedPole));
	Label_PoleCaptureMax.SetText(TL::ToText(Net_PoleLimit));
	
	Last_NbToadsReachedPole = Net_NbToadsReachedPole;
	Last_PoleLimit = Net_PoleLimit;
}

// ---------------------------------- //
// Toad armor bonus icon
if (Last_ToadArmorBonus != Net_ToadArmorBonus) {
	Last_ToadArmorBonus = Net_ToadArmorBonus;
	
	LibManialink_Anim("<frame scale=\"3\" id=\"Frame_ToadArmorBonus\"/>", 500, "EaseInOutCirc");
	LibManialink_Anim("<quad colorize=\"DF0\" id=\"Quad_ArmorBonusIcon\"/>", 500, "EaseInOutCirc");
	LibManialink_AnimInsert("<frame scale=\"1\" id=\"Frame_ToadArmorBonus\"/>", 500, 500, "EaseInOutCirc");
	LibManialink_AnimInsert("<quad colorize=\"777\" id=\"Quad_ArmorBonusIcon\"/>", 500, 500, "EaseInOutCirc");
	
	Label_ArmorBonusCount.SetText(TL::ToText(1 + Net_ToadArmorBonus/100));
}

// ---------------------------------- //
// Solo elements
if ({{{G_IsSolo}}} /* G_IsColo */) {
	// ---------------------------------- //
	// Time points
	if (Net_Invasion_IsMatchOver) {
		Net_SoloTimeScore = SoloTimePoints;
	} else if (GameTime >= Net_GameStartTime) {
		SoloTimePoints = (GameTime - Net_GameStartTime) / 1000;
	}
	
	// ---------------------------------- //
	// Medal score
	if (ObjectiveAuthor > -1 && ObjectiveGold > -1 && ObjectiveSilver > -1 && ObjectiveBronze > -1) {
		if (!Frame_MedalProgressBar.Visible) Frame_MedalProgressBar.Show();
		
		declare Integer TargetMedalScore;
		declare Integer CurrentMedal;
		
		if (TotalPlayerScore < ObjectiveBronze) {
			TargetMedalScore = ObjectiveBronze;
			CurrentMedal = 0;
		} else if (TotalPlayerScore < ObjectiveSilver) {
			TargetMedalScore = ObjectiveSilver;
			CurrentMedal = 1;
		} else if (TotalPlayerScore < ObjectiveGold) {
			TargetMedalScore = ObjectiveGold;
			CurrentMedal = 2;
		} else if (TotalPlayerScore < ObjectiveAuthor) {
			TargetMedalScore = ObjectiveAuthor;
			CurrentMedal = 3;
		} else {
			TargetMedalScore = ObjectiveAuthor;
			CurrentMedal = 4;
		}
		
		if (CurrentMedal < 4) Quad_MedalProgressGauge.BgColor = C_MedalColors[CurrentMedal];
		else Quad_MedalProgressGauge.BgColor = C_MedalColors[3];
		
		Label_MedalTargetPoints.Value = TL::ToText(TargetMedalScore);
		if (Last_MedalScore != TotalPlayerScore) {
			Last_MedalScore = TotalPlayerScore;
			LibManialink_Anim("<quad sizen=\""^TotalPlayerScore*50./TargetMedalScore^" 4\" id=\"Quad_MedalProgressGauge\"/>", 250, "EaseInOutSine");
		}
		
		if (Last_CurrentMedal != CurrentMedal) {
			Last_CurrentMedal = CurrentMedal;
			MedalTriggeredBlinking = False;
		}
		
		if (!MedalTriggeredBlinking) {
			MedalTriggeredBlinking = True;
			
			if (CurrentMedal != 0) {
				declare Text ControlToAnimate;
				switch (CurrentMedal) {
					case 1 : ControlToAnimate = "Quad_MedalIconBronze";
					case 2 : ControlToAnimate = "Quad_MedalIconSilver";
					case 3 : ControlToAnimate = "Quad_MedalIconGold";
					case 4 : ControlToAnimate = "Quad_MedalIconNadeo";
				}
				
				Audio.PlaySoundEvent(CAudioManager::ELibSound::Victory, CurrentMedal-1, -5.);
				
				LibManialink_AnimRepeatStart(200, 25);
				LibManialink_Anim("<quad opacity=\"0\" id=\""^ControlToAnimate^"\"/>", 100, "EaseInOutSine");
				LibManialink_AnimChain("<quad opacity=\"1\" id=\""^ControlToAnimate^"\"/>", 100, "EaseInOutSine");
				LibManialink_AnimRepeatEnd();
			}
		}
	} else {
		if (Frame_MedalProgressBar.Visible) Frame_MedalProgressBar.Hide();
	}
}

// ---------------------------------- //
// Custom score summary
if (UseClans) {
	if (!Frame_ScoreSummary.Visible) Frame_ScoreSummary.Show();
	
	for (Clan, 0, 1) {
		// Animate scores
		if (Last_ClanScores[Clan+1] != ClanScores[Clan+1]) {
			Last_ClanScores[Clan+1] = ClanScores[Clan+1];
			
			Label_SummaryTeam0.SetText(TL::ToText(ClanScores[1]));
			Label_SummaryTeam1.SetText(TL::ToText(ClanScores[2]));
			
			LibManialink_Anim("<frame scale=\"1.25\" id=\"Label_SummaryTeam"^Clan^"\"/>", 200, "EaseOutSine");
			LibManialink_AnimInsert("<frame scale=\"1\" id=\"Label_SummaryTeam"^Clan^"\"/>", 200, 200, "EaseInSine");
		}
		
		// Update colors
		if (Last_TeamsColors[Clan] != Teams[Clan].ColorPrimary) {
			Quad_SummaryLeft.Colorize = Teams[0].ColorPrimary;
			Quad_SummaryRight.Colorize = Teams[1].ColorPrimary;
		}
	}
	
	// Update leader
	if (ClanScores[1] == ClanScores[2]) {
		SumArrowColor = TL::ColorToText(<.5, .5, .5>);
		SumArrowRotation = 0.;
		CurrentLeadClan = 0;
	} else if (ClanScores[1] > ClanScores[2]) {
		SumArrowColor = TL::ColorToText(Teams[0].ColorPrimary);
		SumArrowRotation = -90.;
		CurrentLeadClan = 1;
	} else {
		SumArrowColor = TL::ColorToText(Teams[1].ColorPrimary);
		SumArrowRotation = 90.;
		CurrentLeadClan = 2;
	}
	
	// Rotate arrow
	if (Last_CurrentLeadClan != CurrentLeadClan) {
		Last_CurrentLeadClan = CurrentLeadClan;
		LibManialink_Anim("<frame rot=\""^SumArrowRotation^"\" colorize=\""^SumArrowColor^"\" id=\"Quad_WinnerArrow\"/>", 333, "EaseInOutCirc");
	}
} else {
	if (Frame_ScoreSummary.Visible) Frame_ScoreSummary.Hide();
}

// ---------------------------------- //
// Show stealth icon
if (Last_HasStealth != Net_HasStealth) {
	Last_HasStealth = Net_HasStealth;
	if (Net_HasStealth) {
		Audio.PlaySoundEvent("{{{C_ImgBase}}}Stealth_Earned.wav", -7.5);
		LibManialink_Anim("<quad scale=\"1\" rot=\"0\" id=\"Quad_StealthIcon\"/>", 1000, "EaseOutBack");
	}
}

// ---------------------------------- //
// Set personal elements visibility
if (InputPlayer != Null) {
	Frame_PersonalElements.Visible = ((GUIPlayer != Null && !GUIPlayer.IsBot) || !InputPlayer.RequestsSpectate);
	
	// ---------------------------------- //
	// Colorize elements
	if (GUIPlayer != Null) {
		if (GUIPlayer.CurrentClan != 0) InterfaceColor = Teams[GUIPlayer.CurrentClan - 1].ColorPrimary;
		else InterfaceColor = GUIPlayer.User.Color;
	}
	
	if (Last_InterfaceColor != InterfaceColor) {
		Quad_BuffGauge.BgColor			= InterfaceColor;
		Quad_BuffOverlay.Colorize		= InterfaceColor;
		Quad_EvolutionGauge.BgColor		= InterfaceColor;
		
		Label_EvolutionPointsToNext.TextColor = <
			InterfaceColor.X * 3/4,
			InterfaceColor.Y * 3/4,
			InterfaceColor.Z * 3/4
		>;
		Label_EvolutionPointsCurrent.TextColor = Label_EvolutionPointsToNext.TextColor;
		
		Last_InterfaceColor = InterfaceColor;
	}
	
	if (GUIPlayer != Null && GUIPlayer == InputPlayer) {
		// ---------------------------------- //
		// Anim Stealth when armor decreases
		if (Net_HasStealth && InputPlayer.ArmorMax > 0) {
			Quad_StealthIcon.Opacity = ML::ToReal(InputPlayer.Armor) / InputPlayer.ArmorMax;
		} else {
			Quad_StealthIcon.RelativeScale		= 0.;
			Quad_StealthIcon.RelativeRotation	= -180.;
			Quad_StealthIcon.Opacity			= 0.;
		}
	}
}

// ---------------------------------- //
// Personal elements
if (GUIPlayer != Null && !GUIPlayer.IsBot) {
	// ---------------------------------- //
	// Score label
	TotalPlayerScore = (GUIPlayer.Score.Points + SoloTimePoints) * 10;
	
	if (Last_PlayerScore != GUIPlayer.Score.Points) {
		Last_PlayerScore = GUIPlayer.Score.Points;			
		LibManialink_Anim("<frame scale=\"1.1\" id=\"Frame_PlayerScore\"/>", 200, "EaseOutSine");
		LibManialink_AnimInsert("<frame scale=\"1\" id=\"Frame_PlayerScore\"/>", 200, 200, "EaseInSine");
	}
	
	if (Last_TotalPlayerScore != TotalPlayerScore) {
		Last_TotalPlayerScore = TotalPlayerScore;
		Label_PlayerScorePoints.SetText(GetScoreLabel(Last_TotalPlayerScore));
	}
	
	// ---------------------------------- //
	// Evolution
	if (Net_UseEvolution && Net_PlayerEvolutionData.existskey(GUIPlayer.Login)) {
		if (!Frame_Evolution.Visible) Frame_Evolution.Show();
		
		if (Last_EvolutionDataCurrent != Net_PlayerEvolutionData[GUIPlayer.Login].Y ||
			Last_EvolutionDataToNext != Net_PlayerEvolutionData[GUIPlayer.Login].Z) {
			Last_EvolutionDataCurrent = Net_PlayerEvolutionData[GUIPlayer.Login].Y;
			Last_EvolutionDataToNext = Net_PlayerEvolutionData[GUIPlayer.Login].Z;
			
			Label_EvolutionLevel.SetText(TL::ToText(Net_PlayerEvolutionData[GUIPlayer.Login].X));
			Label_EvolutionPointsCurrent.SetText(TL::ToText(Net_PlayerEvolutionData[GUIPlayer.Login].Y));
			Label_EvolutionPointsToNext.SetText("/"^TL::ToText(Net_PlayerEvolutionData[GUIPlayer.Login].Z));
			
			declare Real Size;
			if (Net_PlayerEvolutionData[GUIPlayer.Login].Z > 0) Size = 18. * (ML::ToReal(Net_PlayerEvolutionData[GUIPlayer.Login].Y) / Net_PlayerEvolutionData[GUIPlayer.Login].Z);
			else Size = 18.;
			
			LibManialink_Anim("<quad sizen=\"2 "^Size^"\" id=\"Quad_EvolutionGauge\"/>", 250, "EaseLinear");
		}
	} else {
		if (Frame_Evolution.Visible) Frame_Evolution.Hide();
	}
	
	// ---------------------------------- //
	// Critical hits
	if (Net_HG_LastCritTime != Last_InterfaceCritTime && Net_HG_LastCritTime != 0) {
		Last_InterfaceCritTime = Net_HG_LastCritTime;
		if (GUIPlayer.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
			LibManialink_Anim("<label scale=\"1.5\" opacity=\"1\" id=\"Label_CritMsg\"/>", 1, "EaseLinear");
			LibManialink_AnimInsert("<label scale=\"1\" opacity=\"0\" id=\"Label_CritMsg\"/>", 1, 500, "EaseInCirc");
		}
	}
	
	// ---------------------------------- //
	// Reload Boost
	if (Net_ReloadBoostEndTime.existskey(GUIPlayer.Login)) {
		declare ReloadBoostTime = (Net_ReloadBoostEndTime[GUIPlayer.Login] + 1000 - GameTime) / 1000;
		
		if (ReloadBoostTime <= {{{C_FuelBoostDuration}}} && ReloadBoostTime >= 1) {
			ReloadBoostVisible = True;
			
			if (Last_ReloadBoostTime != ReloadBoostTime) {
				Last_ReloadBoostTime = ReloadBoostTime;
				
				for (I, 0, {{{C_FuelBoostDuration}}} - 1) {
					if (ReloadBoostTime < I + 1) {
						Quad_ReloadBoost[I].Colorize = <.25, .25, .25>;
					} else {
						Quad_ReloadBoost[I].Colorize = InterfaceColor;
					}
				}
			}
		} else {
			ReloadBoostVisible = False;
		}
	} else {
		ReloadBoostVisible = False;
	}
}

// ---------------------------------- //
// Show/hide Reload Boost
if (Last_ReloadBoostVisible != ReloadBoostVisible) {
	Last_ReloadBoostVisible = ReloadBoostVisible;
	Frame_ReloadBoost.Visible = ReloadBoostVisible;
}

// ---------------------------------- //
// Weapon power-up: show/hide
if (Last_HasWeaponBuff != Net_HasWeaponBuff) {
	Last_HasWeaponBuff = Net_HasWeaponBuff;
	
	if (Net_HasWeaponBuff) {
		PlayerBuffDuration = {{{C_GoldBuffDuration/1000}}} + Net_GoldBuffBonus / 1000;
		Frame_BuffEvoBonus.Visible = (Net_GoldBuffBonus > 0);
		Label_BuffEvoBonus.SetText(TL::Compose(_("+%1s"), TL::ToText(Net_GoldBuffBonus/1000)));
		Label_BuffName.SetText(Net_BonusWeaponName);
		
		LibManialink_Anim("<frame scale=\"1\" id=\"Frame_BuffGauge\"/>", 750, "EaseOutBack");
		
		LibManialink_AnimRepeatStart(1000, PlayerBuffDuration);
		LibManialink_Anim("<quad opacity=\"1\" id=\"Quad_BuffOverlay\"/>", 500, "EaseInOutSine");
		LibManialink_AnimChain("<quad opacity=\"0\" id=\"Quad_BuffOverlay\"/>", 500, "EaseInOutSine");
		LibManialink_AnimRepeatEnd();
	} else {
		LibManialink_Anim("<frame scale=\"0\" id=\"Frame_BuffGauge\"/>", 500, "EaseInBack");
		Audio.PlaySoundEvent("{{{C_ImgBase}}}BonusEnd.wav", -5.);
	}
}

// ---------------------------------- //
// Weapon power-up: display value
if (Net_HasWeaponBuff) {
	declare Ratio = 1. - ((Now - PlayerBuffPickTime) / (PlayerBuffDuration * 1000.));
	Quad_BuffGauge.Size.X = 90. * Ratio;
} else {
	PlayerBuffPickTime = Now;
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

/* ------------------------------------- */
/** Get score with zeros
 *
 *	@param	_Points		Score points
 *
 *	@return		Score text string
 */
Text GetScoreLabel(Integer _Points) {
	declare Text TextScore;
	
	if (_Points > 0) {
		declare Integer NbZero = 5 - ML::FloorInteger(((ML::Ln(_Points*1.)/ML::Ln(10.))+1.));
		for (I, 0, NbZero) {
			TextScore ^= "0";
		}
		TextScore ^= "$FFF"^_Points;
	} else {
		TextScore = "000000";
	}
	
	return TextScore;
}

// ---------------------------------- //
// Library Animations
// ---------------------------------- //
{{{Manialink::Animations(["EaseInBack", "EaseOutBack", "EaseInSine", "EaseOutSine", "EaseInOutSine", "EaseInCirc", "EaseInOutCirc"])}}}
{{{Manialink::Functions(["AnimRepeat"])}}}

// ---------------------------------- //
// Main function
// ---------------------------------- //
main() {
	+++StartManialink+++
	while (True) {
		yield;
		LibManialink_AnimLoop();
		+++Yield+++
	}
}
--></script>
</manialink>
	""";
	
	return OutputManialink;
}

// ---------------------------------- //
// Marker
// ---------------------------------- //

/* ------------------------------------- */
/** Set visibility for specific player
 *
 *	@param	_Player			Player to set visibility
 *	@param	_Visibility		Marker visibility
 */
Void Marker_SetVisibility(CSmPlayer _Player, Boolean _Visibility) {
	if (_Player == Null) return;
	
	declare netwrite Boolean[Text] Net_GoldVisibleForPlayer for Teams[0];
	Net_GoldVisibleForPlayer[_Player.Login] = _Visibility;
}

/* ------------------------------------- */
/** Set visibility for everyone
 *
 *	@param	_Visibility		Marker visibility
 */
Void Marker_SetVisibilityAll(Boolean _Visibility) {
	foreach (Player in Players) Marker_SetVisibility(Player, _Visibility);
}

/* ------------------------------------- */
/** Update Gold marker position
 *
 *	@param	_Object		Object to set position
 */
Void Marker_Update(Vec3 _Position) {
	if (_Position == <0., 0., 0.>) return;
	
	declare Text PositionText;
	PositionText = _Position.X^" "^_Position.Y + 1.5^" "^_Position.Z;
	
	UIManager.UIAll.MarkersXML = """
		<marker pos="{{{PositionText}}}" manialinkframeid="marker-gold"/>
	""";
	
	declare netwrite Integer Net_GoldSpawnTime for Teams[0];
	Net_GoldSpawnTime = Now;
}

// ---------------------------------- //
/// Get markers layer
Text CreateMarkers() {
	declare Text OutputManialink;
	declare Ratio = 9./16;
	declare StepsML = "";
	for (I, 1, 8) {
		StepsML ^= """
		<quad posn="0 0 1" sizen="{{{14 * Ratio}}} 14" halign="center" valign="center" image="{{{C_ImgBase}}}/MarkerGold/Step{{{I-1}}}.png" colorize="FC0" id="ClockStep{{{I}}}"/>""";
	}
	
	// ---------------------------------- //
	// Create
	OutputManialink = """
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<manialink version="2" name="Invasion:GoldMarker">
<frame id="marker-gold">
	<frame id="Frame_GoldItemMarker" scale="0">
		<quad sizen="{{{14 * Ratio}}} 14" id="ClockBG" image="{{{C_ImgBase}}}/MarkerGold/SimpleBG.png" halign="center" valign="center"/>
		{{{StepsML}}}
		<quad posn="0 0 -2" sizen="{{{6 * Ratio}}} 10" image="{{{C_ImgBase}}}/MarkerGold/crystalsVide.png" halign="center" valign="center"/>
		<quad posn="0 0 -1" sizen="{{{6 * Ratio}}} 10" image="{{{C_ImgBase}}}/MarkerGold/crystals.png" halign="center" valign="center"/>
	</frame>
</frame>
<script><!--
// -------------------------------------- //
//  INVASION GOLD MARKER by domino54      //
//  script version: {{{Version}}}                //
// -------------------------------------- //

{{{Manialink::Includes(["TextLib" => "TL", "MathLib" => "ML"])}}}
// ---------------------------------- //
// Manialink start
// ---------------------------------- //
***StartManialink***
***
// ---------------------------------- //
// Load elements
declare Frame_GoldItemMarker <=> (Page.GetFirstChild("Frame_GoldItemMarker") as CMlFrame);
declare ClockBG <=> (Page.GetFirstChild("ClockBG") as CMlQuad);
declare CMlQuad[] ClockSteps;
for (I, 1, 8) ClockSteps.add((Page.GetFirstChild("ClockStep"^I) as CMlQuad));

// ---------------------------------- //
// Net variables
declare netread Integer Net_GoldSpawnTime for Teams[0];
declare netread Boolean[Text] Net_GoldVisibleForPlayer for Teams[0];

// ---------------------------------- //
// Manialink variables
declare Real	ClockRatio					= -1.;
declare Boolean MarkerVisible				= False;
declare Integer MarkerVisibilityEndTime		= 0;

// ---------------------------------- //
// Last variables
declare Boolean Last_MarkerVisible		= True;
declare Integer Last_GoldSpawnTime		= -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update spawn time
if (Last_GoldSpawnTime != Net_GoldSpawnTime) {
	Last_GoldSpawnTime = Net_GoldSpawnTime;
	MarkerVisibilityEndTime = Now + {{{C_GoldMultiLifetime}}} - 500;
}

// ---------------------------------- //
// Set visibility
if (Now < MarkerVisibilityEndTime) {
	MarkerVisible = ((InputPlayer != Null && InputPlayer.RequestsSpectate) || (GUIPlayer != Null && Net_GoldVisibleForPlayer.existskey(GUIPlayer.Login) && Net_GoldVisibleForPlayer[GUIPlayer.Login]));
	ClockRatio = (MarkerVisibilityEndTime - Now) / ({{{C_GoldMultiLifetime}}} - 500.);
} else {
	MarkerVisible = False;
}

// ---------------------------------- //
// Show/hide marker
if (Last_MarkerVisible != MarkerVisible) {
	Last_MarkerVisible = MarkerVisible;
	
	declare Text TargetAnim;
	declare Real TargetScale;
	
	if (MarkerVisible) {
		TargetAnim = "EaseOutBack";
		TargetScale = 1.;
	} else {
		TargetAnim = "EaseInBack";
		TargetScale = 0.;
	}
	
	LibManialink_Anim("<frame scale=\""^TargetScale^"\" id=\"Frame_GoldItemMarker\"/>", 333, TargetAnim);
}

// ---------------------------------- //
// Clock ratio
if (MarkerVisible) {
	for (I, 0, 7) {
		if (ClockRatio * 8 <= I) {
			ClockSteps[7-I].Opacity = 0.;
		}
		else if (ClockRatio * 8 > I && ClockRatio * 8 < I+1) {
			ClockSteps[7-I].Opacity = ClockRatio * 8 - I;
		}
		else {
			ClockSteps[7-I].Opacity = 1.;
		}
	}
}
***

// ---------------------------------- //
// Library Animations
// ---------------------------------- //
{{{Manialink::Animations(["EaseInBack", "EaseOutBack"])}}}
// ---------------------------------- //
// Main function
// ---------------------------------- //
main() {
	+++StartManialink+++
	while (True) {
		yield;
		LibManialink_AnimLoop();
		+++Yield+++
	}
}
--></script>
</manialink>
	""";
	
	return OutputManialink;
}
