// -------------------------------------- //
//  INVASION by domino54                  //
//  script version: v3.2.1 @2017-06-28    //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes	"InvasionArena, HordeArena"
#Const Version				"2017-06-28"
#Const ScriptName			"Modes/ShootMania/Invasion.Script.txt"

#Include "Libs/Nadeo/Sound.Script.txt" as Sound
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/domino54/ShootMania/InvasionUI.Script.txt" as InvasionUI

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_ToadsReachedPoleLimit	20		as _("Pole limit")
#Setting S_NbWavesBeforeInvasion	15		as _("Amount of waves before Invasion mode")
#Setting S_NbToadsPerWave			6		as _("Amount of Toads spawned in wave")
#Setting S_TimeBetweenWaves			20		as _("Time between waves")
#Setting S_ProgressiveToadsAmount	True	as _("Spawn extra Toads depending on server population")
#Setting S_UseEvolutionLevels		True	as _("Use Evolution levels")
#Setting S_UseWeaponsOverheating	True	as _("Allow Arrow and Nucleus overheating")
#Setting S_ToadAggroRadiusMax		80.		as _("Toads fire range on maximum difficulty")
#Setting S_UseTeamsMode				False	as _("Teams mode (require server restart)")
#Setting S_MaxNbToadsAtOnce			60		as "<hidden>" ///< Maximum amount of Toads spawned at once
#Setting S_MaximumNbReplies			5		///< Increased Replies limit
#Setting S_UsePlayerClublinks		False	///< Disable Clublinks

#Setting S_NeutralEmblemUrl "file://Media/Manialinks/ShootMania/GalaxyTitles/EmblemInvasion.dds"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_SafePhaseDuration		10000	///< Duration of the preparation phase without PvP interaction
#Const C_MatchBeginDelay		1500	///< Small synhronization delay before game start
#Const C_PlayersPerExtraToad	2		///< Amount of players per each next additional Toad
#Const C_CriticalHitChance		.02		///< Chance of performing a critical hit
#Const C_PoleUnderAttackDist	24.		///< Toad maximum distance to mark Pole as being attacked
#Const C_PlayerBaseArmorMax		400		///< Default amount of player Armor
#Const C_PlayerBaseAmmoGain		1.5		///< Default player ammo reload speed
#Const C_PlayerHurtShieldTime	1000	///< Duration of the damage shielding effect
#Const C_WeaponHeatTimePerCombo	750		///< Overheating time given by every combo performed
#Const C_WeaponHeatTimeMax		20000	///< Maximum overheating duration
#Const C_WeaponBaseReloadBonus	.333	///< Normal reload bonus on hit
#Const C_WeaponCustomBonus		.5		///< Ammo bonus on custom weapon hit

#Const Description _("TYPE: Cooperation\nOBJECTIVE: Protect Pole from Toads attack as long as it's possible. Game is over when 20 Toads reach the Pole.")

// Gold crystal properties
#Const C_GoldSpawningInterval	40000	///< Time between each Gold spawn
#Const C_GoldLifeDuration		15000	///< Life duration of the Gold item
#Const C_GoldBuffBaseDuration	10000	///< Duration of the weapon buff
#Const C_GoldBuffTimePerEvoLvl	2000	///< Extra time of the weapon buff per evolution level

/// Human bots
#Const C_FakeUserWpChangeTime	30000	///< Time before fake player switch weapon again
#Const C_FakeUserWpChangeDelta	10000	///< Weapon change time variety
#Const C_FakeUserWeapons		[::EWeapon::Laser, ::EWeapon::Rocket, ::EWeapon::Nucleus]

/// Toads spawning settings
#Const C_ToadSpawnIntervalMax	1000	///< Maximum time interval between every Toad spawned in a wave
#Const C_ToadSpawnIntervalMin	500		///< Minimum time interval between every Toad spawned in a wave

/// Toads Armor settings
#Const C_ToadArmorPointsMin			100		///< Toads Armor points at the beginning of the game
#Const C_ToadArmorPointsMax			2500	///< Maximum possible amount of Toads Armor points
#Const C_ToadArmorWavesPerPoint		3		///< Amount of waves between Toads Armor incrementation
#Const C_ToadArmorInvasionInterval	45000	///< Time between Toads Armor incrementation in Invasion phase

/// Toads detailed attributes
#Const C_ToadSpeedPowerMin		.2		///< Speed at lowest difficulty
#Const C_ToadSpeedPowerMax		.5		///< Speed at highest difficulty
#Const C_ToadAimAccuracyMin		.875	///< Aiming accuracy at lowest difficulty
#Const C_ToadAimAccuracyMax		1.		///< Aiming accuracy at highest difficulty
#Const C_ToadReactionTimeMin	125		///< Reaction time at lowest difficulty
#Const C_ToadReactionTimeMax	500		///< Reaction time at highest difficulty
#Const C_ToadShootIntervalMin	2000	///< Shooting interval at lowest difficulty
#Const C_ToadShootIntervalMax	200		///< Shooting interval at highest difficulty
#Const C_ToadAggroRadiusMin		12.		///< Target searching range at lowest difficulty
#Const C_ToadDisengageDistance	16.		///< Toads disengage distance (added to aggressivity radius)

/// Stuck Toads detection settings
#Const C_ToadStuckUpdateDistance	.5		///< Distance a Toad needs to travel to reset stuck detection timer
#Const C_ToadStuckMaxDuration		5000	///< Maximum time Toad can be stuck in one place before unspawning

/// Special Toads occurrence settings
#Const C_ToadFrequencyGimp		6	///< Amount of usual Toads between each Gimp Toad
#Const C_ToadFrequencyWeapon	12	///< Amount of usual Toads between each Toad carrying a special weapon
#Const C_ToadFrequencyZombie	18	///< Amount of usual Toads between each Zombie
#Const C_ToadWeaponTypes ["Nucleus", "Laser", "Arrow"] ///< Types of Toads weapons

/// Special Toad types parameters
#Const C_ToadGimpBlinkFrequency		250		///< Frequency of the Gimp Toads blink animation
#Const C_ToadGimpFuelDropChance		.1		///< Chance for a Gimp Toad to drop Fuel upon elimination
#Const C_ToadZombieBlinkFrequency	1000	///< Frequency of the Zombies blink animation
#Const C_ToadZombieBlinkDuration	125		///< Zombies blink effect duration
#Const C_ToadZombieSpeedMultiplier	1.125	///< Speed multiplier of the Zombies

/// Giants settings
#Const C_GiantMaxNbSpawnedAtOnce	4		///< Maximum amount of Giants present on the map at the same time
#Const C_GiantMinPlayersToSpawn		3		///< Minimum number of players required for a Giant to spawn
#Const C_GiantSpawnChanceRatio		.125	///< Chance of spawning a Giant instead of a Zombie in wave
#Const C_GiantArmorPointsMinimum	12000	///< Minimum amount of Armor points the Giant spawns with
#Const C_GiantArmorPointsPerPlayer	1000	///< Additional Armor points per every player on the server
#Const C_GiantAmmoReloadSpeed		5.		///< Giant ammunition reload speed
#Const C_GiantDefaultWalkSpeed		.1		///< Walking speed of a Giant
#Const C_GiantPointsScoredAtGoal	10		///< Amount of points scored when a Giant touch the Goal
#Const C_GiantColorTransition		[0. => <1., 0., 0.>, .5 => <1., 1., 0.>, 1. => <0., 1., 0.>]

/// Colors of each available Toad type
#Const C_ToadTypesColors [
	"Default" => <0., 1., 0.>, "Gimp" => <0., 1., .75>, "Zombie" => <1., .5, 0.>,
	"Nucleus" => <0., .5, 1.>, "Laser" => <1., 0., 0.>, "Arrow" => <1., .75, 0.>
]

/// Maximum amount of bullets in each weapon of a Toad
#Const C_ToadWeaponAmmoMax [
	::EWeapon::Rocket => 3,
	::EWeapon::Nucleus => 1,
	::EWeapon::Arrow => 2
]

/// Actions used as weapons
#Const C_CustomWeaponActions ["EnergyCharge", "FrozenArrow", "PlasmaGrenade", "Torpede", "WideRail"]

/// Names of the custom weapons
#Const C_CustomWeaponsNames [
	"EnergyCharge" => "Handheld Charge",
	"FrozenArrow" => "Frozen Arrow",
	"PlasmaGrenade" => "Plasma Grenade",
	"Torpede" => "Torpede",
	"WideRail" => "Wide Rail"
]

/// Weapons accessible with their numbers
#Const C_GetWeaponFromNum [
	1 => CSmMode::EWeapon::Laser,
	2 => CSmMode::EWeapon::Rocket,
	3 => CSmMode::EWeapon::Nucleus,
	5 => CSmMode::EWeapon::Arrow
]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Boolean G_IsSoloMode; ///< Specifies if mode is in solo campaign or local play

declare Text G_ToadLatestSpecialWeapon;	///< Last type of Toad special weapon
declare CSmObject G_GoldCrystalObject;	///< The Gold item
declare Integer G_CurGoldItemSpawnId;	///< Id of current Gold item life
declare Integer G_NbGiantsAlive;		///< Amount of all alive Giants

declare Ident[Text] G_ObjectId; ///< List of all available objects
declare Ident[Text] G_ActionId; ///< List of all available actions

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(InvasionUI::GetScriptName(), InvasionUI::GetScriptVersion());
Log::RegisterScript(Sound::GetScriptName(), Sound::GetScriptVersion());
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Scores table
// ---------------------------------- //
***ScoresTable***
***
// ---------------------------------- //
// Columns
ST2::CreateCol("Invasion_Evolution", _("Evo"), "", 3., 90.);
ST2::DestroyCol("LibST_SMRoundPoints");
TopScores::RemoveCategory("Hit");

// ---------------------------------- //
// Score points
ST2::SetColWidth("LibST_SMPoints", 6.);
ST2::SetColLegend("LibST_SMPoints", _("Score"));
ST2::SetColScript("LibST_SMPoints", """
declare Score <=> (_Score as CSmScore);
Label_Col.Value = TL::ToText(Score.Points * 10);""");
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("Invasion");
ModeInfo::SetType(ModeInfo::C_Type_FreeForAll);
ModeInfo::SetRules("1. Player has to protect Goal from Toads attack as long as it's possible.\n2. Fact: You don't have time to read these rules.\n3. Toads become stronger over time and later start to appear one by one.\n4. In Solo Campaign player has to score enough points to get a medal.\n5. In multiplayer mode player or team with most points wins.\n6. Players can switch their weapons with mouse roll and 1 - 4 keys.\n7. Blue Crystal increases reload speed for a fet seconds when picked up.\n8. Gold Crystal gives random powerful weapon for a short amount of time.\n9. With Evolution mode on, you can increase your Armors amount with Evolution levels.\n10. To earn Evolution points, just shoot the Toads.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Galaxy settings
// ---------------------------------- //
***GalaxyTitles_Settings***
***
GT_UseNoCollisionsStart = False;
GT_UseComboWeapons = False;
GT_UseRandomToads = False;
GT_AutoManageOnHit = False;
GT_AutoManageOnShoot = False;
GT_AutoManageOnArmorEmpty = False;
GT_AutoManageOnNearMiss = False;
GT_AllowMatchmakingMode = False;
***

// ---------------------------------- //
// Init server
// ---------------------------------- //
***Match_InitServer***
***
UseClans = S_UseTeamsMode;
UseAmmoBonusOnHit = False;

// ---------------------------------- //
// Setup interface
SM::SetupDefaultVisibility();
Sound::Load();

Interfancy::SetModuleVisibility("ScoreSummary", UseClans);
FancyMessages::FormatBigMessage(<0., 53., 0.>, "Eurostile_Bold", -1);
FancyMessages::FormatStatusMessage(<0., 59., 0.>, "Eurostile_Bold", -1);

InvasionUI::LoadAllModules();
InvasionUI::SetDisplayInterface(False);

// Unload minimap
MiniMap::Unload();

// ---------------------------------- //
// Load objects
G_ObjectId["Toad"]	= ItemList_Add("Characters\\ToadSample.Item.Gbx");
//G_ObjectId["Toad"]	= ItemList_Add("Minion");
G_ObjectId["Giant"]	= ItemList_Add("Characters\\StormManBig.Item.Gbx");
G_ObjectId["Gold"]	= ItemList_Add("SMCommon\\Collectibles\\Gold.Item.gbx");

// ---------------------------------- //
// Load actions
G_ActionId["EnergyCharge"]	= ActionList_Add("Invasion\\EnergyCharge.Action.Gbx");
G_ActionId["FrozenArrow"]	= ActionList_Add("Invasion\\FrozenArrow.Action.Gbx");
G_ActionId["PlasmaGrenade"]	= ActionList_Add("Invasion\\PlasmaGrenade.Action.Gbx");
G_ActionId["Torpede"]		= ActionList_Add("Invasion\\Torpede.Action.Gbx");
G_ActionId["WideRail"]		= ActionList_Add("Invasion\\WideRail.Action.Gbx");

// ---------------------------------- //
// Mode variables
declare GameplaySequence = 0;	///< Active gameplay sequence [0 => Safe phase, 1 => Waves, 2 => Invasion]
declare MatchEndReason = 0;		///< Reason of a match end [0 => Skipped, 1 => Pole capture, 2 => No players]
declare CurLeadingClan = 0;		///< Number of the currently leading clan
declare SoloTimeScore = 0;		///< Points awarded for game duration

declare NbToadsSpawned = 0;			///< Total amount of Toads spawned during the game
declare NbToadsReachedPole = 0;		///< Amount of Toads that reached the Goal
declare NbWavesSpawned = 0;			///< Amount of spawned waves
declare NextWaveSpawnTime = 0;		///< Spawn time of the next wave
declare UpdatePoleGauge = True;		///< Force update the gauge value on all Goals
declare GameDifficulty = 0.;		///< Current difficulty level of the game

declare CurToadsArmorPoints = C_ToadArmorPointsMin;	///< Current maximum amount of Toads Armor points
declare NbWavesToNextToadArmor = 0;	///< Amount of waves to next Armor incrementation
declare NextArmorIncrementTime = 0;	///< Time of the next Armor incrementation in Invasion mode
declare GoldNextSpawnTime = 0;		///< Spawn time of the Gold item
declare GoldCrystalUnspawnTime = 0;	///< Lifetime of the Gold object
declare MapCanSpawnGoldCrystal = False;

declare EvolutionPointsPerLevel = [0];	///< Amount of points per every Evolution level
declare UpdateGiantsInfo = True;		///< Force update information about Giants
declare LeadId = NullId;

/// Update variables
declare PrevUseEvolution = False;
declare PrevPoleLimit = -1;
declare PrevLeadingClan = -1;
***

// ---------------------------------- //
// Initialize map
// ---------------------------------- //
***Match_InitMap***
***
UpdateScoresTableFooter(S_ToadsReachedPoleLimit, C_ToadArmorPointsMin);
GalaxyTitles::SetObjectsAffectEveryone(True);
InvasionUI::InitializeMatch();

// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;
for (Order, 1, 2) {
	if (Map::GetLandmarkPlayerSpawn("Spawn", 0) == Null) MapValidated = False;
	if (Map::GetLandmarkBotPath("BotPath", 0) == Null) MapValidated = False;
	if (Map::GetLandmarkGauge("Goal", 0) == Null) MapValidated = False;
}

// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Start map
// ---------------------------------- //
***Match_StartMap***
***
UseLaserSkewering = False;

GameplaySequence = 0;
MatchEndReason = 0;
CurLeadingClan = 0;
SoloTimeScore = 0;

NbToadsSpawned = 0;
NbToadsReachedPole = 0;
NbWavesSpawned = 0;
NextWaveSpawnTime = 0;
UpdatePoleGauge = True;
GameDifficulty = 0.;

CurToadsArmorPoints = C_ToadArmorPointsMin;
NbWavesToNextToadArmor = 0;
NextArmorIncrementTime = 0;
GoldNextSpawnTime = 0;
GoldCrystalUnspawnTime = 0;

EvolutionPointsPerLevel = [0];
UpdateGiantsInfo = True;

// ---------------------------------- //
// Set weapons icons
Interfancy::SetGaugesIconsImages([
	"Handheld Charge" => C_ImgBase^"Icons/HandheldCharge.png",
	"Frozen Arrow" => C_ImgBase^"Icons/FrozenArrow.png",
	"Plasma Grenade" => C_ImgBase^"Icons/PlasmaGrenade.png",
	"Torpede" => C_ImgBase^"Icons/Torpede.png",
	"Wide Rail" => C_ImgBase^"Icons/Laser.png"
]);

// ---------------------------------- //
// Clear Evolution
foreach (Score in Scores) {
	declare Integer PlayerEvolutionPoints for Score;
	declare Integer PrevEvolutionPoints for Score;
	PlayerEvolutionPoints = 0;
	PrevEvolutionPoints = -1;
}

// ---------------------------------- //
// Init landmarks
foreach (MapLandmark in MapLandmarks) {
	// Bases
	if (MapLandmark.Base != Null) {
		MapLandmark.Base.IsActive = True;
		MapLandmark.Base.Clan = 1;
	}
	
	// Poles
	if (MapLandmark.Tag == "Goal") MapLandmark.Gauge.Clan = 2;
	
	// Gates
	if (MapLandmark.Gate != Null) MapLandmark.Gauge.Clan = 1;
}

// Init teams emblems
foreach (Team in Teams) Team.EmblemUrl = S_NeutralEmblemUrl;

// ---------------------------------- //
// Wait for enough players to start game
GT_WaitForPlayers();

// ---------------------------------- //
// Check if there are Gold crystals on the map
foreach (MapLandmark in MapLandmarks_ObjectAnchor) if (MapLandmark.Tag == "Gold") {
	MapCanSpawnGoldCrystal = True;
	break;
}

// ---------------------------------- //
// Initialize objects
ObjectDestroyAll();
foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	declare ObjectSpawned for MapLandmark = False;
	declare ObjectNextSpawn for MapLandmark = Now;
	ObjectSpawned = False;
	ObjectNextSpawn = Now + C_SafePhaseDuration + C_MatchBeginDelay;
}

G_GoldCrystalObject = Null;
G_CurGoldItemSpawnId = 0;

// ---------------------------------- //
// Init interface
InvasionUI::SetDisplayInterface(True);
InvasionUI::SetUseEvolution(S_UseEvolutionLevels);
InvasionUI::SetPoleLimit(S_ToadsReachedPoleLimit);
InvasionUI::SetToadsArmor(CurToadsArmorPoints);
InvasionUI::SetTotalNbToadSpawned(NbToadsSpawned);

// ---------------------------------- //
// Initialize scores
MB_Yield(); ///< Allow the scores array to be sorted
foreach (Score in Scores) {
	declare Integer LastPoint for Score;
	LastPoint = 0;
}
if (Scores.existskey(0)) LeadId = Scores[0].User.Id;

CurLeadingClan = 0;
PrevLeadingClan = 0;

// ---------------------------------- //
// Reset players stats
foreach (Player in Players) {
	declare Boolean PlayerHasCustomWeapon for Player;
	declare Integer PlayerLastGoldSpawnId for Player;
	PlayerHasCustomWeapon = False;
	PlayerLastGoldSpawnId = 0;
	ActionBind(Player, ::EActionSlot::Slot_A, ::EActionInput::None);
}

// ---------------------------------- //
// Start game
StartTime = Now + C_MatchBeginDelay;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.SendNotice(
	"", CUIConfig::ENoticeLevel::PlayerInfo, Null,
	CUIConfig::EAvatarVariant::Default, 
	CUIConfig::EUISound::StartRound, 0
);

// Set the time functions
UIManager.UIAll.CountdownEndTime = StartTime + C_SafePhaseDuration;
GoldNextSpawnTime = UIManager.UIAll.CountdownEndTime + C_GoldSpawningInterval / 2;

Interfancy::Loop();
Interfancy::Private_SetModuleSetting("StartTime", TL::ToText(UIManager.UIAll.CountdownEndTime));
InvasionUI::SetStartTime(UIManager.UIAll.CountdownEndTime);
InvasionUI::SetNbWavesToInvasion(-1);

// Initialize safe phase
UsePvPCollisions = False;
UsePvPWeapons = False;
***

// ---------------------------------- //
// Player picked up object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);

declare Boolean PlayerHasCustomWeapon for Event.Player;
declare Integer PlayerLastGoldSpawnId for Event.Player;

if (PlayerHasCustomWeapon || PlayerLastGoldSpawnId == G_CurGoldItemSpawnId) continue;
PickUpObject(Event.Player, Event.Object);
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// ---------------------------------- //
// Events management
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Player Armor is empty
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (!Event.Victim.IsBot) {
			if (Event.Shooter == Null || Event.Shooter == Event.Victim) RemoveScorePoints(Event.Victim, 1);
			Killfeed::OnArmorEmpty(Event, Null);
		}
		// ---------------------------------- //
		// Drop Fuel from Gimp Toads
		else {
			declare Text ToadType for Event.Victim;
			if (ToadType == "Gimp" && ML::Rand(0., 1.) <= C_ToadGimpFuelDropChance) {
				declare Object = GalaxyTitles::SpawnObject(Event.Victim.Position, "Fuel");
			}
			
			// Track elimination statistics
			if (Event.Shooter == Null) Statistics::TrackEvent(Event.Shooter, "InvasionEliminatedToads"^ToadType, 1);

			// Update Giants information
			if (ToadType == "Giant") UpdateGiantsInfo = True;
		}
		
		PassOn(Event);
	}
	// ---------------------------------- //
	// Standard weapon hit
	else if (Event.Type == CSmModeEvent::EType::OnHit) {
		if (Event.Shooter == Null || Event.Victim == Null || Event.Shooter.IsBot == Event.Victim.IsBot) { Discard(Event); continue; }

		// Get the hit damage
		Event.Damage = 100;
		if (!Event.Shooter.IsBot) Event.Damage = GetCriticalDamage();
		declare Points = Event.Damage / 100;
		
		// ---------------------------------- //
		// Apply shield preventing from taking rapid damage
		if (!Event.Victim.IsBot) {
			declare Integer PlayerLastHitTime for Event.Victim;
			if (Now < PlayerLastHitTime + C_PlayerHurtShieldTime) { Discard(Event); continue; }
			PlayerLastHitTime = Now;
		}
		// ---------------------------------- //
		// Player has hit a Toad
		else {
			SendCritNotification(Event.Shooter, Event.Damage);
			AddScorePoints(Event.Shooter, Points);
			AddEvolutionPoints(Event.Shooter, Points);

			// ---------------------------------- //
			// Give points in teams mode
			if (UseClans) {
				ClanScores[Event.Shooter.CurrentClan] += Points;

				// Update the leading clan
				if (ClanScores[1] > ClanScores[2]) CurLeadingClan = 1;
				else if (ClanScores[2] > ClanScores[1]) CurLeadingClan = 2;
				else CurLeadingClan = 0;
			}
		
			// ---------------------------------- //
			// Track damage statistics
			declare Text ToadType for Event.Victim;
			Statistics::TrackEvent(Event.Shooter, "InvasionDamageToads"^ToadType, Points);

			// ---------------------------------- //
			// Custom reload bonus processing
			if (Event.Shooter.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
				declare HitAmmoBonus = 1/3.;
				
				// ---------------------------------- //
				// Arrow and Nucleus overheating
				if (S_UseWeaponsOverheating && (Event.WeaponNum == 3 || Event.WeaponNum == 5)) {
					declare Integer PlayerPrevHitTime for Event.Shooter;
					declare Integer[Integer] WeaponFullBonusTime for Event.Shooter;
					if (!WeaponFullBonusTime.existskey(Event.WeaponNum)) WeaponFullBonusTime[Event.WeaponNum] = -1;
					
					if (PlayerPrevHitTime != Now) {
						// Start decreasing bonus from beginning
						if (WeaponFullBonusTime[Event.WeaponNum] <= Now)
							WeaponFullBonusTime[Event.WeaponNum] = Now + C_WeaponHeatTimePerCombo;
						
						// Add bonus delay 
						else WeaponFullBonusTime[Event.WeaponNum] += C_WeaponHeatTimePerCombo;
						
						// Reduce reload bonus penalty to maximum delay
						if (WeaponFullBonusTime[Event.WeaponNum] > Now + C_WeaponHeatTimeMax)
							WeaponFullBonusTime[Event.WeaponNum] = Now + C_WeaponHeatTimeMax;
						
						InvasionUI::SetPlayerOverheating(Event.Shooter, Event.WeaponNum, WeaponFullBonusTime[Event.WeaponNum]);
						PlayerPrevHitTime = Now;
					}
					
					// Reduce the reload bonus
					if (WeaponFullBonusTime[Event.WeaponNum] > Now)
						HitAmmoBonus *= 1 - ((WeaponFullBonusTime[Event.WeaponNum] - Now) / ML::ToReal(C_WeaponHeatTimeMax));
				}
				
				// Give ammo for the shooter
				AddPlayerAmmo(Event.Shooter, C_GetWeaponFromNum[Event.WeaponNum], HitAmmoBonus);
			}
		}

		Event.ShooterPoints = Points;
		PassOn(Event);
	}
	// ---------------------------------- //
	// Custom weapon hit
	else if (Event.Type == CSmModeEvent::EType::OnActionCustomEvent && Event.Param1 == "damage") {
		if (Event.Shooter == Null || Event.Victim == Null || Event.Shooter.IsBot == Event.Victim.IsBot) { Discard(Event); continue; }
		
		// Get the hit damage
		declare EventDamage = 100;
		if (!Event.Shooter.IsBot) EventDamage = GetCriticalDamage();
		declare Points = EventDamage / 100;

		// ---------------------------------- //
		// Manage player functions
		if (!Event.Shooter.IsBot) {
			SendCritNotification(Event.Shooter, EventDamage);
			AddScorePoints(Event.Shooter, Points);
			AddEvolutionPoints(Event.Shooter, Points);

			// ---------------------------------- //
			// Give points in teams mode
			if (UseClans) {
				ClanScores[Event.Shooter.CurrentClan] += Points;

				// Update the leading clan
				if (ClanScores[1] > ClanScores[2]) CurLeadingClan = 1;
				else if (ClanScores[2] > ClanScores[1]) CurLeadingClan = 2;
				else CurLeadingClan = 0;
			}
			
			// ---------------------------------- //
			// Track damage statistics
			declare Text ToadType for Event.Victim;
			Statistics::TrackEvent(Event.Shooter, "InvasionDamageToads"^ToadType, Points);
		}

		RemovePlayerArmor(Event.Victim, EventDamage, Event.Shooter, Points);
		PassOn(Event);
	}
	// ---------------------------------- //
	// Action buttons press
	else if (Event.Type == CSmModeEvent::EType::OnActionEvent) {
		SwitchWeapon(Event.Player, Event.ActionInput);

		// ---------------------------------- //
		// Drop Gold item weapon
		declare Boolean PlayerHasCustomWeapon for Event.Player;
		if (Event.ActionInput == CSmModeEvent::EActionInput::Consumable2 && PlayerHasCustomWeapon) {
			declare Integer PlayerWeaponExpiration for Event.Player;
			PlayerWeaponExpiration = Now;
			InvasionUI::SetPlayerWeaponData(Event.Player, 0, 0, 0);
		}
		
		PassOn(Event);
	}
	// ---------------------------------- //
	// Mouse wheel
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestActionChange) {
		CycleWeapon(Event.Player, Event.ActionChange);
		PassOn(Event);
	}
}

switch (GameplaySequence) {
	// ---------------------------------- //
	// Safe phase
	case 0 : {
		// ---------------------------------- //
		// Stop safe phase
		if (Now >= UIManager.UIAll.CountdownEndTime) {
			UIManager.UIAll.CountdownEndTime = -1;
			GameplaySequence = 1;
			NextWaveSpawnTime = Now;
			NbWavesToNextToadArmor = C_ToadArmorWavesPerPoint + 1;
			
			InvasionUI::SetTimeScoreCounting(G_IsSoloMode);
			
			// Enable collisions
			UsePvPCollisions = True;
			UsePvPWeapons = True;
		}
	}
	// ---------------------------------- //
	// Spawning waves
	case 1 : {
		// ---------------------------------- //
		// Progressive Toads amount
		declare NbToadsToSpawn = S_NbToadsPerWave;
		if (S_ProgressiveToadsAmount) NbToadsToSpawn += Players.count / C_PlayersPerExtraToad;
		
		// ---------------------------------- //
		// Check if new wave can be deployed
		declare CanDeployWave = (BotPlayers.count <= S_MaxNbToadsAtOnce - NbToadsToSpawn * MapLandmarks_BotPath.count);
		
		if (Now >= NextWaveSpawnTime && CanDeployWave) {
			NextWaveSpawnTime = Now + S_TimeBetweenWaves * 1000;
			NbWavesSpawned += 1;
			NbWavesToNextToadArmor -= 1;

			if (S_NbWavesBeforeInvasion > 0) GameDifficulty = ML::ToReal(NbWavesSpawned) / S_NbWavesBeforeInvasion;
			
			// ---------------------------------- //
			// Increase Toads Armor max points
			if (NbWavesToNextToadArmor <= 0 && CurToadsArmorPoints < C_ToadArmorPointsMax) {
				NbWavesToNextToadArmor = C_ToadArmorWavesPerPoint;
				CurToadsArmorPoints += 100;
				UpdateScoresTableFooter(S_ToadsReachedPoleLimit, CurToadsArmorPoints);
				InvasionUI::SetToadsArmor(CurToadsArmorPoints);
			}
			
			// ---------------------------------- //
			// Spawn next wave
			if (NbWavesSpawned <= S_NbWavesBeforeInvasion) {
				// ---------------------------------- //
				// Spawn Toads
				declare SpawnDelay = ML::NearestInteger(C_ToadSpawnIntervalMax - (C_ToadSpawnIntervalMax - C_ToadSpawnIntervalMin) * GameDifficulty);
				foreach (MapLandmark in MapLandmarks_BotPath) {
					for (I, 0, NbToadsToSpawn - 1) {
						NbToadsSpawned += 1;
						SpawnToad(MapLandmark.BotPath, NbToadsSpawned, CurToadsArmorPoints, GameDifficulty, SpawnDelay * I);
					}
				}
				
				// ---------------------------------- //
				// Send message
				declare MessageBody = "Incoming wave!";
				declare MessageSound = CUIConfig::EUISound::PhaseChange;
				
				if (NbWavesSpawned == S_NbWavesBeforeInvasion) {
					MessageBody = "Incoming last wave!";
					MessageSound = CUIConfig::EUISound::Warning;
				}
				
				Translations::SendBigMessage(MessageBody, 3000, 10, MessageSound, 0);
				InvasionUI::SetNbWavesToInvasion(S_NbWavesBeforeInvasion - NbWavesSpawned + 1);
				InvasionUI::SetTotalNbToadSpawned(NbToadsSpawned);
			}
			// ---------------------------------- //
			// Start Invasion mode
			else {
				GameplaySequence = 2;
				GameDifficulty = 1.;
				NextWaveSpawnTime = Now;
				NextArmorIncrementTime = Now + C_ToadArmorInvasionInterval;
				
				// Send message
				Translations::SendBigMessage("$tInvasion", 3000, 10, CUIConfig::EUISound::StartMatch, 1);
				InvasionUI::SetNbWavesToInvasion(0);
			}
		}
	}
	// ---------------------------------- //
	// Invasion mode
	case 2 : {
		// ---------------------------------- //
		// Check if Toads can be deployed
		declare CanDeployToads = BotPlayers.count <= S_MaxNbToadsAtOnce - MapLandmarks_BotPath.count;
		
		// Enable Laser pass through
		if (!UseLaserSkewering) UseLaserSkewering = True;
		
		// ---------------------------------- //
		// Increase Toads Armor max points
		if (Now >= NextArmorIncrementTime && CurToadsArmorPoints < C_ToadArmorPointsMax) {
			NextArmorIncrementTime = Now + C_ToadArmorInvasionInterval;
			CurToadsArmorPoints += 100;
			
			UpdateScoresTableFooter(S_ToadsReachedPoleLimit, CurToadsArmorPoints);
			InvasionUI::SetToadsArmor(CurToadsArmorPoints);
		}
		
		// ---------------------------------- //
		// Spawn Toads
		if (Now >= NextWaveSpawnTime && CanDeployToads) {
			NextWaveSpawnTime = Now + C_ToadSpawnIntervalMin;
			
			foreach (MapLandmark in MapLandmarks_BotPath) {
				NbToadsSpawned += 1;
				SpawnToad(MapLandmark.BotPath, NbToadsSpawned, CurToadsArmorPoints, GameDifficulty, 0);
			}
			
			InvasionUI::SetTotalNbToadSpawned(NbToadsSpawned);
		}
	}
}

// ---------------------------------- //
// Toads management
foreach (Bot in BotPlayers) {
	declare Text ToadType for Bot;
	
	// ---------------------------------- //
	// Score pole
	if (Bot.CapturedLandmark != Null && Bot.CapturedLandmark.Tag == "Goal") {
		declare Points = 1;
		if (ToadType == "Gimp") Points *= 2;
		if (ToadType == "Giant") Points = C_GiantPointsScoredAtGoal;
		NbToadsReachedPole += Points;
		
		// ---------------------------------- //
		// Last Toad scores goal
		if (NbToadsReachedPole > S_ToadsReachedPoleLimit && S_ToadsReachedPoleLimit > 0) {
			NbToadsReachedPole = S_ToadsReachedPoleLimit;
			
			UIManager.UIAll.SendNotice(
				"", CUIConfig::ENoticeLevel::PlayerInfo, 
				Null, CUIConfig::EAvatarVariant::Default, 
				CUIConfig::EUISound::VictoryPoint, 0
			);
		}

		// Update Giants information
		if (ToadType == "Giant") UpdateGiantsInfo = True;
		
		UpdatePoleGauge = True;
		UnspawnPlayer(Bot);
	}
	
	// ---------------------------------- //
	// Blink Gimp Toads
	if (ToadType == "Gimp") {
		declare EnergyAnim = 0.;
		if ((Now - Bot.StartTime) % C_ToadGimpBlinkFrequency >= C_ToadGimpBlinkFrequency / 2) EnergyAnim = 1.;
		Bot.EnergyLevel = EnergyAnim;
	}
	
	// ---------------------------------- //
	// Find target for Zombie Toads
	if (ToadType == "Zombie") {
		Bot.IsHighlighted = (Now - Bot.StartTime) % C_ToadZombieBlinkFrequency <= C_ToadZombieBlinkDuration;
		
		if (Bot.Driver.ForcedTarget == Null) {
			Bot.ForceColor = C_ToadTypesColors["Default"];
			
			// ---------------------------------- //
			// Select nearest player
			if (Bot.Driver.AggroRadius > 0) {
				declare SmallestDistance = 0.;
				declare Ident NearestPlayerId;
				
				foreach (Player in Players) {
					if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
					declare Distance = ML::Distance(Bot.Position, Player.Position);
					
					if (Distance <= Bot.Driver.AggroRadius && (SmallestDistance <= 0 || Distance > SmallestDistance))
						NearestPlayerId = Player.Id;
				}
				
				if (NearestPlayerId != NullId) Bot.Driver.ForcedTarget = Players[NearestPlayerId];
			}
		}
		// ---------------------------------- //
		// Remove Zombie eliminated target
		else {
			Bot.ForceColor = C_ToadTypesColors["Zombie"];
			
			if (
				Bot.Driver.ForcedTarget.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned ||
				ML::Distance(Bot.Position, Bot.Driver.ForcedTarget.Position) > Bot.Driver.AggroRadius
			)
				Bot.Driver.ForcedTarget = Null;
		}
	}
	
	// ---------------------------------- //
	// Unspawn normal Toads in some conditions
	if (Bot.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && ToadType != "Giant") {
		// ---------------------------------- //
		// Unspawn stuck Toads
		declare Vec3 ToadIdleUpdatePosition for Bot;
		declare Integer ToadIdleStartTime for Bot;
		
		if (ML::Distance(Bot.Position, ToadIdleUpdatePosition) > C_ToadStuckUpdateDistance) {
			ToadIdleUpdatePosition = Bot.Position;
			ToadIdleStartTime = Now;
		}
		
		if (Now >= ToadIdleStartTime + C_ToadStuckMaxDuration) UnspawnPlayer(Bot);
		
		// Unspawn Toads in water and under arena
		if (Bot.Stamina <= 0 || Bot.Position.Y < -50.) UnspawnPlayer(Bot);
	}
	
	// ---------------------------------- //
	// Update Giant color on its Armor points change
	if (ToadType == "Giant") {
		declare Integer PrevArmorPoints for Bot;
		if (PrevArmorPoints != Bot.Armor && Bot.ArmorMax > 0) {
			PrevArmorPoints = Bot.Armor;
			Bot.ForceColor = ColorTransition(ML::ToReal(Bot.Armor) / Bot.ArmorMax, C_GiantColorTransition);
			UpdateGiantsInfo = True;
		}
	}
	
	// Destroy unspawned bots
	if (Bot.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) DestroyBotPlayer(Bot);
}

// ---------------------------------- //
// Players management
foreach (Player in Players) {
	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate) {
		GT_InitPlayer(Player);
		GalaxyTitles::InitPlayer(Player);
		SetPlayerReloadAllWeapons(Player, True);

		// Set Rocket without auto-switch for the first time
		if (Player.AutoSwitchWeapon) SetPlayerWeapon(Player, CSmMode::EWeapon::Rocket, False);

		// Set max Armor
		if (!S_UseEvolutionLevels) Player.ArmorMax = C_PlayerBaseArmorMax;
		
		// Faster ammo reload
		Player.AmmoGain = C_PlayerBaseAmmoGain;
	
		// ---------------------------------- //
		// Configure fake players
		if (Player.Driver != Null) {
			Player.Driver.AttackFilter = CSmPlayerDriver::ESmAttackFilter::AllBots;
			Player.Driver.AggroRadius = S_ToadAggroRadiusMax;
			
			// First weapon switch
			declare Integer NextWeaponUpdateTime for Player;
			NextWeaponUpdateTime = Now;
		}

		// spawn the player
		InvasionSpawnPlayer(Player);
	}
	
	// ---------------------------------- //
	// Reset custom weapon buff
	declare Boolean PlayerHasCustomWeapon for Player;
	declare Integer PlayerWeaponExpiration for Player;
	
	if (PlayerHasCustomWeapon && Now >= PlayerWeaponExpiration) {
		PlayerHasCustomWeapon = False;
		ActionBind(Player, ::EActionSlot::Slot_A, ::EActionInput::None);
		
		Interfancy::SetPlayerCustomWeapon(Player, "");
		Sound::PlaySound(C_ImgBase^"Sounds/GoldWeaponExpired.ogg", Player);
	}
	
	// ---------------------------------- //
	// Fake players
	if (Player.Driver != Null) {
		// ---------------------------------- //
		// Switch fake player weapon
		declare Integer NextWeaponUpdateTime for Player;
		if (Now > NextWeaponUpdateTime) {
			NextWeaponUpdateTime = Now + C_FakeUserWpChangeTime + ML::Rand(0, C_FakeUserWpChangeDelta);
			SetPlayerWeapon(Player, C_FakeUserWeapons[ML::Rand(0, C_FakeUserWeapons.count - 1)], False);
		}
		
		// ---------------------------------- //
		// Unspawn fake players in water and under the arena
		if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned && (Player.Stamina <= 0 || Player.Position.Y < -50.)) UnspawnPlayer(Player);
	}
}

// ---------------------------------- //
// Update evolution status
if (PrevUseEvolution != S_UseEvolutionLevels) {
	PrevUseEvolution = S_UseEvolutionLevels;
	InvasionUI::SetUseEvolution(S_UseEvolutionLevels);
	
	// ---------------------------------- //
	// Set default Armor max
	if (!S_UseEvolutionLevels) {
		foreach (Player in Players) {
			declare ArmorsToHeal = C_PlayerBaseArmorMax - Player.ArmorMax;
			Player.ArmorMax = C_PlayerBaseArmorMax;
			if (ArmorsToHeal > 0) GalaxyTitles::GivePlayerArmor(Player, ArmorsToHeal);
			
			// Reset columns
			ST2::SetColValue("Invasion_Evolution", Player.Score, "");
		}
	}
}

// ---------------------------------- //
// Invasion Evolution
if (S_UseEvolutionLevels) foreach (Player in Players) {
	declare Integer PlayerEvolutionPoints for Player.Score;
	declare Integer PlayerEvolutionLevel for Player;
	declare PrevEvolutionPoints for Player.Score = -1;
	
	// Wait until player gets more evolution points
	if (PrevEvolutionPoints == PlayerEvolutionPoints) continue;
	PrevEvolutionPoints = PlayerEvolutionPoints;

	// ---------------------------------- //
	// Compute next level requirements
	if (PlayerEvolutionPoints >= EvolutionPointsPerLevel[EvolutionPointsPerLevel.count - 1]) {
		declare Integer NextLevelPoints;
		NextLevelPoints = EvolutionPointsPerLevel[EvolutionPointsPerLevel.count - 1] + ML::FloorInteger(ML::Pow(2., EvolutionPointsPerLevel.count + 1.));
		
		if (!EvolutionPointsPerLevel.exists(NextLevelPoints)) EvolutionPointsPerLevel.add(NextLevelPoints);
	}
	
	// Determine current player level
	for (I, 1, EvolutionPointsPerLevel.count) if (PlayerEvolutionPoints >= EvolutionPointsPerLevel[I-1]) PlayerEvolutionLevel = I;
	
	// ---------------------------------- //
	// Increase player Armor on level growth
	declare Integer PrevEvolutionLevel for Player;
	Player.ArmorMax = PlayerEvolutionLevel * 100;
	
	if (PlayerEvolutionLevel != PrevEvolutionLevel) {
		GalaxyTitles::GivePlayerArmor(Player, (PlayerEvolutionLevel - PrevEvolutionLevel) * 100);
		PrevEvolutionLevel = PlayerEvolutionLevel;
		
		// Update scores table
		if (PlayerEvolutionLevel >= 2) ST2::SetColValue("Invasion_Evolution", Player.Score, TL::ToText(PlayerEvolutionLevel));
	}
	
	// ---------------------------------- //
	// Create progress variables
	declare Integer LevelPointsCurrent for Player;
	declare Integer LevelPointsToNext for Player;
	
	if (PlayerEvolutionLevel < EvolutionPointsPerLevel.count) {
		LevelPointsCurrent = PlayerEvolutionPoints - EvolutionPointsPerLevel[PlayerEvolutionLevel-1];
		LevelPointsToNext = ML::FloorInteger(ML::Pow(2., (PlayerEvolutionLevel + 1) * 1.));
	}
	
	// ---------------------------------- //
	// Send progress information to the interface
	InvasionUI::SetPlayerEvolutionData(Player, PlayerEvolutionLevel, LevelPointsCurrent, LevelPointsToNext);
}

// ---------------------------------- //
// Update pole limit
if (PrevPoleLimit != S_ToadsReachedPoleLimit) {
	PrevPoleLimit = S_ToadsReachedPoleLimit;
	
	UpdateScoresTableFooter(S_ToadsReachedPoleLimit, CurToadsArmorPoints);
	InvasionUI::SetPoleLimit(S_ToadsReachedPoleLimit);
	UpdatePoleGauge = True;
}

// ---------------------------------- //
// Update poles gauge bars
if (UpdatePoleGauge) {
	UpdatePoleGauge = False;
	InvasionUI::SetNbToadsReachedPole(NbToadsReachedPole);
	
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag != "Goal") continue;
		
		MapLandmark.Gauge.Value = NbToadsReachedPole;
		MapLandmark.Gauge.Max = S_ToadsReachedPoleLimit;
		MapLandmark.Gauge.Captured = NbToadsReachedPole >= S_ToadsReachedPoleLimit && S_ToadsReachedPoleLimit > 0;
	}
}

// ---------------------------------- //
// Spawn Gold item
if (MapCanSpawnGoldCrystal && Now >= GoldNextSpawnTime) {
	GoldNextSpawnTime = Now + C_GoldSpawningInterval;
	GoldCrystalUnspawnTime = Now + C_GoldLifeDuration;
	G_CurGoldItemSpawnId += 1;
	
	// ---------------------------------- //
	// Compute weighted center of the players group
	declare Vec3 PlayersPositionCenter;
	declare Vec3 PlayerPositionMin;
	declare Vec3 PlayerPositionMax;

	foreach (Player in Players) {
		if (Player.Position == <0., 0., 0.>) continue;
		for (I, 0, 2) {
			if (PlayerPositionMin[I] == 0 || Player.Position[I] < PlayerPositionMin[I]) PlayerPositionMin[I] = Player.Position[I];
			if (PlayerPositionMax[I] == 0 || Player.Position[I] > PlayerPositionMax[I]) PlayerPositionMax[I] = Player.Position[I];
		}
	}

	if (PlayerPositionMin == PlayerPositionMax) PlayersPositionCenter = PlayerPositionMin;
	else {
		PlayersPositionCenter = PlayerPositionMin + PlayerPositionMax;
		for (I, 0, 2) PlayersPositionCenter[I] /= 2;
	}
	
	// ---------------------------------- //
	// Select landmark near the center of players group
	declare Real[Ident] LandmarkDistances;

	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		if (MapLandmark.Tag != "Gold") continue;
		LandmarkDistances[MapLandmark.Id] = ML::Distance(MapLandmark.Position, PlayersPositionCenter);
	}
	
	// ---------------------------------- //
	// Create item
	LandmarkDistances = LandmarkDistances.sort();

	foreach (MapLandmarkId => Distance in LandmarkDistances) {
		if (!MapLandmarks_ObjectAnchor.existskey(MapLandmarkId)) continue;
		declare MapLandmark <=> MapLandmarks_ObjectAnchor[MapLandmarkId];

		InvasionUI::UpdateGoldMarker(MapLandmark.Position, Now, C_GoldLifeDuration, G_CurGoldItemSpawnId);
		G_GoldCrystalObject = ObjectCreate(G_ObjectId["Gold"]);
		G_GoldCrystalObject.SetPosition(MapLandmark.Position);
		declare Tag for G_GoldCrystalObject = "Gold";

		// Break the loop
		break;
	}
}

// ---------------------------------- //
// Destroy Gold object
if (G_GoldCrystalObject != Null && Now >= GoldCrystalUnspawnTime) {
	G_GoldCrystalObject.SetUnspawned();
	ObjectDestroy(G_GoldCrystalObject);
	G_GoldCrystalObject = Null;
}

// ---------------------------------- //
// Update Giants amount and their health
if (UpdateGiantsInfo) {
	UpdateGiantsInfo = False;
	G_NbGiantsAlive = 0;
	declare Integer[][] BossesHealth;

	foreach (Bot in BotPlayers) {
		declare Text ToadType for Bot;
		if (ToadType != "Giant" || Bot.Armor <= 0) continue;
		BossesHealth.add([Bot.Armor, Bot.ArmorMax]);
	}
	
	InvasionUI::SetBossesHealth(BossesHealth);
	G_NbGiantsAlive = BossesHealth.count;
}

// ---------------------------------- //
// Multiplayer exclusive features
if (!G_IsSoloMode) {
	// ---------------------------------- //
	// Play sound and notice if someone is taking the lead
	if (!UseClans) {
		if (Scores.existskey(0) && Scores[0].User.Id != LeadId) {
			LeadId = Scores[0].User.Id;
			Message::SendBigMessage(
				TL::Compose(_("$<%1$> takes the lead!"), Scores[0].User.Name), 
				3000, 1, CUIConfig::EUISound::PhaseChange, 1
			);
		}
	}
	// ---------------------------------- //
	// Sound and notice if team is taking the lead
	else if (PrevLeadingClan != CurLeadingClan) {
		PrevLeadingClan = CurLeadingClan;
		
		if (CurLeadingClan > 0) Message::SendBigMessage(
			TL::Compose(_("$<%1$> takes the lead!"), Teams[CurLeadingClan - 1].ColorizedName),
			3000, 1, CUIConfig::EUISound::PhaseChange, 1
		);
	}
}

// ---------------------------------- //
// End conditions
if (S_ToadsReachedPoleLimit > 0 && NbToadsReachedPole >= S_ToadsReachedPoleLimit) {
	MatchEndReason = 1;
	MB_StopMatch();
}
else if (Players.count <= 0) {
	MatchEndReason = 2;
	MB_StopMatch();
}
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_EndRound***
***
UIManager.UIAll.CountdownEndTime = -1;
SoloTimeScore = (Now - StartTime - C_SafePhaseDuration) / 1000;
InvasionUI::SetTimeScoreCounting(False);

// ---------------------------------- //
// Destroy everything
ObjectDestroyAll();
DestroyAllBotPlayers();
SM::UnspawnAllPlayers();

MB_Sleep(2000);

// ---------------------------------- //
// Compute final time score
InvasionUI::SetDisplayInterface(False);
Message::CleanAllMessages();
StartTime = -1;

// ---------------------------------- //
// Do a proper end sequence
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
declare EndMessage = "";

switch (MatchEndReason) {
	// ---------------------------------- //
	// Toads captured the pole
	case 1 : EndMessage = "Game over!";
	
	// ---------------------------------- //
	// All players left the game
	case 2 : EndMessage = _("All players left the server.");
	
	// ---------------------------------- //
	// Map has been skipped
	default : EndMessage = _("Map skipped, going to the next.");
}

if (EndMessage != "") Message::SendBigMessage(EndMessage, 3000, 10, CUIConfig::EUISound::EndRound, 0);
MB_Sleep(5000);
***

// ---------------------------------- //
// End server
// ---------------------------------- //
***Match_EndServer***
***
InvasionUI::UnloadAllModules();
Sound::Unload();
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Add score points
 *
 *	@param	_Player		The player to give points
 *	@param	_Points		Amount of points to give to a player
 */
Void AddScorePoints(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null || _Points == 0) return;
	_Player.Score.Points += _Points;
	_Player.Score.Points = ML::Clamp(_Player.Score.Points, 0, 32767);
}

// ---------------------------------- //
/** Remove score points
 *
 *	@param	_Player		The player to remove points
 *	@param	_Points		Amount of points to remove from a player
 */
Void RemoveScorePoints(CSmPlayer _Player, Integer _Points) { AddScorePoints(_Player, -_Points); }

// ---------------------------------- //
/** Update scores table footer
 *
 *	@param	_PoleLimit		Pole limit
 *	@param	_ToadArmor		Toads Armor
 */
Void UpdateScoresTableFooter(Integer _PoleLimit, Integer _ToadArmor) {
	declare PoleLimitText = TL::ToText(_PoleLimit);
	declare ToadsArmorText = TL::ToText(_ToadArmor / 100);
	if (_PoleLimit <= 0) PoleLimitText = "-";
	
	ST2::SetFooterText(TL::Compose(_("Pole limit: %1	$<$FD0///$>	Toads Armor: %2"), PoleLimitText, ToadsArmorText));
}

// ---------------------------------- //
/** Spawn a player
 *
 *	@param	_Player		The player to spawn
 */
Void InvasionSpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null || MapLandmarks_PlayerSpawn.count == 0) return;
	declare SpawnId = NullId;
	
	// If there is only one spawn on map, choose it
	if (MapLandmarks_PlayerSpawn.count == 1) SpawnId = MapLandmarks_PlayerSpawn[0].Id;
	
	else {
		declare AverageSpawnDistance = Real[Ident];
		declare SpawnDistancesList = Real[];
		
		// ---------------------------------- //
		// No Toads on map - spawn near path start point
		if (BotPlayers.count == 0) {
			foreach (MapLandmark in MapLandmarks_PlayerSpawn) {
				AverageSpawnDistance[MapLandmark.Id] = 0.;
				
				foreach (MapLandmark_BotPath in MapLandmarks_BotPath)
					AverageSpawnDistance[MapLandmark.Id] += ML::Distance(MapLandmark.Position, MapLandmark_BotPath.Position);
				
				AverageSpawnDistance[MapLandmark.Id] /= MapLandmarks_BotPath.count;
				SpawnDistancesList.add(AverageSpawnDistance[MapLandmark.Id]);
			}
		}
		// ---------------------------------- //
		// Toads are present on the map
		else {
			// ---------------------------------- //
			// Check if there are poles under Toads attack
			declare PolesUnderAttack = Integer[CSmMapLandmark];
			declare NbToadsAttacking = Integer[];
			
			foreach (MapLandmark in MapLandmarks_Gauge) {
				if (MapLandmark.Tag == "Goal") {
					foreach (Toad in BotPlayers) {
						if (ML::Distance(MapLandmark.Position, Toad.Position) <= C_PoleUnderAttackDist) {
							if (!PolesUnderAttack.existskey(MapLandmark)) PolesUnderAttack[MapLandmark] = 0;
							PolesUnderAttack[MapLandmark] -= 1; ///< Lowest negative number will be first after sorting
						}
					}
					if (PolesUnderAttack.existskey(MapLandmark)) NbToadsAttacking.add(PolesUnderAttack[MapLandmark]);
				}
			}
			
			// ---------------------------------- //
			// Spawn near poles under attack
			if (PolesUnderAttack.count > 0) {
				PolesUnderAttack = PolesUnderAttack.sort();
				NbToadsAttacking = NbToadsAttacking.sort();
				
				declare BlockPole <=> PolesUnderAttack.keyof(NbToadsAttacking[0]);
				
				foreach (MapLandmark in MapLandmarks_PlayerSpawn) {
					AverageSpawnDistance[MapLandmark.Id] = ML::Distance(MapLandmark.Position, BlockPole.Position);
					SpawnDistancesList.add(AverageSpawnDistance[MapLandmark.Id]);
				}
			}
			// ---------------------------------- //
			// Spawn the player near most of the Toads
			else foreach (MapLandmark in MapLandmarks_PlayerSpawn) {
				AverageSpawnDistance[MapLandmark.Id] = 0.;
				
				foreach (Toad in BotPlayers)
					AverageSpawnDistance[MapLandmark.Id] += ML::Distance(MapLandmark.Position, Toad.Position);
				
				AverageSpawnDistance[MapLandmark.Id] /= BotPlayers.count;
				SpawnDistancesList.add(AverageSpawnDistance[MapLandmark.Id]);
			}
		}
		
		SpawnDistancesList = SpawnDistancesList.sort();
		SpawnId = AverageSpawnDistance.keyof(SpawnDistancesList[0]);
	}
	
	declare TargetClan = 0;
	if (UseClans) TargetClan = _Player.CurrentClan;
	
	// Spawn player
	SpawnPlayer(_Player, TargetClan, _Player.ArmorMax, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, Now);
}

Real ComputeDifficulty(Real _Difficulty, Real _Min, Real _Max) {
	if (_Min >= _Max) return _Min;
	if (_Max <= _Min) return _Max;
	declare Difficulty = ML::Clamp(_Difficulty, 0., 1.);
	return _Min + (_Max - _Min) * Difficulty;
}

Integer ComputeDifficulty(Real _Difficulty, Integer _Min, Integer _Max) {
	return ML::NearestInteger(ComputeDifficulty(_Difficulty, ML::ToReal(_Min), ML::ToReal(_Max)));
}

// ---------------------------------- //
/** Spawn a Toad
 *
 *	@param	_BotPath			Path to spawn a Toad
 *	@param	_NbToadsSpawned		Amount of spawned Toads (used to determine special type)
 *	@param	_ArmorMax			Amount of Toad Armors
 *	@param	_Difficulty			Difficulty level of the Toad
 *	@param	_Delay				Spawn time delay
 */
Void SpawnToad(CSmMapBotPath _BotPath, Integer _NbToadsSpawned, Integer _ArmorMax, Real _Difficulty, Integer _Delay) {
	declare Bot = CreateBotPlayer(G_ObjectId["Toad"], 0);
	declare ToadType for Bot = "Default";
	declare Difficulty = ML::Clamp(_Difficulty, 0., 1.);
	
	// ---------------------------------- //
	// Define Toad special type
	if (_NbToadsSpawned % C_ToadFrequencyGimp == 0) ToadType = "Gimp";
	if (_NbToadsSpawned % C_ToadFrequencyZombie == C_ToadFrequencyZombie - 1) ToadType = "Zombie";
	
	// ---------------------------------- //
	// Check if Toad is carrying a special weapon
	if (_NbToadsSpawned % C_ToadFrequencyWeapon == C_ToadFrequencyWeapon / 2 + 1) {
		declare Key = C_ToadWeaponTypes.keyof(G_ToadLatestSpecialWeapon) + 1;
		if (Key > C_ToadWeaponTypes.count - 1) Key = 0;
		
		ToadType = C_ToadWeaponTypes[Key];
		G_ToadLatestSpecialWeapon = ToadType;
	}
	
	// ---------------------------------- //
	// Configure behavior
	Bot.Driver.Behaviour = CSmPlayerDriver::ESmDriverBehaviour::Patrol;
	Bot.Driver.AttackFilter = CSmPlayerDriver::ESmAttackFilter::AllPlayers;
	
	// Set Toad maximum ammo and force defualt weapon
	SetPlayerWeapon(Bot, ::EWeapon::Rocket, False);
	foreach (Weapon => Amount in C_ToadWeaponAmmoMax) SetPlayerAmmoMax(Bot, Weapon, Amount);
	
	// Set Toad fire range
	Bot.Driver.AggroRadius = ComputeDifficulty(Difficulty, C_ToadAggroRadiusMin, S_ToadAggroRadiusMax);
	Bot.Driver.DisengageDistance = Bot.Driver.AggroRadius + C_ToadDisengageDistance;
	Bot.Driver.ShootRadius = Bot.Driver.AggroRadius;
	
	// Set Toad parameters depending on target difficulty
	Bot.SpeedPower = ComputeDifficulty(Difficulty, C_ToadSpeedPowerMin, C_ToadSpeedPowerMax);
	Bot.Driver.Accuracy 		= ComputeDifficulty(Difficulty, C_ToadAimAccuracyMin, C_ToadAimAccuracyMax);
	Bot.Driver.ReactionTime		= ComputeDifficulty(Difficulty, C_ToadReactionTimeMin, C_ToadReactionTimeMax);
	Bot.Driver.ShootPeriodMin	= ComputeDifficulty(Difficulty, C_ToadShootIntervalMin, C_ToadShootIntervalMax);
	Bot.Driver.ShootPeriodMax	= Bot.Driver.ShootPeriodMin;
	
	// Set the color and maximum Armor points
	if (C_ToadTypesColors.existskey(ToadType)) Bot.ForceColor = C_ToadTypesColors[ToadType];
	Bot.ArmorMax = _ArmorMax;

	// ---------------------------------- //
	// Special type parameters
	switch (ToadType) {
		// ---------------------------------- //
		// Gimp Toads
		case "Gimp" : Bot.UseAlternateWeaponVisual = True;
		
		// ---------------------------------- //
		// Zombies and Giants
		case "Zombie" : {
			// ---------------------------------- //
			// Giants
			if (
				Players.count >= C_GiantMinPlayersToSpawn &&
				G_NbGiantsAlive < C_GiantMaxNbSpawnedAtOnce &&
				C_GiantSpawnChanceRatio > 0 && ML::Rand(0., 1.) <= C_GiantSpawnChanceRatio
			) {
				ToadType = "Giant";
				G_NbGiantsAlive += 1;
				
				Bot.Driver.Accuracy = 1.;
				Bot.ForceModelId = G_ObjectId["Giant"];
				Bot.SpeedPower = C_GiantDefaultWalkSpeed;
				Bot.AmmoGain = C_GiantAmmoReloadSpeed;
				Bot.ArmorMax = C_GiantArmorPointsMinimum + C_GiantArmorPointsPerPlayer * (Players.count - C_GiantMinPlayersToSpawn);
				
				Translations::SendStatusMessage("Giant has been spawned!", 3000, 1);
				Sound::PlaySound(TL::Replace(C_ImgBase^"Sounds/GiantSpawned%1.ogg", "%1", TL::ToText(ML::Rand(1, 4))), -5.);
			}
			// ---------------------------------- //
			// Zombies
			else {
				Bot.ForceModelId = NullId;
				Bot.Driver.AttackFilter = CSmPlayerDriver::ESmAttackFilter::Nobody;
				Bot.EnergyLevel = 1.;
				Bot.SpeedPower *= C_ToadZombieSpeedMultiplier;
			}
		}
		// ---------------------------------- //
		// Nucleus Toads
		case "Nucleus" : SetPlayerWeapon(Bot, ::EWeapon::Nucleus, False);
		
		// ---------------------------------- //
		// Laser Toads
		case "Laser" : SetPlayerWeapon(Bot, ::EWeapon::Laser, False);
		
		// ---------------------------------- //
		// Arrow Toads
		case "Arrow" : SetPlayerWeapon(Bot, ::EWeapon::Arrow, False);
	}
	
	// Spawn bot
	SpawnBotPlayer(Bot, 0, Bot.ArmorMax, _BotPath, Now + 3000 + _Delay);
}

// ---------------------------------- //
/** Switch the weapon of a player
 *
 *	@param	_Player		The player who will switch weapon
 *	@param	_Input		The number of the new weapon
 */
Void SwitchWeapon(CSmPlayer _Player, CSmModeEvent::EActionInput _Input) {
	if (_Player == Null) return;
	declare ActivableToWeapon = [
		CSmModeEvent::EActionInput::Activable1 => ::EWeapon::Laser,
		CSmModeEvent::EActionInput::Activable2 => ::EWeapon::Nucleus,
		CSmModeEvent::EActionInput::Activable3 => ::EWeapon::Arrow,
		CSmModeEvent::EActionInput::Activable4 => ::EWeapon::Rocket
	];
	if (ActivableToWeapon.existskey(_Input)) SetPlayerWeapon(_Player, ActivableToWeapon[_Input], False);
}

// ---------------------------------- //
/** Cycle through the available weapons
 *
 *	@param	_Player		The player who will cycle through his weapons
 *	@param	_Step		The number of step to go forward or backward in the weapons list
 */
Void CycleWeapon(CSmPlayer _Player, Integer _Step) {
	if (_Player == Null || _Step == 0) return;
	
	declare Weapons = [1, 3, 5, 2, 6];
	declare NewWeapon = _Player.CurWeapon;
	declare Key = Weapons.keyof(NewWeapon) + _Step;
	
	if (Key > Weapons.count - 1) Key = 0;
	else if (Key < 0) Key = Weapons.count - 1;
	NewWeapon = Weapons[Key];
	
	declare WeaponFromNum = [
		1 => ::EWeapon::Laser,
		2 => ::EWeapon::Rocket,
		3 => ::EWeapon::Nucleus,
		5 => ::EWeapon::Arrow
	];
	if (WeaponFromNum.existskey(NewWeapon)) SetPlayerWeapon(_Player, WeaponFromNum[NewWeapon], False);
}

// ---------------------------------- //
/** Pick up object
 *
 *	@param	_Player		The player who picked up the item
 *	@param	_Object		The item picked up by the player
 */
Void PickUpObject(CSmPlayer _Player, CSmObject _Object) {
	if (_Player == Null || _Object == Null || _Player.IsBot) return;
	
	declare Text Tag for _Object;
	if (Tag != "Gold") return;
	
	declare Text[] PlayerActionsList for _Player;
	declare Text PlayerLatestActionName for _Player;
	declare Text NewAction = "";
	
	// ---------------------------------- //
	// Select random action (Melee-like)
	if (PlayerActionsList.count <= 0) PlayerActionsList = C_CustomWeaponActions;
	while (NewAction == "") {
		NewAction = PlayerActionsList[ML::Rand(0, PlayerActionsList.count - 1)];
		if (NewAction != PlayerLatestActionName) break;
	}
	PlayerLatestActionName = NewAction;
	declare Removed = PlayerActionsList.remove(NewAction);
	
	// ---------------------------------- //
	// Apply custom weapon
	ActionLoad(_Player, ::EActionSlot::Slot_A, G_ActionId[NewAction]);
	ActionBind(_Player, ::EActionSlot::Slot_A, ::EActionInput::Weapon);
	
	// ---------------------------------- //
	// Set variables
	declare Boolean PlayerHasCustomWeapon for _Player;
	declare Integer PlayerWeaponExpiration for _Player;
	declare Integer PlayerLastGoldSpawnId for _Player;
	declare Integer PlayerEvolutionLevel for _Player;
	
	PlayerHasCustomWeapon = True;
	PlayerLastGoldSpawnId = G_CurGoldItemSpawnId;
	PlayerWeaponExpiration = Now + C_GoldBuffBaseDuration;
	
	// Evolution levels bonus
	declare EvolutionBonus = 0;
	if (S_UseEvolutionLevels) EvolutionBonus = (PlayerEvolutionLevel - 1) * C_GoldBuffTimePerEvoLvl;
	PlayerWeaponExpiration += EvolutionBonus;
	
	// Send interface data
	InvasionUI::SetPlayerGoldSpawnId(_Player, G_CurGoldItemSpawnId);
	InvasionUI::SetPlayerWeaponData(_Player, Now, C_GoldBuffBaseDuration, EvolutionBonus);
	
	// Weapon name
	declare WeaponName = NewAction;
	if (C_CustomWeaponsNames.existskey(NewAction)) WeaponName = C_CustomWeaponsNames[NewAction];
	
	InvasionUI::SetPlayerWeaponName(_Player, WeaponName);
	Interfancy::SetPlayerCustomWeapon(_Player, WeaponName);
	Statistics::TrackEvent(_Player, "GoldWeaponsAcquired", 1);
	
	// Play sound
	Sound::PlaySound(C_ImgBase^"Sounds/GoldPickUp.ogg", _Player);
	
	// ---------------------------------- //
	// Destroy Gold in solo mode
	if (G_IsSoloMode && G_GoldCrystalObject != Null) {
		_Object.SetUnspawned();
		ObjectDestroy(_Object);
		G_GoldCrystalObject = Null;
	}
}

// ---------------------------------- //
/// Let the server sleep until there's enough players to start a game
Void WaitForPlayers() {
	while (!ServerShutdownRequested && !MatchEndRequested && PlayersNbTotal <= 0) MB_Yield();
}

// ---------------------------------- //
/** Get the color depending on a ratio
 *
 *	@param	_Ratio			The ratio of the color
 *	@param	_ColorRatios	List of the colors for each ratio
 *
 *	@return		The Blend color according to the ratio
 */
Vec3 ColorTransition(Real _Ratio, Vec3[Real] _ColorRatios) {
	if (_ColorRatios.count <= 0) return <0., 0., 0.>;
	if (_ColorRatios.count == 1) foreach (Color in _ColorRatios) return Color;
	if (_ColorRatios.existskey(_Ratio)) return _ColorRatios[_Ratio];
	
	// Sort all colors ratios in ascending order
	declare Real[] SortedRatios;
	foreach (Ratio => Color in _ColorRatios) SortedRatios.add(Ratio);
	SortedRatios = SortedRatios.sort();
	
	// Get the lowest color ratio
	declare MinimumRatio = SortedRatios[0];
	foreach (Ratio in SortedRatios) if (Ratio > MinimumRatio && Ratio < _Ratio) MinimumRatio = Ratio;
	
	// Get the highest color ratio
	declare MaximumRatio = SortedRatios[SortedRatios.count - 1];
	foreach (Ratio in SortedRatios) if (Ratio < MaximumRatio && Ratio > _Ratio) MaximumRatio = Ratio;
	
	// Get the colors blend properties
	declare BlendRatio = (_Ratio - MinimumRatio) / (MaximumRatio - MinimumRatio);
	declare MinimumColor = _ColorRatios[MinimumRatio];
	declare MaximumColor = _ColorRatios[MaximumRatio];
	
	// Compute the final color
	declare Vec3 OutputColor;
	for (I, 0, 2) OutputColor[I] = MinimumColor[I] + (MaximumColor[I] - MinimumColor[I]) * BlendRatio;
	return OutputColor;
}

// ---------------------------------- //
/** Add Evolution points
 *
 *	@param	_Player		The player to give points
 *	@param	_Points		Amount of points to give to a player
 */
Void AddEvolutionPoints(CSmPlayer _Player, Integer _Points) {
	if (_Player == Null || _Player.Score == Null || _Points == 0) return;
	declare Integer PlayerEvolutionPoints for _Player.Score;
	PlayerEvolutionPoints += _Points;
	if (PlayerEvolutionPoints < 0) PlayerEvolutionPoints = 0;
}

// ---------------------------------- //
/** Get a critical hit
 *
 *	@return		THit event damage
 */
Integer GetCriticalDamage() {
	declare Damage = 100;
	for (I, 0, 2) if (ML::Rand(0., 1.) <= C_CriticalHitChance) Damage *= 2;
	return Damage;
}

// ---------------------------------- //
/** Send critical hit notification
 *
 *	@param	_Player		Player to notify
 *	@param	_Damage		Hit event damage
 */
Void SendCritNotification(CSmPlayer _Player, Integer _Damage) {
	if (_Player == Null || _Damage < 200) return;
	
	declare Message = "CRITICAL HIT!";
	if (_Damage >= 400) Message = "$FB0DOUBLE CRIT!";
	if (_Damage >= 800) Message = "$BF0TRIPLE CRIT!";
	
	Statistics::TrackEvent(_Player, "InvasionCriticalHits", 1);
	Interfancy::SendCrosshairNote(_Player, [Message], 1000);
}