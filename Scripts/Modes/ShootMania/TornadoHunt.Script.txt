// -------------------------------------- //
//  TORNADO HUNT by domino54              //
//  script version: 2016-11-23            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes	"TornadoHuntArena GoalHuntArena RealmArena BattleArena"
#Const Version		"2016-11-23"
#Const ScriptName	"TornadoHunt.Script.txt"

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeLimit			600 	as _("Time limit (seconds)")
#Setting S_PointsLimit			120		as _("Points limit")
#Setting S_EnablePvPWeapons		True	as _("Enable PvP weapons")
#Setting S_ShowTornadoOnGoal	True	as _("Show Tornado over the first Goal")
#Setting S_MaxNbPrevGoals		2		as _("Number of capturable previous goals")
#Setting S_BoostOthersOnCap		True	as _("Boost other players on capture")
#Setting S_GoalCaptureTimeout	30		as _("Time before other Goal is selected if not captured")

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_PointsPerCapturedGoal	2	///< Amount of points per every goal avaialble
#Const C_OffZoneConstantRadius	3.	///< Radius of the Tornado around the Goal

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[] G_GoalsOrder;	///< All Goals listed from the oldest to the newest tossed
declare Ident[] G_GoalsList;	///< List of Goals available to toss
declare Ident G_LatestGoalId;	///< Previously tossed Goal
declare Ident[] G_SpawnsList;	///< List of Spawns available to toss
declare Ident G_LatestSpawnId;	///< Previously tossed Spawn

// ---------------------------------- //
// Adjust the scores table
// ---------------------------------- //
***ScoresTable***
***
ST2::DestroyCol("LibST_SMRoundPoints");
ST2::SetColWidth("LibST_SMPoints", 5.);
TopScores::RemoveCategory("Items");
TopScores::AddCategory("Capture", "Cp", 2.25, 70.);
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***StartServer***
***
// ---------------------------------- //
// Set mode options
GT_AutoManageOnArmorEmpty = False;
GT_LogScriptsVersions = [ScriptName => Version];

// ---------------------------------- //
// Set the rules in the SpawnScreen
GT_SpawnScreenModeName = "Tornado Hunt";
GT_SpawnScreenModeType = _("Free for all");
GT_SpawnScreenObjectives = TL::Compose(
	_("$<%11. $>Touch the $<$F00red$> Goal highlighted with the Tornado to get a point.\n$<%12. $>Touch the previous $<$00Fblue$> and $<$FFFwhite$> Goals to get less points than highlighted one gives.\n$<%13. $>The first player to reach the points limit or the player with the highest score at the end of the time limit wins the map."),
	"$"^SpawnScreen::GetModeColor()
);

// ---------------------------------- //
// Set the rules in the pause menu
PauseMenu::SetModeRules(GT_SpawnScreenModeName, "Rules", "Touch the $<$F00red$> Goal highlighted with the Tornado to get a point. Touch the previous $<$00Fblue$> and $<$FFFwhite$> Goals to get less points than highlighted one gives. The first player to reach the points limit or the player with the highest score at the end of the time limit wins the map.");

// ---------------------------------- //
// Create custom interface
Layers::Create("TornadoHunt:Markers", CreateManialinkMarkers());
Layers::Attach("TornadoHunt:Markers");
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***InitMap***
***
declare CurrentTimeLimit = S_TimeLimit;
declare PrevPointsLimit = -1;
declare PrevShowTornado = False;

// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;
declare TotalNbGoals = 0;

if (MapLandmarks_PlayerSpawn.count <= 0) MapValidated = False;
foreach (MapLandmark in MapLandmarks_Gauge) if (MapLandmark.Gate == Null) TotalNbGoals += 1;
if (TotalNbGoals < 3) MapValidated = False;

// ---------------------------------- //
// Skip map if not valid
if (!MapValidated) {
	Translations::SendChat("This map is not valid, moving to the next one.");
	MB_Sleep(10000);
	MB_StopMap = True;
}
***

// ---------------------------------- //
// Start map
// ---------------------------------- //
***StartMap***
***
G_GoalsOrder.clear();
G_GoalsList.clear();
G_SpawnsList.clear();
G_LatestGoalId = NullId;
G_LatestSpawnId = NullId;

// Reset OffZone
OffZoneRadius = 0.;
PrevShowTornado = False;

// ---------------------------------- //
// Wait for enough players to start game
while (!ServerShutdownRequested && !MatchEndRequested && Players.count <= 0) MB_Yield();

// ---------------------------------- //
// Init scores
MB_Sleep(1); ///< Allow the scores array to be sorted
foreach (Score in Scores) {
	declare Integer LastPoint for Score;
	LastPoint = 0;
}
declare LeadId = NullId;
if (Scores.existskey(0)) LeadId = Scores[0].User.Id;

// ---------------------------------- //
// Init players
foreach (Player in Players) {
	declare Ident[] CapturedLandmarksIds for Player;
	CapturedLandmarksIds.clear();
}

// ---------------------------------- //
// Start match
StartTime = Now + S_RespawnTime;
if (S_TimeLimit > 0) EndTime = StartTime + (S_TimeLimit * 1000);
else EndTime = -1;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::StartRound, 0);

// Set the first Goal
SelectNextGoal();
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
// ---------------------------------- //
// Events management
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Completely ignore OffZone in the mode
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (OffZoneRadius > 0 && Event.Shooter == Null) { Discard(Event); continue; }
		---PremadeOnArmorEmpty---
	}
}

// ---------------------------------- //
// Check if current Goal has timed out
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Gate != Null || MapLandmark.Gauge.Speed >= 0) continue;
	if (MapLandmark.Gauge.ValueReal <= 0) {
		Translations::SendStatusMessage("The Goal has timed out", 3000, 0, CUIConfig::EUISound::Notice, 0);
		SelectNextGoal();
	}
}

// ---------------------------------- //
// Spawn players
foreach (Player in Players) {
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);
		GH_SpawnPlayer(Player);
	}
	
	// ---------------------------------- //
	// Check if player is touching a goal
	declare Ident PrevLandmarkId for Player;
	
	// Get the ID of landmark the player is on
	declare MapLandmarkId = NullId;
	if (Player.CapturedLandmark != Null) MapLandmarkId = Player.CapturedLandmark.Id;
	
	// Fire event on landmark change
	if (PrevLandmarkId != MapLandmarkId) {
		PrevLandmarkId = MapLandmarkId;
		CaptureLandmark(Player, MapLandmarkId);
	}
}

// ---------------------------------- //
// Turn all round points into normal points
foreach (Score in Scores) {
	if (Score.RoundPoints == 0) continue;
	Score.Points += Score.RoundPoints;
	Score.RoundPoints = 0;
}

// ---------------------------------- //
// Play sound and notice if someone is taking the lead
if (Scores.existskey(0) && Scores[0].User.Id != LeadId) {
	LeadId = Scores[0].User.Id;
	Message::SendBigMessage(TL::Compose(_("$<%1$> takes the lead!"), Scores[0].User.Name), 3000, 1, CUIConfig::EUISound::PhaseChange, 1);
}

// ---------------------------------- //
// Server info change
if (PrevPointsLimit != S_PointsLimit) {
	PrevPointsLimit = S_PointsLimit;
	ST2::SetFooterText(TL::Compose("%1 "^S_PointsLimit, _("Points limit : ")));
}

// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit) {
	CurrentTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) EndTime = StartTime + (S_TimeLimit * 1000);
	else EndTime = -1;
}

// ---------------------------------- //
// PvP weapons setting change
if (UsePvPWeapons != S_EnablePvPWeapons) {
	UsePvPWeapons = S_EnablePvPWeapons;
}

// ---------------------------------- //
// Set the Tornado visibility
if (PrevShowTornado != S_ShowTornadoOnGoal) {
	PrevShowTornado = S_ShowTornadoOnGoal;
	
	if (S_ShowTornadoOnGoal) OffZoneRadius = C_OffZoneConstantRadius;
	else OffZoneRadius = 0.;
}

// ---------------------------------- //
// Victory conditions
if (Scores.existskey(0) && Scores[0].Points >= S_PointsLimit) {
	Message::SendBigMessage(
		TL::Compose(_("$<%1$> gets the final hit!"), Scores[0].User.Name),
		3000, 3, CUIConfig::EUISound::VictoryPoint, 0
	);
	MB_StopMap = True;
}
if (EndTime > 0 && Now > EndTime) MB_StopMap = True;
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMapBeforePodium***
***
G_GoalsOrder.clear();
UpdateInterface();
OffZoneRadius = -1.;
StartTime = -1;
EndTime = -1;

// Unspawn everyone except the winner
foreach (I => Player in Players) if (I > 0) UnspawnPlayer(Player);

MB_Sleep(3000);

Message::CleanBigMessages();
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
Layers::Detach("TornadoHunt:Markers");
Layers::Destroy("TornadoHunt:Markers");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the selection order of a landmark
 *
 *	@param	_MapLandmarkId		Id of the landmark to get order
 *
 *	@return		The landmark order
 */
Integer GetGoalOrder(Ident _MapLandmarkId) {
	if (!MapLandmarks_Gauge.existskey(_MapLandmarkId) || !G_GoalsOrder.exists(_MapLandmarkId)) return -1;
	
	declare Order = 0;
	while (Order <= G_GoalsOrder.count - 1) {
		if (G_GoalsOrder[G_GoalsOrder.count - Order - 1] == _MapLandmarkId) return Order;
		Order += 1;
	}
	return -1;
}

// ---------------------------------- //
/// Update the data sent to the interface
Void UpdateInterface() {
	declare netwrite Integer Net_TornadoHunt_UpdateTime for Teams[0];
	declare netwrite Vec3[] Net_TornadoHunt_GoalsOrder for Teams[0];
	declare netwrite Vec3[][Text] Net_TornadoHunt_CapturedGoals for Teams[0];
	
	Net_TornadoHunt_UpdateTime = Now;
	Net_TornadoHunt_GoalsOrder.clear();
	Net_TornadoHunt_CapturedGoals.clear();
	
	// ---------------------------------- //
	// Get the list of all capturable Goals
	foreach (MapLandmarkId in G_GoalsOrder) {
		declare GoalOrder = GetGoalOrder(MapLandmarkId);
		if (GoalOrder < 0 || GoalOrder > S_MaxNbPrevGoals) continue;
		
		// Get landmark position
		if (!MapLandmarks.existskey(MapLandmarkId)) continue;
		declare MapLandmark <=> MapLandmarks[MapLandmarkId];
		Net_TornadoHunt_GoalsOrder.add(MapLandmark.Position);
	}
	
	// ---------------------------------- //
	// Get list of Goals captured by players
	foreach (Player in Players) {
		declare Ident[] CapturedLandmarksIds for Player;
		Net_TornadoHunt_CapturedGoals[Player.User.Login] = Vec3[];
		
		foreach (MapLandmarkId in CapturedLandmarksIds) {
			if (!MapLandmarks.existskey(MapLandmarkId)) continue;
			declare MapLandmark <=> MapLandmarks[MapLandmarkId];
			Net_TornadoHunt_CapturedGoals[Player.User.Login].add(MapLandmark.Position);
		}
	}
}

// ---------------------------------- //
/// Select random next goal
Void SelectNextGoal() {
	// Fill the goals list
	if (G_GoalsList.count <= 0) foreach (MapLandmark in MapLandmarks_Gauge) if (MapLandmark.Gate == Null) G_GoalsList.add(MapLandmark.Id);
	
	// ---------------------------------- //
	// Choose random goal
	declare MapLandmarkId = NullId;
	while (True) {
		MapLandmarkId = G_GoalsList[ML::Rand(0, G_GoalsList.count - 1)];
		if (MapLandmarkId != G_LatestGoalId || G_GoalsList.count == 1) break;
	}
	declare Removed = G_GoalsList.remove(MapLandmarkId);
	G_LatestGoalId = MapLandmarkId;
	
	// ---------------------------------- //
	// List the goal at the end of the array
	if (G_GoalsOrder.exists(MapLandmarkId)) {
		declare Removed = G_GoalsOrder.remove(MapLandmarkId);
	}
	G_GoalsOrder.add(MapLandmarkId);
	
	// ---------------------------------- //
	// Remove landmark from captured IDs array
	foreach (Player in AllPlayers) {
		declare Ident[] CapturedLandmarksIds for Player;
		while (CapturedLandmarksIds.exists(MapLandmarkId)) {
			Removed = CapturedLandmarksIds.remove(MapLandmarkId);
		}
	}
	
	// ---------------------------------- //
	// Configure landmarks apperance
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Gate != Null) continue;
		declare GoalOrder = GetGoalOrder(MapLandmark.Id);
		
		// Make the goal center of the OffZone
		if (GoalOrder == 0) OffZoneCenterLandmarkId = MapLandmark.Id;
		
		// Reset Goal gauge
		MapLandmark.Gauge.Max = 1;
		MapLandmark.Gauge.ValueReal = 0.;
		MapLandmark.Gauge.Speed = 0;
		
		// ---------------------------------- //
		// Configure the landmark base
		if (MapLandmark.Base == Null) continue;
		MapLandmark.Base.IsActive = GoalOrder != -1 && GoalOrder <= S_MaxNbPrevGoals;
		if (MapLandmark.Base.IsActive) MapLandmark.Gauge.ValueReal = 1.;
		
		// Set clan depending on order
		declare Clan = 0;
		switch (GoalOrder) {
			case 0 : Clan = 2;
			case 1 : Clan = 1;
		}
		MapLandmark.Base.Clan = Clan;
		MapLandmark.Gauge.Clan = Clan;
	}
	
	// ---------------------------------- //
	// Set the goal timeout
	if (S_GoalCaptureTimeout > 0) {
		declare MapLandmark <=> MapLandmarks[MapLandmarkId];
		MapLandmark.Gauge.Max = S_GoalCaptureTimeout * 1000;
		MapLandmark.Gauge.ValueReal = 1.;
		MapLandmark.Gauge.Speed = -1;
	}
	
	// Update interfaces
	UpdateInterface();
}

// ---------------------------------- //
/** Capture a landmark by a player
 *
 *	@param	_Player			The player that captures a landmark
 *	@param	_MapLandmarkId	Id of the landmark to capture
 */
Void CaptureLandmark(CSmPlayer _Player, Ident _MapLandmarkId) {
	if (_Player == Null || _MapLandmarkId == NullId) return;
	
	// Get the order of the goal
	declare GoalOrder = GetGoalOrder(_MapLandmarkId);
	if (GoalOrder <= -1 || GoalOrder > S_MaxNbPrevGoals) return;
	
	// Check if player haven't captured this goal yet
	declare Ident[] CapturedLandmarksIds for _Player;
	if (CapturedLandmarksIds.exists(_MapLandmarkId)) return;
	CapturedLandmarksIds.add(_MapLandmarkId);
	
	// Give points for capturing the goal
	declare Points = (S_MaxNbPrevGoals - GoalOrder + 1) * C_PointsPerCapturedGoal;
	Score::AddPoints(_Player, Points);
	TopScores::AddPoints(_Player.Score, "Capture", Points);
	Statistics::TrackEvent(_Player, "TornadoHuntGoals", 1);
	
	// Notify player about the capture
	Translations::SendStatusMessage("You've captured the Goal!", 3000, 1, CUIConfig::EUISound::Checkpoint, 0);
	
	// ---------------------------------- //
	// Things valid only for the highlighted Goal
	if (GoalOrder == 0) {
		foreach (Player in AllPlayers) {
			if (Player == _Player || Player.IsBot) continue;
			
			// Notify other players about the capture
			Translations::SendStatusMessage(["$<%1$> has captured the Goal", _Player.User.Name], 3000, 0, CUIConfig::EUISound::Checkpoint, 1);
			
			// Boost other players on capture
			if (S_BoostOthersOnCap && Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
				GalaxyTitles::AddReloadBoost(Player);
				Player.Stamina = ML::FloorInteger(3600 * Player.StaminaMax);
			}
		}
		
		// Select new random Goal
		SelectNextGoal();
	}
	
	// Update interfaces
	else UpdateInterface();
}

// ---------------------------------- //
/** Spawn a player
 *
 *	@param	_Player		The player to spawn
 */
Void GH_SpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	// Fill the spawns lists
	if (G_SpawnsList.count == 0) foreach (MapLandmark in MapLandmarks_PlayerSpawn) G_SpawnsList.add(MapLandmark.Id);
	
	// ---------------------------------- //
	// Get new spawn
	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[ML::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId || G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	
	// ---------------------------------- //
	// Spawn player
	SM::SpawnPlayer(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, Now + S_RespawnTime);
	declare Removed = G_SpawnsList.remove(SpawnId);
}

// ---------------------------------- //
/** Create manialink for the markers module
 *
 *	@return		The markers manialink
 */
Text CreateManialinkMarkers() {
	return """
<manialink version="2" name="TornadoHunt:Markers">
<script><!--
/**
 *	TornadoHunt: Markers
 */

#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Netcode
declare netread Integer Net_TornadoHunt_UpdateTime for Teams[0];
declare netread Vec3[] Net_TornadoHunt_GoalsOrder for Teams[0];
declare netread Vec3[][Text] Net_TornadoHunt_CapturedGoals for Teams[0];

// ---------------------------------- //
// Variables
declare UpdateMarkers = True;
declare PrevUpdateTime = -1;
declare PrevGUIPlayerId = NullId;

// Reset markers
ClientUI.MarkersXML = "<marker/>";
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Server script called an update
if (PrevUpdateTime != Net_TornadoHunt_UpdateTime) {
	PrevUpdateTime = Net_TornadoHunt_UpdateTime;
	UpdateMarkers = True;
}

// ---------------------------------- //
// Force update on spectated player change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerId != GUIPlayer.Id) {
		PrevGUIPlayerId = GUIPlayer.Id;
		UpdateMarkers = True;
	}
}
if (PrevGUIPlayerId != NullId) {
	PrevGUIPlayerId = NullId;
	UpdateMarkers = True;
}

// ---------------------------------- //
// Update markers
if (UpdateMarkers) {
	UpdateMarkers = False;
	
	// Reset markers
	ClientUI.MarkersXML = "<marker/>";
	
	declare Text Login;
	if (GUIPlayer != Null && GUIPlayer.User != Null) Login = GUIPlayer.User.Login;
	
	// ---------------------------------- //
	// Create marker for every Goal available
	foreach (I => Position in Net_TornadoHunt_GoalsOrder) {
		declare GoalOrder = Net_TornadoHunt_GoalsOrder.count - I - 1;
		
		// ---------------------------------- //
		// Ignore goal if captured by the spectated player
		declare Vec3[] GUIPlayerGoals;
		if (Net_TornadoHunt_CapturedGoals.existskey(Login)) GUIPlayerGoals = Net_TornadoHunt_CapturedGoals[Login];
		if (GUIPlayerGoals.exists(Position)) continue;
		
		// ---------------------------------- //
		// Create marker
		declare Pos = Position.X^" "^Position.Y + 25^" "^Position.Z;
		declare Label = TL::GetTranslatedText(TL::Compose("%1 #"^GoalOrder + 1, _("Goal")));
		declare Color = "FFF";
		
		if (GoalOrder == 0) Color = TL::ColorToText(Teams[1].ColorPrimary);
		if (GoalOrder == 1) Color = TL::ColorToText(Teams[0].ColorPrimary);
		
		ClientUI.MarkersXML ^= "<marker label='"^TL::MLEncode(Label)^"' pos='"^Pos^"' color='"^Color^"' visibility='WhenInFrustum' minimapvisibility='Never'/>";
	}
}
***

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}