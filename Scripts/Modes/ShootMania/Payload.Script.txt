// -------------------------------------- //
//  PAYLOAD by domino54                   //
//  script version: 2017-02-18            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes	"PayloadArena"
#Const Version		"2017-02-18"
#Const ScriptName	"Payload.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_NbRoundsPerTeam			1		as _("Attack rounds fer team")
#Setting S_TimeLimit				300 	as _("Time limit (seconds)")
#Setting S_AllowPayloadReversing	True	as _("Allow Payload to move backwards")

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_MapMaximumNbSectors		9		///< Maximum number of sectors the map can have
#Const C_PayloadSpeedPerPlayer		1.		///< Payload speed bonus per every additional player in m/s
#Const C_PayloadMaxPlayersPushing	3		///< Maximum Payload speed multiplier
#Const C_PayloadActivationRadius	8.		///< Radius within the Payload can be interacted with
#Const C_PayloadReversingTimeLimit	10000	///< Time after which Payload starts going backwards
#Const C_PayloadReversingSpeed		.5		///< Payload speed in m/s when going backwards
#Const C_PayloadTimePerPoint		3000	///< Time required for each attack point
#Const C_SetupPhaseDuration			15000	///< Duration of the preparation phase for defenderss

#Const Description _("TYPE: Team versus Team\nOBJECTIVE: Attacking team is pushing Payload across the map, defenders have to stop them.")

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Real G_PayloadTrackCurrentDist;			///< Distance travelled by the Payload
declare Real G_PayloadTrackTotalDist;			///< Total distance of the Payload track
declare Real[Vec3] G_PayloadTrackPointsDist;	///< All track point distances to the starting point
declare Integer G_CurMapTotalNbSectors;			///< Total number of Sectors in the current map
declare Real[Integer] G_SectorCheckpointsDist;	///< Checkpoints distances to the starting point

declare Vec3 G_PayloadPosition;		///< Current position of the Payload
declare Integer G_AttackingClan;	///< Currently attacking team
declare Integer G_CapturedSectors;	///< Number of sectors captured by the attackers
declare Boolean G_IsOvertime;		///< True, if the game is in overtime mode
declare Ident[Text] G_ObjectsIds;	///< Ids of the objects models

// ---------------------------------- //
// Extend
// ---------------------------------- //
***LogVersion***
***
MB_LogVersion(ScriptName, Version);
MB_LogVersion(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Set the scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("Attack", "Atk", 2.25, 60.);
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***InitServer***
***
// ---------------------------------- //
// Set the mode options
UseClans = True;
G_AttackingClan = 1;

// ---------------------------------- //
// Set the rules in the SpawnScreen
GT_SpawnScreenModeName = "Payload";
GT_SpawnScreenModeType = _("Team versus Team");
GT_SpawnScreenObjectives = TL::Compose(
	_("$<%11. $>Attackers goal is to push the Payload to the end of its route, while defenders try to stop them.\n$<%12. $>Attacking team will get 1 point for every Checkpoint reached.\n$<%13. $>If attackers leave Payload for enough time, it will start to slowly go backwards.\n$<%14. $>After both teams have finished their attack round, the team with more points wins.\n$<%15. $>If teams end up with the same score, Sudden Death mode is played to decide the winner."),
	"$"^SpawnScreen::GetModeColor()
);

// ---------------------------------- //
// Set the rules in the pause menu
PauseMenu::SetModeRules(GT_SpawnScreenModeName, "Attackers goal is to push the Payload to the end of its route, while defenders try to stop them. After both teams have finished their attack round, the team with more points wins.", "");

// ---------------------------------- //
// Create custom interface
Layers::Create("Payload:Interface", CreateManialinkPayloadUI());

// ---------------------------------- //
// Load objects
// G_ObjectsIds["Crystal"] = ItemList_Add("SMCommon\\Collectibles\\Gold.Item.gbx");
G_ObjectsIds["Crystal"] = ItemList_Add("CrystalPickup.Item.gbx");

// ---------------------------------- //
// Variables
declare PayloadStructureObjects = Ident[];
declare NbAttackersPushingPayload = 0;
declare NbDefendersStoppingPayload = 0;
declare LastPayloadInteractionTime = 0;
declare IsPreparationPhase = False;
declare NextCheckpointDistance = 0.;
declare CurSectorStartTime = 0;

declare PrevCheckpointDistance = 0.;
declare PrevPayloadDistance = G_PayloadTrackCurrentDist;
declare PrevAllowPayloadReversing = S_AllowPayloadReversing;
declare CurrentTimeLimit = S_TimeLimit;
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***InitMap***
***
// ---------------------------------- //
// Reset map parameters
G_PayloadTrackTotalDist = 0.;
G_PayloadTrackPointsDist.clear();
G_CurMapTotalNbSectors = 0;
G_SectorCheckpointsDist.clear();

// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;

// Map must have a BotPath for Payload route with at least 2 points on it
declare PayloadRoute <=> Map::GetBotPath("Payload", 0);
if (PayloadRoute == Null || PayloadRoute.Path.count < 2) MapValidated = False;

// ---------------------------------- //
// Map must have correct Sectors
declare Integer[] MapSectors;
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Checkpoint") continue;
	if (MapLandmark.Order > G_CurMapTotalNbSectors) G_CurMapTotalNbSectors = MapLandmark.Order;
	if (!MapSectors.exists(MapLandmark.Order)) MapSectors.add(MapLandmark.Order);
}
for (I, 1, G_CurMapTotalNbSectors) if (!MapSectors.exists(I)) { MapValidated = False; break; }

// ---------------------------------- //
// Map must have one Checkpoint, SpawnAtk and SpawnDef per Sector
for (Sector, 1, G_CurMapTotalNbSectors) {
	declare Checkpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
	declare SpawnAtk <=> Map::GetLandmarkPlayerSpawn("SpawnAtk", Sector);
	declare SpawnDef <=> Map::GetLandmarkPlayerSpawn("SpawnDef", Sector);
	if (Checkpoint == Null || SpawnAtk == Null || SpawnDef == Null) { MapValidated = False; break; }
}

// At least one Gate in front of first SpawnAtk
if (Map::GetLandmarkGate("Gate", 1) == Null) MapValidated = False;

// ---------------------------------- //
// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Start map
// ---------------------------------- //
***StartMap***
***
// ---------------------------------- //
// Get the complete data about the Payload track
declare Vec3 PrevPointPosn;
foreach (I => Point in PayloadRoute.Path) {
	declare Distance = 0.;
	if (I > 0) Distance = ML::Distance(PrevPointPosn, Point);
	
	G_PayloadTrackTotalDist += Distance;
	G_PayloadTrackPointsDist[Point] = G_PayloadTrackTotalDist;
	PrevPointPosn = Point;
}

// ---------------------------------- //
// Compute distances at which the Checkpoints will get TRIGGERED
for (Sector, 1, G_CurMapTotalNbSectors) {
	declare CurSectorCheckpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
	
	// ---------------------------------- //
	// Get distances to all points
	declare Real[Vec3] PathPointsDistances;
	foreach (Point in PayloadRoute.Path) PathPointsDistances[Point] = ML::Distance(CurSectorCheckpoint.Position, Point);
	PathPointsDistances = PathPointsDistances.sort();
	
	// ---------------------------------- //
	// Get 2 nearest points to the Checkpoint
	declare Vec3[Real] NearestPoints;
	declare PrevPointPosn = Vec3;
	declare PointsDistance = 0.;
	declare I = 0;
	
	foreach (Position => Distance in PathPointsDistances) {
		if (I >= 2) break;
		if (I == 1) PointsDistance = ML::Distance(PrevPointPosn, Position);
		NearestPoints[G_PayloadTrackPointsDist[Position]] = Position;
		PrevPointPosn = Position;
		I += 1;
	}
	NearestPoints = NearestPoints.sortkey();
	
	// ---------------------------------- //
	// Get Checkpoint distance to both points
	declare Real StartPointDist;
	declare Real StartPointPayloadDist;
	declare Real EndPointDist;
	declare Real EndPointPayloadDist;
	
	I = 0;
	foreach (PayloadDist => Position in NearestPoints) {
		declare Distance = ML::Distance(CurSectorCheckpoint.Position, Position);
		switch (I) {
			case 0 : {
				StartPointDist = Distance;
				StartPointPayloadDist = PayloadDist;
			}
			case 1 : {
				EndPointDist = Distance;
				EndPointPayloadDist = PayloadDist;
			}
		}
		I += 1;
	}
	
	// ---------------------------------- //
	// Checkpoint is beyond both points
	if (ML::Pow(StartPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(EndPointDist, 2.))) {
		G_SectorCheckpointsDist[Sector] = ML::Min(EndPointPayloadDist, G_PayloadTrackTotalDist);
		continue;
	}
	
	// ---------------------------------- //
	// Checkpoint is (somehow) behind points
	if (ML::Pow(EndPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(StartPointDist, 2.))) {
		G_SectorCheckpointsDist[Sector] = ML::Max(StartPointPayloadDist, 0.);
		continue;
	}
	
	// ---------------------------------- //
	// Checkpoint is between two points
	declare Ratio = StartPointDist / (StartPointDist + EndPointDist);
	G_SectorCheckpointsDist[Sector] = StartPointPayloadDist + Ratio * (EndPointPayloadDist - StartPointPayloadDist);
}

// Send Checkpoints data to the UI
UISetCheckpointsDistances(G_SectorCheckpointsDist);
***

// ---------------------------------- //
// Initialize round
// ---------------------------------- //
***InitRound***
***
UISetNbPlayersPushingPayload(0);
UISetLastPushTime(-1);
G_CapturedSectors = 0;
G_IsOvertime = False;
IsPreparationPhase = True;
NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors + 1];
PrevCheckpointDistance = 0.;
PrevPayloadDistance = -1.;

// Swap the currently attacking team
G_AttackingClan = 3 - G_AttackingClan;
UISetAttackingTeam(G_AttackingClan);

// Reset Payload distance
G_PayloadTrackCurrentDist = 0.;
UISetPayloadDistance(G_PayloadTrackCurrentDist);

UpdateBasesColors();

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (ObjectId in PayloadStructureObjects) {
	if (!Objects.existskey(ObjectId)) continue;
	ObjectDestroy(Objects[ObjectId]);
}
PayloadStructureObjects.clear();

// ---------------------------------- //
// Create new Payload structure objects
PayloadStructureObjects.add(ObjectCreate(G_ObjectsIds["Crystal"]).Id);

// Reset the payload position
G_PayloadPosition = GetPayloadPosition(G_PayloadTrackCurrentDist);
SetObjectsPosition(PayloadStructureObjects, G_PayloadPosition);

// ---------------------------------- //
// Decapture all used Gauges
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Checkpoint") continue;
	MapLandmark.Gauge.ValueReal = 0.;
	MapLandmark.Gauge.Captured = False;
}

// ---------------------------------- //
// Deautomatize Gates used on the map
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.Automatic = False;
	MapLandmark.Gate.ManualClosed = False;
	MapLandmark.Gate.Clan = 0;
	MapLandmark.Gauge.Speed = 0;
	MapLandmark.Gauge.ValueReal = 0.;
}

// ---------------------------------- //
// Reset players Payload time
foreach (Player in Players) {
	declare Real TimeNearPayload for Player;
	declare Real PrevTimeNearPayload for Player;
	TimeNearPayload = 0.;
	PrevTimeNearPayload = 0.;
}

// ---------------------------------- //
// Wait for enough players to start the game
WaitForPlayers(S_NbPlayersPerTeamMin);

// ---------------------------------- //
// Close Gates after warm-up
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.ManualClosed = True;
	MapLandmark.Gauge.ValueReal = 1.;
}

// ---------------------------------- //
// New round sound
StartTime = Now + S_RespawnTime;
UIManager.UIAll.CountdownEndTime = StartTime + C_SetupPhaseDuration;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

LastPayloadInteractionTime = UIManager.UIAll.CountdownEndTime;
if (S_AllowPayloadReversing) UISetLastPushTime(LastPayloadInteractionTime);

Message::SendBigMessage(
	TL::Compose("%1 "^MB_SectionRoundNb + 1^" / "^S_NbRoundsPerTeam * 2, _("Round")),
	3000, 0, CUIConfig::EUISound::StartRound, 0
);
Message::SendStatusMessage(TL::Compose(_("$<%1$> is attacking!"), Teams[G_AttackingClan - 1].ColorizedName), 3000, 0);

// Setup the time limit
if (S_TimeLimit > 0) EndTime = UIManager.UIAll.CountdownEndTime + S_TimeLimit * 1000;
else EndTime = -1;

// Apply custom interface
Layers::Attach("Payload:Interface");
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
// ---------------------------------- //
// Preparation phase countdown as opening first Sector Gates
if (IsPreparationPhase) foreach (MapLandmark in MapLandmarks_Gate) {
	if (MapLandmark.Order > 1) continue;
	if (C_SetupPhaseDuration > 0) MapLandmark.Gauge.ValueReal = ML::Clamp(
		ML::ToReal(UIManager.UIAll.CountdownEndTime - Now) / C_SetupPhaseDuration + .01, 0., 1.
	);
}

// ---------------------------------- //
// Stop the preparation phase
if (IsPreparationPhase && Now >= UIManager.UIAll.CountdownEndTime) {
	UIManager.UIAll.CountdownEndTime = -1;
	CurSectorStartTime = Now;
	IsPreparationPhase = False;
	
	// ---------------------------------- //
	// Match beginning sound
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::PlayerInfo, 
		Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartMatch, 1
	);
	
	// ---------------------------------- //
	// Open the first Sector Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		if (MapLandmark.Order > 1) continue;
		MapLandmark.Gate.ManualClosed = False;
		MapLandmark.Gauge.ValueReal = 0.;
	}
}

// ---------------------------------- //
// Manage player functions
foreach (Player in Players) {
	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);
		
		// ---------------------------------- //
		// Select player spawn
		declare SpawnSector = ML::Min(G_CapturedSectors + 1, G_CurMapTotalNbSectors);
		declare SpawnTag = "SpawnAtk";
		if (Player.CurrentClan != G_AttackingClan) SpawnTag = "SpawnDef";
		declare PlayerSpawn <=> Map::GetPlayerSpawn(SpawnTag, SpawnSector);
		
		// ---------------------------------- //
		// Spawn player
		if (PlayerSpawn != Null) SM::SpawnPlayer(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
	}
}

// ---------------------------------- //
// Get the amount of players who push the Payload
NbAttackersPushingPayload = 0;
NbDefendersStoppingPayload = 0;

foreach (Player in Players) {
	if (IsPreparationPhase) break;
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || Player.Position == <0., 0., 0.>) continue;
	if (ML::Distance(Player.Position, G_PayloadPosition) > C_PayloadActivationRadius) continue;
	
	if (Player.CurrentClan == G_AttackingClan) NbAttackersPushingPayload += 1;
	else NbDefendersStoppingPayload += 1;
	
	// ---------------------------------- //
	// Attack points
	if (Player.CurrentClan != G_AttackingClan) continue;
	declare Real TimeNearPayload for Player;
	declare Real PrevTimeNearPayload for Player;
	TimeNearPayload += 1000. / C_ScriptTicksPerSecond;
	
	if (TimeNearPayload - PrevTimeNearPayload > C_PayloadTimePerPoint) {
		PrevTimeNearPayload = TimeNearPayload;
		Score::AddPoints(Player, 1);
		TopScores::AddPoints(Player.Score, "Attack", 1);
	}
}

// UI
if (NbDefendersStoppingPayload <= 0) UISetNbPlayersPushingPayload(NbAttackersPushingPayload);
else UISetNbPlayersPushingPayload(0);

// ---------------------------------- //
// Move Payload along its route
if (G_CapturedSectors < G_CurMapTotalNbSectors && NbAttackersPushingPayload >= 1 && NbDefendersStoppingPayload <= 0) {
	declare PayloadSpeed = ML::Min(NbAttackersPushingPayload, C_PayloadMaxPlayersPushing) * C_PayloadSpeedPerPlayer;
	
	// Update last push time
	if (S_AllowPayloadReversing) {
		LastPayloadInteractionTime = Now;
		UISetLastPushTime(LastPayloadInteractionTime);
	}
	
	// Increase travelled distance
	G_PayloadTrackCurrentDist += PayloadSpeed / C_ScriptTicksPerSecond;
	if (G_PayloadTrackCurrentDist > G_PayloadTrackTotalDist) G_PayloadTrackCurrentDist = G_PayloadTrackTotalDist;
}

// ---------------------------------- //
// Moving Payload backwards if noone pushed it for enough time
if (S_AllowPayloadReversing && Now > LastPayloadInteractionTime + C_PayloadReversingTimeLimit && G_PayloadTrackCurrentDist > PrevCheckpointDistance) {
	G_PayloadTrackCurrentDist -= C_PayloadReversingSpeed / C_ScriptTicksPerSecond;
	
	if (G_PayloadTrackCurrentDist <= PrevCheckpointDistance) {
		G_PayloadTrackCurrentDist = PrevCheckpointDistance;
		UISetLastPushTime(-1);
	}
}

// ---------------------------------- //
// Payload distance has changed
if (PrevPayloadDistance != G_PayloadTrackCurrentDist) {
	PrevPayloadDistance = G_PayloadTrackCurrentDist;
	
	// Update distance on the UI
	UISetPayloadDistance(G_PayloadTrackCurrentDist);
	
	// Update the Payload position
	G_PayloadPosition = GetPayloadPosition(G_PayloadTrackCurrentDist);
	SetObjectsPosition(PayloadStructureObjects, G_PayloadPosition);
	
	MiniMap::SetMarker("Payload", "Ball.png", Teams[G_AttackingClan - 1].ColorPrimary, G_PayloadPosition);
	
	// ---------------------------------- //
	// Attacker captured a Checkpoint
	if (PrevPayloadDistance >= NextCheckpointDistance) {
		G_CapturedSectors += 1;
		UpdateBasesColors();
		
		// Give point for the attacking team
		ClanScores[G_AttackingClan] += 1;
		MM_SetScores([ClanScores[1], ClanScores[2]]);
		
		// ---------------------------------- //
		// Get parameters for the next Sector
		if (G_CapturedSectors < G_CurMapTotalNbSectors) {
			PrevCheckpointDistance = NextCheckpointDistance;
			NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors + 1];
			
			Message::SendBigMessage(TL::Compose(
				_("%1 captured %2 checkpoints"), Teams[G_AttackingClan - 1].ColorizedName, TL::ToText(G_CapturedSectors)),
				3000, 0, CUIConfig::EUISound::Capture, 0
			);
			
			// ---------------------------------- //
			// Extend the time limit
			CurSectorStartTime = Now;
			if (S_TimeLimit > 0) EndTime = CurSectorStartTime + S_TimeLimit * 1000;
		}
		// ---------------------------------- //
		// Stop the round
		else {
			MB_StopRound = True;
			Message::SendBigMessage(TL::Compose(
				_("$<%1$> captured the last pole."), Teams[G_AttackingClan - 1].ColorizedName),
				3000, 0, CUIConfig::EUISound::VictoryPoint, 0
			);
		}
	}
	
	// Get the current Checkpoint progres
	declare CheckpointProgres = (PrevPayloadDistance - PrevCheckpointDistance) / (NextCheckpointDistance - PrevCheckpointDistance);
	
	// ---------------------------------- //
	// Show Payload progress on Checkpoints gauges
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag != "Checkpoint") continue;
		
		if (MapLandmark.Order <= G_CapturedSectors) {
			MapLandmark.Gauge.ValueReal = 1.;
			MapLandmark.Gauge.Captured = True;
		}
		else if (MapLandmark.Order == G_CapturedSectors + 1) MapLandmark.Gauge.ValueReal = CheckpointProgres;
		else MapLandmark.Gauge.ValueReal = 0.;
	}
	
	// ---------------------------------- //
	// Show Payload progress as opening Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		if (MapLandmark.Tag != "Gate" || MapLandmark.Order < 2) continue;
		
		MapLandmark.Gate.ManualClosed = MapLandmark.Order > G_CapturedSectors;
		if (MapLandmark.Order > G_CapturedSectors + 1) MapLandmark.Gauge.ValueReal = 1.;
		else if (MapLandmark.Gate.ManualClosed) MapLandmark.Gauge.ValueReal = 1. - CheckpointProgres;
		else MapLandmark.Gauge.ValueReal = 0.;
	}
}

// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit && UIManager.UIAll.CountdownEndTime <= 0) {
	CurrentTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) EndTime = CurSectorStartTime + S_TimeLimit * 1000;
	else EndTime = -1;
}

// ---------------------------------- //
// Payload reversing setting change
if (PrevAllowPayloadReversing != S_AllowPayloadReversing) {
	PrevAllowPayloadReversing = S_AllowPayloadReversing;
	
	if (!S_AllowPayloadReversing) UISetLastPushTime(-1);
	else LastPayloadInteractionTime = Now;
}

// ---------------------------------- //
// Victory conditions
if (EndTime > 0 && Now > EndTime) MB_StopRound = True;
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***EndRound***
***
SM::UnspawnAllPlayers();

// ---------------------------------- //
// Set the round winner
declare RoundWinner = 0;
if (!MB_StopMap && !MatchEndRequested) {
	if (G_CapturedSectors >= G_CurMapTotalNbSectors) RoundWinner = G_AttackingClan;
	else RoundWinner = 3 - G_AttackingClan;
}

MB_Sleep(3000);

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (ObjectId in PayloadStructureObjects) {
	if (!Objects.existskey(ObjectId)) continue;
	ObjectDestroy(Objects[ObjectId]);
}
PayloadStructureObjects.clear();

Layers::Detach("Payload:Interface");
Message::CleanBigMessages();

// Destroy Payload marker
MiniMap::DestroyMarker("Payload");
UIManager.UIAll.MarkersXML = "";

// ---------------------------------- //
// Show the winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

declare Msg = _("|Match|Draw");
if (RoundWinner != 0) Msg = TL::Compose(_("$<%1$> wins the round!"), Teams[RoundWinner - 1].ColorizedName);
Message::SendBigMessage(Msg, 6000, 0, CUIConfig::EUISound::EndRound, 0);

MB_Sleep(6000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Map end conditions
if (MB_SectionRoundNb >= S_NbRoundsPerTeam * 2) MB_StopMatch = True;
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMapBeforeCloseLadder***
***
// ---------------------------------- //
// Play Sudden Death mode in case there is a draw
if (ClanScores[1] > 0 && ClanScores[1] == ClanScores[2]) {
	// ---------------------------------- //
	// Open all Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		MapLandmark.Gate.Automatic = False;
		MapLandmark.Gate.ManualClosed = False;
		MapLandmark.Gauge.ValueReal = 0.;
	}
	
	// Award one point to the winner
	declare SuddenDeathWinner = GT_SuddenDeath(
		Map::GetLandmarkPlayerSpawn("SpawnAtk", 1),
		Map::GetLandmarkPlayerSpawn("SpawnDef", 1)
	);
	ClanScores[SuddenDeathWinner] += 1;
}
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
Layers::Destroy("Payload:Interface");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get Payload position according to the given distance
 *
 *	@param	_RawDistance	The distance the Payload has travelled
 *
 *	@return		The position the Payload should appear at
 */
Vec3 GetPayloadPosition(Real _RawDistance) {
	if (G_PayloadTrackTotalDist <= 0 || G_PayloadTrackPointsDist.count < 2) return Vec3;
	
	// Clamp the distance to fit between 0 and total Payload route length
	declare Distance = ML::Clamp(_RawDistance, 0., G_PayloadTrackTotalDist);
	
	// A point exists exactly at the given distance
	if (G_PayloadTrackPointsDist.exists(Distance)) return G_PayloadTrackPointsDist.keyof(Distance);
	
	// ---------------------------------- //
	// Get the segment start and end positions and distances
	declare SegmentStartPosn = Vec3;
	declare SegmentStartDist = 0.;
	declare SegmentEndPosn = Vec3;
	declare SegmentEndDist = 0.;
	declare PrevPointPosn = Vec3;
	declare PrevPointDist = 0.;
	
	foreach (PointPosition => PointDistance in G_PayloadTrackPointsDist) {
		if (PointDistance >= Distance) {
			SegmentStartPosn = PrevPointPosn;
			SegmentStartDist = PrevPointDist;
			SegmentEndPosn = PointPosition;
			SegmentEndDist = PointDistance;
			break;
		}
		PrevPointPosn = PointPosition;
		PrevPointDist = PointDistance;
	}
	
	// Percentage progress on completing the route segment
	declare SegmentOffset = (Distance - SegmentStartDist) / (SegmentEndDist - SegmentStartDist);
	
	// Compute the final position
	declare Vec3 PayloadPosition;
	for (I, 0, 2) PayloadPosition[I] = SegmentStartPosn[I] + (SegmentEndPosn[I] - SegmentStartPosn[I]) * SegmentOffset;
	return PayloadPosition;
}

// ---------------------------------- //
/// Update colors of all used landmarks
Void UpdateBasesColors() {
	foreach (MapLandmark in MapLandmarks) {
		// ---------------------------------- //
		// Colorize Checkpoints and defense Spawns
		if (MapLandmark.Tag == "Checkpoint" || MapLandmark.Tag == "SpawnDef") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors) Clan = G_AttackingClan;
			
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;
			if (MapLandmark.Gauge != Null) MapLandmark.Gauge.Clan = G_AttackingClan;
		}
		
		// ---------------------------------- //
		// Colorize attackers Spawns and Gates
		if (MapLandmark.Tag == "SpawnAtk" || MapLandmark.Tag == "Gate") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors + 1) Clan = G_AttackingClan;
			
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;
			if (MapLandmark.Gauge != Null) MapLandmark.Gauge.Clan = Clan;
		}
	}
}

// ---------------------------------- //
/** Set poition of a group of objects
 *
 *	@param	_Objects	The objects to set position
 *	@param	_Position	Target position
 */
Void SetObjectsPosition(Ident[] _Objects, Vec3 _Position) {
	if (_Objects.count <= 0) return;
	
	foreach (ObjectId in _Objects) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object = Objects[ObjectId];
		
		if (_Position == <0., 0., 0.>) Object.SetUnspawned();
		else Object.SetPosition(_Position); 
	}
}

// ---------------------------------- //
/** Wait for enough players to play
 *
 *	@param	_MinimumNbPlayers	The number of players to wait in each clan before starting the map
 */
Void WaitForPlayers(Integer _MinimumNbPlayers) {
	// ---------------------------------- //
	// Initialize
	declare OldSequence = UIManager.UIAll.UISequence;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	declare HasWaited = False;
	declare WasPause = False;
	StartTime = Now;
	
	foreach (Player in AllPlayers) SetPlayerClan(Player, GT_GetRequestedClan(Player));
	
	// ---------------------------------- //
	// Initialize objects
	GalaxyTitles::ResetAll();
	GalaxyTitles::InitObjects();
	
	// ---------------------------------- //
	// Waiting for players play loop
	while (!ServerShutdownRequested && !MatchEndRequested) {
		MB_Yield();
		
		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		
		// Stop waiting if there are enough players to start the game
		if (ClansNbPlayers[1] >= _MinimumNbPlayers && ClansNbPlayers[2] >= _MinimumNbPlayers && !CupAdmin::IsCupPaused()) break;
		
		// ---------------------------------- //
		// Display big message
		if (!HasWaited) {
			UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
			
			if (CupAdmin::IsCupPaused()) {
				Translations::SetStatusMessage("Competition has been paused");
				UIManager.UIAll.BigMessage = TL::Compose("$F90%1", _("Pause"));
				WasPause = True;
			}
			else UIManager.UIAll.BigMessage = _("Waiting for players in each team...");
			
			HasWaited = True;
		}
		
		GalaxyTitles::SpawnObjects();
		GT_UnspawnPlayersChangingClan();
		WarmUp2::ManageEvents();
		
		// ---------------------------------- //
		// Spawn players
		foreach (Player in Players) {
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
			
			// ---------------------------------- //
			// Initialize player
			SetPlayerClan(Player, GT_GetRequestedClan(Player));
			Player.ArmorMax = ML::Max(1, ML::Min(S_PlayerArmorPoints, 10)) * 100;
			Player.StaminaMax = C_PlayerStaminaMax;
			
			// Spawn player
			if (Player.CurrentClan == 0) continue;
			declare CSmMapPlayerSpawn PlayerSpawn;
			if (Player.CurrentClan == G_AttackingClan) PlayerSpawn <=> Map::GetPlayerSpawn("SpawnAtk", 1);
			else PlayerSpawn <=> Map::GetPlayerSpawn("SpawnDef", 1);
			if (PlayerSpawn != Null) SM::SpawnPlayer(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
		}
	}
	
	StartTime = -1;
	
	// ---------------------------------- //
	// Player joined the game
	if (HasWaited) {
		SM::UnspawnAllPlayers();
		GalaxyTitles::ResetAll();
		
		if (!ServerShutdownRequested && !MatchEndRequested) {
			declare Message = _("A new player joins the game.");
			if (WasPause) Message = "Competition has been resumed!";
			
			Translations::SendBigMessage(Message, 5000, 0, CUIConfig::EUISound::Default, 0);
			MB_Sleep(5000);
		}
	}
	
	// ---------------------------------- //
	// Revert changes
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.UISequence = OldSequence;
	---UpdateClublinks---
}

// ---------------------------------- //
/** Set UI Checkpoints distances
 *
 *	@param	_CPDistances	Checkpoints distances
 */
Void UISetCheckpointsDistances(Real[Integer] _CPDistances) {
	declare netwrite Real[] Net_Payload_CheckpointDistances for Teams[0];
	Net_Payload_CheckpointDistances.clear();
	foreach (Distance in _CPDistances) Net_Payload_CheckpointDistances.add(Distance);
	Net_Payload_CheckpointDistances = Net_Payload_CheckpointDistances.sort();
}

// ---------------------------------- //
/** Set UI Payload distance
 *
 *	@param	_PayloadDistance	Payload distance
 */
Void UISetPayloadDistance(Real _PayloadDistance) {
	declare netwrite Real Net_Payload_PayloadDistance for Teams[0];
	Net_Payload_PayloadDistance = ML::Clamp(_PayloadDistance, 0., G_PayloadTrackTotalDist);
}

// ---------------------------------- //
/** Set UI attacking team
 *
 *	@param	_AttackingTeam		Currently attacking team
 */
Void UISetAttackingTeam(Integer _AttackingTeam) {
	declare netwrite Integer Net_Payload_AttackingTeam for Teams[0];
	Net_Payload_AttackingTeam = ML::Clamp(_AttackingTeam, 1, 2);
}

// ---------------------------------- //
/** Set UI amount of attackers pushing Payload
 *
 *	@param	_PlayersNb		Players pushing Payload
 */
Void UISetNbPlayersPushingPayload(Integer _PlayersNb) {
	declare netwrite Integer Net_Payload_NbPlayersPushingPayload for Teams[0];
	Net_Payload_NbPlayersPushingPayload = ML::Max(0, _PlayersNb);
}

Void UISetLastPushTime(Integer _Time) {
	declare netwrite Integer Net_Payload_LastPushTime for Teams[0];
	Net_Payload_LastPushTime = _Time;
}

// ---------------------------------- //
/** Create manialink for the Payload Interface
 *
 *	@return		The manialink
 */
Text CreateManialinkPayloadUI() {
	declare Text SectorBarFrames;
	for (I, 0, C_MapMaximumNbSectors - 1) SectorBarFrames ^= "<frameinstance modelid='FrameModel_Sector' id='Frame_SectorProgress#"^I^"' />";
	
	return """
<manialink version="2" name="Payload:Interface">
<stylesheet>
	<style id="Label_PayloadMarker" textsize="2" textcolor="FFF" textfont="Eurostile" />
	<style class="CircGauge" sizen="16 16" halign="center" valign="center" colorize="FFF" />
</stylesheet>

<framemodel id="FrameModel_Sector">
	<gauge posn="-2" sizen="0 8" valign="center" drawbg="0" id="Gauge_CPProgress" />
</framemodel>

<frame id="Frame_PayloadProgress" posn="0 78" hidden="1">
	<quad sizen="135.875 8" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadProgressBar.png" />
	<frame posn="-60 .3 1">{{{SectorBarFrames}}}</frame>
	<quad posn="-63 0 1" sizen="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemLeft" />
	<quad posn="63 0 1" sizen="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemRight" />
	
	<frame id="Frame_PayloadMarker" posn="0 -7" hidden="1">
		<quad posn="0 0 -1" sizen="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadMarker.png" />
		<label posn="0 -1.25" sizen="5 5" halign="center" valign="center2" id="Label_PayloadMarker" text="0" />
		
		<frame posn="0 -1.3" scale=".4">
			<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeBg.png" id="Quad_GaugeBg" />
			<frame posn="0 0 1" clip="1" clipposn="4" clipsizen="8 16">
				<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeL" hidden="1" />
			</frame>
			<frame posn="0 0 1" clip="1" clipposn="-4" clipsizen="8 16">
				<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeR" hidden="1" rot="180" />
			</frame>
		</frame>
	</frame>
</frame>

<label id="Label_DistanceDebug" scale="0" />

<script><!--
/**
 *	Payload: Interface
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_TotalProgressBarWidth	120.
#Const C_GaugeBarsSpacing		.5

{{{Manialink::Animations(["EaseOutSine"])}}}
{{{ManialinkTools::Functions(["SetGaugeRatio"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_PayloadProgress <=> (Page.GetFirstChild("Frame_PayloadProgress") as CMlFrame);
	declare Quad_EmblemLeft <=> (Page.GetFirstChild("Quad_EmblemLeft") as CMlQuad);
	declare Quad_EmblemRight <=> (Page.GetFirstChild("Quad_EmblemRight") as CMlQuad);
	declare Frame_PayloadMarker <=> (Page.GetFirstChild("Frame_PayloadMarker") as CMlFrame);
	declare Label_PayloadMarker <=> (Page.GetFirstChild("Label_PayloadMarker") as CMlLabel);
	declare Label_DistanceDebug <=> (Page.GetFirstChild("Label_DistanceDebug") as CMlLabel);
	declare Quad_GaugeBg <=> (Page.GetFirstChild("Quad_GaugeBg") as CMlQuad);
	declare Quad_GaugeL <=> (Page.GetFirstChild("Quad_GaugeL") as CMlQuad);
	declare Quad_GaugeR <=> (Page.GetFirstChild("Quad_GaugeR") as CMlQuad);
	
	declare CMlFrame[] Frame_SectorProgress;
	for (I, 0, {{{C_MapMaximumNbSectors - 1}}}) Frame_SectorProgress.add((Page.GetFirstChild("Frame_SectorProgress#"^I) as CMlFrame));
	
	// ---------------------------------- //
	// Netcode
	declare netread Real[] Net_Payload_CheckpointDistances for Teams[0];
	declare netread Real Net_Payload_PayloadDistance for Teams[0];
	declare netread Integer Net_Payload_AttackingTeam for Teams[0];
	declare netread Integer Net_Payload_NbPlayersPushingPayload for Teams[0];
	declare netread Integer Net_Payload_LastPushTime for Teams[0];
	
	// Wait for at least one checkpoint distance
	wait(Net_Payload_CheckpointDistances.count > 0);
	
	// ---------------------------------- //
	// Variables
	declare SpacingSub = (Net_Payload_CheckpointDistances.count - 1) * C_GaugeBarsSpacing;
	declare TotalDistance = Net_Payload_CheckpointDistances[Net_Payload_CheckpointDistances.count - 1];
	declare UpdateColors = True;
	declare GaugeRatio = 0.;
	
	/// Update
	declare PrevPayloadDistance = -1.;
	declare PrevAnimDistance = -1.;
	declare PrevAttackingTeam = -1;
	declare PrevAttackingTeamColor = Vec3;
	declare PrevCheckpointDistance = 0.;
	declare PrevFramePosX = 0.;
	declare PrevPlayersPushingPayload = -1;
	declare PrevGaugeRatio = -1.;
	
	// ---------------------------------- //
	// Compute 
	foreach (I => Frame in Frame_SectorProgress) {
		Frame.Visible = Net_Payload_CheckpointDistances.existskey(I);
		if (!Frame.Visible) continue;
		
		declare CurCPDistance = Net_Payload_CheckpointDistances[I];
		declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
		
		Gauge_CPProgress.Size.X = (C_TotalProgressBarWidth - SpacingSub) * (CurCPDistance - PrevCheckpointDistance) / TotalDistance + 4;
		Frame.RelativePosition.X = PrevFramePosX;
		PrevFramePosX += Gauge_CPProgress.Size.X - 4 + C_GaugeBarsSpacing;
		PrevCheckpointDistance = CurCPDistance;
	}
	
	Frame_PayloadProgress.Show();
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		// ---------------------------------- //
		// Payload marker visibility
		Frame_PayloadMarker.Visible = Net_Payload_PayloadDistance < TotalDistance;
		
		// ---------------------------------- //
		// Payload distance has changed
		if (PrevPayloadDistance != Net_Payload_PayloadDistance) {
			PrevPayloadDistance = Net_Payload_PayloadDistance;
			
			LibManialink_AnimStop(Label_DistanceDebug);
			LibManialink_Anim(Label_DistanceDebug, "<label scale='"^PrevPayloadDistance^"' />", 125, "EaseLinear");
		}
		
		// ---------------------------------- //
		// Update Payload marker animated position
		if (PrevAnimDistance != Label_DistanceDebug.RelativeScale) {
			PrevAnimDistance = Label_DistanceDebug.RelativeScale;
			
			PrevCheckpointDistance = 0.;
			declare AllSegmentsDist = 0.;
			
			Frame_PayloadMarker.RelativePosition.X = C_TotalProgressBarWidth * PrevAnimDistance / TotalDistance - C_TotalProgressBarWidth / 2;
			
			foreach (I => Frame in Frame_SectorProgress) {
				if (!Frame.Visible) continue;
				
				declare CurCPDistance = Net_Payload_CheckpointDistances[I];
				declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
				
				declare Ratio = 0.;
				if (Net_Payload_PayloadDistance >= CurCPDistance) Ratio = 1.;
				else Ratio = ML::Clamp((PrevAnimDistance - AllSegmentsDist) / (CurCPDistance - AllSegmentsDist),	0., 1.
				);
				
				SetGaugeRatio(Gauge_CPProgress, Ratio);
				
				AllSegmentsDist += CurCPDistance - PrevCheckpointDistance;
				PrevCheckpointDistance = CurCPDistance;
			}
			
			if (PrevPayloadDistance >= TotalDistance) Quad_EmblemRight.Substyle = "#"^Net_Payload_AttackingTeam;
		}
		
		// ---------------------------------- //
		// Attacking team has changed
		if (PrevAttackingTeam != Net_Payload_AttackingTeam) {
			PrevAttackingTeam = Net_Payload_AttackingTeam;
			UpdateColors = True;
		}
		
		// ---------------------------------- //
		// Attacking team color changed
		foreach (I => Team in Teams) {
			if (I != Net_Payload_AttackingTeam - 1) continue;
			if (Team.ColorPrimary == PrevAttackingTeamColor) continue;
			UpdateColors = True;
			PrevAttackingTeamColor = Team.ColorPrimary;
		}
		
		// ---------------------------------- //
		// Amount of players pushing Payload changed
		if (PrevPlayersPushingPayload != Net_Payload_NbPlayersPushingPayload) {
			PrevPlayersPushingPayload = Net_Payload_NbPlayersPushingPayload;
			if (PrevPlayersPushingPayload > 0) GaugeRatio = 1.;
			Label_PayloadMarker.SetText(TL::ToText(PrevPlayersPushingPayload));
		}
		
		// ---------------------------------- //
		// Set reversing time limit gauge ratio
		if (PrevPlayersPushingPayload <= 0) {
			GaugeRatio = 0.;
			if (Net_Payload_LastPushTime > 0) {
				GaugeRatio = 1 - ML::Clamp(ML::ToReal(GameTime - Net_Payload_LastPushTime) / {{{C_PayloadReversingTimeLimit}}}, 0., 1.);
				if (GaugeRatio <= 0 && Net_Payload_PayloadDistance > 0) Label_PayloadMarker.SetText("<");
			}
			else Label_PayloadMarker.SetText("0");
		}
		
		// ---------------------------------- //
		// Reversing time limit gauge
		if (PrevGaugeRatio != GaugeRatio) {
			PrevGaugeRatio = GaugeRatio;
			
			// ---------------------------------- //
			// Set ratio
			Quad_GaugeR.RelativeRotation = 180 - ML::Clamp(GaugeRatio * 360., 0., 180.);
			Quad_GaugeL.RelativeRotation = 360 - ML::Clamp((GaugeRatio - .5) * 360., 0., 180.);
			Quad_GaugeR.Visible = GaugeRatio > 0;
			Quad_GaugeL.Visible = GaugeRatio > .5;
			
			// ---------------------------------- //
			// Set gauge image
			declare Image = "CircGaugeProg.png";
			if (GaugeRatio >= 1) Image = "CircGaugeFull.png";
			Quad_GaugeL.ImageUrl = "{{{C_ImgBase}}}"^Image;
			Quad_GaugeR.ImageUrl = Quad_GaugeL.ImageUrl;
		}
		
		// ---------------------------------- //
		// Update interface colors
		if (UpdateColors) {
			UpdateColors = False;
			declare Clan = ML::Clamp(Net_Payload_AttackingTeam, 1, 2);
			
			foreach (I => Frame in Frame_SectorProgress) {
				if (!Frame.Visible) continue;
				declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
				Gauge_CPProgress.Color = PrevAttackingTeamColor;
			}
			
			Quad_EmblemLeft.Substyle = "#"^Net_Payload_AttackingTeam;
			Quad_EmblemRight.Substyle = "#"^3-Net_Payload_AttackingTeam;
			
			Quad_GaugeBg.Colorize = PrevAttackingTeamColor;
			Quad_GaugeL.Colorize = PrevAttackingTeamColor;
			Quad_GaugeR.Colorize = PrevAttackingTeamColor;
		}
		
		LibManialink_AnimLoop();
		yield;
	}
}
--></script>
</manialink>""";
}