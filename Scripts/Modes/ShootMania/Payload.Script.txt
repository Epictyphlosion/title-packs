// -------------------------------------- //
//  PAYLOAD by domino54                   //
//  script version: 2017-07-19            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes	"PayloadArena"
#Const Version		"2017-07-19"
#Const ScriptName	"Modes/ShootMania/Payload.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_NbRoundsPerTeam			1		as _("Attack rounds per team")
#Setting S_TimeLimit				300 	as _("Time limit (seconds)")
#Setting S_AllowPayloadReversing	True	as _("Allow Payload to move backwards")
#Setting S_EnableDebugMode			False	as _("Debug mode (for developers only)")

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_MapMaximumNbSectors		9		///< Maximum number of sectors the map can have
#Const C_PayloadSpeedPerPlayer		1.		///< Payload speed bonus per every additional player in m/s
#Const C_PayloadMaxPlayersPushing	3		///< Maximum Payload speed multiplier
#Const C_PayloadActivationRadius	4.		///< Radius within the Payload can be interacted with
#Const C_PayloadReversingTimeLimit	10000	///< Time after which Payload starts going backwards
#Const C_PayloadReversingSpeed		.5		///< Payload speed in m/s when going backwards
#Const C_PayloadTimePerPoint		3000	///< Time required for each attack point
#Const C_SetupPhaseDuration			15000	///< Duration of the preparation phase for defenderss

#Const Description _("TYPE: Team versus Team\nOBJECTIVE: Attacking team is pushing Payload across the map, defenders have to stop them.")

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Real G_PayloadTrackCurrentDist;			///< Distance travelled by the Payload
declare Real G_PayloadTrackTotalDist;			///< Total distance of the Payload track
declare Real[Vec3] G_PayloadTrackPointsDist;	///< All track point distances to the starting point
declare Integer G_CurMapTotalNbSectors;			///< Total number of Sectors in the current map
declare Real[Integer] G_SectorCheckpointsDist;	///< Checkpoints distances to the starting point

declare Vec3 G_PayloadPosition;		///< Current position of the Payload
declare Integer G_AttackingClan;	///< Currently attacking team
declare Integer G_CapturedSectors;	///< Number of sectors captured by the attackers
declare Boolean G_IsOvertime;		///< True, if the game is in overtime mode
declare Ident[Text] G_ObjectsIds;	///< Ids of the objects models

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Set the scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("Attack", "Atk", 2.25, 60.);
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("Payload");
ModeInfo::SetType(ModeInfo::C_Type_Teams);
ModeInfo::SetRules("1. Attackers goal is to push the Payload to the end of its route, while defenders try to stop them.\n2. Attacking team will get 1 point for every Checkpoint reached.\n3. If attackers leave Payload for enough time, it will start to slowly go backwards.\n4. After both teams have finished their attack round, the team with more points wins.\n5. If teams end up with the same score, Sudden Death mode is played to decide the winner.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Galaxy settings
// ---------------------------------- //
***GalaxyTitles_Settings***
***
GT_UseNoCollisionsStart = False;
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***Match_InitServer***
***
UseClans = True;

// Create custom interface
Layers::Create("Payload:Interface", CreateManialinkPayloadUI());
Layers::Create("Payload:Markers", CreateManialinkMarkers());
Layers::SetType("Payload:Markers", CUILayer::EUILayerType::Markers);

// Load objects
G_ObjectsIds["Payload"] = ItemList_Add("SMCommon\\Payload\\Payload.Item.gbx");

// ---------------------------------- //
// Variables
declare PayloadStructureObjects = Ident[];
declare NbAttackersPushingPayload = 0;
declare NbDefendersStoppingPayload = 0;
declare LastPayloadInteractionTime = 0;
declare IsPreparationPhase = False;
declare NextCheckpointDistance = 0.;
declare CurSectorStartTime = 0;
declare TeamsPayloadMaxDist = [0., 0., 0.];

declare PrevCheckpointDistance = 0.;
declare PrevPayloadDistance = G_PayloadTrackCurrentDist;
declare PrevAllowPayloadReversing = S_AllowPayloadReversing;
declare CurrentTimeLimit = S_TimeLimit;
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***Match_InitMap***
***
// ---------------------------------- //
// Reset map parameters
G_PayloadTrackTotalDist = 0.;
G_PayloadTrackPointsDist.clear();
G_CurMapTotalNbSectors = 0;
G_SectorCheckpointsDist.clear();
G_AttackingClan = 1;

// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;

// Map must have a BotPath for Payload route with at least 2 points on it
declare PayloadRoute <=> Map::GetBotPath("Payload", 0);
if (PayloadRoute == Null || PayloadRoute.Path.count < 2) MapValidated = False;

// ---------------------------------- //
// Map must have correct Sectors
declare Integer[] MapSectors;
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Checkpoint") continue;
	if (MapLandmark.Order > G_CurMapTotalNbSectors) G_CurMapTotalNbSectors = MapLandmark.Order;
	if (!MapSectors.exists(MapLandmark.Order)) MapSectors.add(MapLandmark.Order);
}
for (I, 1, G_CurMapTotalNbSectors) if (!MapSectors.exists(I)) { MapValidated = False; break; }

// ---------------------------------- //
// Map must have one Checkpoint, SpawnAtk and SpawnDef per Sector
for (Sector, 1, G_CurMapTotalNbSectors) {
	declare Checkpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
	declare SpawnAtk <=> Map::GetLandmarkPlayerSpawn("SpawnAtk", Sector);
	declare SpawnDef <=> Map::GetLandmarkPlayerSpawn("SpawnDef", Sector);
	if (Checkpoint == Null || SpawnAtk == Null || SpawnDef == Null) { MapValidated = False; break; }
}

// At least one Gate in front of first SpawnAtk
if (Map::GetLandmarkGate("Gate", 1) == Null) MapValidated = False;

// ---------------------------------- //
// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Start map
// ---------------------------------- //
***Match_StartMap***
***
TeamsPayloadMaxDist = [0., 0., 0.];
Layers::Attach("Payload:Interface");

// ---------------------------------- //
// Get the complete data about the Payload track
declare Vec3 PrevPointpos;
foreach (I => Point in PayloadRoute.Path) {
	declare Distance = 0.;
	if (I > 0) Distance = ML::Distance(PrevPointpos, Point);
	
	G_PayloadTrackTotalDist += Distance;
	G_PayloadTrackPointsDist[Point] = G_PayloadTrackTotalDist;
	PrevPointpos = Point;
}

// ---------------------------------- //
// Compute distances at which the Checkpoints will get TRIGGERED
for (Sector, 1, G_CurMapTotalNbSectors) {
	declare CurSectorCheckpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
	
	// ---------------------------------- //
	// Get distances to all points
	declare Real[Vec3] PathPointsDistances;
	foreach (Point in PayloadRoute.Path) PathPointsDistances[Point] = ML::Distance(CurSectorCheckpoint.Position, Point);
	PathPointsDistances = PathPointsDistances.sort();
	
	// ---------------------------------- //
	// Get 2 nearest points to the Checkpoint
	declare Vec3[Real] NearestPoints;
	declare PrevPointpos = Vec3;
	declare PointsDistance = 0.;
	declare I = 0;
	
	foreach (Position => Distance in PathPointsDistances) {
		if (I >= 2) break;
		if (I == 1) PointsDistance = ML::Distance(PrevPointpos, Position);
		NearestPoints[G_PayloadTrackPointsDist[Position]] = Position;
		PrevPointpos = Position;
		I += 1;
	}
	NearestPoints = NearestPoints.sortkey();
	
	// ---------------------------------- //
	// Get Checkpoint distance to both points
	declare Real StartPointDist;
	declare Real StartPointPayloadDist;
	declare Real EndPointDist;
	declare Real EndPointPayloadDist;
	
	I = 0;
	foreach (PayloadDist => Position in NearestPoints) {
		declare Distance = ML::Distance(CurSectorCheckpoint.Position, Position);
		switch (I) {
			case 0 : {
				StartPointDist = Distance;
				StartPointPayloadDist = PayloadDist;
			}
			case 1 : {
				EndPointDist = Distance;
				EndPointPayloadDist = PayloadDist;
			}
		}
		I += 1;
	}
	
	// ---------------------------------- //
	// Checkpoint is beyond both points
	if (ML::Pow(StartPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(EndPointDist, 2.))) {
		G_SectorCheckpointsDist[Sector] = ML::Min(EndPointPayloadDist, G_PayloadTrackTotalDist);
		continue;
	}
	
	// ---------------------------------- //
	// Checkpoint is (somehow) behind points
	if (ML::Pow(EndPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(StartPointDist, 2.))) {
		G_SectorCheckpointsDist[Sector] = ML::Max(StartPointPayloadDist, 0.);
		continue;
	}
	
	// ---------------------------------- //
	// Checkpoint is between two points
	declare Ratio = StartPointDist / (StartPointDist + EndPointDist);
	G_SectorCheckpointsDist[Sector] = StartPointPayloadDist + Ratio * (EndPointPayloadDist - StartPointPayloadDist);
}

// Send Checkpoints data to the UI
UISetCheckpointsDistances(G_SectorCheckpointsDist);
***

// ---------------------------------- //
// Initialize round
// ---------------------------------- //
***Match_InitRound***
***
UISetNbPlayersPushingPayload(0);
UISetLastPushTime(-1);
G_CapturedSectors = 0;
IsPreparationPhase = True;
NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors + 1];
PrevCheckpointDistance = 0.;
PrevPayloadDistance = -1.;

G_IsOvertime = False;
UISetIsOvertime(G_IsOvertime);

// Swap the currently attacking team
G_AttackingClan = 3 - G_AttackingClan;
UISetAttackingTeam(G_AttackingClan);

// Reset Payload distance
G_PayloadTrackCurrentDist = 0.;
UISetPayloadDistance(0.);

UpdateBasesColors();

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (ObjectId in PayloadStructureObjects) {
	if (!Objects.existskey(ObjectId)) continue;
	ObjectDestroy(Objects[ObjectId]);
}
PayloadStructureObjects.clear();

// ---------------------------------- //
// Create new Payload structure objects
PayloadStructureObjects.add(ObjectCreate(G_ObjectsIds["Payload"]).Id);

// Reset the payload position
G_PayloadPosition = GetPayloadPosition(G_PayloadTrackCurrentDist);
SetObjectsPosition(PayloadStructureObjects, G_PayloadPosition);

// ---------------------------------- //
// Decapture all used Gauges
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Checkpoint") continue;
	MapLandmark.Gauge.ValueReal = 0.;
	MapLandmark.Gauge.Captured = False;
}

// ---------------------------------- //
// Deautomatize Gates used on the map
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.Automatic = False;
	MapLandmark.Gate.ManualClosed = False;
	MapLandmark.Gate.Clan = 0;
	MapLandmark.Gauge.Speed = 0;
	MapLandmark.Gauge.ValueReal = 0.;
}

// ---------------------------------- //
// Reset players Payload time
foreach (Player in Players) {
	declare Real TimeNearPayload for Player;
	declare Real PrevTimeNearPayload for Player;
	TimeNearPayload = 0.;
	PrevTimeNearPayload = 0.;
}

// Wait for enough players to start the game
GT_WaitForPlayers(S_NbPlayersPerTeamMin);

// ---------------------------------- //
// Close Gates after warm-up
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.ManualClosed = True;
	MapLandmark.Gauge.ValueReal = 1.;
}

// Init objects tiers
GalaxyTitles::InitObjects();
GalaxyTitles::SetObjectsSpawnTier(G_CapturedSectors + 1);

// ---------------------------------- //
// New round sound
StartTime = Now + S_RespawnTime;
UIManager.UIAll.CountdownEndTime = StartTime + C_SetupPhaseDuration;
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

// Faster gate activation in debug mode
if (S_EnableDebugMode) UIManager.UIAll.CountdownEndTime = StartTime + 3000;

LastPayloadInteractionTime = UIManager.UIAll.CountdownEndTime;
if (S_AllowPayloadReversing) UISetLastPushTime(LastPayloadInteractionTime);

// Disable PvP
UsePvPCollisions = False;
UsePvPWeapons = False;

Message::SendBigMessage(
	TL::Compose("%1 "^MB_GetRoundCount()^" / "^S_NbRoundsPerTeam * 2, _("Round")),
	3000, 0, CUIConfig::EUISound::StartRound, 0
);
Message::SendStatusMessage(TL::Compose(_("$<%1$> is attacking!"), Teams[G_AttackingClan - 1].ColorizedName), 3000, 0);

// Setup the time limit
if (S_TimeLimit > 0) GT_SetTimeLimit(UIManager.UIAll.CountdownEndTime + S_TimeLimit * 1000);
else GT_DisableTimeLimit();
***

// ---------------------------------- //
// Play loop start
// ---------------------------------- //
***Match_StartPlayLoop***
***
Layers::Attach("Payload:Interface");
Layers::Attach("Payload:Markers");
UpdateMarkers(PayloadStructureObjects[0]);
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// ---------------------------------- //
// Preparation phase countdown as opening first Sector Gates
if (IsPreparationPhase) foreach (MapLandmark in MapLandmarks_Gate) {
	if (MapLandmark.Order > 1) continue;
	if (C_SetupPhaseDuration > 0) MapLandmark.Gauge.ValueReal = ML::Clamp(
		ML::ToReal(UIManager.UIAll.CountdownEndTime - Now) / C_SetupPhaseDuration + .01, 0., 1.
	);
}

// ---------------------------------- //
// Stop the preparation phase
if (IsPreparationPhase && Now >= UIManager.UIAll.CountdownEndTime) {
	UIManager.UIAll.CountdownEndTime = -1;
	CurSectorStartTime = Now;
	IsPreparationPhase = False;

	// Enable PvP
	UsePvPCollisions = True;
	UsePvPWeapons = True;
	
	// ---------------------------------- //
	// Match beginning sound
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::PlayerInfo, 
		Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartMatch, 1
	);
	
	// ---------------------------------- //
	// Open the first Sector Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		if (MapLandmark.Order > 1) continue;
		MapLandmark.Gate.ManualClosed = False;
		MapLandmark.Gauge.ValueReal = 0.;
	}
}

// ---------------------------------- //
// Manage player functions
foreach (Player in Players) {
	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);
		
		// ---------------------------------- //
		// Select player spawn
		declare SpawnSector = ML::Min(G_CapturedSectors + 1, G_CurMapTotalNbSectors);
		declare SpawnTag = "SpawnAtk";
		if (Player.CurrentClan != G_AttackingClan) SpawnTag = "SpawnDef";
		declare PlayerSpawn <=> Map::GetPlayerSpawn(SpawnTag, SpawnSector);
		
		// ---------------------------------- //
		// Spawn player
		if (PlayerSpawn != Null) SM::Spawn(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
	}
}

// ---------------------------------- //
// Get the amount of players who push the Payload
NbAttackersPushingPayload = 0;
NbDefendersStoppingPayload = 0;

foreach (Player in Players) {
	if (IsPreparationPhase) break;
	if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || Player.Position == <0., 0., 0.>) continue;
	if (ML::Distance(Player.Position, G_PayloadPosition) > C_PayloadActivationRadius) continue;
	
	if (Player.CurrentClan == G_AttackingClan) NbAttackersPushingPayload += 1;
	else NbDefendersStoppingPayload += 1;
	
	// ---------------------------------- //
	// Attack points
	if (Player.CurrentClan != G_AttackingClan) continue;
	declare Real TimeNearPayload for Player;
	declare Real PrevTimeNearPayload for Player;
	TimeNearPayload += 1000. / C_ScriptTicksPerSecond;
	
	if (TimeNearPayload - PrevTimeNearPayload > C_PayloadTimePerPoint) {
		PrevTimeNearPayload = TimeNearPayload;
		Scores::AddPlayerRoundPoints(Player.Score, 1);
		TopScores::AddPoints(Player.Score, "Attack", 1);
	}
}

// UI
if (NbDefendersStoppingPayload <= 0) UISetNbPlayersPushingPayload(NbAttackersPushingPayload);
else UISetNbPlayersPushingPayload(0);

// ---------------------------------- //
// Move Payload along its route
if (G_CapturedSectors < G_CurMapTotalNbSectors && NbAttackersPushingPayload > NbDefendersStoppingPayload) {
	declare PayloadSpeed = ML::Min(NbAttackersPushingPayload, C_PayloadMaxPlayersPushing) * C_PayloadSpeedPerPlayer;
	
	// Update last push time
	if (S_AllowPayloadReversing) {
		LastPayloadInteractionTime = Now;
		UISetLastPushTime(LastPayloadInteractionTime);
	}

	// Increased speed in debug mode
	if (S_EnableDebugMode) PayloadSpeed *= 10.;
	
	// Increase travelled distance
	G_PayloadTrackCurrentDist += PayloadSpeed / C_ScriptTicksPerSecond;
	if (G_PayloadTrackCurrentDist >= G_PayloadTrackTotalDist) G_PayloadTrackCurrentDist = G_PayloadTrackTotalDist;
}

// ---------------------------------- //
// Moving Payload backwards if noone pushed it for enough time
if (S_AllowPayloadReversing && Now > LastPayloadInteractionTime + C_PayloadReversingTimeLimit && G_PayloadTrackCurrentDist > PrevCheckpointDistance) {
	G_PayloadTrackCurrentDist -= C_PayloadReversingSpeed / C_ScriptTicksPerSecond;
	
	if (G_PayloadTrackCurrentDist <= PrevCheckpointDistance) {
		G_PayloadTrackCurrentDist = PrevCheckpointDistance;
		UISetLastPushTime(-1);
	}

	// Stop the round in overtime
	if (G_IsOvertime) {
		UIManager.UIAll.SendNotice(
			"", CUIConfig::ENoticeLevel::MatchInfo, Null,
			CUIConfig::EAvatarVariant::Default,
			CUIConfig::EUISound::VictoryPoint, 0
		);
		MB_StopRound();
	}
}

// ---------------------------------- //
// Payload distance has changed
if (PrevPayloadDistance != G_PayloadTrackCurrentDist) {
	UISetPayloadDistance(G_PayloadTrackCurrentDist);
	UpdateMarkers(PayloadStructureObjects[0]);
	
	// Update the Payload position
	G_PayloadPosition = GetPayloadPosition(G_PayloadTrackCurrentDist);
	SetObjectsPosition(PayloadStructureObjects, G_PayloadPosition);
	
	MiniMap::SetMarker("Payload", "Payload.png", Teams[G_AttackingClan - 1].ColorPrimary, G_PayloadPosition);
	
	// ---------------------------------- //
	// Attackers captured a Checkpoint
	if (G_PayloadTrackCurrentDist >= NextCheckpointDistance) {
		G_CapturedSectors += 1;
		UpdateBasesColors();
		GalaxyTitles::SetObjectsSpawnTier(G_CapturedSectors + 1);
		
		// Give point for the attacking team
		ClanScores[G_AttackingClan] += 1;
		MM_SetScores([ClanScores[1], ClanScores[2]]);
		
		// ---------------------------------- //
		// Get parameters for the next Sector
		if (G_CapturedSectors < G_CurMapTotalNbSectors) {
			PrevCheckpointDistance = NextCheckpointDistance;
			NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors + 1];

			// Disable overtime
			G_IsOvertime = False;
			UISetIsOvertime(G_IsOvertime);
			
			Message::SendBigMessage(TL::Compose(
				_("%1 captured %2 checkpoints"), Teams[G_AttackingClan - 1].ColorizedName, TL::ToText(G_CapturedSectors)),
				3000, 0, CUIConfig::EUISound::Capture, 0
			);
			
			// ---------------------------------- //
			// Extend the time limit
			CurSectorStartTime = Now;
			if (S_TimeLimit > 0) GT_SetTimeLimit(CurSectorStartTime + S_TimeLimit * 1000);
		}
		// ---------------------------------- //
		// Stop the round
		else {
			MB_StopRound();
			Message::SendBigMessage(TL::Compose(
				_("$<%1$> captured the last pole."), Teams[G_AttackingClan - 1].ColorizedName),
				3000, 0, CUIConfig::EUISound::VictoryPoint, 0
			);
		}
	}
	
	// Get the current Checkpoint progres
	declare CheckpointProgres = (G_PayloadTrackCurrentDist - PrevCheckpointDistance) / (NextCheckpointDistance - PrevCheckpointDistance);
	
	// ---------------------------------- //
	// Show Payload progress on Checkpoints gauges
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag != "Checkpoint") continue;
		
		if (MapLandmark.Order <= G_CapturedSectors) {
			MapLandmark.Gauge.ValueReal = 1.;
			MapLandmark.Gauge.Captured = True;
		}
		else if (MapLandmark.Order == G_CapturedSectors + 1) MapLandmark.Gauge.ValueReal = CheckpointProgres;
		else MapLandmark.Gauge.ValueReal = 0.;
	}
	
	// ---------------------------------- //
	// Show Payload progress as opening Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		if (MapLandmark.Tag != "Gate" || MapLandmark.Order <= 1) continue;
		
		MapLandmark.Gate.ManualClosed = MapLandmark.Order > G_CapturedSectors + 1;

		if (MapLandmark.Order == G_CapturedSectors + 2) MapLandmark.Gauge.ValueReal = ML::Clamp(1.05 - CheckpointProgres, .05, 1.);
		else if (MapLandmark.Order > G_CapturedSectors + 2) MapLandmark.Gauge.ValueReal = 1.;
		else MapLandmark.Gauge.ValueReal = 0.;
	}

	// Save the furthest distance
	if (G_PayloadTrackCurrentDist > PrevPayloadDistance) TeamsPayloadMaxDist[G_AttackingClan] = G_PayloadTrackCurrentDist;
	
	PrevPayloadDistance = G_PayloadTrackCurrentDist;
}

// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit && UIManager.UIAll.CountdownEndTime <= 0) {
	CurrentTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) GT_SetTimeLimit(CurSectorStartTime + S_TimeLimit * 1000);
	else GT_DisableTimeLimit();
}

// ---------------------------------- //
// Payload reversing setting change
if (PrevAllowPayloadReversing != S_AllowPayloadReversing) {
	PrevAllowPayloadReversing = S_AllowPayloadReversing;
	
	if (!S_AllowPayloadReversing) UISetLastPushTime(-1);
	else LastPayloadInteractionTime = Now;
}

// ---------------------------------- //
// Victory conditions
if (GT_TimeReachedLimit()) {
	if (S_AllowPayloadReversing && Now < LastPayloadInteractionTime + C_PayloadReversingTimeLimit) {
		G_IsOvertime = True;
		UISetIsOvertime(G_IsOvertime);
	}
	else MB_StopRound();
}
***

// ---------------------------------- //
// Play loop end
// ---------------------------------- //
***Match_EndPlayLoop***
***
Layers::Detach("Payload:Markers");
Layers::Detach("Payload:Interface");
MiniMap::DestroyMarker("Payload");
UISetIsOvertime(False);
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_EndRound***
***
SM::UnspawnAllPlayers();

// ---------------------------------- //
// Set the round winner
declare RoundWinner = 3 - G_AttackingClan;
if (G_CapturedSectors >= G_CurMapTotalNbSectors) RoundWinner = G_AttackingClan;

MB_Sleep(3000);

GT_DisableTimeLimit();
StartTime = -1;

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (ObjectId in PayloadStructureObjects) {
	if (!Objects.existskey(ObjectId)) continue;
	ObjectDestroy(Objects[ObjectId]);
}
PayloadStructureObjects.clear();

Message::CleanBigMessages();

// ---------------------------------- //
// Show the winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

declare Msg = _("|Match|Draw");
if (RoundWinner != 0) Msg = TL::Compose(_("$<%1$> wins the round!"), Teams[RoundWinner - 1].ColorizedName);
Message::SendBigMessage(Msg, 6000, 0, CUIConfig::EUISound::EndRound, 0);

MB_Sleep(6000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

// Map end conditions
if (MB_GetRoundCount() >= S_NbRoundsPerTeam * 2) MB_StopMatch();
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***Match_EndMap***
***
if (ClanScores[1] == ClanScores[2]) {
	// ---------------------------------- //
	// Team with furthest distance wins
	if (TeamsPayloadMaxDist[1] != TeamsPayloadMaxDist[2]) {
		declare AdvantageTeam = 1;
		if (TeamsPayloadMaxDist[2] > TeamsPayloadMaxDist[1]) AdvantageTeam = 2;
		declare Diff = ML::Abs(TeamsPayloadMaxDist[1] - TeamsPayloadMaxDist[2]);

		Translations::SendStatusMessage([
			"$<%1$> have delivered the Payload %2 m further",
			Teams[AdvantageTeam - 1].ColorizedName, TL::FormatReal(Diff, 2, False, False)],
			5000, 0);
		ClanScores[AdvantageTeam] += 1;
	}

	// ---------------------------------- //
	// Play Sudden Death mode in case there is a draw
	else {
		// ---------------------------------- //
		// Open all Gates
		foreach (MapLandmark in MapLandmarks_Gate) {
			MapLandmark.Gate.Automatic = False;
			MapLandmark.Gate.ManualClosed = False;
			MapLandmark.Gauge.ValueReal = 0.;
		}
		
		// Award one point to the winner
		declare SuddenDeathWinner = GT_SuddenDeath(
			Map::GetLandmarkPlayerSpawn("SpawnAtk", 1),
			Map::GetLandmarkPlayerSpawn("SpawnDef", 1)
		);
		ClanScores[SuddenDeathWinner] += 1;
	}
}
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***Match_EndServer***
***
Layers::Destroy("Payload:Interface");
Layers::Destroy("Payload:Markers");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get Payload position according to the given distance
 *
 *	@param	_RawDistance	The distance the Payload has travelled
 *
 *	@return		The position the Payload should appear at
 */
Vec3 GetPayloadPosition(Real _RawDistance) {
	if (G_PayloadTrackTotalDist <= 0 || G_PayloadTrackPointsDist.count < 2) return Vec3;
	
	// Clamp the distance to fit between 0 and total Payload route length
	declare Distance = ML::Clamp(_RawDistance, 0., G_PayloadTrackTotalDist);
	
	// A point exists exactly at the given distance
	if (G_PayloadTrackPointsDist.exists(Distance)) return G_PayloadTrackPointsDist.keyof(Distance);
	
	// ---------------------------------- //
	// Get the segment start and end positions and distances
	declare SegmentStartPosn = Vec3;
	declare SegmentStartDist = 0.;
	declare SegmentEndPosn = Vec3;
	declare SegmentEndDist = 0.;
	declare PrevPointPosn = Vec3;
	declare PrevPointDist = 0.;
	
	foreach (PointPosnition => PointDistance in G_PayloadTrackPointsDist) {
		if (PointDistance >= Distance) {
			SegmentStartPosn = PrevPointPosn;
			SegmentStartDist = PrevPointDist;
			SegmentEndPosn = PointPosnition;
			SegmentEndDist = PointDistance;
			break;
		}
		PrevPointPosn = PointPosnition;
		PrevPointDist = PointDistance;
	}
	
	// Percentage progress on completing the route segment
	declare SegmentOffset = (Distance - SegmentStartDist) / (SegmentEndDist - SegmentStartDist);
	
	// Compute the final position
	declare Vec3 PayloadPosition;
	for (I, 0, 2) PayloadPosition[I] = SegmentStartPosn[I] + (SegmentEndPosn[I] - SegmentStartPosn[I]) * SegmentOffset;
	return PayloadPosition;
}

// ---------------------------------- //
/// Update colors of all used landmarks
Void UpdateBasesColors() {
	foreach (MapLandmark in MapLandmarks) {
		// ---------------------------------- //
		// Colorize Checkpoints and defense Spawns
		if (MapLandmark.Tag == "Checkpoint" || MapLandmark.Tag == "SpawnDef") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors) Clan = G_AttackingClan;
			
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;
			if (MapLandmark.Gauge != Null) MapLandmark.Gauge.Clan = G_AttackingClan;
		}
		
		// ---------------------------------- //
		// Colorize attackers Spawns and Gates
		if (MapLandmark.Tag == "SpawnAtk" || MapLandmark.Tag == "Gate") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors + 1) Clan = G_AttackingClan;
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;

			if (MapLandmark.Gauge != Null) {
				if (MapLandmark.Order == 1) MapLandmark.Gauge.Clan = G_AttackingClan;
				else MapLandmark.Gauge.Clan = 3 - G_AttackingClan;
			}
		}
	}
}

// ---------------------------------- //
/** Set poition of a group of objects
 *
 *	@param	_Objects	The objects to set position
 *	@param	_Position	Target position
 */
Void SetObjectsPosition(Ident[] _Objects, Vec3 _Position) {
	if (_Objects.count <= 0) return;
	
	foreach (ObjectId in _Objects) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object = Objects[ObjectId];
		
		if (_Position == <0., 0., 0.>) Object.SetUnspawned();
		else Object.SetPosition(_Position + <0., 1.25, 0.>); 
	}

	// Send position to the interface
	declare netwrite Vec3 Net_Payload_PayloadPosition for Teams[0];
	Net_Payload_PayloadPosition = _Position;
}

// ---------------------------------- //
/** Update the markers manialink.
 *
 *	@param	_PayloadObjectId	Id of the Payload object to get position from.
 */
Void UpdateMarkers(Ident _PayloadObjectId) {
	UIManager.UIAll.MarkersXML = "";
	if (S_EnableDebugMode) return;

	// Payload object marker
	declare Payload <=> Objects[_PayloadObjectId];
	declare PayloadPos = Payload.Position.X^" "^Payload.Position.Y^" "^Payload.Position.Z;
	Markers::AddMarker("Payload", "<marker manialinkframeid='Frame_MarkerPayload' visibility='WhenInFrustum' pos='"^PayloadPos^"' box='0 2 0' />");

	// Next checkpoint marker
	declare CurSector = ML::Clamp(G_CapturedSectors + 1, 1, G_CurMapTotalNbSectors);
	declare MapLandmark <=> Map::GetLandmarkGauge("Checkpoint", CurSector);
	if (MapLandmark != Null) {
		declare Pos = MapLandmark.Position.X^" "^MapLandmark.Position.Y + 2^" "^MapLandmark.Position.Z;
		Markers::AddMarker("Checkpoint", "<marker manialinkframeid='Frame_MarkerCheckpoint' visibility='WhenInFrustum' pos='"^Pos^"' />");
	}
}

// ---------------------------------- //
/** Wait for enough players to play
 *
 *	@param	_MinimumNbPlayers	The number of players to wait in each clan before starting the map
 */
Void WaitForPlayers(Integer _MinimumNbPlayers) {
	// ---------------------------------- //
	// Initialize
	declare OldSequence = UIManager.UIAll.UISequence;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	
	declare HasWaited = False;
	declare WasPause = False;
	StartTime = Now;

	// Enable PvP
	UsePvPCollisions = True;
	UsePvPWeapons = True;
	
	foreach (Player in AllPlayers) SetPlayerClan(Player, GT_GetRequestedClan(Player));
	
	// ---------------------------------- //
	// Initialize objects
	GalaxyTitles::ResetAll();
	GalaxyTitles::InitObjects();
	GalaxyTitles::SetObjectsSpawnTier(-1);

	// ---------------------------------- //
	// Waiting for players play loop
	while (!ServerShutdownRequested && !MatchEndRequested && !S_EnableDebugMode) {
		MB_Yield();

		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;
		
		// Stop waiting if there are enough players to start the game
		if (ClansNbPlayers[1] >= _MinimumNbPlayers && ClansNbPlayers[2] >= _MinimumNbPlayers && !CupAdmin::IsCupPaused()) break;
		
		// ---------------------------------- //
		// Display big message
		if (!HasWaited) {
			UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::Warning;
			
			if (CupAdmin::IsCupPaused()) {
				Translations::SetStatusMessage("Competition has been paused");
				UIManager.UIAll.BigMessage = TL::Compose("$F90%1", _("Pause"));
				WasPause = True;
			}
			else UIManager.UIAll.BigMessage = _("Waiting for players in each team...");
			
			HasWaited = True;
		}
		
		GalaxyTitles::SpawnObjects();
		GT_UnspawnPlayersChangingClan();
		WarmUp::ManageEvents();
		
		// ---------------------------------- //
		// Spawn players
		foreach (Player in Players) {
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;
			
			// ---------------------------------- //
			// Initialize player
			SetPlayerClan(Player, GT_GetRequestedClan(Player));
			Player.ArmorMax = ML::Max(1, ML::Min(S_PlayerArmorPoints, 10)) * 100;
			Player.StaminaMax = C_PlayerStaminaMax;
			
			// Spawn player
			if (Player.CurrentClan == 0) continue;
			declare CSmMapPlayerSpawn PlayerSpawn;
			if (Player.CurrentClan == G_AttackingClan) PlayerSpawn <=> Map::GetPlayerSpawn("SpawnAtk", 1);
			else PlayerSpawn <=> Map::GetPlayerSpawn("SpawnDef", 1);
			if (PlayerSpawn != Null) SM::Spawn(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
		}
	}
	
	StartTime = -1;
	
	// ---------------------------------- //
	// Player joined the game
	if (HasWaited) {
		SM::UnspawnAllPlayers();
		GalaxyTitles::ResetAll();
		
		if (!ServerShutdownRequested && !MatchEndRequested) {
			declare Message = _("A new player joins the game.");
			if (WasPause) Message = "Competition has been resumed!";
			
			Translations::SendBigMessage(Message, 5000, 0, CUIConfig::EUISound::Default, 0);
			MB_Sleep(5000);
		}
	}
	
	// ---------------------------------- //
	// Revert changes
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.UISequence = OldSequence;
}

// ---------------------------------- //
/** Set UI Checkpoints distances
 *
 *	@param	_CPDistances	Checkpoints distances
 */
Void UISetCheckpointsDistances(Real[Integer] _CPDistances) {
	declare netwrite Real[] Net_Payload_CheckpointDistances for Teams[0];
	declare netwrite Integer Net_Payload_LastUIUpdate for Teams[0];
	Net_Payload_LastUIUpdate = Now;

	Net_Payload_CheckpointDistances.clear();
	foreach (Distance in _CPDistances) Net_Payload_CheckpointDistances.add(Distance);
	Net_Payload_CheckpointDistances = Net_Payload_CheckpointDistances.sort();
}

// ---------------------------------- //
/** Set UI Payload distance
 *
 *	@param	_PayloadDistance	Payload distance
 */
Void UISetPayloadDistance(Real _PayloadDistance) {
	declare netwrite Real Net_Payload_PayloadDistance for Teams[0];
	Net_Payload_PayloadDistance = ML::Clamp(_PayloadDistance, 0., G_PayloadTrackTotalDist);
}

// ---------------------------------- //
/** Set UI attacking team
 *
 *	@param	_AttackingTeam		Currently attacking team
 */
Void UISetAttackingTeam(Integer _AttackingTeam) {
	declare netwrite Integer Net_Payload_AttackingTeam for Teams[0];
	Net_Payload_AttackingTeam = ML::Clamp(_AttackingTeam, 1, 2);
}

// ---------------------------------- //
/** Set UI amount of attackers pushing Payload
 *
 *	@param	_PlayersNb		Players pushing Payload
 */
Void UISetNbPlayersPushingPayload(Integer _PlayersNb) {
	declare netwrite Integer Net_Payload_NbPlayersPushingPayload for Teams[0];
	Net_Payload_NbPlayersPushingPayload = ML::Max(0, _PlayersNb);
}

// ---------------------------------- //
/** Set the latest push time.
 *
 *	@param	_Time	Latest push time.
 */
Void UISetLastPushTime(Integer _Time) {
	declare netwrite Integer Net_Payload_LastPushTime for Teams[0];
	Net_Payload_LastPushTime = _Time;
}

// ---------------------------------- //
/** Set the overtime status.
 *
 *	@param	_IsOvertime		If overtime is active or not.
 */
Void UISetIsOvertime(Boolean _IsOvertime) {
	declare netwrite Boolean Net_Payload_IsOvertime for Teams[0];
	Net_Payload_IsOvertime = _IsOvertime;
	Interfancy::SetModuleVisibility("Countdown", !_IsOvertime);
}

// ---------------------------------- //
/** Create manialink for the Payload Interface
 *
 *	@return		The manialink
 */
Text CreateManialinkPayloadUI() {
	declare Text SectorBarFrames;
	for (I, 0, C_MapMaximumNbSectors - 1) SectorBarFrames ^= "<frameinstance modelid='FrameModel_Sector' id='Frame_SectorProgress#"^I^"' />";
	
	return """
<manialink version="3" name="Payload:Interface">
<stylesheet>
	<style id="Label_PayloadMarker" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="CircGauge" size="16 16" halign="center" valign="center" colorize="FFF" />
	<style id="Label_TextOvertime" halign="center" valign="center2" textsize="2" textemboss="1" textfont="Eurostile_Bold" textcolor="FB0" textprefix="$t" />
	<style id="Label_CaptureProgress" halign="center" valign="center2" textsize="3" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
</stylesheet>

<framemodel id="FrameModel_Sector">
	<gauge pos="-2" size="0 8" valign="center" drawbg="0" id="Gauge_CPProgress" />
</framemodel>

<frame id="Frame_PayloadProgress" pos="0 78" hidden="1">
	<frame pos="-60 .3">{{{SectorBarFrames}}}</frame>
	<quad pos="-63" size="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemLeft" />
	<quad pos="63" size="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemRight" />
	<quad size="135.875 8" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadProgressBar.png" />
	
	<frame id="Frame_PayloadMarker" pos="0 -7" hidden="1">
		<label pos="0 -1.25" size="5 5" halign="center" valign="center2" id="Label_PayloadMarker" text="0" />
		<frame pos="0 -1.3" scale=".4">
			<frame size="8 16" valign="center" halign="left">
				<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeL" hidden="1" />
			</frame>
			<frame size="8 16" valign="center" halign="right">
				<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeR" hidden="1" rot="180" />
			</frame>
			<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeBg.png" id="Quad_GaugeBg" />
		</frame>
		<quad size="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadMarker.png" />
	</frame>
</frame>

<frame id="Frame_OvertimeGauge" pos="0 86.5" hidden="1">
	<label pos="0 .5" id="Label_TextOvertime" text="Overtime" translate="1" />
	<gauge pos="0 -2" size="0 7" halign="center" valign="center" drawbg="0" drawblockbg="0" color="FB0" id="Gauge_OvertimeProgress" />
</frame>

<frame id="Frame_CaptureProgress" pos="0 -54">
	<frame id="Frame_CaptureProgAnim">
		<label id="Label_CaptureProgress" opacity="0" />
		<quad pos="0 8" size="12 12" halign="center" valign="center" id="Quad_CaptureProgIcon" opacity="0" />
		<gauge pos="0 -3" size="52 8" halign="center" valign="center" drawbg="0" id="Gauge_CaptureProgress" hidden="1" />
	</frame>
</frame>

<label id="Label_DistanceDebug" scale="0" />

<script><!--
/**
 *	Payload: Interface
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_TotalProgressBarWidth	120.
#Const C_GaugeBarsSpacing		.75
#Const C_CaptureBarImgBase		"file://Media/Manialinks/ShootMania/Common/"

{{{Translations::InjectInManialink(["Payload is reversing", "Payload is stopped", "Escorting the Payload", "Blocking the Payload"])}}}
{{{ManialinkTools::Functions(["SetGaugeRatio", "ComputeWidth", "HsvToRgb"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_PayloadProgress <=> (Page.GetFirstChild("Frame_PayloadProgress") as CMlFrame);
	declare Quad_EmblemLeft <=> (Page.GetFirstChild("Quad_EmblemLeft") as CMlQuad);
	declare Quad_EmblemRight <=> (Page.GetFirstChild("Quad_EmblemRight") as CMlQuad);

	declare Frame_PayloadMarker <=> (Page.GetFirstChild("Frame_PayloadMarker") as CMlFrame);
	declare Label_PayloadMarker <=> (Page.GetFirstChild("Label_PayloadMarker") as CMlLabel);
	declare Label_DistanceDebug <=> (Page.GetFirstChild("Label_DistanceDebug") as CMlLabel);
	declare Quad_GaugeBg <=> (Page.GetFirstChild("Quad_GaugeBg") as CMlQuad);
	declare Quad_GaugeL <=> (Page.GetFirstChild("Quad_GaugeL") as CMlQuad);
	declare Quad_GaugeR <=> (Page.GetFirstChild("Quad_GaugeR") as CMlQuad);

	declare Frame_OvertimeGauge <=> (Page.GetFirstChild("Frame_OvertimeGauge") as CMlFrame);
	declare Label_TextOvertime <=> (Page.GetFirstChild("Label_TextOvertime") as CMlLabel);
	declare Gauge_OvertimeProgress <=> (Page.GetFirstChild("Gauge_OvertimeProgress") as CMlGauge);

	declare Frame_CaptureProgress <=> (Page.GetFirstChild("Frame_CaptureProgress") as CMlFrame);
	declare Frame_CaptureProgAnim <=> (Page.GetFirstChild("Frame_CaptureProgAnim") as CMlLabel);
	declare Label_CaptureProgress <=> (Page.GetFirstChild("Label_CaptureProgress") as CMlLabel);
	declare Quad_CaptureProgIcon <=> (Page.GetFirstChild("Quad_CaptureProgIcon") as CMlQuad);
	declare Gauge_CaptureProgress <=> (Page.GetFirstChild("Gauge_CaptureProgress") as CMlGauge);
	
	declare CMlFrame[] Frame_SectorProgress;
	for (I, 0, {{{C_MapMaximumNbSectors - 1}}}) Frame_SectorProgress.add((Page.GetFirstChild("Frame_SectorProgress#"^I) as CMlFrame));

	Label_TextOvertime.Value = _("Overtime");
	Label_TextOvertime.Size.X = ML::Min(ComputeWidth(Label_TextOvertime), 18.);
	Gauge_OvertimeProgress.Size.X = Label_TextOvertime.Size.X + 4.;
	
	// ---------------------------------- //
	// Netcode
	declare netread Real[] Net_Payload_CheckpointDistances for Teams[0];
	declare netread Integer Net_Payload_LastUIUpdate for Teams[0];
	declare netread Real Net_Payload_PayloadDistance for Teams[0];
	declare netread Vec3 Net_Payload_PayloadPosition for Teams[0];
	declare netread Integer Net_Payload_AttackingTeam for Teams[0];
	declare netread Integer Net_Payload_NbPlayersPushingPayload for Teams[0];
	declare netread Integer Net_Payload_LastPushTime for Teams[0];
	declare netread Boolean Net_Payload_IsOvertime for Teams[0];
	
	// Wait for at least one checkpoint distance
	wait(Net_Payload_CheckpointDistances.count > 0);

	// ---------------------------------- //
	// Variables
	declare TotalDistance = 0.;
	declare CaptureProgressVisible = False;
	declare CaptureMesageType = 0;
	declare UpdateColors = True;
	declare GaugeRatio = 0.;
	
	/// Update
	declare PrevPayloadDistance = -1.;
	declare PrevAnimDistance = -1.;
	declare PrevAttackingTeam = -1;
	declare PrevAttackingTeamColor = Vec3;
	declare PrevCheckpointDistance = 0.;
	declare PrevPlayersPushingPayload = -1;
	declare PrevGaugeRatio = -1.;
	declare PrevCaptureProgressVisible = False;
	declare PrevCaptureMesageType = -1;
	declare PrevUIUpdate = -1;
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		if (!PageIsVisible) continue;

		// ---------------------------------- //
		// Update the checkpoints amount
		if (PrevUIUpdate != Net_Payload_LastUIUpdate) {
			PrevUIUpdate = Net_Payload_LastUIUpdate;

			Label_DistanceDebug.RelativeScale = 0.;
			PrevPayloadDistance = -1.;
			PrevCheckpointDistance = 0.;
			UpdateColors = True;

			TotalDistance = Net_Payload_CheckpointDistances[Net_Payload_CheckpointDistances.count - 1];
			declare SpacingSub = (Net_Payload_CheckpointDistances.count - 1) * C_GaugeBarsSpacing;
			declare PrevFramePosX = 0.;

			foreach (I => Frame in Frame_SectorProgress) {
				Frame.Visible = Net_Payload_CheckpointDistances.existskey(I);
				if (!Frame.Visible) continue;
				
				declare CurCPDistance = Net_Payload_CheckpointDistances[I];
				declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
				
				Gauge_CPProgress.Size.X = (C_TotalProgressBarWidth - SpacingSub) * (CurCPDistance - PrevCheckpointDistance) / TotalDistance + 4;
				Frame.RelativePosition_V3.X = PrevFramePosX;
				PrevFramePosX += Gauge_CPProgress.Size.X - 4 + C_GaugeBarsSpacing;
				PrevCheckpointDistance = CurCPDistance;
			}
			
			Frame_PayloadProgress.Show();
		}
		
		// Payload marker visibility
		Frame_PayloadMarker.Visible = Net_Payload_PayloadDistance < TotalDistance;
		
		// Payload distance has changed
		if (PrevPayloadDistance != Net_Payload_PayloadDistance) {
			PrevPayloadDistance = Net_Payload_PayloadDistance;
			AnimMgr.Add(Label_DistanceDebug, "<label scale='"^PrevPayloadDistance^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
		}

		// ---------------------------------- //
		// Update Payload marker animated position
		if (PrevAnimDistance != Label_DistanceDebug.RelativeScale) {
			PrevAnimDistance = Label_DistanceDebug.RelativeScale;
			
			PrevCheckpointDistance = 0.;
			declare AllSegmentsDist = 0.;
			
			Frame_PayloadMarker.RelativePosition_V3.X = C_TotalProgressBarWidth * PrevAnimDistance / TotalDistance - C_TotalProgressBarWidth / 2;
			
			foreach (I => Frame in Frame_SectorProgress) {
				if (!Frame.Visible || !Net_Payload_CheckpointDistances.existskey(I)) continue;
				
				declare CurCPDistance = Net_Payload_CheckpointDistances[I];
				declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
				
				declare Ratio = 0.;
				if (Net_Payload_PayloadDistance >= CurCPDistance) Ratio = 1.;
				else Ratio = ML::Clamp((PrevAnimDistance - AllSegmentsDist) / (CurCPDistance - AllSegmentsDist), 0., 1.);
				
				SetGaugeRatio(Gauge_CPProgress, Ratio);
				
				AllSegmentsDist += CurCPDistance - PrevCheckpointDistance;
				PrevCheckpointDistance = CurCPDistance;
			}
			
			if (PrevPayloadDistance >= TotalDistance) Quad_EmblemRight.Substyle = "#"^Net_Payload_AttackingTeam;
		}
		
		// Attacking team has changed
		if (PrevAttackingTeam != Net_Payload_AttackingTeam) {
			PrevAttackingTeam = Net_Payload_AttackingTeam;
			UpdateColors = True;
		}
		
		// Attacking team color changed
		foreach (I => Team in Teams) {
			if (I != Net_Payload_AttackingTeam - 1) continue;
			if (Team.ColorPrimary == PrevAttackingTeamColor) continue;
			UpdateColors = True;
			PrevAttackingTeamColor = Team.ColorPrimary;
		}
		
		// Amount of players pushing Payload changed
		if (PrevPlayersPushingPayload != Net_Payload_NbPlayersPushingPayload) {
			PrevPlayersPushingPayload = Net_Payload_NbPlayersPushingPayload;
			if (PrevPlayersPushingPayload > 0) GaugeRatio = 1.;
			Label_PayloadMarker.SetText(TL::ToText(PrevPlayersPushingPayload));
		}

		// Set reversing time limit gauge ratio
		if (PrevPlayersPushingPayload <= 0) {
			GaugeRatio = 0.;
			if (Net_Payload_LastPushTime > 0) {
				GaugeRatio = 1 - ML::Clamp(ML::ToReal(GameTime - Net_Payload_LastPushTime) / {{{C_PayloadReversingTimeLimit}}}, 0., 1.);
				if (GaugeRatio <= 0 && Net_Payload_PayloadDistance > 0) Label_PayloadMarker.SetText("<");
			}
			else Label_PayloadMarker.SetText("0");
		}

		// Overtime gauge
		Frame_OvertimeGauge.Visible = Net_Payload_IsOvertime;
		
		// ---------------------------------- //
		// Reversing time limit gauge
		if (PrevGaugeRatio != GaugeRatio) {
			PrevGaugeRatio = GaugeRatio;

			// Overtime gauge
			SetGaugeRatio(Gauge_OvertimeProgress, GaugeRatio);
			
			// ---------------------------------- //
			// Set ratio
			Quad_GaugeR.RelativeRotation = 180 - ML::Clamp(GaugeRatio * 360., 0., 180.);
			Quad_GaugeL.RelativeRotation = 360 - ML::Clamp((GaugeRatio - .5) * 360., 0., 180.);
			Quad_GaugeR.Visible = GaugeRatio > 0;
			Quad_GaugeL.Visible = GaugeRatio > .5;
			
			// ---------------------------------- //
			// Set gauge image
			declare Image = "CircGaugeProg.png";
			if (GaugeRatio >= 1) Image = "CircGaugeFull.png";
			Quad_GaugeL.ImageUrl = "{{{C_ImgBase}}}"^Image;
			Quad_GaugeR.ImageUrl = Quad_GaugeL.ImageUrl;
		}
		
		// ---------------------------------- //
		// Update interface colors
		if (UpdateColors) {
			UpdateColors = False;
			declare Clan = ML::Clamp(Net_Payload_AttackingTeam, 1, 2);
			
			foreach (I => Frame in Frame_SectorProgress) {
				if (!Frame.Visible) continue;
				declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
				Gauge_CPProgress.Color = PrevAttackingTeamColor;
			}
			
			Quad_EmblemLeft.Substyle = "#"^Net_Payload_AttackingTeam;
			Quad_EmblemRight.Substyle = "#"^3-Net_Payload_AttackingTeam;
			
			Quad_GaugeBg.Colorize = PrevAttackingTeamColor;
			Quad_GaugeL.Colorize = PrevAttackingTeamColor;
			Quad_GaugeR.Colorize = PrevAttackingTeamColor;
		}

		// ---------------------------------- //
		// Set capture progress visibility
		CaptureProgressVisible =
			GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && Net_Payload_PayloadPosition != <0., 0., 0.> &&
			ML::Distance(GUIPlayer.Position, Net_Payload_PayloadPosition) <= {{{C_PayloadActivationRadius}}};

		if (PrevCaptureProgressVisible != CaptureProgressVisible) {
			PrevCaptureProgressVisible = CaptureProgressVisible;
			Gauge_CaptureProgress.Visible = CaptureProgressVisible;
			
			Frame_CaptureProgAnim.RelativePosition_V3.Y = 0.;
			Label_CaptureProgress.Opacity = 1.;
			declare PositionY = -2.;
			declare Opacity = 0.;
			
			if (CaptureProgressVisible) {
				Frame_CaptureProgAnim.RelativePosition_V3.Y = -PositionY;
				Label_CaptureProgress.Opacity = 0.;
				PositionY = 0.;
				Opacity = 1.;
			}
			
			declare Easing = CAnimManager::EAnimManagerEasing::Linear;
			AnimMgr.Add(Frame_CaptureProgAnim, "<frame pos='0 "^PositionY^"'/>", 125, Easing);
			AnimMgr.Add(Label_CaptureProgress, "<label opacity='"^Opacity^"' />", 125, Easing);
			AnimMgr.Add(Quad_CaptureProgIcon, "<quad opacity='"^Opacity^"' />", 125, Easing);
		}

		// ---------------------------------- //
		// Display information
		if (CaptureProgressVisible) {
			Gauge_CaptureProgress.Color = HsvToRgb(<GUIPlayer.GetLinearHue, 1., 1.>);

			// Checkpoint progress for attackers
			if (GUIPlayer.CurrentClan == Net_Payload_AttackingTeam) {
				declare Ratio = 0.;
				declare PrevDist = 0.;

				foreach (Distance in Net_Payload_CheckpointDistances) {
					if (PrevDist < Net_Payload_PayloadDistance && Net_Payload_PayloadDistance <= Distance)
						Ratio = (Net_Payload_PayloadDistance - PrevDist) / (Distance - PrevDist);

					PrevDist = Distance;
				}

				if (Net_Payload_NbPlayersPushingPayload <= 0) CaptureMesageType = 1;
				else CaptureMesageType = 2;

				SetGaugeRatio(Gauge_CaptureProgress, Ratio);
			}

			// Reversing gauge for opponents
			else {
				SetGaugeRatio(Gauge_CaptureProgress, 1 - GaugeRatio);
				CaptureMesageType = 3;
			}
		}

		// ---------------------------------- //
		// Update payload capture message
		if (PrevCaptureMesageType != CaptureMesageType) {
			PrevCaptureMesageType = CaptureMesageType;
			Quad_CaptureProgIcon.ImageUrl = C_CaptureBarImgBase;

			switch (CaptureMesageType) {
				case 1 : {
					Label_CaptureProgress.Value = Translate("Payload is stopped");
					Quad_CaptureProgIcon.ImageUrl ^= "c_goal_capture.dds";
				}
				case 2 : {
					Label_CaptureProgress.Value = Translate("Escorting the Payload");
					Quad_CaptureProgIcon.ImageUrl ^= "c_goal_shield.dds";
				}
				case 3 : {
					Label_CaptureProgress.Value = Translate("Blocking the Payload");
					Quad_CaptureProgIcon.ImageUrl ^= "c_goal_lock.dds";
				}
			}
		}
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the markers module.
 *
 *	@return		The markers manialink.
 */
Text CreateManialinkMarkers() {
	declare R = 9/16.;
	return """
<manialink version="2" name="Payload:Markers">
<stylesheet>
	<style class="text" halign="center" valign="center2" textsize="0" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
</stylesheet>

<framemodel id="FrameModel_GoalMarker">
	<label posn="0 .5" class="text" scale="1.5" textprefix="$t$n" id="Label_MarkerGoalName"/>
	<quad posn="0 3" sizen="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon"/>
</framemodel>

<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerPayload" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerCheckpoint" hidden="1" />

<script><!--
/**
 *	Payload: Markers
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

{{{Translations::InjectInManialink(["Payload"])}}}
{{{ManialinkTools::Functions(["Brightness"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_MarkerPayload <=> (Page.GetFirstChild("Frame_MarkerPayload") as CMlFrame);
	declare Label_MarkerPayloadName <=> (Frame_MarkerPayload.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerPayloadIcon <=> (Frame_MarkerPayload.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
	declare Frame_MarkerCheckpoint <=> (Page.GetFirstChild("Frame_MarkerCheckpoint") as CMlFrame);
	declare Label_MarkerCheckpointName <=> (Frame_MarkerCheckpoint.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerCheckpointIcon <=> (Frame_MarkerCheckpoint.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	Label_MarkerPayloadName.Value = Translate("Payload");

	declare CurCheckpointNb = 1;

	declare PrevCheckpointNb = -1;
	declare PrevAttackingTeam = -1;

	// ---------------------------------- //
	// Netcode
	declare netread Real[] Net_Payload_CheckpointDistances for Teams[0];
	declare netread Real Net_Payload_PayloadDistance for Teams[0];
	declare netread Integer Net_Payload_AttackingTeam for Teams[0];

	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		if (!PageIsVisible) continue;

		// ---------------------------------- //
		// Update Checkpoint marker
		CurCheckpointNb = 1;
		foreach (Distance in Net_Payload_CheckpointDistances) {
			if (Net_Payload_PayloadDistance >= Distance) CurCheckpointNb += 1;
			else break;
		}

		if (PrevCheckpointNb != CurCheckpointNb) {
			PrevCheckpointNb = CurCheckpointNb;
			Label_MarkerCheckpointName.Value = TL::Compose("%1 #"^CurCheckpointNb, ("Checkpoint"));
		}

		// ---------------------------------- //
		// Update markers colors
		if (PrevAttackingTeam != Net_Payload_AttackingTeam) {
			PrevAttackingTeam = Net_Payload_AttackingTeam;
			declare Team = ML::Clamp(Net_Payload_AttackingTeam - 1, 0, 1);

			Quad_MarkerPayloadIcon.Colorize = Teams[Team].ColorPrimary;
			Quad_MarkerCheckpointIcon.Colorize = Teams[1 - Team].ColorPrimary;

			Label_MarkerPayloadName.TextColor = Brightness(Quad_MarkerPayloadIcon.Colorize, 2.);
			Label_MarkerCheckpointName.TextColor = Brightness(Quad_MarkerCheckpointIcon.Colorize, 2.);
		}
	}
}
--></script>
</manialink>""";
}