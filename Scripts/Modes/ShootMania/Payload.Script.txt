// -------------------------------------- //
//  PAYLOAD by domino54                   //
//  script version: 2017-09-07            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes	"PayloadArena, PayloadRaceArena"
#Const Version		"2017-09-07"
#Const ScriptName	"Modes/ShootMania/Payload.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_NbRoundsPerTeam			1		as _("Attack rounds per team (Classic)")
#Setting S_TimeLimit				300 	as _("Time limit (seconds)")
#Setting S_AllowPayloadReversing	True	as _("Allow Payload to move backwards")
#Setting S_RoundsToWin				2		as _("Rounds to win (Race)")	///< Number of rounds to win a map
#Setting S_RoundGapToWin			1		as _("Round gap to win (Race)")	///< Minimum gap between the two leaders to win a map
#Setting S_RoundsLimit				3		as _("Rounds limit (Race)")		///< Point limit on map
#Setting S_UseAutoBalance			True	as _("Balance teams on match start")
#Setting S_EnableDebugMode			False	as _("Debug mode (for developers only)")
#Setting S_WarmUpDuration			0		as _("Warm up duration (sec.)") 
#Setting S_NbPlayersPerTeamMin		1		as _("Minumum number of players in each team")
#Setting S_NbPlayersPerTeamMax		5		as _("Maximum number of players per team (0: no max)")
	
// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_MapMaximumNbSectors		9		///< Maximum number of sectors the map can have
#Const C_PayloadSpeedPerPlayer		1.		///< Payload speed bonus per every additional player in m/s
#Const C_PayloadMaxPlayersPushing	3		///< Maximum Payload speed multiplier
#Const C_PayloadActivationRadius	4.		///< Radius within the Payload can be interacted with
#Const C_PayloadReversingTimeLimit	10000	///< Time after which Payload starts going backwards
#Const C_PayloadReversingSpeed		.5		///< Payload speed in m/s when going backwards
#Const C_PayloadTimePerPoint		3000	///< Time required for each attack point
#Const C_SetupPhaseDuration			15000	///< Duration of the preparation phase for defenderss

#Const Description _("TYPE: Team versus Team\nOBJECTIVE: Attacking team is pushing Payload across the map, defenders have to stop them.")

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Real[Vec3][Integer] G_PayloadTrackPointsDist;	///< All track point distances to the starting point.
declare Real[Integer] G_PayloadCurrentDist;		///< Distance travelled by the Payload.
declare Vec3[Integer] G_PayloadPosition;		///< Current position of the Payload.
declare Real G_PayloadTrackTotalDist;			///< Total distance of the Payload track.
declare Boolean G_IsOvertime;		///< True, if the game is in overtime mode.
declare Ident[Text] G_ObjectsIds;	///< Ids of the objects models.

// Classic mode
declare Integer G_CurMapTotalNbSectors;			///< Total number of Sectors in the current map.
declare Real[Integer] G_SectorCheckpointsDist;	///< Checkpoints distances to the starting point.
declare Integer G_AttackingClan;	///< Currently attacking team.
declare Integer G_CapturedSectors;	///< Number of sectors captured by the attackers.

// Race mode
declare Boolean G_IsPayloadRace;	///< True, if the game is a Payload Race.
declare CSmMapLandmark[Integer] G_ClansRaceSpawns;	///< Teams Spawns in the Race mode.
declare CSmMapLandmark[Integer] G_ClansRaceGoals;	///< Teams Goals in the Race mode.

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Set up matchmaking
// ---------------------------------- //
***MM_SetupMatchmaking***
***
MM_SetFormat([S_NbPlayersPerTeamMax, S_NbPlayersPerTeamMax]);
if (S_NbPlayersPerTeamMax > S_NbPlayersPerTeamMin) {
	MM_SetProgressiveFormats([1, 1], S_NbPlayersPerTeamMin, S_NbPlayersPerTeamMax-1);
}
***

// ---------------------------------- //
// Set the scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("Attack", "Best Attacker", "", 2., "", 2.25, 60.);
TopScores::SetFormat(3, 1);
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("Payload");
ModeInfo::SetType(ModeInfo::C_Type_Teams);
ModeInfo::SetRules("1. Attackers goal is to push the Payload to the end of its route, while defenders try to stop them.\n2. Attacking team will get 1 point for every Checkpoint reached.\n3. If attackers leave Payload for enough time, it will start to slowly go backwards.\n4. After both teams have finished their attack round, the team with more points wins.\n5. If teams end up with the same score, Sudden Death mode is played to decide the winner.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Galaxy settings
// ---------------------------------- //
***GalaxyTitles_Settings***
***
GT_UseNoCollisionsStart = False;
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***Match_InitServer***
***
UseClans = True;

// Create custom interface
Layers::Create("Payload:Interface", CreateManialinkPayloadUI());
Layers::Create("Payload:Markers", CreateManialinkMarkers());
Layers::SetType("Payload:Markers", CUILayer::EUILayerType::Markers);

// Load objects
G_ObjectsIds["Payload"] = ItemList_Add("SMCommon\\Payload\\Payload.Item.gbx");

// ---------------------------------- //
// Variables
declare PayloadStructureObjects = Ident[][Integer];
declare LastPayloadInteractionTime = [1 => 0, 2 => 0];
declare AttackPathOrder = [1 => 0, 2 => 0];
declare IsPreparationPhase = False;
declare NextCheckpointDistance = 0.;
declare CurSectorStartTime = 0;
declare TeamsPayloadMaxDist = [0., 0., 0.];

declare PrevCheckpointDistance = 0.;
declare PrevPayloadDistance = G_PayloadCurrentDist;
declare PrevAllowPayloadReversing = S_AllowPayloadReversing;
declare CurrentTimeLimit = S_TimeLimit;
declare PrevLeadingClan = 0;
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***Match_InitMap***
***
// ---------------------------------- //
// Reset map parameters
G_PayloadTrackTotalDist = 0.;
G_PayloadTrackPointsDist.clear();
G_CurMapTotalNbSectors = 0;
G_SectorCheckpointsDist.clear();
G_AttackingClan = 1;
G_IsPayloadRace = Map.MapType == "ShootMania\\PayloadRaceArena";

// Check if the map is valid
declare MapValidated = True;

// Map must have a BotPath for Payload route with at least 2 points on it
declare CSmMapBotPath[Integer] PayloadRoutes;
for (Order, 0, 2) PayloadRoutes[Order] <=> Map::GetBotPath("Payload", Order);

if (!G_IsPayloadRace && PayloadRoutes[0] == Null) MapValidated = False;
if (G_IsPayloadRace && (PayloadRoutes[1] == Null || PayloadRoutes[2] == Null)) MapValidated = False;
foreach (PayloadRoute in PayloadRoutes) if (PayloadRoute != Null && PayloadRoute.Path.count < 2) MapValidated = False;

// ---------------------------------- //
// Classic Payload
if (!G_IsPayloadRace) {
	// ---------------------------------- //
	// Map must have correct Sectors
	declare Integer[] MapSectors;
	foreach (MapLandmark in MapLandmarks_Gauge) {
		if (MapLandmark.Tag != "Checkpoint") continue;
		if (MapLandmark.Order > G_CurMapTotalNbSectors) G_CurMapTotalNbSectors = MapLandmark.Order;
		if (!MapSectors.exists(MapLandmark.Order)) MapSectors.add(MapLandmark.Order);
	}
	for (I, 1, G_CurMapTotalNbSectors) if (!MapSectors.exists(I)) { MapValidated = False; break; }

	// ---------------------------------- //
	// Map must have one Checkpoint, SpawnAtk and SpawnDef per Sector
	for (Sector, 1, G_CurMapTotalNbSectors) {
		declare Checkpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
		declare SpawnAtk <=> Map::GetLandmarkPlayerSpawn("SpawnAtk", Sector);
		declare SpawnDef <=> Map::GetLandmarkPlayerSpawn("SpawnDef", Sector);
		if (Checkpoint == Null || SpawnAtk == Null || SpawnDef == Null) { MapValidated = False; break; }
	}

	// At least one Gate in front of first SpawnAtk
	if (Map::GetLandmarkGate("Gate", 1) == Null) MapValidated = False;
}
// ---------------------------------- //
// Payload Race
else {
	// ---------------------------------- //
	// Map must have exactly one Spawn and Goal per team
	for (Clan, 1, 2) {
		declare Goal <=> Map::GetLandmarkGauge("Goal", Clan);
		declare Spawn <=> Map::GetLandmarkPlayerSpawn("Spawn", Clan);
		if (Goal == Null || Spawn == Null) { MapValidated = False; break; }
	}
}

// ---------------------------------- //
// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Start map
// ---------------------------------- //
***Match_StartMap***
***
if (S_WarmUpDuration > 0) GT_InitWarmUp(S_NbPlayersPerTeamMax);
TeamsPayloadMaxDist = [0., 0., 0.];
G_PayloadTrackTotalDist = 0.;
Layers::Attach("Payload:Interface");

for (Order, 0, 2) {
	declare PayloadRoute <=> PayloadRoutes[Order];
	if (PayloadRoute == Null) continue;
	G_PayloadTrackPointsDist[Order] = Real[Vec3];
	
	// ---------------------------------- //
	// Get the complete data about the Payload track
	declare Vec3 PrevPointPosn;
	declare TrackTotalDist = 0.;

	foreach (I => Point in PayloadRoute.Path) {
		declare Distance = 0.;
		if (I > 0) Distance = ML::Distance(PrevPointPosn, Point);
		
		TrackTotalDist += Distance;
		G_PayloadTrackPointsDist[Order][Point] = TrackTotalDist;
		PrevPointPosn = Point;
	}

	if (G_PayloadTrackTotalDist <= 0 || TrackTotalDist < G_PayloadTrackTotalDist)
		G_PayloadTrackTotalDist = TrackTotalDist;

	// ---------------------------------- //
	// Compute distances at which the Checkpoints will get TRIGGERED
	for (Sector, 1, G_CurMapTotalNbSectors) {
		if (Order != 0) break;
		declare CurSectorCheckpoint <=> Map::GetLandmarkGauge("Checkpoint", Sector);
		
		// ---------------------------------- //
		// Get distances to all points
		declare Real[Vec3] PathPointsDistances;
		foreach (Point in PayloadRoute.Path) PathPointsDistances[Point] = ML::Distance(CurSectorCheckpoint.Position, Point);
		PathPointsDistances = PathPointsDistances.sort();
		
		// ---------------------------------- //
		// Get 2 nearest points to the Checkpoint
		declare Vec3[Real] NearestPoints;
		declare PrevPointPosn = Vec3;
		declare PointsDistance = 0.;
		declare I = 0;
		
		foreach (Position => Distance in PathPointsDistances) {
			if (I >= 2) break;
			if (I == 1) PointsDistance = ML::Distance(PrevPointPosn, Position);
			NearestPoints[G_PayloadTrackPointsDist[Order][Position]] = Position;
			PrevPointPosn = Position;
			I += 1;
		}
		NearestPoints = NearestPoints.sortkey();
		
		// ---------------------------------- //
		// Get Checkpoint distance to both points
		declare Real StartPointDist;
		declare Real StartPointPayloadDist;
		declare Real EndPointDist;
		declare Real EndPointPayloadDist;
		
		I = 0;
		foreach (PayloadDist => Position in NearestPoints) {
			declare Distance = ML::Distance(CurSectorCheckpoint.Position, Position);
			switch (I) {
				case 0 : {
					StartPointDist = Distance;
					StartPointPayloadDist = PayloadDist;
				}
				case 1 : {
					EndPointDist = Distance;
					EndPointPayloadDist = PayloadDist;
				}
			}
			I += 1;
		}
		
		// ---------------------------------- //
		// Checkpoint is beyond both points
		if (ML::Pow(StartPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(EndPointDist, 2.))) {
			G_SectorCheckpointsDist[Sector] = ML::Min(EndPointPayloadDist, G_PayloadTrackTotalDist);
			continue;
		}
		
		// ---------------------------------- //
		// Checkpoint is (somehow) behind points
		if (ML::Pow(EndPointDist, 2.) >= ML::Sqrt(ML::Pow(PointsDistance, 2.) + ML::Pow(StartPointDist, 2.))) {
			G_SectorCheckpointsDist[Sector] = ML::Max(StartPointPayloadDist, 0.);
			continue;
		}
		
		// ---------------------------------- //
		// Checkpoint is between two points
		declare Ratio = StartPointDist / (StartPointDist + EndPointDist);
		G_SectorCheckpointsDist[Sector] = StartPointPayloadDist + Ratio * (EndPointPayloadDist - StartPointPayloadDist);
	}
	
	// Send Checkpoints data to the UI
	UISetCheckpointsDistances(G_SectorCheckpointsDist);
}

if (G_IsPayloadRace) UISetCheckpointsDistances([1 => G_PayloadTrackTotalDist]);

// Balance teams
if (S_UseAutoBalance) GT_AutoBalance();

// ---------------------------------- //
// Deautomatize Gates used on the map
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.Automatic = False;
	MapLandmark.Gate.ManualClosed = False;
	MapLandmark.Gate.Clan = 0;
	MapLandmark.Gauge.Speed = 0;
	MapLandmark.Gauge.ValueReal = 0.;
}

// Init UI
for (Clan, 1, 2) {
	UISetNbPlayersPushingPayload(0, Clan);
	UISetLastPushTime(-1, Clan);
}
UISetIsOvertime(False);
UISetAttackingTeam(3 - G_AttackingClan);
UISetIsPayloadRace(G_IsPayloadRace);

// Warm Up
if (!MM_IsMatchServer() && S_WarmUpDuration > 0 && S_NbPlayersPerTeamMax > 0)
	GT_DoWarmUp(S_WarmUpDuration, S_NbPlayersPerTeamMax);
***

// ---------------------------------- //
// Initialize round
// ---------------------------------- //
***Match_InitRound***
***
G_CapturedSectors = 0;
IsPreparationPhase = True;
PrevCheckpointDistance = 0.;
PrevPayloadDistance = [1 => -1., 2 => -1.];
PrevLeadingClan = 0;

if (G_IsPayloadRace) TeamsPayloadMaxDist = [0., 0., 0.];
else NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors+1];

for (Clan, 1, 2) {
	Markers::RemoveMarker("Payload#"^Clan);
	Markers::RemoveMarker("Goal#"^Clan);
	UISetNbPlayersPushingPayload(0, Clan);
	UISetLastPushTime(-1, Clan);
}
Markers::RemoveMarker("Checkpoint");

G_IsOvertime = False;
UISetIsOvertime(G_IsOvertime);

// Swap the currently attacking team
G_AttackingClan = 3 - G_AttackingClan;
UISetAttackingTeam(G_AttackingClan);

AttackPathOrder = [1 => 0, 2 => 0];
if (G_IsPayloadRace) AttackPathOrder = [1 => 3-G_AttackingClan, 2 => G_AttackingClan];

// Reset Payload distance
for (Clan, 1, 2) {
	G_PayloadCurrentDist[Clan] = 0.;
	UISetPayloadDistance(G_PayloadCurrentDist[Clan], Clan);
}

UpdateBasesColors();

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (Clan => ObjectsIds in PayloadStructureObjects) {
	if (Clan <= 0 || ObjectsIds.count <= 0) continue;
	foreach (ObjectId in ObjectsIds) {
		if (!Objects.existskey(ObjectId)) continue;
		ObjectDestroy(Objects[ObjectId]);
	}
}
PayloadStructureObjects = [1 => Ident[], 2 => Ident[]];

// ---------------------------------- //
// Create new Payload structure objects
for (Clan, 1, 2) {
	if (!G_IsPayloadRace && Clan != G_AttackingClan) continue;
	PayloadStructureObjects[Clan] = [ObjectCreate(G_ObjectsIds["Payload"]).Id];
	
	// Reset the payload position
	G_PayloadPosition[Clan] = GetPayloadPosition(G_PayloadCurrentDist[Clan], AttackPathOrder[Clan]);
	SetObjectsPosition(PayloadStructureObjects[Clan], G_PayloadPosition[Clan], Clan);
}

// ---------------------------------- //
// Init Payload Race mode
if (G_IsPayloadRace) {
	for (Clan, 1, 2) {
		declare Order = AttackPathOrder[Clan];

		// Get clan Spawn
		declare Spawn <=> Map::GetLandmarkPlayerSpawn("Spawn", Order);
		G_ClansRaceSpawns[Clan] <=> Spawn;
		if (Spawn.Base != Null) {
			Spawn.Base.IsActive = True;
			Spawn.Base.Clan = Clan;
		}

		// Get clan Goal
		declare Goal <=> Map::GetLandmarkGauge("Goal", Order);
		G_ClansRaceGoals[Clan] <=> Goal;
		Goal.Gauge.Clan = Clan;
		Goal.Gauge.Captured = False;

		if (Goal.Base != Null) {
			Goal.Base.IsActive = True;
			Goal.Base.Clan = 3-Clan;
		}
	}
}

// ---------------------------------- //
// Decapture all used Gauges
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Checkpoint") continue;
	MapLandmark.Gauge.ValueReal = 0.;
	MapLandmark.Gauge.Captured = False;
}

// ---------------------------------- //
// Deautomatize Gates used on the map
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gauge.ValueReal = 0.;
}

// ---------------------------------- //
// Reset players Payload time
foreach (Player in Players) {
	declare Real TimeNearPayload for Player;
	declare Real PrevTimeNearPayload for Player;
	TimeNearPayload = 0.;
	PrevTimeNearPayload = 0.;
}

// Wait for enough players to start the game
if (!S_EnableDebugMode) GT_WaitForPlayers(S_NbPlayersPerTeamMin);

// Matchmaking: allow substitutes
if (MM_IsMatchServer()) MM_AllowSubstitutes(True);

// Character selection screen
GT_ShowCharSelection();

// ---------------------------------- //
// Close Gates after warm-up
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.ManualClosed = True;
	MapLandmark.Gauge.ValueReal = 1.;
}

// ---------------------------------- //
// Init objects tiers
declare ObjectsTier = G_CapturedSectors + 1;
if (G_IsPayloadRace) ObjectsTier = 0;

GalaxyTitles::InitObjects();
GalaxyTitles::SetObjectsSpawnTier(ObjectsTier);

// ---------------------------------- //
// New round start
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
StartTime = Now + S_RespawnTime;
IsPreparationPhase = !G_IsPayloadRace;
declare RoundText = "";

// ---------------------------------- //
// Init Payload Race
if (G_IsPayloadRace) {
	CurSectorStartTime = StartTime;
	if (S_TimeLimit > 0) GT_SetTimeLimit(CurSectorStartTime + S_TimeLimit * 1000);
	else GT_DisableTimeLimit();

	for (Clan, 1, 2) {
		LastPayloadInteractionTime[Clan] = StartTime;
		if (S_AllowPayloadReversing) UISetLastPushTime(LastPayloadInteractionTime[Clan], Clan);
	}

	// Announce round start
	RoundText = TL::Compose("%1 #"^MB_GetRoundCount(), _("Round"));
	Message::SendBigMessage(RoundText, 3000, 0, CUIConfig::EUISound::StartRound, 0);
	Translations::SendStatusMessage("Payload Race", 3000, 0);
}
// ---------------------------------- //
// Init Payload Classic
else {
	UIManager.UIAll.CountdownEndTime = StartTime + C_SetupPhaseDuration;
	if (S_TimeLimit > 0) GT_SetTimeLimit(UIManager.UIAll.CountdownEndTime + S_TimeLimit * 1000);
	else GT_DisableTimeLimit();

	LastPayloadInteractionTime[G_AttackingClan] = UIManager.UIAll.CountdownEndTime;
	if (S_AllowPayloadReversing) UISetLastPushTime(LastPayloadInteractionTime[G_AttackingClan], G_AttackingClan);

	// Disable PvP
	UsePvPCollisions = False;
	UsePvPWeapons = False;

	// Faster gate activation in debug mode
	if (S_EnableDebugMode) UIManager.UIAll.CountdownEndTime = StartTime + 3000;

	// Announce attackers
	RoundText = TL::Compose("%1 "^MB_GetRoundCount()^" / "^S_NbRoundsPerTeam * 2, _("Round"));
	Message::SendBigMessage(RoundText, 3000, 0, CUIConfig::EUISound::StartRound, 0);
	Message::SendStatusMessage(TL::Compose(_("$<%1$> is attacking!"), Teams[G_AttackingClan - 1].ColorizedName), 3000, 0);
}

ST2::SetFooterText(RoundText);
***

// ---------------------------------- //
// Play loop start
// ---------------------------------- //
***Match_StartPlayLoop***
***
Layers::Attach("Payload:Interface");
Layers::Attach("Payload:Markers");

for (Clan, 1, 2) {
	if (!G_IsPayloadRace && Clan != G_AttackingClan) continue;
	UpdateMarkers(PayloadStructureObjects[Clan][0], Clan);
}
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// ---------------------------------- //
// Preparation phase countdown as opening first Sector Gates
if (IsPreparationPhase) foreach (MapLandmark in MapLandmarks_Gate) {
	if (MapLandmark.Order > 1) continue;
	if (C_SetupPhaseDuration > 0) MapLandmark.Gauge.ValueReal = ML::Clamp(
		ML::ToReal(UIManager.UIAll.CountdownEndTime - Now) / C_SetupPhaseDuration + .01, 0., 1.
	);
}

// ---------------------------------- //
// Stop the preparation phase
if (UIManager.UIAll.CountdownEndTime > 0 && Now >= UIManager.UIAll.CountdownEndTime) {
	UIManager.UIAll.CountdownEndTime = -1;
	CurSectorStartTime = Now;
	IsPreparationPhase = False;

	// Enable PvP
	UsePvPCollisions = True;
	UsePvPWeapons = True;
	
	// ---------------------------------- //
	// Match beginning sound
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::PlayerInfo, 
		Null, CUIConfig::EAvatarVariant::Default, 
		CUIConfig::EUISound::StartMatch, 1
	);
	
	// ---------------------------------- //
	// Open the first Sector Gates
	foreach (MapLandmark in MapLandmarks_Gate) {
		if (MapLandmark.Order > 1) continue;
		MapLandmark.Gate.ManualClosed = False;
		MapLandmark.Gauge.ValueReal = 0.;
	}
}

// ---------------------------------- //
// Manage player functions
foreach (Player in Players) {
	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);
		
		// ---------------------------------- //
		// Select player spawn
		declare CSmMapPlayerSpawn PlayerSpawn;
		if (!G_IsPayloadRace) {
			declare SpawnSector = ML::Min(G_CapturedSectors + 1, G_CurMapTotalNbSectors);
			declare SpawnTag = "SpawnAtk";
			if (Player.CurrentClan != G_AttackingClan) SpawnTag = "SpawnDef";
			PlayerSpawn <=> Map::GetPlayerSpawn(SpawnTag, SpawnSector);
		}
		else if (G_ClansRaceSpawns.existskey(Player.CurrentClan)) {
			PlayerSpawn <=> G_ClansRaceSpawns[Player.CurrentClan].PlayerSpawn;
		}

		// ---------------------------------- //
		// Spawn player
		if (PlayerSpawn != Null) SM::Spawn(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
	}
}

// ---------------------------------- //
// Get the amount of players who push the Payload
for (Clan, 1, 2) {
	if (!G_IsPayloadRace && Clan != G_AttackingClan) continue;
	
	declare NbAttackersPushingPayload = 0;
	declare NbDefendersStoppingPayload = 0;
	
	foreach (Player in Players) {
		if (IsPreparationPhase) break;
		if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || Player.Position == <0., 0., 0.>) continue;
		if (ML::Distance(Player.Position, G_PayloadPosition[Clan]) > C_PayloadActivationRadius) continue;
		
		if (Player.CurrentClan == Clan) NbAttackersPushingPayload += 1;
		else NbDefendersStoppingPayload += 1;
		
		// ---------------------------------- //
		// Attack points
		if (Player.CurrentClan != Clan) continue;
		declare Real TimeNearPayload for Player;
		declare Real PrevTimeNearPayload for Player;
		TimeNearPayload += 1000. / C_ScriptTicksPerSecond;
		
		if (TimeNearPayload - PrevTimeNearPayload > C_PayloadTimePerPoint) {
			PrevTimeNearPayload = TimeNearPayload;
			Scores::AddPlayerRoundPoints(Player.Score, 1);
			TopScores::AddPoints(Player.Score, "Attack", 1);
		}
	}
	
	// UI
	if (NbDefendersStoppingPayload <= 0) UISetNbPlayersPushingPayload(NbAttackersPushingPayload, Clan);
	else UISetNbPlayersPushingPayload(0, Clan);
	
	// ---------------------------------- //
	// Move Payload along its route
	if (NbAttackersPushingPayload > NbDefendersStoppingPayload) {
		declare PayloadSpeed = ML::Min(NbAttackersPushingPayload, C_PayloadMaxPlayersPushing) * C_PayloadSpeedPerPlayer;
		
		// Update last push time
		if (S_AllowPayloadReversing) {
			LastPayloadInteractionTime[Clan] = Now;
			UISetLastPushTime(LastPayloadInteractionTime[Clan], Clan);
		}
	
		// Increased speed in debug mode
		if (S_EnableDebugMode) PayloadSpeed *= 10.;
		
		// Increase travelled distance
		G_PayloadCurrentDist[Clan] += PayloadSpeed / C_ScriptTicksPerSecond;
		if (G_PayloadCurrentDist[Clan] >= G_PayloadTrackTotalDist) G_PayloadCurrentDist[Clan] = G_PayloadTrackTotalDist;
	}
	
	// ---------------------------------- //
	// Moving Payload backwards if noone pushed it for enough time
	if (
		S_AllowPayloadReversing &&
		Now > LastPayloadInteractionTime[Clan] + C_PayloadReversingTimeLimit &&
		(G_IsPayloadRace || G_PayloadCurrentDist[Clan] > PrevCheckpointDistance)
	) {
		G_PayloadCurrentDist[Clan] -= C_PayloadReversingSpeed / C_ScriptTicksPerSecond;
		
		if (G_PayloadCurrentDist[Clan] <= PrevCheckpointDistance) {
			G_PayloadCurrentDist[Clan] = PrevCheckpointDistance;
			UISetLastPushTime(-1, Clan);
		}
	
		// Stop the round in overtime
		if (G_IsOvertime) {
			UIManager.UIAll.SendNotice(
				"", CUIConfig::ENoticeLevel::MatchInfo, Null,
				CUIConfig::EAvatarVariant::Default,
				CUIConfig::EUISound::VictoryPoint, 0
			);
			MB_StopRound();
		}
	}
	
	// ---------------------------------- //
	// Payload distance has changed
	if (PrevPayloadDistance[Clan] != G_PayloadCurrentDist[Clan]) {
		UISetPayloadDistance(G_PayloadCurrentDist[Clan], Clan);
		UpdateMarkers(PayloadStructureObjects[Clan][0], Clan);
		
		// Update the Payload position
		G_PayloadPosition[Clan] = GetPayloadPosition(G_PayloadCurrentDist[Clan], AttackPathOrder[Clan]);
		SetObjectsPosition(PayloadStructureObjects[Clan], G_PayloadPosition[Clan], Clan);
		
		// Save the furthest distance
		if (G_PayloadCurrentDist[Clan] > TeamsPayloadMaxDist[Clan])
			TeamsPayloadMaxDist[Clan] = G_PayloadCurrentDist[Clan];
		
		MiniMap::SetMarker("Payload#"^Clan, "Payload.png", Teams[Clan-1].ColorPrimary, G_PayloadPosition[Clan]);

		// ---------------------------------- //
		// Manage Payload Race
		if (G_IsPayloadRace) {
			TeamsPayloadMaxDist[Clan] = G_PayloadCurrentDist[Clan];

			// ---------------------------------- //
			// Manage the Goal
			declare MapLandmark <=> G_ClansRaceGoals[Clan];
			MapLandmark.Gauge.ValueReal = ML::Clamp(G_PayloadCurrentDist[Clan] / G_PayloadTrackTotalDist, 0., 1.);
			MapLandmark.Gauge.Captured = MapLandmark.Gauge.ValueReal >= 1;

			// ---------------------------------- //
			// Team captured a checkpoint
			if (G_PayloadCurrentDist[Clan] >= G_PayloadTrackTotalDist) {
				TeamsPayloadMaxDist[Clan] = G_PayloadTrackTotalDist;
				if (MapLandmark.Base != Null) MapLandmark.Base.Clan = MapLandmark.Gauge.Clan;
				MB_StopRound();

				Message::SendBigMessage(TL::Compose(
					_("$<%1$> captured the goal!"), Teams[Clan-1].ColorizedName),
					3000, 0, CUIConfig::EUISound::VictoryPoint, 0
				);
				MiniMap::Flash();
			}

			// ---------------------------------- //
			// Change leading team
			declare LeadingTeam = 0;
			if (TeamsPayloadMaxDist[1] != TeamsPayloadMaxDist[2]) {
				LeadingTeam = 1;
				if (TeamsPayloadMaxDist[2] > TeamsPayloadMaxDist[1]) LeadingTeam = 2;
			}
			if (PrevLeadingClan != LeadingTeam) {
				PrevLeadingClan = LeadingTeam;

				if (LeadingTeam != 0) {
					Message::SendBigMessage(
						TL::Compose(_("$<%1$> takes the lead!"), Teams[LeadingTeam-1].ColorizedName),
						3000, 1, CUIConfig::EUISound::PhaseChange, 1
					);
					MiniMap::Flash();
				}
			}

			continue;
		}
		
		// ---------------------------------- //
		// Attackers captured a Checkpoint
		if (G_PayloadCurrentDist[Clan] >= NextCheckpointDistance) {
			G_CapturedSectors += 1;
			UpdateBasesColors();
			GalaxyTitles::SetObjectsSpawnTier(G_CapturedSectors + 1);
			MiniMap::Flash();
			
			// Give point for the attacking team
			ClanScores[G_AttackingClan] += 1;
			MM_SetScores([ClanScores[1], ClanScores[2]]);
			
			// ---------------------------------- //
			// Get parameters for the next Sector
			if (G_CapturedSectors < G_CurMapTotalNbSectors) {
				PrevCheckpointDistance = NextCheckpointDistance;
				NextCheckpointDistance = G_SectorCheckpointsDist[G_CapturedSectors + 1];
	
				// Disable overtime
				G_IsOvertime = False;
				UISetIsOvertime(G_IsOvertime);
				
				Message::SendBigMessage(TL::Compose(
					_("%1 captured %2 checkpoints"), Teams[Clan-1].ColorizedName, TL::ToText(G_CapturedSectors)),
					3000, 0, CUIConfig::EUISound::Capture, 0
				);
				
				// ---------------------------------- //
				// Extend the time limit
				CurSectorStartTime = Now;
				if (S_TimeLimit > 0) GT_SetTimeLimit(CurSectorStartTime + S_TimeLimit * 1000);
			}
			// ---------------------------------- //
			// Stop the round
			else {
				TeamsPayloadMaxDist[G_AttackingClan] = G_PayloadTrackTotalDist;
				MB_StopRound();
	
				Message::SendBigMessage(TL::Compose(
					_("$<%1$> captured the last pole."), Teams[G_AttackingClan - 1].ColorizedName),
					3000, 0, CUIConfig::EUISound::VictoryPoint, 0
				);
			}
		}
		
		// Get the current Checkpoint progres
		declare CheckpointProgres = (G_PayloadCurrentDist[Clan] - PrevCheckpointDistance) / (NextCheckpointDistance - PrevCheckpointDistance);
		
		// ---------------------------------- //
		// Show Payload progress on Checkpoints gauges
		foreach (MapLandmark in MapLandmarks_Gauge) {
			if (MapLandmark.Tag != "Checkpoint") continue;
			
			if (MapLandmark.Order <= G_CapturedSectors) {
				MapLandmark.Gauge.ValueReal = 1.;
				MapLandmark.Gauge.Captured = True;
			}
			else if (MapLandmark.Order == G_CapturedSectors + 1) MapLandmark.Gauge.ValueReal = CheckpointProgres;
			else MapLandmark.Gauge.ValueReal = 0.;
		}
		
		// ---------------------------------- //
		// Show Payload progress as opening Gates
		foreach (MapLandmark in MapLandmarks_Gate) {
			if (MapLandmark.Tag != "Gate" || MapLandmark.Order <= 1) continue;
			
			MapLandmark.Gate.ManualClosed = MapLandmark.Order > G_CapturedSectors + 1;
	
			if (MapLandmark.Order == G_CapturedSectors + 2) MapLandmark.Gauge.ValueReal = ML::Clamp(1.05 - CheckpointProgres, .05, 1.);
			else if (MapLandmark.Order > G_CapturedSectors + 2) MapLandmark.Gauge.ValueReal = 1.;
			else MapLandmark.Gauge.ValueReal = 0.;
		}
	
		PrevPayloadDistance[Clan] = G_PayloadCurrentDist[Clan];
	}
}

// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit && UIManager.UIAll.CountdownEndTime <= 0) {
	CurrentTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) GT_SetTimeLimit(CurSectorStartTime + S_TimeLimit * 1000);
	else GT_DisableTimeLimit();
}

// ---------------------------------- //
// Payload reversing setting change
if (PrevAllowPayloadReversing != S_AllowPayloadReversing) {
	PrevAllowPayloadReversing = S_AllowPayloadReversing;
	
	for (Clan, 1, 2) {
		if (!S_AllowPayloadReversing) UISetLastPushTime(-1, Clan);
		else LastPayloadInteractionTime[Clan] = Now;
	}
}

// ---------------------------------- //
// Victory conditions
if (GT_TimeReachedLimit()) {
	if (
		S_AllowPayloadReversing && !G_IsPayloadRace &&
		Now < LastPayloadInteractionTime[G_AttackingClan] + C_PayloadReversingTimeLimit
	) {
		G_IsOvertime = True;
		UISetIsOvertime(G_IsOvertime);
	}
	else MB_StopRound();
}
***

// ---------------------------------- //
// Play loop end
// ---------------------------------- //
***Match_EndPlayLoop***
***
Layers::Detach("Payload:Markers");
MiniMap::DestroyMarker("Payload");
UISetIsOvertime(False);
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_EndRound***
***
SM::UnspawnAllPlayers();
declare RoundWinner = 0;
declare RoundStatusMessage = Text[];

// ---------------------------------- //
// Get round winner in Payload Race
if (G_IsPayloadRace) {
	declare Difference = 0.;

	if (TeamsPayloadMaxDist[1] != TeamsPayloadMaxDist[2]) {
		RoundWinner = 1;
		if (TeamsPayloadMaxDist[2] > TeamsPayloadMaxDist[1]) RoundWinner = 2;
		Difference = ML::Abs(TeamsPayloadMaxDist[1] - TeamsPayloadMaxDist[2]);
	}

	if (RoundWinner > 0) {
		RoundStatusMessage = [
			"$<%1$> have delivered the Payload %2 m further",
			Teams[RoundWinner-1].ColorizedName, TL::FormatReal(Difference, 2, False, False)
		];
		ClanScores[RoundWinner] += 1;
	}
}
// ---------------------------------- //
// Get round winner in Payload Classic
else {
	RoundWinner = 3 - G_AttackingClan;
	if (G_CapturedSectors >= G_CurMapTotalNbSectors) RoundWinner = G_AttackingClan;
}

MB_Sleep(3000);

Layers::Detach("Payload:Interface");
GT_DisableTimeLimit();
StartTime = -1;

// ---------------------------------- //
// Destroy previous Payload structure objects
foreach (Clan => ObjectsIds in PayloadStructureObjects) {
	if (Clan <= 0 || ObjectsIds.count <= 0) continue;
	foreach (ObjectId in ObjectsIds) {
		if (!Objects.existskey(ObjectId)) continue;
		ObjectDestroy(Objects[ObjectId]);
	}
}
PayloadStructureObjects = [1 => Ident[], 2 => Ident[]];

Message::CleanBigMessages();

// ---------------------------------- //
// Show the winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

declare Msg = _("|Match|Draw");
if (RoundWinner != 0) Msg = TL::Compose(_("$<%1$> wins the round!"), Teams[RoundWinner - 1].ColorizedName);
Message::SendBigMessage(Msg, 6000, 0, CUIConfig::EUISound::EndRound, 0);
if (RoundStatusMessage.count > 0) Translations::SendStatusMessage(RoundStatusMessage, 6000, 0);

MB_Sleep(6000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Map end conditions
if (G_IsPayloadRace) {
	declare MatchWiningClan = GT_GetMatchWinner(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
	if (MatchWiningClan > 0) MB_StopMatch();
}
else if (MB_GetRoundCount() >= S_NbRoundsPerTeam * 2) MB_StopMatch();
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***Match_EndMap***
***
if (!G_IsPayloadRace && ClanScores[1] == ClanScores[2]) {
	// ---------------------------------- //
	// Team with furthest distance wins
	if (TeamsPayloadMaxDist[1] != TeamsPayloadMaxDist[2]) {
		declare AdvantageTeam = 1;
		if (TeamsPayloadMaxDist[2] > TeamsPayloadMaxDist[1]) AdvantageTeam = 2;
		declare Diff = ML::Abs(TeamsPayloadMaxDist[1] - TeamsPayloadMaxDist[2]);

		Translations::SendStatusMessage([
			"$<%1$> have delivered the Payload %2 m further",
			Teams[AdvantageTeam - 1].ColorizedName, TL::FormatReal(Diff, 2, False, False)],
			5000, 0);
		ClanScores[AdvantageTeam] += 1;
	}

	// ---------------------------------- //
	// Play Sudden Death mode in case there is a draw
	else {
		// ---------------------------------- //
		// Open all Gates
		foreach (MapLandmark in MapLandmarks_Gate) {
			MapLandmark.Gate.Automatic = False;
			MapLandmark.Gate.ManualClosed = False;
			MapLandmark.Gauge.ValueReal = 0.;
		}
		
		// Award one point to the winner
		declare SuddenDeathWinner = GT_SuddenDeath(
			Map::GetLandmarkPlayerSpawn("SpawnAtk", 1),
			Map::GetLandmarkPlayerSpawn("SpawnDef", 1)
		);
		ClanScores[SuddenDeathWinner] += 1;
	}
}
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***Match_EndServer***
***
Layers::Destroy("Payload:Interface");
Layers::Destroy("Payload:Markers");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get Payload position according to the given distance
 *
 *	@param	_RawDistance	The distance the Payload has travelled
 *
 *	@return		The position the Payload should appear at
 */
Vec3 GetPayloadPosition(Real _RawDistance, Integer _Order) {
	if (G_PayloadTrackTotalDist <= 0) return Vec3;
	
	if (!G_PayloadTrackPointsDist.existskey(_Order)) return Vec3;
	declare PayloadTrackPoints = G_PayloadTrackPointsDist[_Order];
	
	// Clamp the distance to fit between 0 and total Payload route length
	declare Distance = ML::Clamp(_RawDistance, 0., G_PayloadTrackTotalDist);
	
	// A point exists exactly at the given distance
	if (PayloadTrackPoints.exists(Distance)) return PayloadTrackPoints.keyof(Distance);
	
	// ---------------------------------- //
	// Get the segment start and end positions and distances
	declare SegmentStartPosn = Vec3;
	declare SegmentStartDist = 0.;
	declare SegmentEndPosn = Vec3;
	declare SegmentEndDist = 0.;
	declare PrevPointPosn = Vec3;
	declare PrevPointDist = 0.;
	
	foreach (PointPosnition => PointDistance in PayloadTrackPoints) {
		if (PointDistance >= Distance) {
			SegmentStartPosn = PrevPointPosn;
			SegmentStartDist = PrevPointDist;
			SegmentEndPosn = PointPosnition;
			SegmentEndDist = PointDistance;
			break;
		}
		PrevPointPosn = PointPosnition;
		PrevPointDist = PointDistance;
	}
	
	// Percentage progress on completing the route segment
	declare SegmentOffset = (Distance - SegmentStartDist) / (SegmentEndDist - SegmentStartDist);
	
	// Compute the final position
	declare Vec3 PayloadPosition;
	for (I, 0, 2) PayloadPosition[I] = SegmentStartPosn[I] + (SegmentEndPosn[I] - SegmentStartPosn[I]) * SegmentOffset;
	return PayloadPosition;
}

// ---------------------------------- //
/// Update colors of all used landmarks
Void UpdateBasesColors() {
	foreach (MapLandmark in MapLandmarks) {
		// ---------------------------------- //
		// Colorize Checkpoints and defense Spawns
		if (MapLandmark.Tag == "Checkpoint" || MapLandmark.Tag == "SpawnDef") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors) Clan = G_AttackingClan;
			
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;
			if (MapLandmark.Gauge != Null) MapLandmark.Gauge.Clan = G_AttackingClan;
		}
		
		// ---------------------------------- //
		// Colorize attackers Spawns and Gates
		if (MapLandmark.Tag == "SpawnAtk" || MapLandmark.Tag == "Gate") {
			declare Clan = 3 - G_AttackingClan;
			if (MapLandmark.Order <= G_CapturedSectors + 1) Clan = G_AttackingClan;
			if (MapLandmark.Base != Null) MapLandmark.Base.Clan = Clan;

			if (MapLandmark.Gauge != Null) {
				if (MapLandmark.Order == 1) MapLandmark.Gauge.Clan = G_AttackingClan;
				else MapLandmark.Gauge.Clan = 3 - G_AttackingClan;
			}
		}
	}
}

// ---------------------------------- //
/** Set poition of a group of objects.
 *
 *	@param	_Objects	The objects to set position.
 *	@param	_Position	Target position.
 *	@param	_Clan		The clan to update.
 */
Void SetObjectsPosition(Ident[] _Objects, Vec3 _Position, Integer _Clan) {
	if (_Objects.count <= 0) return;
	
	foreach (ObjectId in _Objects) {
		if (!Objects.existskey(ObjectId)) continue;
		declare Object = Objects[ObjectId];
		
		if (_Position == <0., 0., 0.>) Object.SetUnspawned();
		else Object.SetPosition(_Position + <0., 1.25, 0.>); 
	}

	// Send position to the interface
	declare netwrite Vec3[Integer] Net_Payload_PayloadPosition for Teams[0];
	Net_Payload_PayloadPosition[_Clan] = _Position;
}

// ---------------------------------- //
/** Update the markers manialink.
 *
 *	@param	_PayloadObjectId	Id of the Payload object to get position from.
 */
Void UpdateMarkers(Ident _PayloadObjectId, Integer _Clan) {
	UIManager.UIAll.MarkersXML = "";
	if (!G_IsPayloadRace && _Clan != G_AttackingClan) return;

	// Payload object marker
	declare Payload <=> Objects[_PayloadObjectId];
	declare PayloadPos = Payload.Position.X^" "^Payload.Position.Y^" "^Payload.Position.Z;
	Markers::AddMarker("Payload#"^_Clan, "<marker manialinkframeid='Frame_MarkerPayload#"^_Clan^"' visibility='WhenInFrustum' pos='"^PayloadPos^"' box='0 2 0' />");

	// Next checkpoint marker
	if (!G_IsPayloadRace) {
		declare CurSector = ML::Clamp(G_CapturedSectors + 1, 1, G_CurMapTotalNbSectors);
		declare MapLandmark <=> Map::GetLandmarkGauge("Checkpoint", CurSector);
		if (MapLandmark != Null) {
			declare Pos = MapLandmark.Position.X^" "^MapLandmark.Position.Y + 2^" "^MapLandmark.Position.Z;
			Markers::AddMarker("Checkpoint", "<marker manialinkframeid='Frame_MarkerCheckpoint' visibility='WhenInFrustum' pos='"^Pos^"' />");
		}
	}

	// Goals markers
	else for (Clan, 1, 2) {
		declare MapLandmark <=> G_ClansRaceGoals[Clan];
		declare Pos = MapLandmark.Position.X^" "^MapLandmark.Position.Y + 28^" "^MapLandmark.Position.Z;
		Markers::AddMarker("Goal#"^3-Clan, "<marker manialinkframeid='Frame_MarkerGoal#"^3-Clan^"' visibility='WhenInFrustum' pos='"^Pos^"' />");
	}
}

// ---------------------------------- //
/// UI update.
Void TriggerUIUpdate() {
	declare netwrite Integer Net_Payload_LastUIUpdate for Teams[0];
	Net_Payload_LastUIUpdate = Now;
}

// ---------------------------------- //
/** Set UI Checkpoints distances
 *
 *	@param	_CPDistances	Checkpoints distances
 */
Void UISetCheckpointsDistances(Real[Integer] _CPDistances) {
	declare netwrite Real[] Net_Payload_CheckpointDistances for Teams[0];
	Net_Payload_CheckpointDistances.clear();

	foreach (Distance in _CPDistances) Net_Payload_CheckpointDistances.add(Distance);
	Net_Payload_CheckpointDistances = Net_Payload_CheckpointDistances.sort();
	TriggerUIUpdate();
}

// ---------------------------------- //
/** Set UI Payload distance.
 *
 *	@param	_PayloadDistance	Payload distance.
 *	@param	_Clan				The clan to update.
 */
Void UISetPayloadDistance(Real _PayloadDistance, Integer _Clan) {
	declare netwrite Real[Integer] Net_Payload_PayloadDistance for Teams[0];
	Net_Payload_PayloadDistance[_Clan] = ML::Clamp(_PayloadDistance, 0., G_PayloadTrackTotalDist);
}

// ---------------------------------- //
/** Set UI attacking team
 *
 *	@param	_AttackingTeam		Currently attacking team
 */
Void UISetAttackingTeam(Integer _AttackingTeam) {
	declare netwrite Integer Net_Payload_AttackingTeam for Teams[0];
	Net_Payload_AttackingTeam = ML::Clamp(_AttackingTeam, 1, 2);
	TriggerUIUpdate();
}

// ---------------------------------- //
/** Set UI amount of attackers pushing Payload.
 *
 *	@param	_PlayersNb	Players pushing Payload.
 *	@param	_Clan		The clan to update.
 */
Void UISetNbPlayersPushingPayload(Integer _PlayersNb, Integer _Clan) {
	declare netwrite Integer[Integer] Net_Payload_NbPlayersPushingPayload for Teams[0];
	Net_Payload_NbPlayersPushingPayload[_Clan] = ML::Max(0, _PlayersNb);
}

// ---------------------------------- //
/** Set the latest push time.
 *
 *	@param	_Time	Latest push time.
 *	@param	_Clan	The clan to update.
 */
Void UISetLastPushTime(Integer _Time, Integer _Clan) {
	declare netwrite Integer[Integer] Net_Payload_LastPushTime for Teams[0];
	Net_Payload_LastPushTime[_Clan] = _Time;
}

// ---------------------------------- //
/** Set the overtime status.
 *
 *	@param	_IsOvertime		If overtime is active or not.
 */
Void UISetIsOvertime(Boolean _IsOvertime) {
	declare netwrite Boolean Net_Payload_IsOvertime for Teams[0];
	Net_Payload_IsOvertime = _IsOvertime;
	Interfancy::SetModuleVisibility("Countdown", !_IsOvertime);
}

// ---------------------------------- //
/** Set the type of the game.
 *
 *	@param	_IsPayloadRace	If the game ins a Payload Race or not.
 */
Void UISetIsPayloadRace(Boolean _IsPayloadRace) {
	declare netwrite Boolean Net_Payload_IsPayloadRace for Teams[0];
	Net_Payload_IsPayloadRace = _IsPayloadRace;
	TriggerUIUpdate();
}

// ---------------------------------- //
/** Create manialink for the Payload Interface
 *
 *	@return		The manialink
 */
Text CreateManialinkPayloadUI() {
	declare Text SectorBarFrames;
	for (I, 0, C_MapMaximumNbSectors - 1) SectorBarFrames ^= "<frameinstance modelid='FrameModel_Sector' id='Frame_SectorProgress#"^I^"' />";
	
	return """
<manialink version="3" name="Payload:Interface">
<stylesheet>
	<style id="Label_PayloadMarker" textsize="2" textcolor="FFF" textfont="Eurostile_Bold" />
	<style id="Label_PayloadBackwards" textsize="1" textcolor="FFF" textfont="Eurostile_Bold" />
	<style class="CircGauge" size="16 16" halign="center" valign="center" colorize="FFF" />
	<style id="Label_TextOvertime" halign="center" valign="center2" textsize="2" textemboss="1" textfont="Eurostile_Bold" textcolor="FB0" textprefix="$t" />
	<style id="Label_CaptureProgress" halign="center" valign="center2" textsize="3" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold" />
</stylesheet>

<framemodel id="FrameModel_Sector">
	<gauge pos="-2" size="0 8" valign="center" drawbg="0" id="Gauge_CPProgress" />
</framemodel>

<framemodel id="FrameModel_PayloadProgress">
	<frame pos="-60 .3">{{{SectorBarFrames}}}</frame>
	<quad pos="-63" size="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemLeft" />
	<quad pos="63" size="5 5" halign="center" valign="center" style="Emblems" id="Quad_EmblemRight" />
	<quad size="135.875 8" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadProgressBar.png" />
</framemodel>

<frame id="Frame_PayloadProgressBox">
	<frameinstance modelid="FrameModel_PayloadProgress" id="Frame_PayloadProgress#1" pos="0 78" hidden="1" />
	<frameinstance modelid="FrameModel_PayloadProgress" id="Frame_PayloadProgress#2" pos="0 70" hidden="1" />
</frame>

<framemodel id="FrameModel_PayloadGauge">
	<label size="5 5" halign="center" valign="center2" id="Label_PayloadMarker" text="0" />
	<label size="5 5" halign="center" valign="center2" id="Label_PayloadBackwards" text="" hidden="1" />
	<frame scale=".4">
		<frame size="8 16" valign="center" halign="left">
			<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeL" hidden="1" />
		</frame>
		<frame size="8 16" valign="center" halign="right">
			<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeR" hidden="1" rot="180" />
		</frame>
		<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeBg.png" id="Quad_GaugeBg" />
	</frame>
</framemodel>

<frame id="Frame_PayloadTimersBox" pos="0 74" hidden="1">
	<framemodel id="FrameModel_PayloadTimer">
		<frameinstance modelid="FrameModel_PayloadGauge" />
		<quad size="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadMarker2.png" />
	</framemodel>
	<frameinstance modelid="FrameModel_PayloadTimer" id="Frame_PayloadTimer#1" pos="-71" />
	<frameinstance modelid="FrameModel_PayloadTimer" id="Frame_PayloadTimer#2" pos="71" />
</frame>

<frame pos="0 78">
	<frame id="Frame_PayloadMarker" pos="0 -7" hidden="1">
		<frameinstance modelid="FrameModel_PayloadGauge" pos="0 -1.3" />
		<quad size="10 10" halign="center" valign="center" image="{{{C_ImgBase}}}PayloadMarker.png" />
	</frame>
</frame>

<frame id="Frame_OvertimeGauge" pos="0 86.5" hidden="1">
	<label pos="0 .5" id="Label_TextOvertime" text="Overtime" translate="1" />
	<gauge pos="0 -2" size="0 7" halign="center" valign="center" drawbg="0" drawblockbg="0" color="FB0" id="Gauge_OvertimeProgress" />
</frame>

<frame id="Frame_CaptureProgress" pos="0 -54">
	<frame id="Frame_CaptureProgAnim">
		<label id="Label_CaptureProgress" opacity="0" />
		<quad pos="0 8" size="12 12" halign="center" valign="center" id="Quad_CaptureProgIcon" opacity="0" />
		<gauge pos="0 -3" size="52 8" halign="center" valign="center" drawbg="0" id="Gauge_CaptureProgress" hidden="1" />
	</frame>
</frame>

<label id="Label_DistanceDebug#1" scale="0" />
<label id="Label_DistanceDebug#2" scale="0" />

<script><!--
/**
 *	Payload: Interface
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_TotalProgressBarWidth	120.
#Const C_GaugeBarsSpacing		.75
#Const C_CaptureBarImgBase		"file://Media/Manialinks/ShootMania/Common/"

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Frame_PayloadTimersBox <=> (Page.GetFirstChild("Frame_PayloadTimersBox") as CMlFrame);
declare Frame_PayloadMarker <=> (Page.GetFirstChild("Frame_PayloadMarker") as CMlFrame);
declare Frame_PayloadTimer1 <=> (Page.GetFirstChild("Frame_PayloadTimer#1") as CMlFrame);
declare Frame_PayloadTimer2 <=> (Page.GetFirstChild("Frame_PayloadTimer#2") as CMlFrame);

declare Frame_OvertimeGauge <=> (Page.GetFirstChild("Frame_OvertimeGauge") as CMlFrame);
declare Label_TextOvertime <=> (Page.GetFirstChild("Label_TextOvertime") as CMlLabel);
declare Gauge_OvertimeProgress <=> (Page.GetFirstChild("Gauge_OvertimeProgress") as CMlGauge);

declare Frame_CaptureProgress <=> (Page.GetFirstChild("Frame_CaptureProgress") as CMlFrame);
declare Frame_CaptureProgAnim <=> (Page.GetFirstChild("Frame_CaptureProgAnim") as CMlLabel);
declare Label_CaptureProgress <=> (Page.GetFirstChild("Label_CaptureProgress") as CMlLabel);
declare Quad_CaptureProgIcon <=> (Page.GetFirstChild("Quad_CaptureProgIcon") as CMlQuad);
declare Gauge_CaptureProgress <=> (Page.GetFirstChild("Gauge_CaptureProgress") as CMlGauge);

declare CMlFrame[Integer] Frame_PayloadsProgress;
declare CMlLabel[Integer] Label_DistanceDebug;
declare CMlFrame[Integer] Frame_PayloadsTimers;

for (I, 1, 2) {
	Frame_PayloadsProgress[I] <=> (Page.GetFirstChild("Frame_PayloadProgress#"^I) as CMlFrame);
	Label_DistanceDebug[I] <=> (Page.GetFirstChild("Label_DistanceDebug#"^I) as CMlLabel);
}

foreach (I => Frame in Frame_PayloadsProgress) {
	declare CMlFrame[] Frame_SectorProgress for Frame;
	for (I, 0, {{{C_MapMaximumNbSectors-1}}}) Frame_SectorProgress.add((Frame.GetFirstChild("Frame_SectorProgress#"^I) as CMlFrame));
}

Label_TextOvertime.Value = _("Overtime");
Label_TextOvertime.Size.X = ML::Min(ComputeWidth(Label_TextOvertime), 18.);
Gauge_OvertimeProgress.Size.X = Label_TextOvertime.Size.X + 4.;

// ---------------------------------- //
// Netcode
declare netread Real[] Net_Payload_CheckpointDistances for Teams[0];
declare netread Integer Net_Payload_LastUIUpdate for Teams[0];
declare netread Integer Net_Payload_AttackingTeam for Teams[0];
declare netread Boolean Net_Payload_IsOvertime for Teams[0];
declare netread Boolean Net_Payload_IsPayloadRace for Teams[0];

declare netread Real[Integer] Net_Payload_PayloadDistance for Teams[0];
declare netread Vec3[Integer] Net_Payload_PayloadPosition for Teams[0];
declare netread Integer[Integer] Net_Payload_NbPlayersPushingPayload for Teams[0];
declare netread Integer[Integer] Net_Payload_LastPushTime for Teams[0];

// ---------------------------------- //
// Wait for at UI to initialize
wait(Net_Payload_CheckpointDistances.count > 0);
wait(Net_Payload_PayloadDistance.count > 0);
wait(Net_Payload_PayloadPosition.count > 0);
wait(Net_Payload_NbPlayersPushingPayload.count > 0);
wait(Net_Payload_LastPushTime.count > 0);

// ---------------------------------- //
// Variables
declare TotalDistance = 0.;
declare CaptureProgressVisible = False;
declare CaptureMesageType = 0;
declare UpdateColors = True;
declare GaugeRatio = [1 => 0., 2 => 0.];

/// Update
declare PrevPayloadDistance = [1 => -1., 2 => -1.];
declare PrevAnimDistance = [1 => -1., 2 => -1.];
declare PrevPlayersPushingPayload = [1 => -1, 2 => -1];
declare PrevGaugeRatio = [1 => -1., 2 => -1.];
declare PrevAttackingTeam = -1;
declare PrevCaptureProgressVisible = False;
declare PrevCaptureMesageType = -1;
declare PrevUIUpdate = -1;
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update the checkpoints amount
if (PrevUIUpdate != Net_Payload_LastUIUpdate) {
	PrevUIUpdate = Net_Payload_LastUIUpdate;

	for (Clan, 1, 2) {
		PrevPayloadDistance[Clan] = -1.;
		PrevAnimDistance[Clan] = -1.;
	}

	TotalDistance = Net_Payload_CheckpointDistances[Net_Payload_CheckpointDistances.count-1];
	declare SpacingSub = (Net_Payload_CheckpointDistances.count - 1) * C_GaugeBarsSpacing;
	UpdateColors = True;

	foreach (Clan => Frame in Frame_PayloadsProgress) {
		Frame.Visible = Clan == 1 || Net_Payload_IsPayloadRace;
		if (!Frame.Visible) continue;

		declare CMlFrame[] Frame_SectorProgress for Frame;
		declare PrevFramePosX = 0.;
		declare PrevCheckpointDistance = 0.;

		foreach (I => Frame_Sector in Frame_SectorProgress) {
			Frame_Sector.Visible = Net_Payload_CheckpointDistances.existskey(I);
			if (!Frame_Sector.Visible) continue;

			declare CurCPDistance = Net_Payload_CheckpointDistances[I];
			declare Gauge_CPProgress <=> (Frame_Sector.GetFirstChild("Gauge_CPProgress") as CMlGauge);
			
			Gauge_CPProgress.Size.X = (C_TotalProgressBarWidth - SpacingSub) * (CurCPDistance - PrevCheckpointDistance) / TotalDistance + 4;
			Frame_Sector.RelativePosition_V3.X = PrevFramePosX;
			PrevFramePosX += Gauge_CPProgress.Size.X - 4 + C_GaugeBarsSpacing;
			PrevCheckpointDistance = CurCPDistance;
		}
	}

	// ---------------------------------- //
	// Get the timers
	Frame_PayloadsTimers = [1 => Frame_PayloadTimer1, 2 => Frame_PayloadTimer2];
	if (!Net_Payload_IsPayloadRace) Frame_PayloadsTimers[1] <=> Frame_PayloadMarker;
}

// Overtime gauge
Frame_OvertimeGauge.Visible = Net_Payload_IsOvertime;

// ---------------------------------- //
// Manage teams progress bars
for (_Clan, 1, 2) {
	if (!Net_Payload_IsPayloadRace && _Clan != 1) continue;

	declare Frame <=> Frame_PayloadsProgress[_Clan];
	declare Clan = Net_Payload_AttackingTeam;
	if (Net_Payload_IsPayloadRace) Clan = _Clan;

	// ---------------------------------- //
	// Payload distance change
	if (PrevPayloadDistance[Clan] != Net_Payload_PayloadDistance[Clan]) {
		PrevPayloadDistance[Clan] = Net_Payload_PayloadDistance[Clan];
		AnimMgr.Add(
			Label_DistanceDebug[Clan], "<label scale='"^PrevPayloadDistance[Clan]^"' />",
			125, CAnimManager::EAnimManagerEasing::Linear
		);
	}

	// ---------------------------------- //
	// Update Payload marker animated position
	if (PrevAnimDistance[Clan] != Label_DistanceDebug[Clan].RelativeScale) {
		PrevAnimDistance[Clan] = Label_DistanceDebug[Clan].RelativeScale;
		
		declare PrevCheckpointDistance = 0.;
		declare AllSegmentsDist = 0.;
		
		declare CMlFrame[] Frame_SectorProgress for Frame;
		if (Clan == Net_Payload_AttackingTeam)
			Frame_PayloadMarker.RelativePosition_V3.X = C_TotalProgressBarWidth * PrevAnimDistance[Clan] / TotalDistance - C_TotalProgressBarWidth / 2;
		
		foreach (I => Frame in Frame_SectorProgress) {
			if (!Frame.Visible || !Net_Payload_CheckpointDistances.existskey(I)) continue;
			
			declare CurCPDistance = Net_Payload_CheckpointDistances[I];
			declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
			
			declare Ratio = 0.;
			if (PrevPayloadDistance[Clan] >= CurCPDistance) Ratio = 1.;
			else Ratio = ML::Clamp((PrevAnimDistance[Clan] - AllSegmentsDist) / (CurCPDistance - AllSegmentsDist), 0., 1.);
			
			SetGaugeRatio(Gauge_CPProgress, Ratio);
			
			AllSegmentsDist += CurCPDistance - PrevCheckpointDistance;
			PrevCheckpointDistance = CurCPDistance;
		}
		
		// ---------------------------------- //
		// Enemy embled in team color if team wins the round
		if (PrevPayloadDistance[Clan] >= TotalDistance) {
			declare Quad_EmblemRight <=> (Frame.GetFirstChild("Quad_EmblemRight") as CMlQuad);
			Quad_EmblemRight.Substyle = "#"^Clan;
		}
	}

	Frame <=> Frame_PayloadsTimers[_Clan];
	declare Label_PayloadMarker <=> (Frame.GetFirstChild("Label_PayloadMarker") as CMlLabel);
	declare Label_PayloadBackwards <=> (Frame.GetFirstChild("Label_PayloadBackwards") as CMlLabel);

	// ---------------------------------- //
	// Amount of players pushing Payload changed
	if (PrevPlayersPushingPayload[Clan] != Net_Payload_NbPlayersPushingPayload[Clan]) {
		PrevPlayersPushingPayload[Clan] = Net_Payload_NbPlayersPushingPayload[Clan];

		if (PrevPlayersPushingPayload[Clan] > 0) GaugeRatio[Clan] = 1.;
		Label_PayloadMarker.Value = TL::ToText(PrevPlayersPushingPayload[Clan]);

		if (GaugeRatio[Clan] >= 1) {
			Label_PayloadBackwards.Visible = False;
			Label_PayloadMarker.Visible = !Label_PayloadBackwards.Visible;
		}
	}

	// ---------------------------------- //
	// Set reversing time limit gauge ratio
	if (PrevPlayersPushingPayload[Clan] <= 0) {
		GaugeRatio[Clan] = 0.;

		if (Net_Payload_LastPushTime[Clan] > 0) {
			GaugeRatio[Clan] = 1 - ML::Clamp(ML::ToReal(GameTime - Net_Payload_LastPushTime[Clan]) / {{{C_PayloadReversingTimeLimit}}}, 0., 1.);
			Label_PayloadBackwards.Visible = GaugeRatio[Clan] <= 0 && Net_Payload_PayloadDistance[Clan] > 0;
			Label_PayloadMarker.Visible = !Label_PayloadBackwards.Visible;
		}
		else {
			Label_PayloadMarker.Value = "0";
			Label_PayloadBackwards.Visible = False;
			Label_PayloadMarker.Visible = !Label_PayloadBackwards.Visible;
		}
	}

	// ---------------------------------- //
	// Reversing time limit gauge
	if (PrevGaugeRatio[Clan] != GaugeRatio[Clan]) {
		PrevGaugeRatio[Clan] = GaugeRatio[Clan];

		declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
		declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);

		// Overtime gauge
		SetGaugeRatio(Gauge_OvertimeProgress, GaugeRatio[Clan]);
		
		// ---------------------------------- //
		// Set ratio
		Quad_GaugeR.RelativeRotation = 180 - ML::Clamp(GaugeRatio[Clan] * 360., 0., 180.);
		Quad_GaugeL.RelativeRotation = 360 - ML::Clamp((GaugeRatio[Clan] - .5) * 360., 0., 180.);
		Quad_GaugeR.Visible = GaugeRatio[Clan] > 0;
		Quad_GaugeL.Visible = GaugeRatio[Clan] > .5;
		
		// ---------------------------------- //
		// Set gauge image
		declare Image = "CircGaugeProg.png";
		if (GaugeRatio[Clan] >= 1) Image = "CircGaugeFull.png";
		Quad_GaugeL.ImageUrl = "{{{C_ImgBase}}}"^Image;
		Quad_GaugeR.ImageUrl = Quad_GaugeL.ImageUrl;
	}
}

// ---------------------------------- //
// Attacking team has changed
if (PrevAttackingTeam != Net_Payload_AttackingTeam) {
	PrevAttackingTeam = Net_Payload_AttackingTeam;
	UpdateColors = True;
}

// ---------------------------------- //
// Payload marker visibility
Frame_PayloadMarker.Visible =
	!Net_Payload_IsPayloadRace &&
	Net_Payload_PayloadDistance.existskey(PrevAttackingTeam) &&
	Net_Payload_PayloadDistance[PrevAttackingTeam] < TotalDistance;

Frame_PayloadTimersBox.Visible = Net_Payload_IsPayloadRace;

// ---------------------------------- //
// Attacking team color changed
foreach (I => Team in Teams) {
	declare Vec3 PrevTeamColor for Team;
	if (PrevTeamColor == Team.ColorPrimary) continue;
	PrevTeamColor = Team.ColorPrimary;
	UpdateColors = True;
}

// ---------------------------------- //
// Update interface colors
if (UpdateColors) {
	UpdateColors = False;

	for (_Clan, 1, 2) {
		if (_Clan == 2 && !Net_Payload_IsPayloadRace) continue;

		declare Frame <=> Frame_PayloadsProgress[_Clan];
		declare Clan = Net_Payload_AttackingTeam;
		if (Net_Payload_IsPayloadRace) Clan = _Clan;

		// ---------------------------------- //
		// Update gauges colors
		declare TeamColor = Teams[Clan-1].ColorPrimary;
		declare CMlFrame[] Frame_SectorProgress for Frame;

		foreach (I => Frame in Frame_SectorProgress) {
			if (!Frame.Visible) continue;
			declare Gauge_CPProgress <=> (Frame.GetFirstChild("Gauge_CPProgress") as CMlGauge);
			Gauge_CPProgress.Color = TeamColor;
		}

		// ---------------------------------- //
		// Update emblems
		declare Quad_EmblemLeft <=> (Frame.GetFirstChild("Quad_EmblemLeft") as CMlQuad);
		declare Quad_EmblemRight <=> (Frame.GetFirstChild("Quad_EmblemRight") as CMlQuad);
		Quad_EmblemLeft.Substyle = "#"^Clan;
		Quad_EmblemRight.Substyle = "#"^3-Clan;

		// ---------------------------------- //
		// Update timers
		Frame <=> Frame_PayloadsTimers[_Clan];
		declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
		declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
		declare Quad_GaugeBg <=> (Frame.GetFirstChild("Quad_GaugeBg") as CMlQuad);

		Quad_GaugeL.Colorize = TeamColor;
		Quad_GaugeR.Colorize = TeamColor;
		Quad_GaugeBg.Colorize = TeamColor;
	}
}

// ---------------------------------- //
// Set capture progress visibility
declare IsNearPayload_Teammates = False;
declare IsNearPayload_Opponents = False;

if (GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>) {
	declare Clan = GUIPlayer.CurrentClan;
	IsNearPayload_Teammates = Net_Payload_PayloadPosition.existskey(Clan) && ML::Distance(GUIPlayer.Position, Net_Payload_PayloadPosition[Clan]) <= {{{C_PayloadActivationRadius}}};
	IsNearPayload_Opponents = Net_Payload_PayloadPosition.existskey(3-Clan) && ML::Distance(GUIPlayer.Position, Net_Payload_PayloadPosition[3-Clan]) <= {{{C_PayloadActivationRadius}}};
}
CaptureProgressVisible = IsNearPayload_Teammates || IsNearPayload_Opponents;

// ---------------------------------- //
// Update capture progress visibility
if (PrevCaptureProgressVisible != CaptureProgressVisible) {
	PrevCaptureProgressVisible = CaptureProgressVisible;
	Gauge_CaptureProgress.Visible = CaptureProgressVisible;
	
	Frame_CaptureProgAnim.RelativePosition_V3.Y = 0.;
	Label_CaptureProgress.Opacity = 1.;
	declare PositionY = -2.;
	declare Opacity = 0.;
	
	if (CaptureProgressVisible) {
		Frame_CaptureProgAnim.RelativePosition_V3.Y = -PositionY;
		Label_CaptureProgress.Opacity = 0.;
		PositionY = 0.;
		Opacity = 1.;
	}
	
	declare Easing = CAnimManager::EAnimManagerEasing::Linear;
	AnimMgr.Add(Frame_CaptureProgAnim, "<frame pos='0 "^PositionY^"'/>", 125, Easing);
	AnimMgr.Add(Label_CaptureProgress, "<label opacity='"^Opacity^"' />", 125, Easing);
	AnimMgr.Add(Quad_CaptureProgIcon, "<quad opacity='"^Opacity^"' />", 125, Easing);
}

// ---------------------------------- //
// Display information
if (CaptureProgressVisible) {
	Gauge_CaptureProgress.Color = HsvToRgb(<GUIPlayer.GetLinearHue, 1., 1.>);
	declare Clan = GUIPlayer.CurrentClan;

	// Checkpoint progress for attackers
	if (IsNearPayload_Teammates) {
		declare Ratio = 0.;
		declare PrevDist = 0.;

		foreach (Distance in Net_Payload_CheckpointDistances) {
			if (PrevDist < Net_Payload_PayloadDistance[Clan] && Net_Payload_PayloadDistance[Clan] <= Distance)
				Ratio = (Net_Payload_PayloadDistance[Clan] - PrevDist) / (Distance - PrevDist);

			PrevDist = Distance;
		}

		if (Net_Payload_NbPlayersPushingPayload[Clan] <= 0) CaptureMesageType = 1;
		else CaptureMesageType = 2;

		SetGaugeRatio(Gauge_CaptureProgress, Ratio);
	}

	// Reversing gauge for opponents
	else {
		SetGaugeRatio(Gauge_CaptureProgress, 1 - GaugeRatio[3-Clan]);
		CaptureMesageType = 3;
	}
}

// ---------------------------------- //
// Update payload capture message
if (PrevCaptureMesageType != CaptureMesageType) {
	PrevCaptureMesageType = CaptureMesageType;
	Quad_CaptureProgIcon.ImageUrl = C_CaptureBarImgBase;

	switch (CaptureMesageType) {
		case 1 : {
			Label_CaptureProgress.Value = Translate("Payload is stopped");
			Quad_CaptureProgIcon.ImageUrl ^= "c_goal_capture.dds";
		}
		case 2 : {
			Label_CaptureProgress.Value = Translate("Escorting the Payload");
			Quad_CaptureProgIcon.ImageUrl ^= "c_goal_shield.dds";
		}
		case 3 : {
			Label_CaptureProgress.Value = Translate("Blocking the Payload");
			Quad_CaptureProgIcon.ImageUrl ^= "c_goal_lock.dds";
		}
	}
}
***

{{{Translations::InjectInManialink(["Payload is reversing", "Payload is stopped", "Escorting the Payload", "Blocking the Payload"])}}}
{{{ManialinkTools::Functions(["SetGaugeRatio", "ComputeWidth", "HsvToRgb"])}}}

main() {
	---Main---
	while (True) {
		yield;
		if (!PageIsVisible) continue;
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the markers module.
 *
 *	@return		The markers manialink.
 */
Text CreateManialinkMarkers() {
	declare R = 9/16.;
	return """
<manialink version="2" name="Payload:Markers">
<stylesheet>
	<style class="text" halign="center" valign="center2" textsize="0" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
</stylesheet>

<framemodel id="FrameModel_GoalMarker">
	<label posn="0 .5" class="text" scale="1.5" textprefix="$t$n" id="Label_MarkerGoalName"/>
	<quad posn="0 3" sizen="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon"/>
</framemodel>

<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerPayload#1" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerPayload#2" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerGoal#1" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerGoal#2" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" id="Frame_MarkerCheckpoint" hidden="1" />

<script><!--
/**
 *	Payload: Markers
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

{{{Translations::InjectInManialink(["Payload"])}}}
{{{ManialinkTools::Functions(["Brightness"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_MarkerPayload1 <=> (Page.GetFirstChild("Frame_MarkerPayload#1") as CMlFrame);
	declare Label_MarkerPayloadName1 <=> (Frame_MarkerPayload1.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerPayloadIcon1 <=> (Frame_MarkerPayload1.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	declare Frame_MarkerPayload2 <=> (Page.GetFirstChild("Frame_MarkerPayload#2") as CMlFrame);
	declare Label_MarkerPayloadName2 <=> (Frame_MarkerPayload2.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerPayloadIcon2 <=> (Frame_MarkerPayload2.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	declare Frame_MarkerGoal1 <=> (Page.GetFirstChild("Frame_MarkerGoal#1") as CMlFrame);
	declare Label_MarkerGoalName1 <=> (Frame_MarkerGoal1.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerGoalIcon1 <=> (Frame_MarkerGoal1.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	declare Frame_MarkerGoal2 <=> (Page.GetFirstChild("Frame_MarkerGoal#2") as CMlFrame);
	declare Label_MarkerGoalName2 <=> (Frame_MarkerGoal2.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerGoalIcon2 <=> (Frame_MarkerGoal2.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	declare Frame_MarkerCheckpoint <=> (Page.GetFirstChild("Frame_MarkerCheckpoint") as CMlFrame);
	declare Label_MarkerCheckpointName <=> (Frame_MarkerCheckpoint.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerCheckpointIcon <=> (Frame_MarkerCheckpoint.GetFirstChild("Quad_MarkerIcon") as CMlQuad);

	Label_MarkerPayloadName1.Value = Translate("Payload");
	Label_MarkerPayloadName2.Value = Translate("Payload");

	// ---------------------------------- //
	// Netcode
	declare netread Real[] Net_Payload_CheckpointDistances for Teams[0];
	declare netread Real[Integer] Net_Payload_PayloadDistance for Teams[0];
	declare netread Integer Net_Payload_AttackingTeam for Teams[0];
	declare netread Boolean Net_Payload_IsPayloadRace for Teams[0];

	// ---------------------------------- //
	// Variables
	declare CurCheckpointNb = 1;
	declare UpdateColors = True;
	declare GUIPlayerClan = 0;

	declare PrevCheckpointNb = -1;
	declare PrevAttackingTeam = -1;
	declare PrevGUIPlayerId = NullId;
	declare PrevGUIPlayerClan = -1;

	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		if (!PageIsVisible) continue;

		// ---------------------------------- //
		// Update Checkpoint marker
		CurCheckpointNb = 1;
		foreach (Distance in Net_Payload_CheckpointDistances) {
			if (!Net_Payload_PayloadDistance.existskey(Net_Payload_AttackingTeam)) break;
			if (Net_Payload_PayloadDistance[Net_Payload_AttackingTeam] >= Distance) CurCheckpointNb += 1;
			else break;
		}

		if (PrevCheckpointNb != CurCheckpointNb) {
			PrevCheckpointNb = CurCheckpointNb;
			Label_MarkerCheckpointName.Value = TL::Compose("%1 #"^CurCheckpointNb, ("Checkpoint"));
		}

		// ---------------------------------- //
		// Update markers colors
		if (PrevAttackingTeam != Net_Payload_AttackingTeam) {
			PrevAttackingTeam = Net_Payload_AttackingTeam;
			UpdateColors = True;
		}

		// ---------------------------------- //
		// Teams upate
		foreach (I => Team in Teams) {
			declare Vec3 PrevTeamColor for Team;
			if (PrevTeamColor != Team.ColorPrimary) {
				PrevTeamColor = Team.ColorPrimary;
				UpdateColors = True;
			}
		}

		// ---------------------------------- //
		// Clan change
		if (GUIPlayer != Null) {
			if (PrevGUIPlayerId != GUIPlayer.Id) {
				PrevGUIPlayerId = GUIPlayer.Id;
				GUIPlayerClan = GUIPlayer.CurrentClan;
			}
			GUIPlayerClan = GUIPlayer.CurrentClan;
		} else if (PrevGUIPlayerId != NullId) {
			PrevGUIPlayerId = NullId;
			GUIPlayerClan = 0;
		}

		// ---------------------------------- //
		// On clan change
		if (PrevGUIPlayerClan != GUIPlayerClan) {
			PrevGUIPlayerClan = GUIPlayerClan;

			switch (GUIPlayerClan) {
				case 1 : {
					Label_MarkerGoalName1.Value = _("|Imperative|Defend");
					Label_MarkerGoalName2.Value = _("Capture");
				}
				case 2 : {
					Label_MarkerGoalName1.Value = _("Capture");
					Label_MarkerGoalName2.Value = _("|Imperative|Defend");
				}
				default : {
					Label_MarkerGoalName1.Value = Teams[0].Name;
					Label_MarkerGoalName2.Value = Teams[1].Name;
				}
			}
		}  

		// ---------------------------------- //
		// Update markers colors
		if (UpdateColors) {
			UpdateColors = False;

			declare Team = ML::Clamp(Net_Payload_AttackingTeam-1, 0, 1);
			declare TeamColor1 = Teams[0].ColorPrimary;
			declare TeamColor2 = Teams[1].ColorPrimary;

			// Checkpoint
			Quad_MarkerCheckpointIcon.Colorize = Teams[1-Team].ColorPrimary;
			Label_MarkerCheckpointName.TextColor = Brightness(Quad_MarkerCheckpointIcon.Colorize, 2.);

			// Payload #1
			Quad_MarkerPayloadIcon1.Colorize = TeamColor1;
			Label_MarkerPayloadName1.TextColor = Brightness(Quad_MarkerPayloadIcon1.Colorize, 2.);

			// Payload #2
			Quad_MarkerPayloadIcon2.Colorize = TeamColor2;
			Label_MarkerPayloadName2.TextColor = Brightness(Quad_MarkerPayloadIcon2.Colorize, 2.);

			// Goal #1
			Quad_MarkerGoalIcon1.Colorize = TeamColor1;
			Label_MarkerGoalName1.TextColor = Brightness(Quad_MarkerGoalIcon1.Colorize, 2.);

			// Goal #2
			Quad_MarkerGoalIcon2.Colorize = TeamColor2;
			Label_MarkerGoalName2.TextColor = Brightness(Quad_MarkerGoalIcon2.Colorize, 2.);
		}
	}
}
--></script>
</manialink>""";
}