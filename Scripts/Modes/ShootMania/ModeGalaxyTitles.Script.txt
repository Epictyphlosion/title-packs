// -------------------------------------- //
//  GALAXYTITLES MODE BASE by domino54    //
//  script version: 2017-07-29            //
// -------------------------------------- //

/**
 *	Base for the game modes in the GalaxyTitles title pack.
 */

#Extends "Modes/ShootMania/Base/ModeShootmania.Script.txt"

#Const GTVersion	"2017-07-29"
#Const GTScriptName	"Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Include "MathLib" as ML
#Include "TextLib" as TL
#Include "Libs/Nadeo/ScoresTable2.Script.txt" as ST2
#Include "Libs/Nadeo/ShootMania/WarmUp3.Script.txt" as WarmUp
// Custom libraries
#Include "Libs/domino54/Blacklist.Script.txt" as Blacklist
#Include "Libs/domino54/Characters.Script.txt" as Characters
#Include "Libs/domino54/CupAdmin.Script.txt" as CupAdmin
#Include "Libs/domino54/FakeUsers.Script.txt" as FakeUsers
#Include "Libs/domino54/FancyMessages.Script.txt" as FancyMessages
#Include "Libs/domino54/GTST.Script.txt" as GTST
#Include "Libs/domino54/Killfeed.Script.txt" as Killfeed
#Include "Libs/domino54/ManialinkTools.Script.txt" as ManialinkTools
#Include "Libs/domino54/MapSelection.Script.txt" as MapSelection
#Include "Libs/domino54/MarkersPro.Script.txt" as Markers
#Include "Libs/domino54/Models.Script.txt" as Models
#Include "Libs/domino54/PauseMenu2.Script.txt" as PauseMenu
#Include "Libs/domino54/Statistics.Script.txt" as Statistics
#Include "Libs/domino54/StoragePlayer.Script.txt" as StoragePlayer
#Include "Libs/domino54/TopScores.Script.txt" as TopScores
#Include "Libs/domino54/Translations.Script.txt" as Translations
#Include "Libs/domino54/Webhook.Script.txt" as Webhook
#Include "Libs/domino54/WebLayers.Script.txt" as WebLayers
#Include "Libs/domino54/ShootMania/GalaxyTitles.Script.txt" as GalaxyTitles
#Include "Libs/domino54/ShootMania/Interfancy.Script.txt" as Interfancy
#Include "Libs/domino54/ShootMania/Inventory.Script.txt" as Inventory
#Include "Libs/domino54/ShootMania/MiniMap.Script.txt" as MiniMap
#Include "Libs/domino54/ShootMania/PlayersToads.Script.txt" as Toads
#Include "Libs/domino54/ShootMania/PlayersTurrets.Script.txt" as Turrets
#Include "Libs/domino54/ShootMania/Streaks.Script.txt" as Streaks

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_UseComboWeapons		True	as _("Use Weapons pick-ups (if available on map)")
#Setting S_PlayerArmorPoints	3		as _("Amount of players Armor points (1 min, 10 max)")
#Setting S_EnableCharSelection	True	as _("Allow players to choose their character")
#Setting S_NbFakeUsers			0		as _("Number of fake players")	///< Amount of fake players (bots)
#Setting S_UseAutoBalance		False	as _("Balance teams on round start")
#Setting S_MaximumNbWeapons		1		as _("Max. slots amount of every Weapon")
#Setting S_MaximumNbReplies		3		as _("Max. amount of Replies held")
#Setting S_ObjectsRespawnTime	15		as _("Items respawn time (0 = don't spawn)")
#Setting S_ToadsRespawnTime		60		as _("Toads respawn time (0 = don't spawn)")
#Setting S_ToadsSpawnRatio		.5		as "<hidden>" //_("Percentage amount of Toads to spawn on landmarks")
#Setting S_WeaponsDropLifetime	0		as "<hidden>" ///< Duration before bropped weapons reappear on landmarks
#Setting S_WarmUpDuration		300		as "<hidden>" ///< Duration of the warm up round (0 = no warmup)
#Setting S_RespawnTime			3000	as "<hidden>" ///< Time before respawn
#Setting S_NbPlayersPerTeamMax	0		as "<hidden>" ///< Maximum number of players per team (0: no max)
#Setting S_NbPlayersPerTeamMin	1		as "<hidden>" ///< Minumum number of players per team
#Setting S_CustomLayersURLs		""		as "<hidden>" ///< Try to load custom layers from an URL
#Setting S_CustomBlacklistURL	""		as "<hidden>" ///< URL of the custom blacklist file
#Setting S_KillfeedOffsetY		0.		as "<hidden>" ///< For server hosters: killfeed Y offset
#Setting S_MusicPlaylistURL		""		as "<hidden>" ///< URL of the server custom music playlist file
#Setting S_EnableMapSelection	True	as "<hidden>" ///< Allow players to choose which map they want to play next
#Setting S_PodiumTrackDuration	8000	as "<hidden>" ///< Duration of the podium sequence (10 max)
#Setting S_WebhookURL			""		as "<hidden>" ///< URL of the webhook to send notifications

#Setting S_ScriptEnvironment /* "production" */ "development"

/// Competition settings
#Setting S_AdminEnableCupMode		False	as "<hidden>"
#Setting S_AdminCupModeNbMaps		3		as "<hidden>"
#Setting S_AdminPauseCompetition	False	as "<hidden>"
#Setting S_AdminCupName				""		as "<hidden>"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ImgBase "file://Media/Manialinks/ShootMania/GalaxyTitles/"
#Const C_DefaultMusicPlaylist	"file://Media/Musics/Invasion/playlist.xml"
#Const C_OfflineTranslationsURL	"file://Media/Translations/Default.xml"
#Const C_OnlineTranslationsURL	"http://raw.githubusercontent.com/domino54/title-packs/master/Media/Translations/Default.xml"
#Const C_DefaultCharactersURL	"file://Media/Characters/GalaxyDefault.xml"
#Const C_ScriptTicksPerSecond	100		///< The amount of script ticks per second
#Const C_NoCollisionsDuration	6000	///< No collision duration at the beginning of the round
#Const C_EnviroKillTimeOut		7500	///< Time after which environmental elimination won't be performed
#Const C_MaxPodiumSeqDuration	10000	///< Maximum duration of the podium sequence
#Const C_SuddenDeathPointsLimit	3
#Const C_DefaultKillfeedPosn	<159., 89.>		///< Default position of the Killfeed layer

#Const C_EventMaxDamage		100		///< Maximum damage amount inflicted by weapons
#Const C_PlayerStaminaMax	1.25	///< Amount of player stamina

// Classes
#Const C_ScoutStaminaMax		1.
#Const C_SummonerAmmoGain		.875
#Const C_SummonerRocketMax		3
#Const C_HealerAmmoGain			.875
#Const C_HealerSupplyCooldown	4000

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Integer GT_EndTime;					///< Custom end time (used to remove timer ticking sound)

/// Developer settings
declare Boolean GT_UseNoCollisionsStart;	///< Use the no-collisions round start
declare Boolean GT_UseAutoEndSequence;		///< Use the automatic End Map sequence
declare Boolean GT_UseAutospawnObjects;		///< Use automatically spawned objects
declare Boolean GT_UseComboWeapons;			///< Use Combo weapon items
declare Boolean GT_UseRepliePickups;		///< Use Replie pickup items
declare Boolean GT_UseRandomToads;			///< Spawn Toads on random bot path landmarks
declare Boolean GT_AutoManageOnHit;			///< Automatically manage OnHit events
declare Boolean GT_AutoManageOnShoot;		///< Automatically manage OnShoot events
declare Boolean GT_AutoManageOnArmorEmpty;	///< Automatically manage OnArmorEmpty events
declare Boolean GT_AutoManageOnNearMiss;	///< Automatically manage OnNearMiss events
declare Boolean GT_AutoManageOnRespawn;		///< Automatically manage OnPlayerRequestRespawn event
declare Boolean GT_AutoManageOnObjectTouch;	///< Automatically manage OnPlayerTouchesObject events
declare Boolean GT_AutoRespawnOnCharChange;	///< Automatically respawn players changing their character
declare Boolean GT_AllowMatchmakingMode;	///< Defines if the mode can use matchmaking feature
declare Boolean GT_DisableOffZoneDamage;	///< Disable OffZone eliminations (Tornado may stil leliminate players)
declare Boolean GT_DisableTornadoDamage;	///< Disable Tornado eliminations (only if OffZone is disabled)
declare Text[] GT_KillfeedTranslations;		///< Translations to be loaded with the Killfeed library
declare Text GT_CharactersDataFileURL;		///< URL to the file containing data of characters to load.

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(GTScriptName, GTVersion);
Log::RegisterScript(WarmUp::GetScriptName(), WarmUp::GetScriptVersion());
Log::RegisterScript(Scores::GetScriptName(), Scores::GetScriptVersion());
Log::RegisterScript(Blacklist::GetScriptName(), Blacklist::GetScriptVersion());
Log::RegisterScript(Characters::GetScriptName(), Characters::GetScriptVersion());
Log::RegisterScript(CupAdmin::GetScriptName(), CupAdmin::GetScriptVersion());
Log::RegisterScript(FakeUsers::GetScriptName(), FakeUsers::GetScriptVersion());
Log::RegisterScript(FancyMessages::GetScriptName(), FancyMessages::GetScriptVersion());
Log::RegisterScript(GalaxyTitles::GetScriptName(), GalaxyTitles::GetScriptVersion());
Log::RegisterScript(Interfancy::GetScriptName(), Interfancy::GetScriptVersion());
Log::RegisterScript(Inventory::GetScriptName(), Inventory::GetScriptVersion());
Log::RegisterScript(Killfeed::GetScriptName(), Killfeed::GetScriptVersion());
Log::RegisterScript(ManialinkTools::GetScriptName(), ManialinkTools::GetScriptVersion());
Log::RegisterScript(MapSelection::GetScriptName(), MapSelection::GetScriptVersion());
Log::RegisterScript(Markers::GetScriptName(), Markers::GetScriptVersion());
Log::RegisterScript(MiniMap::GetScriptName(), MiniMap::GetScriptVersion());
Log::RegisterScript(Models::GetScriptName(), Models::GetScriptVersion());
Log::RegisterScript(PauseMenu::GetScriptName(), PauseMenu::GetScriptVersion());
Log::RegisterScript(Statistics::GetScriptName(), Statistics::GetScriptVersion());
Log::RegisterScript(Streaks::GetScriptName(), Streaks::GetScriptVersion());
Log::RegisterScript(Toads::GetScriptName(), Toads::GetScriptVersion());
Log::RegisterScript(TopScores::GetScriptName(), TopScores::GetScriptVersion());
Log::RegisterScript(Translations::GetScriptName(), Translations::GetScriptVersion());
Log::RegisterScript(Turrets::GetScriptName(), Turrets::GetScriptVersion());
Log::RegisterScript(WebLayers::GetScriptName(), WebLayers::GetScriptVersion());
***

// ---------------------------------- //
// Disable Nadeo's unnecessary features
// ---------------------------------- //
***Match_Settings***
***
MB_Settings_UseDefaultPodiumSequence = False;
MB_Settings_UseDefaultUIManagement = False;
MB_Settings_UseDefaultTimer = False;
MB_Settings_UseDefaultHud = False;
MB_Settings_UseDefaultClansScoresUI = False;
MB_Settings_UseDefaultSounds = False;
MB_Settings_UseDefaultObjects = False;
MB_Settings_UseDefaultDispenserObjects = False;
***

// ---------------------------------- //
// Initialize matchmaking lobby
// ---------------------------------- //
***MM_SetupMatchmaking***
***
MM_SetFormat([S_NbPlayersPerTeamMax, S_NbPlayersPerTeamMax]);
if (S_NbPlayersPerTeamMax > S_NbPlayersPerTeamMin) {
	declare Formats = Integer[][];
	for (I, S_NbPlayersPerTeamMin, S_NbPlayersPerTeamMax-1) if (I > 0) Formats.add([I, I]);
	MM_SetProgressiveFormats(Formats);
}
***

// ---------------------------------- //
// Set default scores table format
// ---------------------------------- //
***ScoresTable***
***
// ---------------------------------- //
// Global settings
ST2::SetSize(<164.5, 11.>, <161., 59.5>, <160., 15.5>);
ST2::SetFormat(2, 8);
ST2::SetTextScale(.875);
ST2::SetBackgroundProperties(<0., 5.>, <200., 100.>);
ST2::SetTeamsScoresVisibility(False);

// ---------------------------------- //
// Columns
ST2::SetColWidth("LibST_Avatar", 2.5);
ST2::SetColWidth("LibST_ManiaStars", 2.);
ST2::SetColWidth("LibST_Tools", 1.5);
ST2::SetColWidth("LibST_SMPoints", 4.);
ST2::SetColWidth("LibST_SMRoundPoints", 4.);
ST2::SetColLegend("LibST_SMPoints", _("Total"));
ST2::DestroyCol("LibST_Tags");
// Custom
TopScores::AddCategory("Support", "Sp", 2.25, 70.);
TopScores::AddCategory("Hit", "Hit", 2.25, 80.);

// ---------------------------------- //
// Teams mode
ST2::SetTeamsMode(UseClans);
if (UseClans) {
	ST2::SetTeamImage(1, "file://Media/Manialinks/ShootMania/ScoresTable/teamversus-left.dds", <0., 3.5>, <100., 25.>);
	ST2::SetTeamImage(2, "file://Media/Manialinks/ShootMania/ScoresTable/teamversus-right.dds", <0., 3.5>, <100., 25.>);
}
***

// ---------------------------------- //
// Initialize server
// ---------------------------------- //
***GalaxyTitles_Settings***
***
/**
 *	Enable all options by default
 *
 *	If you wish to disable these features, do it in the
 *	***GalaxyTitles_Settings*** label of your game mode!
 */
GT_UseNoCollisionsStart = True;
GT_UseAutoEndSequence = True;
GT_UseAutospawnObjects = True;
GT_UseComboWeapons = True;
GT_UseRepliePickups = True;
GT_UseRandomToads = True;
GT_AutoManageOnHit = True;
GT_AutoManageOnShoot = True;
GT_AutoManageOnArmorEmpty = True;
GT_AutoManageOnNearMiss = True;
GT_AutoManageOnRespawn = True;
GT_AutoManageOnObjectTouch = True;
GT_AutoRespawnOnCharChange = True;
GT_AllowMatchmakingMode = True;
GT_CharactersDataFileURL = C_DefaultCharactersURL;
***

// ---------------------------------- //
// Set up the pause menu
// ---------------------------------- //
***GalaxyTitles_PauseMenu***
***
PauseMenu::SetButtonIcon("LibPM_ModeHelp", C_ImgBase^"Icons/Help.png");
PauseMenu::SetButtonIcon("LibPM_Spectator", C_ImgBase^"Icons/Spectator.png");
PauseMenu::SetButtonIcon("LibPM_SaveReplay", C_ImgBase^"Icons/Recording.png");
PauseMenu::SetButtonIcon("LibPM_ChangeTeam", C_ImgBase^"Icons/Versus.png");
PauseMenu::SetButtonIcon("LibPM_ManageServer", C_ImgBase^"Icons/Server.png");
PauseMenu::SetButtonIcon("LibPM_Advanced", C_ImgBase^"Icons/AdvancedSettings.png");

// Create buttons for Storage Player and Characters
PauseMenu::CreateButton("GT_StoragePlayer", "Storage Player", C_ImgBase^"Icons/Headphones.png", 6.);
PauseMenu::CreateButton("GT_CharSelection", "Change character", C_ImgBase^"Icons/Run.png", 7.);

PauseMenu::SetButtonScript("GT_StoragePlayer", """
CloseInGameMenu(::EInGameMenuResult::Resume);
declare Boolean LibStoragePlayer_ToggleShowWindow for This;
LibStoragePlayer_ToggleShowWindow = True;
""");

PauseMenu::SetButtonScript("GT_CharSelection", """
CloseInGameMenu(::EInGameMenuResult::Resume);
declare Boolean LibCharacters_ToggleShowWindow for This;
LibCharacters_ToggleShowWindow = True;
""");

PauseMenu::SetButtonVisibility("GT_CharSelection", False);
***

// ---------------------------------- //
// Initialize server
// ---------------------------------- //
***Match_InitServer***
***
// ---------------------------------- //
// Set mode options
UseClans = False; ///< Disable clans by default
ForceNavMapsComputation = True; ///< Lets the bots move around
UseAutoSpawnBots = False; ///< Disable bots items placed on map by user

// Update mode settings
+++GalaxyTitles_Settings+++

// ---------------------------------- //
// Download translations
Translations::Load([C_OfflineTranslationsURL, C_OnlineTranslationsURL]);
while (!Translations::LoadingLoop()) MB_Yield();

// ---------------------------------- //
// Load Turrets, models and Toads
Turrets::Load();
Turrets::SetAutoDestroyTurrets(False);
Models::Load();
Toads::Load();
Toads::SetAutoDestroyToads(False);

// ---------------------------------- //
// Load characters
Characters::Load(GT_CharactersDataFileURL);
while (Characters::IsBeingImported()) MB_Yield();
Characters::Build("Eurostile", "Eurostile_Bold");
Characters::SetArmorBase(S_PlayerArmorPoints);

Models::LoadCustom("Sintel", "Characters\\SintelSample.Item.Gbx");
Models::LoadArenaPlayer("Susu.zip");
Models::LoadArenaPlayer("TronMan.zip");
Models::LoadArenaPlayer("StormWoman.Skin.Pack.Gbx");

// ---------------------------------- //
// Load warm-up
WarmUp::Load();
WarmUp::SetLayerPosition(<0., -58.>);
if (UseClans) {
	WarmUp::CreateGroup("Clan1", S_NbPlayersPerTeamMax);
	WarmUp::CreateGroup("Clan2", S_NbPlayersPerTeamMax);
	WarmUp::DisplayClanSelection(True);
}

// ---------------------------------- //
// Create custom interface
Interfancy::Load(["Gauges", "Countdown", "SpecInfo", "Crosshair", "ScoreSummary"]);
SM::SetupDefaultVisibility();
MapSelection::Load("Eurostile", "Eurostile_Bold");
Markers::Load();

// ---------------------------------- //
// Pause menu
PauseMenu::Load();
+++GalaxyTitles_PauseMenu+++
PauseMenu::Build("Eurostile");

UIManager.UIAll.OverlayHide321Go = True;
UIManager.UIAll.OpposingTeamLabelsShowGauges = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.NoticesFilter_LevelToShowAsBigMessage = CUIConfig::ENoticeLevel::MatchWarning;
// UIManager.UIAll.NoticesFilter_HidePlayerInfo = True;
// UIManager.UIAll.NoticesFilter_HidePlayerWarning = True;

// Load the Storage Music Player
StoragePlayer::Load(C_ImgBase, "Eurostile", "Eurostile_Bold");
StoragePlayer::SetDefaultPlaylistURL(C_DefaultMusicPlaylist);

// Load Killfeed library
Killfeed::Load();
Killfeed::SetPosition(C_DefaultKillfeedPosn + <0., S_KillfeedOffsetY>);
Killfeed::AddTranslations(GT_KillfeedTranslations);
Killfeed::SetTextFont("Eurostile");
Killfeed::SetWeaponsIcons([
	0 => C_ImgBase^"Icons/Shield.png", 1 => C_ImgBase^"Icons/Laser.png", 2 => C_ImgBase^"Icons/Rocket.png",
	3 => C_ImgBase^"Icons/Nucleus.png", 5 => C_ImgBase^"Icons/Arrow.png", 6 => C_ImgBase^"Icons/Missile.png"
]);

// Load Statistics and Streaks
Statistics::Load();
Streaks::Load();

// Load minimap
MiniMap::Load();
MiniMap::SetOpponentsVisibility(!MM_IsMatchServer());

// Load Fancy Messages
FancyMessages::Load();
FancyMessages::FormatBigMessage(<0., 54., 0.>, "Eurostile_Bold", 8);
FancyMessages::FormatStatusMessage(<0., 62., 0.>, "Eurostile_Bold", 3);

// Load GalaxyTitles library
GalaxyTitles::Load();

// ---------------------------------- //
// Variables
declare Integer GT_NoCollisionsEndTime;
declare PrevMaximumNbWeapons = S_MaximumNbWeapons;
declare PrevMaximumNbReplies = S_MaximumNbReplies;
declare PrevEnableCharSelection = S_EnableCharSelection;
declare PrevPlayerNbArmorMax = S_PlayerArmorPoints;

Webhook::SetMapSwitching(True);
Killfeed::SetMapSwitching(True);
Killfeed::Build();
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***Match_StartServer***
***
//PauseMenu::SetModeRules(ModeInfo::GetName(), ModeInfo::GetRules(), "");

// Disable Constructor in non-team modes
if (GT_CharactersDataFileURL == C_DefaultCharactersURL)
	Characters::SetCharAvailable(3, UseClans);

// ---------------------------------- //
// Create the scores table
ST2::Load();
ST2::SetStyle("LibST_SMBaseSolo");
ST2::SetStyle("LibST_SMBasePoints");
+++ScoresTable+++
ST2::Build("SM");

// Update scores summary visibility
Interfancy::SetModuleVisibility("ScoreSummary", UseClans);

// Obtain custom weapons icons
foreach (WeaponId in Inventory::GetCustomWeapons()) {
	declare WeaponName = Inventory::GetWeaponName(WeaponId);
	declare WeaponIcon = Inventory::GetWeaponIcon(WeaponId);
	Interfancy::SetGaugesIconsImages([WeaponName => C_ImgBase^"Icons/"^WeaponIcon]);
}

// ---------------------------------- //
// Character selection
declare GT_CharactersAvailable = S_EnableCharSelection && Http.IsValidUrl(GT_CharactersDataFileURL);
PauseMenu::SetButtonVisibility("GT_CharSelection", GT_CharactersAvailable);
if (GT_CharactersAvailable) Characters::Manual();
else Characters::Hide();

// ---------------------------------- //
// Stop the script if server is in matchmaking mode and mode doesn't support it
assert(!(MM_IsMatchmakingServer() && !GT_AllowMatchmakingMode), "This game mode does not support matchmaking mode!");
***

***MB_Private_AfterLoadMap***
***
Webhook::SetMapSwitching(False);
Killfeed::SetMapSwitching(False);
***

// ---------------------------------- //
// Initialize map
// ---------------------------------- //
***Match_InitMap***
***
TopScores::MatchBegin();
Interfancy::ClearData();
GalaxyTitles::ResetAll();
CupAdmin::StartMap();

// Clear all messages
UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
FancyMessages::ResetData();

// Warm-up
if (UseClans) GT_InitWarmUp();

// ---------------------------------- //
// Reset clan scores
ClanScores[1] = 0;
ClanScores[2] = 0;
MM_SetScores([ClanScores[1], ClanScores[2]]);

// ---------------------------------- //
// Wait players when using matchmaking
if (MM_IsMatchServer()) {
	GT_DoWarmUp();
}

// ---------------------------------- //
// Matchmaking: allow substitutes
if (MM_IsMatchServer()) MM_AllowSubstitutes(True);
***

// ---------------------------------- //
// Initialize round
// ---------------------------------- //
***Match_InitRound***
***
TopScores::RoundBegin();

// Update players clans
GT_AutoBalance();
foreach (Player in Players) SetPlayerClan(Player, GT_GetRequestedClan(Player));
***

// ---------------------------------- //
// Round start
// ---------------------------------- //
***Match_StartPlayLoop***
***
Turrets::ResetAllPlayers();
Toads::ResetAllPlayers();
Markers::Reset();

UIManager.UIAll.BigMessage = "";
UIManager.UIAll.StatusMessage = "";
MiniMap::Show();

// ---------------------------------- //
// Init GalaxyTitles functions
declare ToadsSpawnRatio = 0.;
if (GT_UseRandomToads) ToadsSpawnRatio = S_ToadsSpawnRatio;

GalaxyTitles::SetDroppedWeaponsLifetime(S_WeaponsDropLifetime * 1000);
GalaxyTitles::SetMaxWeapons(S_MaximumNbWeapons);
GalaxyTitles::SetMaxReplies(S_MaximumNbReplies);

GalaxyTitles::Init(
	GT_UseComboWeapons && S_UseComboWeapons && S_MaximumNbWeapons != 0,
	GT_UseRepliePickups && S_MaximumNbReplies != 0,
	ToadsSpawnRatio
);

// No collisions at the beginning of the round
if (GT_UseNoCollisionsStart) UsePvPCollisions = False;
if (!UsePvPCollisions) GT_NoCollisionsEndTime = StartTime + C_NoCollisionsDuration;
***

// ---------------------------------- //
// Mode global loop
// ---------------------------------- //
***MB_Private_Yield***
***
Blacklist::Loop(S_CustomBlacklistURL);
Characters::Loop();
CupAdmin::Loop(S_AdminEnableCupMode, S_AdminPauseCompetition, S_AdminCupModeNbMaps, S_AdminCupName);
FakeUsers::Loop(S_NbFakeUsers);
FancyMessages::Loop();
Interfancy::Loop();
Killfeed::Loop();
Message::Loop();
ST2::XmlRpcLoop();
Statistics::Loop();
StoragePlayer::UpdatePlaylistURL(S_MusicPlaylistURL);
Streaks::Loop();
Webhook::Loop(S_WebhookURL);
WebLayers::Update(S_CustomLayersURLs);
***

// ---------------------------------- //
// Premade on armor empty event manager
// ---------------------------------- //
***PremadeOnArmorEmpty***
***
declare Ident[] GT_VictimShootHistory for Event.Victim;
declare Ident GT_VictimLastShooter for Event.Victim;
declare Integer GT_VictimLastHitTime for Event.Victim;
declare Integer GT_LastFakeHitTime for Event.Victim;

// ---------------------------------- //
// Destroy player's Toad
if (Toads::BelongsToLib(Event.Victim)) {
	declare Boolean GT_JustHitByToad for Event.Victim;

	// ---------------------------------- //
	// Get the elimination icon
	declare EventIcon = "";
	switch (Event.WeaponNum) {
		case 1 : EventIcon = "Laser.png";
		case 2 : EventIcon = "Rocket.png";
		case 3 : EventIcon = "Nucleus.png";
		case 5 : EventIcon = "Arrow.png";
		case 6 : EventIcon = "Missile.png";
		default : EventIcon = "Shield.png";
	}

	// ---------------------------------- //
	// Get the shooter's login
	declare ShooterLogin = "";
	if (Event.Shooter != Null) {
		if (Event.Shooter.IsBot || GT_JustHitByToad) EventIcon = "Toad.png";
		if (!Event.Shooter.IsBot) ShooterLogin = Event.Shooter.User.Login;
	}

	// Send notice and destroy the Toad
	if (Players.exists(Event.Victim.Driver.Owner)) Killfeed::SendNotice(
		"Toad - "^Event.Victim.Driver.Owner.Name,
		ShooterLogin, C_ImgBase^"Icons/"^EventIcon, ""
	);
	declare Destroyed = Toads::DestroyToad(Event.Victim.Id, Toads::GetCooldown());
}

// ---------------------------------- //
// Normal hit elimination
if (Event.Shooter != Null) {
	+++OnArmorEmpty+++
	
	// ---------------------------------- //
	// Elimination assistance
	declare CSmPlayer EventAssistant;
	
	// Get the elimination assistant
	if (GT_VictimShootHistory.count > 0) for (I, 0, GT_VictimShootHistory.count - 1) {
		declare PlayerId = GT_VictimShootHistory[GT_VictimShootHistory.count - 1 - I];
		if (AllPlayers.existskey(PlayerId) && PlayerId != Event.Shooter.Id) {
			EventAssistant = AllPlayers[PlayerId];
			break;
		}
	}
	
	declare Boolean GT_JustHitByToad for Event.Victim;
	declare Boolean GT_JustHitByTurret for Event.Victim;
	GT_VictimLastShooter = NullId;
	GT_VictimShootHistory.clear();
	GT_LastFakeHitTime = Now;

	declare AssistantLogin = "";
	if (EventAssistant != Null) AssistantLogin = EventAssistant.User.Login;

	// ---------------------------------- //
	// Player Toad elimination
	if (Event.Victim.IsBot) { }

	// ---------------------------------- //
	// Eliminated by player's Turret
	else if (GT_JustHitByTurret) Killfeed::SendNotice(
		Event.Victim.Login, Event.Shooter.Login,
		C_ImgBase^"Icons/TurretKill.png", AssistantLogin
	);

	// ---------------------------------- //
	// Eliminated by player's Toad
	else if (GT_JustHitByToad) Killfeed::SendNotice(
		Event.Victim.Login, Event.Shooter.Login,
		C_ImgBase^"Icons/Toad.png", AssistantLogin
	);
	
	// ---------------------------------- //
	// Eliminated by wild Toad
	else if (Event.Shooter.IsBot && EventAssistant == Null) 
		Killfeed::SendNotice(Event.Victim.Login, "", C_ImgBase^"Icons/Toad.png", "");

	else Killfeed::OnArmorEmpty(Event, EventAssistant);
	Streaks::OnArmorEmpty(Event);
	GT_JustHitByToad = False;
	GT_JustHitByTurret = False;
	
	// Statistics tracking
	Statistics::OnArmorEmpty(Event);
	Statistics::TrackEvent(EventAssistant, "EliminationAssists", 1);
	
	PassOn(Event);
}
// ---------------------------------- //
// Environmental elimination
else {
	// ---------------------------------- //
	// Someone performed environmental elimination
	if (
		Now <= GT_VictimLastHitTime + C_EnviroKillTimeOut &&
		GT_VictimLastShooter != NullId && AllPlayers.existskey(GT_VictimLastShooter)
	) {
		declare Shooter = AllPlayers[GT_VictimLastShooter];
		declare Points = Event.Victim.Armor / 100;
		GT_VictimLastShooter = NullId;
		
		Scores::AddPlayerRoundPoints(Shooter.Score, Points);
		TopScores::AddPoints(Shooter.Score, "Hit", Points);
		
		RemovePlayerArmor(Event.Victim, Event.Victim.Armor, Shooter, Points);
		Discard(Event);
	}
	// ---------------------------------- //
	// Normal environmental elimination
	else if (Now > GT_LastFakeHitTime + 500) {
		Scores::RemovePlayerRoundPoints(Event.Victim.Score, 1);
		
		+++OnArmorEmpty+++
		
		GT_VictimLastShooter = NullId;
		GT_VictimShootHistory.clear();

		Killfeed::OnArmorEmpty(Event, Null);
		Statistics::OnArmorEmpty(Event);
		PassOn(Event);
	}
	else Discard(Event);
}
***

// ---------------------------------- //
// Play loop for both Lobby and Match
// ---------------------------------- //
***Match_PlayLoop***
***
Turrets::Loop();
Toads::Loop();

// ---------------------------------- //
// Extended events management
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// On armor empty
	if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
		if (GT_AutoManageOnArmorEmpty) {
			declare PassOnEvent = True;
			
			// ---------------------------------- //
			// OffZone damage is disabled
			if (Event.Shooter == Null && GT_DisableOffZoneDamage) {
				PassOnEvent = False;
				
				// ---------------------------------- //
				// Tornado is enabled even if OffZone is not active
				if (!GT_DisableTornadoDamage && OffZoneRadius > 0) {
					declare Vec3 MapLandmarkPosition;
					foreach (MapLandmark in MapLandmarks) {
						if (MapLandmark.Id != OffZoneCenterLandmarkId) continue;
						MapLandmarkPosition = MapLandmark.Position;
						break;
					}
					PassOnEvent = GT_Distance2D(Event.Victim.Position, MapLandmarkPosition) >= OffZoneRadius;
				}
			}
			
			// ---------------------------------- //
			// Manage the event
			if (PassOnEvent) { ---PremadeOnArmorEmpty--- }
			else Discard(Event);
		}
	}
	// ---------------------------------- //
	// On hit
	else if (
		Event.Type == CSmModeEvent::EType::OnHit ||
		Event.Type == CSmModeEvent::EType::OnActionCustomEvent
	) {
		// ---------------------------------- //
		// Automatic hit management
		if (GT_AutoManageOnHit) {
			if (!GT_IsHitEvent(Event)) {
				Discard(Event);
				continue;
			}

			// Get the event damage
			declare EventDamage = GT_GetEventDamage(Event);
			Event.Damage = EventDamage;

			// ---------------------------------- //
			// Turret shooter
			if (Event.ShooterTurret != Null) {
				// ---------------------------------- //
				// Invalid events
				if ((Event.Victim == Null && Event.VictimObject == Null && Event.VictimTurret == Null) || Event.ShooterTurret == Event.VictimTurret) Discard(Event);

				// ---------------------------------- //
				// Turret hit
				else if (Event.VictimTurret != Null) {
					// ---------------------------------- //
					// Custom Turret
					if (Turrets::BelongsToLib(Event.ShooterTurret)) {
						declare Shooter = Turrets::GetTurretOwner(Event.ShooterTurret);
						if (
							(Turrets::GetTurretClan(Event.VictimTurret) != 0 && Turrets::GetTurretClan(Event.VictimTurret) == Turrets::GetTurretClan(Event.ShooterTurret)) ||
							Shooter == Null || Shooter == Turrets::GetTurretOwner(Event.VictimTurret)
						) {
							Discard(Event);
							continue;
						}
						
						declare Points = EventDamage / 100;
						Scores::AddPlayerRoundPoints(Shooter.Score, Points);
						TopScores::AddPoints(Shooter.Score, "Hit", Points);
						GT_PassOnHit(Event);
					}
					else GT_PassOnHit(Event);
					+++OnTurretHitByTurret+++
				}
				// ---------------------------------- //
				// Object hit
				else if (Event.VictimObject != Null) {
					+++OnObjectHitByTurret+++
					GT_PassOnHit(Event);
				}
				// ---------------------------------- //
				// Player hit
				else if (Event.Victim != Null) {
					// ---------------------------------- //
					// Create fake hit performed by Turret's owner
					if (Turrets::BelongsToLib(Event.ShooterTurret)) {
						Discard(Event);
						if (Event.Victim.CurrentClan != 0 && Event.Victim.CurrentClan == Turrets::GetTurretClan(Event.VictimTurret)) continue;
						declare Shooter = Turrets::GetTurretOwner(Event.ShooterTurret);
						if (Shooter == Null || Shooter == Event.Victim) continue;
						
						declare Points = EventDamage / 100;
						Scores::AddPlayerRoundPoints(Shooter.Score, Points);
						TopScores::AddPoints(Shooter.Score, "Hit", Points);
						RemovePlayerArmor(Event.Victim, EventDamage, Shooter, Points);

						// Elimination assists
						declare Ident[] GT_VictimShootHistory for Event.Victim;
						GT_VictimShootHistory.add(Shooter.Id);

						if (Event.Victim.Armor <= 0 || Event.Victim.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
							declare Boolean GT_JustHitByTurret for Event.Victim;
							GT_JustHitByTurret = True;
						}
					}
					else GT_PassOnHit(Event);
					+++OnHitByTurret+++
				}
			}
			// ---------------------------------- //
			// Player shooter
			else if (Event.Shooter != Null) {
				// ---------------------------------- //
				// Turret hit
				if (Event.VictimTurret != Null) {
					if (Event.Shooter.CurrentClan != 0 && Event.Shooter.CurrentClan == Turrets::GetTurretClan(Event.VictimTurret)) {
						Discard(Event);
						continue;
					}
					// ---------------------------------- //
					// Manage custom turret hit
					else if (Turrets::BelongsToLib(Event.VictimTurret)) {
						declare Shooter = Event.Shooter;
						if (Shooter.IsBot) Shooter = Event.Shooter.Driver.Owner;

						if (Shooter == Null || Shooter == Turrets::GetTurretOwner(Event.VictimTurret)) {
							Discard(Event);
							continue;
						}
						
						GT_PassOnHit(Event);
					}
					else GT_PassOnHit(Event);
					+++OnTurretHit+++
				}
				// ---------------------------------- //
				// Object hit
				else if (Event.VictimObject != Null) {
					+++OnObjectHit+++
					GT_PassOnHit(Event);
				}
				// ---------------------------------- //
				// Invalid events
				else if (Event.Victim == Null || Event.Shooter == Event.Victim) Discard(Event);
				
				// ---------------------------------- //
				// Teammate hit
				else if (Event.Shooter.CurrentClan != 0 && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
					declare ShooterCustomWeapon = Inventory::GetPlayerCustomWeapon(Event.Shooter);

					// ---------------------------------- //
					// Heal teammates using MediShot
					if (ShooterCustomWeapon == "MediShot") {
						if (Event.Victim.Armor < Event.Victim.ArmorMax) {
							declare HealedArmor = 100;
							declare Points = HealedArmor / 100;

							Scores::AddPlayerRoundPoints(Event.Shooter.Score, Points);
							TopScores::AddPoints(Event.Shooter.Score, "Hit", Points);
							GalaxyTitles::ShowHealingParticles(Event.Victim);
							AddPlayerArmor(Event.Victim, HealedArmor, Event.Shooter, Points);
							GT_PassOnHit(Event);

							Interfancy::SendCrosshairNote(Event.Shooter, ["Healed $<%1$>", Event.Victim.User.Name], 2000);
							Interfancy::SendCrosshairNote(Event.Victim, ["$<%1$> healed you!", Event.Shooter.User.Name], 2000);
						}
					}
					else Discard(Event);
				}
				// ---------------------------------- //
				// A bot has hit someone
				else if (Event.Shooter.IsBot) {
					// ---------------------------------- //
					// Create fake hit performed by Toad's owner
					if (Toads::BelongsToLib(Event.Shooter)) {
						Discard(Event);
						declare Shooter = Event.Shooter.Driver.Owner;
						if (Shooter == Null || Shooter == Event.Victim) continue;
						
						declare Points = EventDamage / 100;
						Scores::AddPlayerRoundPoints(Shooter.Score, Points);
						TopScores::AddPoints(Shooter.Score, "Hit", Points);
						RemovePlayerArmor(Event.Victim, EventDamage, Shooter, Points);

						// Elimination assists
						declare Ident[] GT_VictimShootHistory for Event.Victim;
						GT_VictimShootHistory.add(Shooter.Id);

						if (Event.Victim.Armor <= 0 || Event.Victim.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
							declare Boolean GT_JustHitByToad for Event.Victim;
							GT_JustHitByToad = True;
						}
					}

					// Other Toads
					else if (Event.Victim.IsBot) {
						if (Event.Victim.CurrentClan != 0 && Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
						else GT_PassOnHit(Event);
					}
					else GT_PassOnHit(Event);
				}
				
				// ---------------------------------- //
				// Enemy hit
				else {
					+++OnHitConditions+++
					
					declare Points = ML::Min(EventDamage, Event.Victim.Armor) / 100;
					Scores::AddPlayerRoundPoints(Event.Shooter.Score, Points);
					TopScores::AddPoints(Event.Shooter.Score, "Hit", Points);
					Event.ShooterPoints = Points;
					
					+++OnHit+++
					
					// ---------------------------------- //
					// Environmental eliminations
					declare Ident GT_VictimLastShooter for Event.Victim;
					declare Integer GT_VictimLastHitTime for Event.Victim;
					GT_VictimLastShooter = Event.Shooter.Id;
					GT_VictimLastHitTime = Now;
					
					// ---------------------------------- //
					// Elimination assists
					declare Ident[] GT_VictimShootHistory for Event.Victim;
					GT_VictimShootHistory.add(Event.Shooter.Id);
					
					Statistics::OnHit(Event);
					GT_PassOnHit(Event);
				}
			}
			// ---------------------------------- //
			// Invalid event
			else Discard(Event);

			// ---------------------------------- //
			// Destroy player's Turret (Turret has no OnArmorEmpty for some reasons)
			if (Event.VictimTurret != Null && Event.VictimTurret.Armor <= 0 && Turrets::BelongsToLib(Event.VictimTurret)) {
				// ---------------------------------- //
				// Get the elimination icon
				declare EventIcon = "";
				switch (Event.WeaponNum) {
					case 1 : EventIcon = "Laser.png";
					case 2 : EventIcon = "Rocket.png";
					case 3 : EventIcon = "Nucleus.png";
					case 5 : EventIcon = "Arrow.png";
					case 6 : EventIcon = "Missile.png";
					default : EventIcon = "Shield.png";
				}

				// ---------------------------------- //
				// Get the shooter's login
				declare ShooterLogin = "";
				if (Event.Shooter != Null) {
					if (Event.Shooter.IsBot) EventIcon = "Toad.png";
					else ShooterLogin = Event.Shooter.User.Login;
				}
				declare ShooterTurretOwner <=> Turrets::GetTurretOwner(Event.ShooterTurret);
				declare VictimTurretOwner <=> Turrets::GetTurretOwner(Event.VictimTurret);
				if (ShooterTurretOwner != Null) {
					ShooterLogin = ShooterTurretOwner.User.Login;
					EventIcon = "Turret.png";
				}

				// Send notice and destroy the Turret
				if (Players.exists(VictimTurretOwner)) Killfeed::SendNotice(
					"Turret - "^VictimTurretOwner.User.Name,
					ShooterLogin, C_ImgBase^"Icons/"^EventIcon, ""
				);
				declare Destroyed = Turrets::DestroyTurret(Event.VictimTurret.Id, Turrets::GetCooldown());
			}
		}
		// ---------------------------------- //
		// Manual event management
		else {
			+++OnHit+++
		}
	}
	// ---------------------------------- //
	// On shoot
	else if (Event.Type == CSmModeEvent::EType::OnShoot) {
		if (GT_AutoManageOnShoot) {
			Statistics::OnShoot(Event);
		}
		+++OnShoot+++
	}
	// ---------------------------------- //
	// On player request respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		if (GT_AutoManageOnRespawn) {
			+++OnPlayerRequestRespawn+++

			declare Ident[] GT_VictimShootHistory for Event.Player;
			declare Ident GT_VictimLastShooter for Event.Player;
			GT_VictimShootHistory.clear();
			GT_VictimLastShooter = NullId;

			Scores::RemovePlayerRoundPoints(Event.Player.Score, 1);
			Statistics::OnPlayerRequestRespawn(Event);
			PassOn(Event);
		}
		else {
			+++OnPlayerRequestRespawn+++
		}
	}
	// ---------------------------------- //
	// Player picked up item
	else if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject) {
		if (Event.Object == Null || Event.Player == Null || Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) {
			Discard(Event);
			continue;
		}
		
		// Pick up object handled by the mode base
		if (GT_AutoManageOnObjectTouch) if (GalaxyTitles::PickUpObject(Event, S_ObjectsRespawnTime * 1000)) continue;
		
		+++OnPlayerTouchesObject+++
	}
	// ---------------------------------- //
	// On player switch weapon
	else if (Event.Type == CSmModeEvent::EType::OnActionEvent) {
		+++Before_OnActionEvent+++

		declare Switched = Inventory::SwitchWeapon(Event.Player, Event.ActionInput);
		declare UsedTurret = Turrets::UseActionButton(Event.Player, Event.ActionInput);
		declare UsedToad = Toads::UseActionButton(Event.Player, Event.ActionInput);

		GalaxyTitles::UseConsumableItems(Event);

		+++OnActionEvent+++
	}
	// ---------------------------------- //
	// On player cycle weapon
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestActionChange) {
		Inventory::ScrollWeapons(Event.Player, Event.ActionChange);
		+++OnPlayerRequestActionChange+++
	}
	// ---------------------------------- //
	// Near miss event
	else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
		// ---------------------------------- //
		// Display near miss message
		if (
			GT_AutoManageOnNearMiss && !Event.Shooter.IsBot && Event.Victim != Null && Event.WeaponNum == 1 &&
			(Event.Shooter.CurrentClan == 0 || Event.Shooter.CurrentClan != Event.Victim.CurrentClan)
		) {
			Interfancy::DisplayNearMiss(Event.Shooter, Event.MissDist);
		}
		Statistics::OnNearMiss(Event);
		+++OnNearMiss+++
	}
	// ---------------------------------- //
	// On shot deny
	else if (Event.Type == CSmModeEvent::EType::OnShotDeny) {
		Statistics::OnShotDeny(Event);
	}
}

// ---------------------------------- //
// Galaxy Titles features
GT_UnspawnPlayersChangingClan();
GalaxyTitles::Loop(GT_UseAutospawnObjects && S_ObjectsRespawnTime > 0, S_ToadsRespawnTime * 1000);

// ---------------------------------- //
// Update the custom weapon name in gauges
foreach (Player in Players) {
	declare GT_PlayerCustomWeaponId = Inventory::GetPlayerCustomWeapon(Player);
	declare Text GT_PrevCustomWeaponId for Player;

	if (GT_PrevCustomWeaponId == GT_PlayerCustomWeaponId) continue;
	GT_PrevCustomWeaponId = GT_PlayerCustomWeaponId;

	declare WeaponName = Inventory::GetWeaponName(GT_PlayerCustomWeaponId);
	Interfancy::SetPlayerCustomWeapon(Player, WeaponName);
}

// ---------------------------------- //
// Respawn players changing characters
if (GT_AutoRespawnOnCharChange) foreach (PlayerId => CharacterId in Characters::CharChangeRequests()) {
	if (!Players.existskey(PlayerId)) continue;
	declare Player <=> Players[PlayerId];

	UnspawnPlayer(Player);
	Toads::DestroyToad(Player);
	Turrets::DestroyTurret(Player);
}

// ---------------------------------- //
// Stop the no-collisions phase
if (GT_UseNoCollisionsStart && GT_NoCollisionsEndTime > 0 && GT_NoCollisionsEndTime <= Now) {
	GT_NoCollisionsEndTime = -1;
	UsePvPCollisions = True;
}

// ---------------------------------- //
// Update maximum weapons slots setting
if (PrevMaximumNbWeapons != S_MaximumNbWeapons) {
	PrevMaximumNbWeapons = S_MaximumNbWeapons;
	GalaxyTitles::SetMaxWeapons(S_MaximumNbWeapons);
}

// ---------------------------------- //
// Update maximum Replies setting
if (PrevMaximumNbReplies != S_MaximumNbReplies) {
	PrevMaximumNbReplies = S_MaximumNbReplies;
	GalaxyTitles::SetMaxReplies(S_MaximumNbReplies);
}

// ---------------------------------- //
// Allow or deny character selection
if (PrevEnableCharSelection != S_EnableCharSelection) {
	PrevEnableCharSelection = S_EnableCharSelection;

	declare GT_CharactersAvailable = S_EnableCharSelection && Http.IsValidUrl(GT_CharactersDataFileURL);
	PauseMenu::SetButtonVisibility("GT_CharSelection", GT_CharactersAvailable);
	if (GT_CharactersAvailable) Characters::Manual();
	else Characters::Hide();
}

// ---------------------------------- //
// Update maximum Armor
if (PrevPlayerNbArmorMax != S_PlayerArmorPoints) {
	PrevPlayerNbArmorMax = S_PlayerArmorPoints;
	Characters::SetArmorBase(S_PlayerArmorPoints);
}
***

// ---------------------------------- //
// End play loop
// ---------------------------------- //
***Match_EndPlayLoop***
***
Turrets::ResetAllPlayers();
Toads::ResetAllPlayers();
GalaxyTitles::ResetAll();
MiniMap::Hide();
Markers::Reset();
***

// ---------------------------------- //
// End round
// ---------------------------------- //
***Match_EndRound***
***
TopScores::RoundEnd();
GT_SetTimeLimit(-1, False, False);
***

// ---------------------------------- //
// End map
// ---------------------------------- //
***Match_EndMap***
***
TopScores::MatchEnd();
GalaxyTitles::ResetAll();
***

// ---------------------------------- //
// Custom podium sequence
// ---------------------------------- //
***Match_PodiumSequence***
***
if (GT_UseAutoEndSequence) {
	// ---------------------------------- //
	// Set the map winner
	declare Text WinnerName;
	if (UseClans) {
		foreach (Clan => Points in ClanScores)
			if (Clan != 0 && Points > ClanScores[3 - Clan]) WinnerName = Teams[Clan - 1].ColorizedName;
	}
	else {
		declare WinnerScoreId = GT_GetWinnerScoreId();
		if (WinnerScoreId != NullId && Scores[WinnerScoreId].User != Null) WinnerName = Scores[WinnerScoreId].User.Name;
	}
	
	// ---------------------------------- //
	// Display the round winner
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	
	if (WinnerName == "") UIManager.UIAll.BigMessage = _("|Match|Draw");
	else UIManager.UIAll.BigMessage = TL::Compose(_("$<%1$> wins the match!"), WinnerName);
	
	MB_Sleep(4000);
	
	// ---------------------------------- //
	// Play the podium sequence
	if (S_PodiumTrackDuration > 0) {
		declare PodiumSequenceEndTime = Now + ML::Min(S_PodiumTrackDuration, C_MaxPodiumSeqDuration);
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
		while (Now < PodiumSequenceEndTime && !MatchEndRequested && !ServerShutdownRequested) MB_Yield();
	}
	
	if (!MM_IsMatchServer()) UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.BigMessage = "";
}
***

// ---------------------------------- //
// After podium sequence
// ---------------------------------- //
***Match_AfterPodiumSequence***
***
CupAdmin::EndMap();
while (CupAdmin::IsCupEnd()) MB_Yield();
***

// ---------------------------------- //
// Before unloading a map
// ---------------------------------- //
***Match_BeforeUnloadMap***
***
// ---------------------------------- //
// Let players vote for the next map
if (!MM_IsMatchServer() && S_EnableMapSelection && MapSelection::SelectionStart(Now + 10750, True)) {
	declare PrevSummaryVisibility = Interfancy::GetModuleVisibility("ScoreSummary");
	Interfancy::SetModuleVisibility("ScoreSummary", False);

	while (!MapSelection::SelectionLoop() && !MatchEndRequested && !ServerShutdownRequested) MB_Yield();
	MB_Sleep(3000);
	MapSelection::SelectionEnd();

	Interfancy::SetModuleVisibility("ScoreSummary", PrevSummaryVisibility);
}
***

***MB_Private_BeforeUnloadMap***
***
// Avoid fake join/leave mesages
Webhook::SetMapSwitching(True);
Killfeed::SetMapSwitching(True);
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***Match_EndServer***
***
Characters::Unload();
GalaxyTitles::Unload();
Interfancy::Unload();
Killfeed::Unload();
MapSelection::Unload();
Markers::Unload();
MiniMap::Unload();
Models::Unload();
PauseMenu::Unload();
Statistics::Unload();
StoragePlayer::Unload();
Streaks::Unload();
FancyMessages::Unload();

WarmUp::Unload();
***

// ---------------------------------- //
// GalaxyTitles - configure player character
// ---------------------------------- //
***Private_GalaxyTitles_ConfigCharacter***
***
declare PlayerCharacterId = 0;
if (S_EnableCharSelection) PlayerCharacterId = Characters::GetPlayerChar(Player);

// ---------------------------------- //
// Default Galaxy characters
if (GT_CharactersDataFileURL == C_DefaultCharactersURL) switch (PlayerCharacterId) {
	// ---------------------------------- //
	// Sintel
	case 1 : {
		Models::SetCustom(Player, "Sintel");

		Inventory::SetAvailableWeapons(Player, [CSmMode::EWeapon::Missile, CSmMode::EWeapon::Rocket]);
		Inventory::ChangeWeaponHotkey(Player, CSmMode::EWeapon::Missile, CSmModeEvent::EActionInput::Activable1);
		Inventory::SetWeaponSlots(Player, CSmMode::EWeapon::Missile, 1);
		Inventory::SetWeaponSlots(Player, CSmMode::EWeapon::Rocket, 4);

		Player.ArmorMax = ML::Clamp(S_PlayerArmorPoints - 1, 1, 10) * 100;
	}
	// ---------------------------------- //
	// Susu
	case 2 : {
		Models::SetArenaPlayer(Player, "Susu.zip");
		Inventory::SetWeaponSlots(Player, CSmMode::EWeapon::Rocket, C_SummonerRocketMax);
		Toads::AddToInventory(Player);

		Player.AmmoGain = C_SummonerAmmoGain;
		Player.StaminaMax = C_ScoutStaminaMax;
	}
	// ---------------------------------- //
	// Constructor
	case 3 : {
		Models::SetArenaPlayer(Player, "TronMan.zip");
		Inventory::SetWeaponSlots(Player, CSmMode::EWeapon::Rocket, C_SummonerRocketMax);
		Turrets::AddToInventory(Player);

		Player.AmmoGain = C_SummonerAmmoGain;
		Player.StaminaMax = C_ScoutStaminaMax;
	}
	// ---------------------------------- //
	// Medic
	case 4 : {
		Models::SetArenaPlayer(Player, "StormWoman.Skin.Pack.Gbx");

		GalaxyTitles::LoadInfiniteSupplies(Player, C_HealerSupplyCooldown);
		GalaxyTitles::SetPlayerCanPickUpSupplies(Player, False);

		/*
		Inventory::RemoveWeapon(_Player, CSmMode::EWeapon::Laser);
		Inventory::AddWeapon(_Player, CSmMode::EWeapon::Rocket);
		Inventory::AddWeapon(_Player, "MediShot");
		Inventory::SetWeaponSlots(Player, CSmMode::EWeapon::Rocket, 4);
		*/

		Player.AmmoGain = C_HealerAmmoGain;
		Player.StaminaMax = C_ScoutStaminaMax;
	}
	// ---------------------------------- //
	// Toad
	case 5 : {
		Player.ForceModelId = GalaxyTitles::GetToadModel();

		Player.ArmorMax = ML::Clamp(S_PlayerArmorPoints - 1, 1, 10) * 100;
		Player.SpeedPower = .75;
	}
}

---GalaxyTitles_ConfigCharacter---

// ---------------------------------- //
// Current character name
declare PlayerCharacterName = "";
if (PlayerCharacterId > 0) PlayerCharacterName = Characters::GetCharName(Player);
Interfancy::SetArmorText(Player, PlayerCharacterName);

// ---------------------------------- //
// Current character icon
declare PlayerCharacterIcon1 = "";
declare PlayerCharacterIcon2 = "";
if (PlayerCharacterId > 0) {
	PlayerCharacterIcon1 = Characters::GetCharIcon(Player);
	PlayerCharacterIcon2 = Characters::GetCharIcon2(Player);
}
Interfancy::SetCharacterIcon(Player, PlayerCharacterIcon1, PlayerCharacterIcon2);
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get the requested clan of a player
 *
 *	@param	_Player		The player to check
 *
 *	@return		The requested clan of the player
 */
Integer GT_GetRequestedClan(CSmPlayer _Player) {
	if (_Player == Null || !UseClans) return 0;
	
	// Get the clan in matchmaking
	if (MM_IsMatchServer()) return MM_GetRequestedClan(_Player);
	
	// Get the clan from automatic team balance
	/*
	if (S_UseAutoBalance) {
		declare Integer GT_AutoBalanceClan for _Player;
		if (GT_AutoBalanceClan >= 1 && GT_AutoBalanceClan <= 2) return GT_AutoBalanceClan;
	}
	*/
	
	// Get the user requested clan
	return _Player.RequestedClan;
}

// ---------------------------------- //
/// Teams balance based on players total points
Void GT_AutoBalance() {
	if (!S_UseAutoBalance) return;
	MB_AutoTeamBalance();

	foreach (I => Player in Players) {
		declare Integer GT_AutoBalanceClan for Player;
		GT_AutoBalanceClan = I % 2 + 1;
	}
}

// ---------------------------------- //
/** Check if specific event is valid for sending XMLRPC callbacks
 *
 *	@param	_Event		The event to check
 *
 *	@return		True, if event can be sent via XMLRPC
 */
Boolean GT_IsValidForCallbacks(CSmModeEvent _Event) {
	if (_Event == Null) return False;
	declare EventPlayers = [_Event.Player, _Event.Shooter, _Event.Victim];
	foreach (Player in EventPlayers) if (Player != Null && (Player.IsBot || Player.IsFakePlayer)) return False;
	return True;
}

// ---------------------------------- //
/// Unspawn the players requesting a clan change
Void GT_UnspawnPlayersChangingClan() {
	if (!UseClans || UseForcedClans) return;
	foreach (Player in Players) {
		if (
			Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned &&
			Player.CurrentClan != 0 && Player.CurrentClan != GT_GetRequestedClan(Player)
		)
			UnspawnPlayer(Player);
	}
}

// ---------------------------------- //
/** Check if a player is valid to be spawned in mode
 *
 *	@param	_Player		The player to check
 *
 *	@return		True if the player is valid, false otherwise
 */
Boolean GT_IsValidPlayer(CSmPlayer _Player) {
	if (_Player == Null) return False;
	
	// Skip invalid player in matchmaking
	if (MM_IsMatchServer() && !MM_PlayerIsAllowedToPlay(_Player)) return False;
	
	// Set player clan
	SetPlayerClan(_Player, GT_GetRequestedClan(_Player));
	return True;
}

// ---------------------------------- //
/** Initialize player to be spawned
 *
 *	@param	_Player		The player to initialize
 */
Void GT_InitPlayer(CSmPlayer _Player) {
	if (_Player == Null) return;
	
	if (UseClans && _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned)
		SetPlayerClan(_Player, GT_GetRequestedClan(_Player));

	GalaxyTitles::InitPlayer(_Player);
	SetPlayerReloadAllWeapons(_Player, True);
	
	// ---------------------------------- //
	// Force player's favorite color
	if (_Player.CurrentClan != 0) _Player.ForceColor = <-1., -1., -1.>;
	else _Player.ForceColor = _Player.User.Color;
	
	_Player.ArmorMax = ML::Clamp(S_PlayerArmorPoints, 1, 10) * 100;
	_Player.StaminaMax = C_PlayerStaminaMax;
	_Player.AmmoGain = 1.;
	_Player.SpeedPower = 1.;
	Models::SetDefault(_Player);

	// Configure the player's character
	declare Player <=> _Player;
	---Private_GalaxyTitles_ConfigCharacter---

	// Initialize weapon
	Inventory::SetFirstWeapon(_Player);
}

// ---------------------------------- //
/** Check if an event is hit.
 *
 *	@param	_Event	The event to check.
 *
 *	@return		True, if the event is a hit.
 */
Boolean GT_IsHitEvent(CSmModeEvent _Event) {
	if (_Event == Null) return False;
	if (_Event.Type == CSmModeEvent::EType::OnHit) return True;
	if (_Event.Type != CSmModeEvent::EType::OnActionCustomEvent) return False;
	return _Event.Param1 == "damage";
}

// ---------------------------------- //
/** Get the damage of a hit event.
 *
 *	@param	_Event	The event to get damage.
 *
 *	@return		Damage of the hit.
 */
Integer GT_GetEventDamage(CSmModeEvent _Event) {
	if (_Event == Null) return 0;
	if (_Event.Type == CSmModeEvent::EType::OnHit) return ML::Min(_Event.Damage, C_EventMaxDamage);
	if (_Event.Type != CSmModeEvent::EType::OnActionCustomEvent) return 0;

	if (_Event.Param1 != "damage" || !_Event.Param2.existskey(0)) return 0;
	return ML::Min(TL::ToInteger(_Event.Param2[0]), C_EventMaxDamage);
}

// ---------------------------------- //
/** Pass a hit event.
 *
 *	@param	_Event	The event to pass.
 */
Void GT_PassOnHit(CSmModeEvent _Event) {
	if (_Event == Null) return;
	if (_Event.Type != CSmModeEvent::EType::OnHit && _Event.Type != CSmModeEvent::EType::OnActionCustomEvent) return;

	PassOn(_Event);

	if (_Event.Type == CSmModeEvent::EType::OnActionCustomEvent) {
		declare EventDamage = GT_GetEventDamage(_Event);
		if (_Event.Victim != Null) RemovePlayerArmor(_Event.Victim, EventDamage, _Event.Shooter, EventDamage / 100);
	}
}

// ---------------------------------- //
/// Initialize the warm up properties
Void GT_InitWarmUp() {
	if (S_NbPlayersPerTeamMax > 0) {
		if (WarmUp::GroupExists("Clan1")) WarmUp::SetSlotsNb("Clan1", S_NbPlayersPerTeamMax);
		else WarmUp::CreateGroup("Clan1", S_NbPlayersPerTeamMax);
		if (WarmUp::GroupExists("Clan2")) WarmUp::SetSlotsNb("Clan2", S_NbPlayersPerTeamMax);
		else WarmUp::CreateGroup("Clan2", S_NbPlayersPerTeamMax);
		WarmUp::DisplayClanSelection(True);
	} else {
		WarmUp::DestroyGroup("Clan1");
		WarmUp::DestroyGroup("Clan2");
		WarmUp::DisplayClanSelection(False);
	}
}

// ---------------------------------- //
/** Compute distance between points excluding Y axis
 *
 *	@param	_Pos1	Starting point
 *	@param	_Pos2	Ending point
 *
 *	@return		Distance between points
 */
Real GT_Distance2D(Vec3 _Pos1, Vec3 _Pos2) {
	declare Pos1 = <_Pos1.X, _Pos1.Z>;
	declare Pos2 = <_Pos2.X, _Pos2.Z>;
	if (Pos1 == Pos2) return 0.;
	return ML::Sqrt(ML::Pow(Pos1.X - Pos2.X, 2.) + ML::Pow(Pos1.Y - Pos2.Y, 2.));
}

// ---------------------------------- //
/// Skip the map if it's not valid
Void GT_SkipInvalidMap() {
	Translations::SendChat("This map is not valid, moving to the next one.");
	if (!ServerShutdownRequested) MB_Sleep(10000);
	MB_StopMap();
}

// ---------------------------------- //
/** Get the Id of the winner's score object.
 *
 *	@return		Id of the match winner score.
 */
Ident GT_GetWinnerScoreId() {
	if (Scores.count <= 0 || Scores[0].Points <= 0) return NullId; ///< Draw - no players or the 1st player has 0 points
	if (Scores.existskey(1) && Scores[1].Points >= Scores[0].Points) return NullId; /// Draw - second player has the same number of points
	return Scores[0].Id; ///< Return the winner Id
}

// ---------------------------------- //
/** Set the new time limit.
 *
 *	@param	_NewEndTime		New value for the time limit.
 *	@param	_EnableSounds	If True, ticking sound will be heard when time is running out.
 *	@param	_ResetMusic		If True, music will be reset with the timer.
 */
Void GT_SetTimeLimit(Integer _NewEndTime, Boolean _EnableSounds, Boolean _ResetMusic) {
	GT_EndTime = ML::Max(_NewEndTime, -1);
	Interfancy::SetEndTime(GT_EndTime);
	Interfancy::SetUseMusic(!_EnableSounds);
	
	if (_EnableSounds) {
		StoragePlayer::SetCountdown(-1, 0);
		EndTime = GT_EndTime;
	} else {
		if (GT_EndTime > 0 || (GT_EndTime <= 0 && _ResetMusic)) StoragePlayer::SetCountdown(GT_EndTime, 30000);
		EndTime = -1;
	}
}

// ---------------------------------- //
/** Set the new time limit.
 *
 *	@param	_NewEndTime		New value for the time limit.
 *	@param	_EnableSounds	If True, ticking sound will be heard when time is running out.
 */
Void GT_SetTimeLimit(Integer _NewEndTime, Boolean _EnableSounds) {
	GT_SetTimeLimit(_NewEndTime, _EnableSounds, False);
}

// ---------------------------------- //
/** Set the new time limit without using ticking sounds.
 *
 *	@param	_NewEndTime		New value for the time limit.
 */
Void GT_SetTimeLimit(Integer _NewEndTime) {
	GT_SetTimeLimit(_NewEndTime, False, False);
}

// ---------------------------------- //
/** Check if the time has reached its limit.
 *
 *	@return		True, if time has reached its limit.
 */
Boolean GT_TimeReachedLimit() {
	return GT_EndTime > 0 && Now > GT_EndTime;
}

// ---------------------------------- //
/// Disable the time limit.
Void GT_DisableTimeLimit() {
	GT_SetTimeLimit(-1, False, True);
}

// ---------------------------------- //
/// Do the warm-up
Void GT_DoWarmUp() {
	WarmUp::SetAllSlotsIcons("Clan1", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
	WarmUp::SetAllSlotsIcons("Clan2", "file://Media/Manialinks/ShootMania/Common/Rocket.dds");
	
	SM::UnspawnAllPlayers();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.BigMessageSoundVariant = 0;
	UIManager.UIAll.StatusMessage = _("Press F6 once you're ready.");
	UIManager.UIAll.BigMessage = TL::Compose("$f90%1", _("Warm-up"));
	
	WarmUp::Begin();
	
	// Set players clan
	if (UseClans) foreach (Player in AllPlayers) {
		SetPlayerClan(Player, GT_GetRequestedClan(Player));
		WarmUp::SetPlayerGroup(Player, "Clan"^Player.CurrentClan);
	}
	
	WarmUp::Fill();
	
	// Initialize warm-up
	GalaxyTitles::ResetAll();
	GalaxyTitles::InitObjects();
	MiniMap::Show();
	
	declare PrevWarmUpDuration = S_WarmUpDuration - 1;
	declare Ident[] SpawnsList;
	declare Ident LatestSpawnId;
	
	MB_EnablePlayMode(True);
	
	// ---------------------------------- //
	// Warm-up sequence loop
	while (!WarmUp::Stop()) {
		MB_Yield();
		
		// Let the server sleep if there are no players
		if (PlayersNbTotal <= 0) continue;
		
		// ---------------------------------- //
		// Update warm-up duration
		if (PrevWarmUpDuration != S_WarmUpDuration) {
			PrevWarmUpDuration = S_WarmUpDuration;
			
			declare LongTimer = S_WarmUpDuration*1000;
			declare ShortTimer = 5000;
			if (LongTimer <= 0) { LongTimer = 0; ShortTimer = 0; }
			
			WarmUp::SetGroupTimers("Clan1", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
			WarmUp::SetGroupTimers("Clan2", [ShortTimer => [-1, S_NbPlayersPerTeamMax], LongTimer => [1, S_NbPlayersPerTeamMax]]);
		}
		
		WarmUp::Loop();
		WarmUp::ManageEvents();
		
		GalaxyTitles::SpawnObjects(GT_UseAutospawnObjects);
		GT_UnspawnPlayersChangingClan();
		
		// ---------------------------------- //
		// Spawn players
		foreach (Player in Players) {
			if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned) {
				if (UseClans) SetPlayerClan(Player, GT_GetRequestedClan(Player));
				if (Player.CurrentClan == 1) WarmUp::SetPlayerGroup(Player, "Clan1");
				else if (Player.CurrentClan == 2) WarmUp::SetPlayerGroup(Player, "Clan2");
				
				// Init player settings
				Player.ArmorMax = ML::Max(1, ML::Min(S_PlayerArmorPoints, 10)) * 100;
				Player.StaminaMax = C_PlayerStaminaMax;
				
				// Select random spawn
				if (SpawnsList.count == 0) foreach (MapLandmark in MapLandmarks_PlayerSpawn) SpawnsList.add(MapLandmark.Id);
				
				declare SpawnId = NullId;
				while (True) {
					SpawnId = SpawnsList[ML::Rand(0, SpawnsList.count - 1)];
					if (SpawnId != LatestSpawnId) break;
					if (SpawnsList.count == 1) break;
				}
				
				LatestSpawnId = SpawnId;
				SM::Spawn(Player, Player.CurrentClan, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn, Now + S_RespawnTime);
				declare Removed = SpawnsList.remove(SpawnId);
			}
		}
	}
	
	// ---------------------------------- //
	// End the warm-up
	MB_EnablePlayMode(False);
	WarmUp::End();
	
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.BigMessage = "";
	
	SM::UnspawnAllPlayers();
	GalaxyTitles::ResetAll();
	MiniMap::Hide();
}

// ---------------------------------- //
/** Automatic waiting for players sequence.
 *
 *	You can extend this sequence by adding code in labels below:
 *	- GalaxyTitles_StartWaiting
 *	- GalaxyTitles_WaitingYield
 *	- GalaxyTitles_WaitingLoop
 *	- GalaxyTitles_WaitingInitPlayer
 *	- GalaxyTitles_EndWaiting
 *
 *	@param	_MinimumNbPlayers	Minimum number of players required to start the game.
 *	@param	_AllTeamsTotal		In teams mode: count players from all teams if set to True.
 */
Void GT_WaitForPlayers(Integer _MinimumNbPlayers, Boolean _AllTeamsTotal) {
	// ---------------------------------- //
	// Skip the section entriely if there are enough players
	declare GT_HasEnoughPlayers = False;
	if (!UseClans || _AllTeamsTotal) GT_HasEnoughPlayers = PlayersNbTotal >= _MinimumNbPlayers;
	else GT_HasEnoughPlayers = ClansNbPlayers[1] >= _MinimumNbPlayers && ClansNbPlayers[2] >= _MinimumNbPlayers;
	if (!CupAdmin::IsCupPaused() && GT_HasEnoughPlayers) return;

	// ---------------------------------- //
	// Initialize waiting sequence
	Translations::ResetMessages();

	declare OldSequence = UIManager.UIAll.UISequence;
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::PhaseChange;
	UIManager.UIAll.BigMessageSoundVariant = 0;

	if (CupAdmin::IsCupPaused()) {
		Translations::SetStatusMessage("Competition has been paused");
		UIManager.UIAll.BigMessage = TL::Compose("$F90%1", _("Pause"));
	} else {
		UIManager.UIAll.BigMessage = _("Waiting for players in each team...");
		UIManager.UIAll.StatusMessage = "";
	}

	declare Ident[] GT_WaitingSpawnsList;
	declare GT_WaitingDisableOffZone = False;
	declare GT_WaitingLastSpawnId = NullId;
	declare GT_StopWaiting = False;
	declare GT_WasPaused = CupAdmin::IsCupPaused();

	SM::UnspawnAllPlayers();
	MiniMap::Show();
	StartTime = Now;

	// ---------------------------------- //
	// Spawn objects on landmarks
	declare Ident[] GT_WaitingCreatedObjects;
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		if (MapLandmark.ObjectAnchor.ItemModelId == NullId) continue;
		declare Object <=> ObjectCreate(MapLandmark.ObjectAnchor.ItemModelId);
		Object.SetAnchor(MapLandmark.ObjectAnchor);
		GT_WaitingCreatedObjects.add(Object.Id);
	}

	+++GalaxyTitles_StartWaiting+++

	// ---------------------------------- //
	// Waiting sequence loop
	while (!ServerShutdownRequested && !MatchEndRequested) {
		MB_Yield();

		+++GalaxyTitles_WaitingYield+++

		// Let the server sleep if there's no players on it
		if (PlayersNbTotal <= 0) continue;

		+++GalaxyTitles_WaitingLoop+++

		// Check if there are enough players
		if (!UseClans || _AllTeamsTotal) GT_HasEnoughPlayers = PlayersNbTotal >= _MinimumNbPlayers;
		else GT_HasEnoughPlayers = ClansNbPlayers[1] >= _MinimumNbPlayers && ClansNbPlayers[2] >= _MinimumNbPlayers;

		// Stop waiting
		if (!CupAdmin::IsCupPaused() && GT_HasEnoughPlayers) GT_StopWaiting = True;
		if (GT_StopWaiting) break;

		GT_UnspawnPlayersChangingClan();

		// ---------------------------------- //
		// Manage events
		foreach (Event in PendingEvents) {
			// ---------------------------------- //
			// On armor empty
			if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
				if (GT_WaitingDisableOffZone && Event.Victim.IsInOffZone && Event.Victim.Armor > 0) {
					Discard(Event);
				} else {
					Killfeed::OnArmorEmpty(Event, Null);
					PassOn(Event);
				}
			}
			// ---------------------------------- //
			// On hit
			else if (Event.Type == CSmModeEvent::EType::OnHit) {
				if (Event.Victim == Null || Event.Victim == Event.Shooter) continue;
				Event.Victim.Armor = Event.Victim.ArmorMax;
				Event.Damage = 100;
				Event.ShooterPoints = Event.Damage / 100;
				PassOn(Event);
			}
			// ---------------------------------- //
			// On near miss
			else if (Event.Type == CSmModeEvent::EType::OnNearMiss) {
				Interfancy::DisplayNearMiss(Event.Shooter, Event.MissDist);
				PassOn(Event);
			}
			// ---------------------------------- //
			// On player touches object
			else if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject) Discard(Event);

			// Other
			else PassOn(Event);
		}

		// ---------------------------------- //
		// Spawn players
		foreach (Player in Players) {
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) continue;

			// Initialize player
			SetPlayerClan(Player, GT_GetRequestedClan(Player));
			Player.ArmorMax = ML::Max(1, ML::Min(S_PlayerArmorPoints, 10)) * 100;
			Player.StaminaMax = C_PlayerStaminaMax;

			+++GalaxyTitles_WaitingInitPlayer+++

			// Fill the spawns list
			if (GT_WaitingSpawnsList.count <= 0)
				foreach (MapLandmark in MapLandmarks_PlayerSpawn)
					GT_WaitingSpawnsList.add(MapLandmark.Id);

			// Select a random spawn
			declare SpawnId = NullId;
			while (True) {
				SpawnId = GT_WaitingSpawnsList[ML::Rand(0, GT_WaitingSpawnsList.count - 1)];
				if (SpawnId != GT_WaitingLastSpawnId) break;
				if (GT_WaitingSpawnsList.count == 1) break;
			}
			GT_WaitingLastSpawnId = SpawnId;
			
			// Spawn the player
			SM::Spawn(Player, Player.CurrentClan, MapLandmarks[SpawnId].PlayerSpawn, Now + S_RespawnTime);
			declare Removed = GT_WaitingSpawnsList.remove(SpawnId);
		}
	}

	// ---------------------------------- //
	// Stop the waiting sequence
	Translations::ResetMessages();
	SM::UnspawnAllPlayers();
	MiniMap::Hide();
	StartTime = -1;

	// Destroy created objects
	foreach (ObjectId in GT_WaitingCreatedObjects) ObjectDestroy(Objects[ObjectId]);

	+++GalaxyTitles_EndWaiting+++

	// ---------------------------------- //
	// Waiting end message
	if (!ServerShutdownRequested && !MatchEndRequested) {
		declare Message = _("A new player joins the game.");
		if (GT_WasPaused) Message = "Competition has been resumed!";
		
		Translations::SendBigMessage(Message, 5000, 0, CUIConfig::EUISound::Default, 0);
		MB_Sleep(5000);
	}

	// Revert the interface
	Translations::ResetMessages();
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	UIManager.UIAll.UISequence = OldSequence;
}

Void GT_WaitForPlayers(Integer _MinimumNbPlayers) {
	GT_WaitForPlayers(_MinimumNbPlayers, False);
}

// ---------------------------------- //
/** Play the Sudden Death mode to determine match winner
 *
 *	@param	_Team1Spawn		First team spawn
 *	@param	_Team2Spawn		Second team spawn
 *
 *	@return		Match winner
 */
Integer GT_SuddenDeath(CSmMapLandmark _Team1Spawn, CSmMapLandmark _Team2Spawn) {
	if (_Team1Spawn == Null || _Team1Spawn.PlayerSpawn == Null) return 0;
	if (_Team2Spawn == Null || _Team2Spawn.PlayerSpawn == Null) return 0;
	
	// ---------------------------------- //
	// Initialize Sudden Death mode
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = _("SUDDEN DEATH");

	declare TeamsPoints = 0;
	declare StopSuddenDeath = False;
	declare UpdateBigMessage = True;

	GalaxyTitles::ResetAll();
	MiniMap::Show();
	Message::CleanAllMessages();

	UseClans = True;
	EndTime = -1;
	StartTime = Now;
	
	// ---------------------------------- //
	// Colorize bases
	foreach (MapLandmark in MapLandmarks) {
		if (MapLandmark.Base == Null) continue;
		MapLandmark.Base.IsActive = True;
		if (MapLandmark == _Team1Spawn) MapLandmark.Base.Clan = 1;
		if (MapLandmark == _Team2Spawn) MapLandmark.Base.Clan = 2;
		else MapLandmark.Base.Clan = 0;
	}
	
	// Mode start sound
	Translations::SendBigMessage(
		["$<%1$> captured the last pole.", TL::ToText(3)],
		3000, 0, CUIConfig::EUISound::StartRound, 0
	);
	
	// ---------------------------------- //
	// Sudden Death loop
	while (!ServerShutdownRequested && !MatchEndRequested && !StopSuddenDeath) {
		MB_Yield();
		
		// ---------------------------------- //
		// Events management
		foreach (Event in PendingEvents) {
			// ---------------------------------- //
			// On armor empty
			if (Event.Type == CSmModeEvent::EType::OnArmorEmpty) {
				switch (Event.Victim.CurrentClan) {
					case 1 : TeamsPoints += 1;
					case 2 : TeamsPoints -= 1;
				}

				if (ML::Abs(TeamsPoints) == C_SuddenDeathPointsLimit) {
					UIManager.UIAll.SendNotice(
						"", CUIConfig::ENoticeLevel::PlayerInfo, 
						Null, CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::VictoryPoint, 0
					);
					StopSuddenDeath = True;
				} else {
					UIManager.UIAll.SendNotice(
						"", CUIConfig::ENoticeLevel::PlayerInfo, 
						Null, CUIConfig::EAvatarVariant::Default, 
						CUIConfig::EUISound::TieBreakPoint, 0
					);
				}

				Killfeed::OnArmorEmpty(Event, Null);
				Statistics::OnArmorEmpty(Event);
				PassOn(Event);
				UpdateBigMessage = True;
			}
			// ---------------------------------- //
			// On hit
			else if (Event.Type == CSmModeEvent::EType::OnHit) {
				if (Event.Victim == Null || Event.Shooter == Event.Victim) Discard(Event);
				else if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) Discard(Event);
				else {
					// Reduce Laser damage
					if (Event.Damage > C_EventMaxDamage) Event.Damage = C_EventMaxDamage;
					
					declare Points = ML::Min(Event.Damage, Event.Victim.Armor) / 100;
					Scores::AddPlayerRoundPoints(Event.Shooter.Score, Points);
					TopScores::AddPoints(Event.Shooter.Score, "Hit", Points);
					Event.ShooterPoints = Points;
					
					Statistics::OnHit(Event);
					PassOn(Event);
				}
			}
			// ---------------------------------- //
			// On shoot
			else if (Event.Type == CSmModeEvent::EType::OnShoot) {
				if (!GT_AutoManageOnShoot) continue;
				Statistics::OnShoot(Event);
			}
			// ---------------------------------- //
			// On player request respawn
			else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) Discard(Event);
			
			// ---------------------------------- //
			// Player picked up item
			else if (Event.Type == CSmModeEvent::EType::OnPlayerTouchesObject) Discard(Event);
			
			// Others
			else PassOn(Event);
		}
		
		// ---------------------------------- //
		// Spawn players
		foreach (Player in Players) {
			if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned || Player.RequestsSpectate || !GT_IsValidPlayer(Player)) continue;
			
			GT_InitPlayer(Player);
			Inventory::ResetInventory(Player);
			SetPlayerWeapon(Player, CSmMode::EWeapon::Laser, False);
			SetPlayerAmmoMax(Player, CSmMode::EWeapon::Laser, 1);
			Player.ArmorMax = 100;
			Player.AmmoGain = 2.;
			
			// Spawn player
			declare CSmMapPlayerSpawn PlayerSpawn;
			switch (Player.CurrentClan) {
				case 1 : PlayerSpawn <=> _Team1Spawn.PlayerSpawn;
				case 2 : PlayerSpawn <=> _Team2Spawn.PlayerSpawn;
			}
			SM::Spawn(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
		}
		
		// ---------------------------------- //
		// Update the big message
		if (UpdateBigMessage) {
			UpdateBigMessage = False;

			if (TeamsPoints == 0) UIManager.UIAll.BigMessage = "0 / 3";
			else if (TeamsPoints < 0) UIManager.UIAll.BigMessage = "$<$"^TL::ColorToText(Teams[0].ColorPrimary)^-TeamsPoints^"$> / "^C_SuddenDeathPointsLimit;
			else UIManager.UIAll.BigMessage = "$<$"^TL::ColorToText(Teams[1].ColorPrimary)^TeamsPoints^"$> / "^C_SuddenDeathPointsLimit;
		}
	}

	// ---------------------------------- //
	// Stop the Sudden Death mode
	SM::UnspawnAllPlayers();
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
	MB_Sleep(3000);
	UIManager.UIAll.BigMessage = "";
	UIManager.UIAll.StatusMessage = "";
	MiniMap::Hide();
	
	// ---------------------------------- //
	// Return the winner
	if (TeamsPoints < 0) return 1;
	if (TeamsPoints > 0) return 2;
	return 0;
}