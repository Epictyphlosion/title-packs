// -------------------------------------- //
//  KING OF THE HILL by domino54          //
//  script version: 2017-06-28            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes "RoyalArena"
#Const Version		"2017-06-28"
#Const ScriptName	"Modes/ShootMania/KotH.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map
#Include "Libs/domino54/MultiClans.Script.txt" as Clans

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeLimit			600		as _("Time limit (seconds)")
#Setting S_RoundsToWin			2		as _("Number of rounds to win a map")
#Setting S_NbTeams				0		as _("Number of teams (2 - 4, 0 = auto)")
#Setting S_UseDefaultTeams		False	as _("Use default teams (Blue vs Red)")
#Setting S_GoalCaptureDuration	100		as _("Time team requires to capture the Goal")
#Setting S_DarkerGoalColor		False	as "<hidden>"

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_TeamsNbMax		4	///< Maximum number of teams
#Const C_TeamsNames		["Orange", "Purple", "Green", "Pink"]
#Const C_TeamsColors	[<1., .5, 0.>, <.375, 0., 1.>, <.5, 1., 0.>, <1., 0., .5>]

#Const C_GoalCaptureDurationMin		1		///< Minimum Goal capture duration
#Const C_GoalCaptureSpeedBase		3		///< Basic Goal capture speed
#Const C_GoalCaptureSpeedPerPlayer	1		///< Goal capture speed per additional player
#Const C_GoalCaptureTimePerPoint	1500	///< Capture time per every capture point

///< Amount of players per additional team
#Const C_NbPlayersPerTeam [0, 0, 9, 12]

#Const Description _("TYPE: 2 - -4 teams\nOBJECTIVE: Capture the central Goal with your teammates. The first team to capture the Goal by themselves or team with biggest progress when time runs out wins.")

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Integer G_NbTeams;		///< Current amount of teams in game
declare Ident[] G_SpawnsList;	///< Id of all the landmarks with a player spawn of the map
declare Ident G_LatestSpawnId;	///< Id of the last landmark used

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersion***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
Log::RegisterScript(Clans::GetScriptName(), Clans::GetScriptVersion());
***

// ---------------------------------- //
// Set the scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("Capture", "Cap", 3., 75.);
if (!UseClans) ST2::SetPlayerCardImages(" ", C_ImgBase^"STPlayerLeft.png", C_ImgBase^"STPlayerRight.png");
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("King of the Hill");
ModeInfo::SetType(ModeInfo::C_Type_Teams);
ModeInfo::SetRules("1. Multiple teams try to capture single Goal.\n2. Each team has its own capture progress shown below the timer.\n3. The first team to capture the Goal by themselves or team with biggest progress when time runs out wins.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Init server
// ---------------------------------- //
***Match_InitServer***
***
// ---------------------------------- //
// Set the mode options
UseClans = S_UseDefaultTeams || MM_IsMatchServer();
GT_UseAutoEndSequence = UseClans;
GT_DisableTimeLimit();

// ---------------------------------- //
// Initialize teams
Clans::SetUsePlayersNames(True);
for (Clan, 1, 10) {
	if (C_TeamsNames.existskey(Clan - 1)) Clans::SetClanName(Clan, C_TeamsNames[Clan - 1]);
	if (C_TeamsColors.existskey(Clan - 1)) Clans::SetClanColor(Clan, C_TeamsColors[Clan - 1]);
	
	if (UseClans) continue;
	PauseMenu::SetCustomTeamName(Clan, Clans::GetClanName(Clan));
	UISetTeamColor(Clan, Clans::GetClanColor(Clan));
}

// ---------------------------------- //
// Interface
Layers::Create("KotH:Gauges", CreateManialinkGauges());
Layers::Create("KotH:Markers", CreateManialinkMarkers());
Layers::SetType("KotH:Markers", CUILayer::EUILayerType::Markers);

// ---------------------------------- //
// Variables
declare Real[Integer] TeamsCaptureValues;
declare CapturingTeam = 0;
declare NbPlayersCapturing = 0;
declare LeadingTeamNum = 0;
declare LeadingTeamRatio = 0;

// Update
declare PrevCapturingTeam = -1;
declare PrevGaugeValue = -1;
declare PrevLeadingTeam = 0;
declare PrevGoalCaptureDuration = S_GoalCaptureDuration;
declare CurrentTimeLimit = S_TimeLimit;
declare PrevTeamsSetting = S_NbTeams;
declare PrevRoundsToWin = S_RoundsToWin;
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***Match_StartServer***
***
Interfancy::SetModuleVisibility("ScoreSummary", True);
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***Match_InitMap***
***
// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;
declare CentralGoal <=> Map::GetLandmarkGauge("Goal", 0);
if (CentralGoal == Null || MapLandmarks_PlayerSpawn.count <= 0) MapValidated = False;

// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***Match_StartMap***
***
Clans::ResetClansPoints();
for (Clan, 1, C_TeamsNbMax) Interfancy::ResetCustomTeamPoints(Clan);
UpdateScoresTableFooter();
G_SpawnsList.clear();
G_LatestSpawnId = NullId;
***

// ---------------------------------- //
// Initialize round
// ---------------------------------- //
***Match_InitRound***
***
for (I, 1, C_TeamsNbMax) {
	TeamsCaptureValues[I] = 0.;
	UISetTeamProgress(I, 0.);
}
LeadingTeamNum = 0;
LeadingTeamRatio = 0;
UISetCapturingTeam(0);

PrevCapturingTeam = -1;
PrevGaugeValue = -1;
PrevLeadingTeam = 0;

// ---------------------------------- //
// Reset central Goal
CentralGoal.Gauge.Max = ML::Max(S_GoalCaptureDuration, C_GoalCaptureDurationMin) * C_GoalCaptureSpeedBase * 1000;
CentralGoal.Gauge.Value = 0;
CentralGoal.Gauge.Captured = False;
if (CentralGoal.Base != Null) CentralGoal.Base.Clan = 0;

// ---------------------------------- //
// Wait for enough players to start game
while (!ServerShutdownRequested && !MatchEndRequested && Players.count <= 0) MB_Yield();

// Get target amount of teams
UpdateTeamsAmount();
UpdateScoresTableFooter();

// ---------------------------------- //
// Balance teams at the round start
if (S_UseAutoBalance) KotH_AutoBalance();

// ---------------------------------- //
// Reset Goal time counters
foreach (Player in Players) {
	declare Integer TimeCapturingGoal for Player;
	declare Integer PrevTimeCapturingGoal for Player;
	TimeCapturingGoal = 0;
	PrevTimeCapturingGoal = 0;
}

// ---------------------------------- //
// New map sound
UIManager.UIAll.SendNotice("", CUIConfig::ENoticeLevel::MatchInfo, Null, CUIConfig::EAvatarVariant::Default, CUIConfig::EUISound::StartRound, 0);

StartTime = Now + S_RespawnTime;
if (S_TimeLimit > 0) GT_SetTimeLimit(StartTime + S_TimeLimit * 1000);
else GT_DisableTimeLimit();
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;

Layers::Attach("KotH:Gauges");
Layers::Attach("KotH:Markers");
***

// ---------------------------------- //
// On hit event conditions
// ---------------------------------- //
***OnHitConditions***
***
if (Clans::AreTeammates(Event.Shooter, Event.Victim)) {
	Discard(Event);
	continue;
}
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// ---------------------------------- //
// Manage players
foreach (Player in Players) {
	// ---------------------------------- //
	// Spawn players
	if (!Player.RequestsSpectate && Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);
		
		// ---------------------------------- //
		// Set player clan
		if (!UseClans) {
			declare CurrentClan = KotH_GetPlayerClan(Player);
			if (CurrentClan < 1 || CurrentClan > G_NbTeams) CurrentClan = GetNextPlayerClan();
			KotH_SetPlayerClan(Player, CurrentClan);
		}

		// Spawn player
		MeleeSpawnPlayer(Player);
	}
}

// ---------------------------------- //
// Players requesting custom team change
if (!UseClans) foreach (PlayerId => Clan in PauseMenu::CustomTeamsRequests()) {
	if (!Players.existskey(PlayerId)) continue;
	declare Player = Players[PlayerId];
	if (KotH_GetPlayerClan(Player) == Clan) continue;

	UnspawnPlayer(Player);
	KotH_SetPlayerClan(Player, Clan);
	declare Destroyed = Toads::DestroyToad(Player);
}

CapturingTeam = 0;

// ---------------------------------- //
// Get the currently capturing team
if (CentralGoal.Sector.PlayersIds.count > 0) {
	NbPlayersCapturing = 0;
	
	foreach (PlayerId in CentralGoal.Sector.PlayersIds) {
		if (!AllPlayers.existskey(PlayerId)) continue;
		declare Player = AllPlayers[PlayerId];
		
		declare PlayerClan = KotH_GetPlayerClan(Player);
		if (CapturingTeam > 0 && PlayerClan != CapturingTeam) { CapturingTeam = 0; break; }
		
		CapturingTeam = PlayerClan;
		NbPlayersCapturing += 1;
	}
	
	// ---------------------------------- //
	// Give points for players capturing Goal
	foreach (PlayerId in CentralGoal.Sector.PlayersIds) {
		if (!AllPlayers.existskey(PlayerId)) continue;
		declare Player = AllPlayers[PlayerId];
		if (KotH_GetPlayerClan(Player) != CapturingTeam) continue; 
		
		declare Integer TimeCapturingGoal for Player;
		declare Integer PrevTimeCapturingGoal for Player;
		TimeCapturingGoal += 1000 / C_ScriptTicksPerSecond;
		
		if (TimeCapturingGoal - PrevTimeCapturingGoal >= C_GoalCaptureTimePerPoint) {
			PrevTimeCapturingGoal = TimeCapturingGoal;
			TopScores::AddPoints(Player.Score, "Capture", 1);
			Scores::AddPlayerRoundPoints(Player.Score, 1);
		}
	}
}

// ---------------------------------- //
// Capturing team change
if (PrevCapturingTeam != CapturingTeam) {
	PrevCapturingTeam = CapturingTeam;
	UISetCapturingTeam(CapturingTeam);
	
	// Enable or disable color depending if the Goal is being captured
	declare CentralGoalClan = CapturingTeam;
	if (!UseClans) CentralGoalClan = ML::Clamp(CapturingTeam, 0, 1);
	CentralGoal.Gauge.Clan = CentralGoalClan;
	
	// Enable the Goal's Base when capturing
	if (CentralGoal.Base != Null) {
		CentralGoal.Base.IsActive = !S_DarkerGoalColor && CapturingTeam > 0;
		CentralGoal.Base.Clan = CentralGoal.Gauge.Clan;
	}
	
	// ---------------------------------- //
	// Update Goal color and restore team's capture progres
	declare GoalColor = <1., 1., 1.>;
	if (CapturingTeam > 0) {
		if (UseClans) {
			switch (CapturingTeam) {
				case 1 : GoalColor = Teams[0].ColorPrimary;
				case 2 : GoalColor = Teams[1].ColorPrimary;
			}
		}
		else {
			GoalColor = Clans::GetClanColor(CapturingTeam);
			Teams[0].ColorPrimary = GoalColor;
		}
		CentralGoal.Gauge.ValueReal = TeamsCaptureValues[CapturingTeam];
	}
	// ---------------------------------- //
	// Disable Goal when not being captured
	else {
		CentralGoal.Gauge.Speed = 0;
		// CentralGoal.Gauge.Value = 0;
	}
	
	// Set minimap marker
	MiniMap::SetMarker("Goal", "Goal.png", GoalColor, CentralGoal.Position);
}

// ---------------------------------- //
// Set capturing speed depending on capturing players amount
if (CapturingTeam > 0) CentralGoal.Gauge.Speed = C_GoalCaptureSpeedBase + (NbPlayersCapturing - 1) * C_GoalCaptureSpeedPerPlayer;

// ---------------------------------- //
// Gauge value change
if (PrevGaugeValue != CentralGoal.Gauge.Value) {
	PrevGaugeValue = CentralGoal.Gauge.Value;
	
	// ---------------------------------- //
	// Save current team progres
	if (TeamsCaptureValues.existskey(CapturingTeam)) {
		TeamsCaptureValues[CapturingTeam] = CentralGoal.Gauge.ValueReal;
		UISetTeamProgress(CapturingTeam, CentralGoal.Gauge.ValueReal);
		
		// ---------------------------------- //
		// Team becomes the new leader
		if (PrevGaugeValue > LeadingTeamRatio) {
			LeadingTeamNum = CapturingTeam;
			LeadingTeamRatio = PrevGaugeValue;
		}
		
		// ---------------------------------- //
		// Team has captured their Goal
		if (CentralGoal.Gauge.Value >= CentralGoal.Gauge.Max) {
			UIManager.UIAll.SendNotice(
				"", CUIConfig::ENoticeLevel::PlayerInfo, 
				Null, CUIConfig::EAvatarVariant::Default, 
				CUIConfig::EUISound::VictoryPoint, 0
			);

			declare LeadingTeamName = Clans::GetClanColorizedName(LeadingTeamNum);
			if (UseClans) switch (LeadingTeamNum) {
				case 1 : LeadingTeamName = Teams[0].ColorizedName;
				case 2 : LeadingTeamName = Teams[1].ColorizedName;
			}

			Message::SendBigMessage(
				TL::Compose(_("$<%1$> captured the checkpoint!"), LeadingTeamName),
				3000, 1, CUIConfig::EUISound::Capture, 0
			);

			// Stop the round
			MB_StopRound();
		}
	}
}

// ---------------------------------- //
// Leading team change
if (PrevLeadingTeam != LeadingTeamNum) {
	PrevLeadingTeam = LeadingTeamNum;
	
	declare LeadingTeamName = Clans::GetClanColorizedName(LeadingTeamNum);
	if (UseClans) switch (LeadingTeamNum) {
		case 1 : LeadingTeamName = Teams[0].ColorizedName;
		case 2 : LeadingTeamName = Teams[1].ColorizedName;
	}

	if (LeadingTeamNum > 0) Message::SendBigMessage(
		TL::Compose(_("$<%1$> takes the lead!"), LeadingTeamName),
		3000, 1, CUIConfig::EUISound::PhaseChange, 1
	);
}

// ---------------------------------- //
// Update teams amount
if (PrevTeamsSetting != S_NbTeams) {
	PrevTeamsSetting = S_NbTeams;
	
	UpdateTeamsAmount();
	UpdateScoresTableFooter();
	
	// ---------------------------------- //
	// Move players to new proper clans
	if (!UseClans) foreach (Player in Players) {
		if (KotH_GetPlayerClan(Player) > G_NbTeams) KotH_SetPlayerClan(Player, GetNextPlayerClan());
	}
}

// ---------------------------------- //
// Update time limit
if (CurrentTimeLimit != S_TimeLimit) {
	CurrentTimeLimit = S_TimeLimit;
	if (S_TimeLimit > 0) GT_SetTimeLimit(StartTime + S_TimeLimit * 1000);
	else GT_DisableTimeLimit();
}

// ---------------------------------- //
// Update Goal capture duration
if (PrevGoalCaptureDuration != S_GoalCaptureDuration) {
	PrevGoalCaptureDuration = S_GoalCaptureDuration;
	CentralGoal.Gauge.Max = ML::Max(S_GoalCaptureDuration, C_GoalCaptureDurationMin) * C_GoalCaptureSpeedBase * 1000;
}

// ---------------------------------- //
// Update amount of rounds to win a map
if (PrevRoundsToWin != S_RoundsToWin) {
	PrevRoundsToWin = S_RoundsToWin;
	UpdateScoresTableFooter();
}

// ---------------------------------- //
// Victory conditions
if (GT_TimeReachedLimit()) MB_StopRound();
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_EndRound***
***
CentralGoal.Gauge.Speed = 0; ///< Spooky Goal
SM::UnspawnAllPlayers();

// Give points for the winning team
Clans::AddClanPoints(LeadingTeamNum, 1);
for (Clan, 1, C_TeamsNbMax) Interfancy::SetCustomTeamPoints(Clan, Clans::GetClanPoints(Clan));
UpdateScoresTableFooter();

MB_Sleep(3000);
StartTime = -1;

// Hide the interface
MiniMap::DestroyMarker("Goal");
Layers::Detach("KotH:Gauges");
Layers::Detach("KotH:Markers");

// ---------------------------------- //
// Display the round winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

declare Msg = _("|Match|Draw");
if (LeadingTeamNum > 0) {
	declare LeadingTeamName = Clans::GetClanColorizedName(LeadingTeamNum);
	if (UseClans) switch (LeadingTeamNum) {
		case 1 : LeadingTeamName = Teams[0].ColorizedName;
		case 2 : LeadingTeamName = Teams[1].ColorizedName;
	}
	Msg = TL::Compose(_("$<%1$> wins the round!"), LeadingTeamName);
}
Message::SendBigMessage(Msg, 5000, 1, CUIConfig::EUISound::EndRound, 0);

MB_Sleep(5000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Map end conditions
if (UseClans) {
	foreach (Team => Points in ClanScores) if (Points >= S_RoundsToWin) MB_StopMatch();
} else {
	declare Integer[Integer] TeamsScores;
	for (Team, 1, G_NbTeams) TeamsScores[Team] = Clans::GetClanPoints(Team);
	foreach (Team => Points in TeamsScores) if (Points >= S_RoundsToWin) MB_StopMatch();
}
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_PodiumSequence***
***
if (!GT_UseAutoEndSequence) {
	// ---------------------------------- //
	// Get the winning team
	declare WinningTeam = 0;
	declare Integer[Integer] TeamsScores;
	declare MaxPoints = 0;
	declare Integer[] TeamsWithMaxPoints;

	// ---------------------------------- //
	// Custom teams
	for (Team, 1, G_NbTeams) {
		declare Points = Clans::GetClanPoints(Team);
		TeamsScores[Team] = Points;
		if (Points > MaxPoints) MaxPoints = Points;
	}
	foreach (Team => Points in TeamsScores) if (Points == MaxPoints) TeamsWithMaxPoints.add(Team);
	if (TeamsWithMaxPoints.count == 1) WinningTeam = TeamsWithMaxPoints[0];

	// ---------------------------------- //
	// Display the match winner
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

	declare Msg = _("|Match|Draw");
	if (WinningTeam > 0) Msg = TL::Compose(_("$<%1$> wins the match!"), Clans::GetClanColorizedName(WinningTeam));
	Message::SendBigMessage(Msg, 6000, 1, CUIConfig::EUISound::EndRound, 0);

	MB_Sleep(6000);

	// ---------------------------------- //
	// Play the podium sequence
	if (S_PodiumTrackDuration > 0) {
		declare PodiumSequenceEndTime = Now + ML::Min(S_PodiumTrackDuration, C_MaxPodiumSeqDuration);
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
		while (Now < PodiumSequenceEndTime && !MatchEndRequested && !ServerShutdownRequested) MB_Yield();
		UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
	}

	UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
	UIManager.UIAll.BigMessage = "";
}
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
Layers::Detach("KotH:Gauges");
Layers::Detach("KotH:Markers");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Spawn player
 *
 *	@param	_Player		The player to spawn
 */
Void MeleeSpawnPlayer(CSmPlayer _Player) {
	if (G_SpawnsList.count == 0) foreach (MapLandmark in MapLandmarks_PlayerSpawn) G_SpawnsList.add(MapLandmark.Id);

	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[ML::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId) break;
		if (G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	
	SM::Spawn(_Player, _Player.CurrentClan, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);
	declare Removed = G_SpawnsList.remove(SpawnId);
}

// ---------------------------------- //
/** Get new amount of teams
 *
 *	@return		Amount of teams
 */
Integer GetNewNbTeams() {
	if (UseClans) return 2;
	if (S_NbTeams >= 2) return ML::Min(S_NbTeams, C_TeamsNbMax);
	
	// ---------------------------------- //
	// Automatic number of teams
	declare NbTeams = 0;
	foreach (Clan => NbPlayers in C_NbPlayersPerTeam) {
		if (Players.count < NbPlayers) break;
		NbTeams += 1;
	}
	return ML::Clamp(NbTeams, 2, C_TeamsNbMax);
}

// ---------------------------------- //
/** Get the clan of a player.
 *
 *	@param	_Player		The player to get clan.
 *
 *	@return		Clan of the player.
 */
Integer KotH_GetPlayerClan(CSmPlayer _Player) {
	if (_Player == Null) return 0;
	if (UseClans) return _Player.CurrentClan;
	return Clans::GetPlayerClan(_Player);
}

// ---------------------------------- //
/** Set the clan of a player
 *
 *	@param	_Player		The player to set clan
 *	@param	_Clan		The clan to set the player to
 */
Void KotH_SetPlayerClan(CSmPlayer _Player, Integer _Clan) {
	if (_Player == Null) return;
	
	// Set player clan
	declare Clan = ML::Clamp(_Clan, 1, G_NbTeams);
	SetPlayerClan(_Player, 0);
	Clans::SetPlayerClan(_Player, Clan);
	
	// Set player color
	declare ClanColor = Clans::GetClanColor(Clan);
	Interfancy::ForceColor(_Player, ClanColor);
	ST2::SetPlayerColor(_Player, ClanColor);
}

// ---------------------------------- //
/** Get clan number for next player
 *
 *	@return		New clan number
 */
Integer GetNextPlayerClan() {
	declare TeamsNbPlayers = Integer[Integer];
	declare NbPlayersMax = 0;
	
	// ---------------------------------- //
	// Get amount of players in existing teams
	for (I, 1, ML::Max(G_NbTeams, 1)) {
		declare TeamNbPlayers = Clans::GetClanNbPlayers(I);
		TeamsNbPlayers[I] = TeamNbPlayers;
		if (TeamNbPlayers > NbPlayersMax) NbPlayersMax = TeamNbPlayers;
	}
	TeamsNbPlayers = TeamsNbPlayers.sort();
	
	// ---------------------------------- //
	// Return team with least players
	foreach (Clan => NbPlayers in TeamsNbPlayers) if (NbPlayers < NbPlayersMax) return Clan;
	return 1;
}

// ---------------------------------- //
/// Balance the custom teams
Void KotH_AutoBalance() {
	if (UseClans) return;

	// ---------------------------------- //
	// Save player clan before balancing teams
	foreach (Player in Players) {
		declare Integer TeamBeforeBalance for Player;
		TeamBeforeBalance = KotH_GetPlayerClan(Player);
	}
	
	// Reset all teams
	Clans::ResetAllPlayersClans();
	
	// ---------------------------------- //
	// Move players to new clans
	foreach (Player in Players) {
		declare Integer TeamBeforeBalance for Player;
		TeamBeforeBalance = KotH_GetPlayerClan(Player);

		declare NewClan = GetNextPlayerClan();
		if (NewClan == TeamBeforeBalance) continue;
		KotH_SetPlayerClan(Player, NewClan);
		
		// Unspawn players changing clan
		if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) UnspawnPlayer(Player);
	}
}

// ---------------------------------- //
/// Update scores table footer
Void UpdateScoresTableFooter() {
	ST2::SetFooterText(TL::Compose("%1 #"^MB_GetRoundCount()^"\t$<$777///$>\tFirst to reach "^S_RoundsToWin, _("Round")));
}

// ---------------------------------- //
/** Set number of teams on UI
 *
 *	@param	_NbTeams	Amount of teams playing
 */
Void UISetNbTeams(Integer _NbTeams) {
	declare netwrite Integer Net_KotH_NbTeams for Teams[0];
	Net_KotH_NbTeams = _NbTeams;
	
	declare PauseNbTeams = -1;
	if (!UseClans) PauseNbTeams = G_NbTeams;
	PauseMenu::SetCustomTeamsCount(PauseNbTeams);
	Interfancy::SetNbCustomTeams(G_NbTeams);
}

// ---------------------------------- //
/** Set the capturing team on the UI
 *
 *	@param	_Team	Currently capturing team
 */
Void UISetCapturingTeam(Integer _Team) {
	declare netwrite Integer Net_KotH_CapturingTeam for Teams[0];
	Net_KotH_CapturingTeam = _Team;
}

// ---------------------------------- //
/** Set progress of a team on UI
 *
 *	@param	_Team		Team to set progress
 *	@param	_Progress	Progress of the team
 */
Void UISetTeamProgress(Integer _Team, Real _Progress) {
	declare netwrite Real[Integer] Net_KotH_TeamsProgress for Teams[0];
	Net_KotH_TeamsProgress[_Team] = _Progress;
}

// ---------------------------------- //
/** Set color of a team on UI
 *
 *	@param	_Team	Team to set color
 *	@param	_Color	Color of the team
 */
Void UISetTeamColor(Integer _Team, Vec3 _Color) {
	declare netwrite Vec3[Integer] Net_KotH_TeamsColors for Teams[0];
	Net_KotH_TeamsColors[_Team] = _Color;
	
	PauseMenu::SetCustomTeamColor(_Team, _Color);
	Interfancy::SetCustomTeamColor(_Team, _Color);
}

// ---------------------------------- //
// Update the teams amount
Void UpdateTeamsAmount() {
	G_NbTeams = GetNewNbTeams();
	UISetNbTeams(G_NbTeams);
}

// ---------------------------------- //
/** Create manialink for the gauges module
 *
 *	@return		The gauges manialink
 */
Text CreateManialinkGauges() {
	declare TeamsGauges = "";
	for (I, 0, C_TeamsNbMax - 1) TeamsGauges ^= "<frameinstance modelid='FrameModel_PoleGauge' id='Frame_PoleGauge#"^I^"' scale='.875' hidden='1'/>";
	
	declare PlayersIcons = "";
	for (I, 0, 9) PlayersIcons ^= """<quad
		pos="{{{I * 5}}}" size="5 5" halign="center" valign="center" autoscale="0" id="Quad_PlayerIcon#{{{I}}}"
		image="file://Media/Manialinks/ShootMania/Common/DefendersLeft.dds" colorize="000" scale="0"
	/>""";
	
	return """
<manialink version="3" name="KotH:Gauges">
<stylesheet>
	<style class="EscapeMessage" halign="center" valign="center2" textemboss="1" textfont="Eurostile_Bold" textcolor="FFF" />
	<style class="CircGauge" size="16 16" halign="center" valign="center" colorize="FFF" />
</stylesheet>

<framemodel id="FrameModel_PoleGauge">
	<label pos="0 -2.75" class="EscapeMessage" textsize="2" text="0%" id="Label_Ratio" />
	<quad pos="0 1.25" size="6 6" halign="center" valign="center" style="Emblems" substyle="#0" id="Quad_Emblem" />
	<frame size="8 16" halign="left" valign="center">
		<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeL" hidden="1" />
	</frame>
	<frame size="8 16" halign="right" valign="center">
		<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeR" hidden="1" rot="180" />
	</frame>
	<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeBg.png" id="Quad_GaugeBg" />
	<quad
		size="14 14" halign="center" valign="center"
		image="file://Media/Manialinks/Common/disc.dds" colorize="FFF" opacity="0" id="Quad_CaptureAlert"
	/>
</framemodel>

<frame pos="0 75 5">{{{TeamsGauges}}}</frame>

<frame id="Frame_GaugeMessage" pos="0 -54 5">
	<frame id="Frame_GaugeMessageAnim">
		<quad pos="0 8" size="12 12" halign="center" valign="center" id="Quad_CurLandmarkIcon" />
		<label class="EscapeMessage" id="Label_CurLandmarkMessage" />
		<gauge pos="0 -3" size="52 8" halign="center" valign="center" drawbg="0" id="Gauge_CurLandmarkValue" hidden="1" />
	</frame>
</frame>

<frame pos="0 64 5"><frame id="Frame_CapturingPlayers">{{{PlayersIcons}}}</frame></frame>

<script><!--
/**
 *	King of the Hill: Gauges
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_GaugeToGaugeDist	14.
#Const C_GoalIconsPath		"file://Media/Manialinks/ShootMania/Common/"

{{{ManialinkTools::Functions(["SetGaugeRatio", "Brightness"])}}}
{{{Translations::InjectInManialink(["Control point captured!", "Pole blocked by enemy", "Capturing control point..."])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_GaugeMessageAnim		<=> (Page.GetFirstChild("Frame_GaugeMessageAnim") as CMlFrame);
	declare Gauge_CurLandmarkValue		<=> (Page.GetFirstChild("Gauge_CurLandmarkValue") as CMlGauge);
	declare Label_CurLandmarkMessage	<=> (Page.GetFirstChild("Label_CurLandmarkMessage") as CMlLabel);
	declare Quad_CurLandmarkIcon		<=> (Page.GetFirstChild("Quad_CurLandmarkIcon") as CMlQuad);
	declare Frame_CapturingPlayers		<=> (Page.GetFirstChild("Frame_CapturingPlayers") as CMlFrame);

	declare CMlFrame[] Frame_PoleGauges;
	for (I, 0, {{{C_TeamsNbMax - 1}}}) Frame_PoleGauges.add((Page.GetFirstChild("Frame_PoleGauge#"^I) as CMlFrame));
	
	declare CMlQuad[] Quad_PlayersIcons;
	for (I, 0, 9) Quad_PlayersIcons.add((Page.GetFirstChild("Quad_PlayerIcon#"^I) as CMlQuad));
	
	// ---------------------------------- //
	// Netcode
	declare netread Integer Net_KotH_NbTeams for Teams[0];
	declare netread Integer Net_KotH_CapturingTeam for Teams[0];
	declare netread Real[Integer] Net_KotH_TeamsProgress for Teams[0];
	declare netread Vec3[Integer] Net_KotH_TeamsColors for Teams[0];
	
	// ---------------------------------- //
	// Variables
	declare GaugeMessageVisible = False;
	declare CSmMapLandmark CentralGoal;
	
	/// Update
	declare PrevNbTeams = -1;
	declare PrevCapturingTeam = -1;
	declare PrevTeamsProgress = Real[Integer];
	declare PrevTeamsColors = Vec3[Integer];
	declare PrevGaugeMessageVisible = GaugeMessageVisible;
	declare PrevGaugeSpeed = 0;
	
	// ---------------------------------- //
	// Get the central Goal
	foreach (MapLandmark in MapLandmarks_Gauge) if (MapLandmark.Tag == "Goal" && MapLandmark.Order == 0) {
		CentralGoal <=> MapLandmark;
		break;
	}
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		
		// ---------------------------------- //
		// Teams number change
		if (PrevNbTeams != Net_KotH_NbTeams) {
			PrevNbTeams = Net_KotH_NbTeams;
			declare TotalWidth = (Net_KotH_NbTeams - 1) * C_GaugeToGaugeDist;
			
			foreach (Clan => Frame in Frame_PoleGauges) {
				Frame.Visible = Clan + 1 <= Net_KotH_NbTeams;
				Frame.RelativePosition_V3.X = -TotalWidth / 2 + Clan * C_GaugeToGaugeDist;
			}
		}
		
		// ---------------------------------- //
		// Capturing team change
		if (PrevCapturingTeam != Net_KotH_CapturingTeam) {
			PrevCapturingTeam = Net_KotH_CapturingTeam;
			
			if (Frame_PoleGauges.existskey(PrevCapturingTeam - 1)) {
				declare Frame = Frame_PoleGauges[PrevCapturingTeam - 1];
				declare Quad_CaptureAlert <=> (Frame.GetFirstChild("Quad_CaptureAlert") as CMlQuad);
				
				Quad_CaptureAlert.RelativeScale = 1.;
				Quad_CaptureAlert.Opacity = .75;
				AnimMgr.Add(Quad_CaptureAlert, "<quad scale='1.75' opacity=0 />", 1500, CAnimManager::EAnimManagerEasing::CircOut);
			}
			
			declare Color = <.125, .125, .125>;
			if (PrevTeamsColors.existskey(PrevCapturingTeam)) {
				Color = PrevTeamsColors[PrevCapturingTeam];
				if (UseClans) Color = Brightness(Color, 1.5);
			}
			foreach (I => Quad in Quad_PlayersIcons) Quad.Colorize = Color;
		}
		
		// ---------------------------------- //
		// Team color change in custom teams mode
		if (!UseClans) {
			foreach (Clan => Color in Net_KotH_TeamsColors) {
				if (PrevTeamsColors.existskey(Clan) && PrevTeamsColors[Clan] == Color) continue;
				PrevTeamsColors[Clan] = Color;
				
				// ---------------------------------- //
				// Get frame
				if (!Frame_PoleGauges.existskey(Clan - 1)) continue;
				declare Frame = Frame_PoleGauges[Clan - 1];
				
				declare Quad_GaugeBg <=> (Frame.GetFirstChild("Quad_GaugeBg") as CMlQuad);
				declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
				declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
				declare Quad_CaptureAlert <=> (Frame.GetFirstChild("Quad_CaptureAlert") as CMlQuad);
				
				// ---------------------------------- //
				// Set color
				Quad_GaugeBg.Colorize = Color;
				Quad_GaugeL.Colorize = Color;
				Quad_GaugeR.Colorize = Color;
				Quad_CaptureAlert.Colorize = Color;
			}
		}
		// ---------------------------------- //
		// Team color change in default teams mode
		else foreach (I => Team in Teams) {
			declare Clan = I + 1;
			if (PrevTeamsColors.existskey(Clan) && PrevTeamsColors[Clan] == Team.ColorPrimary) continue;
			PrevTeamsColors[Clan] = Team.ColorPrimary;

			// ---------------------------------- //
			// Get frame
			if (!Frame_PoleGauges.existskey(Clan - 1)) continue;
			declare Frame = Frame_PoleGauges[Clan - 1];
			
			declare Quad_GaugeBg <=> (Frame.GetFirstChild("Quad_GaugeBg") as CMlQuad);
			declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
			declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
			declare Quad_CaptureAlert <=> (Frame.GetFirstChild("Quad_CaptureAlert") as CMlQuad);
			
			// ---------------------------------- //
			// Set color
			Quad_GaugeBg.Colorize = Team.ColorPrimary;
			Quad_GaugeL.Colorize = Team.ColorPrimary;
			Quad_GaugeR.Colorize = Team.ColorPrimary;
			Quad_CaptureAlert.Colorize = Team.ColorPrimary;
		}
		
		// ---------------------------------- //
		// Team progress change
		foreach (Clan => Progress in Net_KotH_TeamsProgress) {
			if (PrevTeamsProgress.existskey(Clan) && PrevTeamsProgress[Clan] == Progress) continue;
			PrevTeamsProgress[Clan] = Progress;
			
			// ---------------------------------- //
			// Get frame
			if (!Frame_PoleGauges.existskey(Clan - 1)) continue;
			declare Frame = Frame_PoleGauges[Clan - 1];
			
			declare Quad_GaugeBg <=> (Frame.GetFirstChild("Quad_GaugeBg") as CMlQuad);
			declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
			declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
			declare Label_Ratio <=> (Frame.GetFirstChild("Label_Ratio") as CMlLabel);
			
			// ---------------------------------- //
			// Set ratio
			Quad_GaugeL.RelativeRotation = ML::Clamp(Progress * 360., 0., 180.);
			Quad_GaugeR.RelativeRotation = 180 + ML::Clamp((Progress - .5) * 360., 0., 180.);
			Quad_GaugeL.Visible = Quad_GaugeL.RelativeRotation > 1.5;
			Quad_GaugeR.Visible = Quad_GaugeR.RelativeRotation > 180;
			
			// ---------------------------------- //
			// Set gauge image
			declare Image = "CircGaugeProg.png";
			if (Progress >= 1) Image = "CircGaugeFull.png";
			
			Quad_GaugeL.ImageUrl = "{{{C_ImgBase}}}"^Image;
			Quad_GaugeR.ImageUrl = Quad_GaugeL.ImageUrl;
			Label_Ratio.Value = ML::FloorInteger(Progress * 100)^"%";
		}
		
		// ---------------------------------- //
		// Change gauge message visibility
		GaugeMessageVisible = GUIPlayer != Null && CentralGoal != Null && GUIPlayer.CapturedLandmark == CentralGoal;
		
		if (PrevGaugeMessageVisible != GaugeMessageVisible) {
			PrevGaugeMessageVisible = GaugeMessageVisible;
			
			Gauge_CurLandmarkValue.Visible = GaugeMessageVisible;
			
			declare PositionY = -2.;
			Frame_GaugeMessageAnim.RelativePosition_V3.Y = 0.;
			declare Opacity = 0.;
			Label_CurLandmarkMessage.Opacity = 1.;
			
			if (GaugeMessageVisible) {
				Frame_GaugeMessageAnim.RelativePosition_V3.Y = -PositionY;
				PositionY = 0.;
				Label_CurLandmarkMessage.Opacity = 0.;
				Opacity = 1.;
			}
			
			AnimMgr.Add(Frame_GaugeMessageAnim, "<frame pos='0 "^PositionY^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
			AnimMgr.Add(Label_CurLandmarkMessage, "<label opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
			AnimMgr.Add(Quad_CurLandmarkIcon, "<quad opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
		}
		
		// ---------------------------------- //
		// Gauge message
		if (GaugeMessageVisible) {
			SetGaugeRatio(Gauge_CurLandmarkValue, CentralGoal.Gauge.ValueReal);
			
			// ---------------------------------- //
			// Set gauge color
			if (CentralGoal.Gauge.Clan != 1) Gauge_CurLandmarkValue.Color = <1., 1., 1.>;
			else Gauge_CurLandmarkValue.Color = Teams[0].ColorPrimary;
			
			// ---------------------------------- //
			// Pole has been captured
			if (CentralGoal.Gauge.ValueReal >= 1) {
				Label_CurLandmarkMessage.Value = Translate("Control point captured!");
				Quad_CurLandmarkIcon.ImageUrl = C_GoalIconsPath^"c_goal_captured.dds";
			}
			// ---------------------------------- //
			// Not capturing - enemy is standing on the pole
			else if (CentralGoal.Gauge.Speed <= 0 && CentralGoal.Sector.PlayersIds.count > 1) {
				Label_CurLandmarkMessage.Value = Translate("Pole blocked by enemy");
				Quad_CurLandmarkIcon.ImageUrl = C_GoalIconsPath^"c_goal_lock.dds";
			}
			// ---------------------------------- //
			// Capturing
			else {
				Label_CurLandmarkMessage.Value = Translate("Capturing control point...");
				Quad_CurLandmarkIcon.ImageUrl = C_GoalIconsPath^"c_goal_capture.dds";
			}
		}
		
		// ---------------------------------- //
		// Gauge speed change
		if (CentralGoal != Null && PrevGaugeSpeed != CentralGoal.Sector.PlayersIds.count) {
			PrevGaugeSpeed = CentralGoal.Sector.PlayersIds.count;
			
			// Play sound
			if (PrevGaugeSpeed > 0) Audio.PlaySoundEvent(CAudioManager::ELibSound::ScoreIncrease, 0, -5.);
			
			// Move players icons frame
			declare PosX = -5. * ML::Max(PrevGaugeSpeed - 1, 0) / 2;
			AnimMgr.Add(Frame_CapturingPlayers, "<frame pos='"^PosX^" 0' />", 250, CAnimManager::EAnimManagerEasing::CircOut);
			
			// ---------------------------------- //
			// Animate players icons
			foreach (I => Quad in Quad_PlayersIcons) {
				declare Scale = 0.;
				declare Easing = "EaseInCirc";
				if (I < PrevGaugeSpeed) {
					Scale = 1.;
					Easing = "EaseOutCirc";
				}
				if (Quad.RelativeScale == Scale) continue;
				
				AnimMgr.Add(Quad, "<quad scale='"^Scale^"' />", 250, CAnimManager::EAnimManagerEasing::CircOut);
			}
		}
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the markers module
 *
 *	@return		The markers manialink
 */
Text CreateManialinkMarkers() {
	declare R = 9/16.;

	return """
<manialink version="3" name="KotH:Markers">
<stylesheet>
	<style class="text" halign="center" valign="center2" textsize=".125" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
</stylesheet>

<frame id="Frame_GoalMarker" hidden="1">
	<label pos="0 2.5" class="text" id="Label_MarkerDistance" />
	<label pos="0 .5" class="text" scale="1.5" id="Label_MarkerGoalName" />
	<quad pos="0 3" size="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon" colorize="FFF" />
</frame>

<script><!--
/**
 *	King of the Hill: Markers
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

{{{ManialinkTools::Functions(["Brightness"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_GoalMarker <=> (Page.GetFirstChild("Frame_GoalMarker") as CMlFrame);
	declare Label_MarkerDistance <=> (Page.GetFirstChild("Label_MarkerDistance") as CMlLabel);
	declare Label_MarkerGoalName <=> (Page.GetFirstChild("Label_MarkerGoalName") as CMlLabel);
	declare Quad_MarkerIcon <=> (Page.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
	
	// ---------------------------------- //
	// Netcode
	declare netread Integer Net_KotH_CapturingTeam for Teams[0];
	declare netread Vec3[Integer] Net_KotH_TeamsColors for Teams[0];
	
	// ---------------------------------- //
	// Variables
	declare CSmMapLandmark CentralGoal;
	
	/// Update
	declare PrevCapturingTeam = -1;
	
	// ---------------------------------- //
	// Get the central Goal
	foreach (MapLandmark in MapLandmarks_Gauge) if (MapLandmark.Tag == "Goal" && MapLandmark.Order == 0) {
		CentralGoal <=> MapLandmark;
		break;
	}
	
	// Reset markers
	Frame_GoalMarker.Show();
	Label_MarkerGoalName.Value = TL::GetTranslatedText(TL::Compose("$n$t%1", _("Target")));
	declare Pos = CentralGoal.Position.X^" "^CentralGoal.Position.Y + 25^" "^CentralGoal.Position.Z;
	ClientUI.MarkersXML = "<marker manialinkframeid='Frame_GoalMarker' pos='"^Pos^"' visibility='WhenInFrustum' minimapvisibility='Never'/>";
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		
		// ---------------------------------- //
		// Capturing team change
		if (PrevCapturingTeam != Net_KotH_CapturingTeam) {
			PrevCapturingTeam = Net_KotH_CapturingTeam;
			
			// ---------------------------------- //
			// Set the marker color
			declare Color = <.75, .75, .75>;
			if (UseClans) {
				switch (PrevCapturingTeam) {
					case 1 : Color = Brightness(Teams[0].ColorPrimary, 1.5);
					case 2 : Color = Brightness(Teams[1].ColorPrimary, 1.5);
				}
			}
			else if (Net_KotH_TeamsColors.existskey(PrevCapturingTeam)) Color = Net_KotH_TeamsColors[PrevCapturingTeam];
			Label_MarkerGoalName.TextColor = Brightness(Color, 2.);
			Quad_MarkerIcon.Colorize = Color;
		}
		
		// ---------------------------------- //
		// Show the distance to a Goal
		Label_MarkerDistance.Visible = CentralGoal != Null && GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.>;
		if (Label_MarkerDistance.Visible)
			Label_MarkerDistance.Value = "$n"^ML::FloorInteger(ML::Distance(GUIPlayer.Position, CentralGoal.Position))^" M";
	}
}
--></script>
</manialink>""";
}