// -------------------------------------- //
//  HUNGER GAMES 3.0 by domino54          //
//  script version: 2016-12-05            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes "HungerGamesV2Arena"
#Const Version		"2016-12-05"
#Const ScriptName	"HungerGames.Script.txt"

#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_OffZoneActivationTime	360		as _("OffZone activation time (0 = don't activate)")
#Setting S_OffZoneShrinkDuration	180		as _("OffZone shrink duration (min. 60)")
#Setting S_ObjectsSpawnRatio		-1.		as _("Objects spawning ratio (-1 = auto)")
#Setting S_NewcomersJoinTime		240		as _("Time for new players to join the game after it starts")
#Setting S_ObjectsDroppingRatio		.5		as _("Objects drop ratio from eliminated players")
#Setting S_RandomizeObjectsSpawns	True	as _("Randomize objects locations on the map (except Armor)")
#Setting S_ArmorRespawnTime			180		as _("Armor and Replie respawn duration (0 = don't respawn)")

/// Overwrite existing settings
#Setting S_AutoManageAFK		False
#Setting S_PlayerArmorPoints	5
#Setting S_MaximumNbWeapons		3
#Setting S_MaximumNbReplies		5
#Setting S_ObjectsRespawnTime	300
#Setting S_ToadsRespawnTime		240
#Setting S_ToadsSpawnRatio		1.

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_ModeSupportedObjects ["Weapon", "Charge", "Mini", "Replie", "Armor", "Fuel"]
#Const C_RequiredPlayersNb			2		///< Minimum number of players required to start the game
#Const C_StartCountdownDuration		10000	///< Duration of the cinematic countdown before game start
#Const C_OffZoneMinShrinkDuration	60		///< Minimum Tornado shrinking duration
#Const C_OffZoneMinimumRadius		36.		///< Minimum radius Tornado is shrinking to
#Const C_AutoRatioItemsPerPlayer	20		///< Amount of items spawned per player with automatic ratio on
#Const C_PlayerMaxNbRocketSlots		4		///< Maximum amount of Rockets held by the player
#Const C_PlayerPointsForSurvival	10		///< Points given for surviving other player elimination
#Const C_PlayerPointsForObjects		1		///< Points given for picking up Weapon, Charge and Mini
#Const C_WinnerMinPointsDiff		10		///< Minimum difference in amount of winner points to next player
#Const C_WeaponItemArmorBonus		100		///< Armor healed when picking up Weapon item
#Const C_ChargeItemSkillPoints		5		///< Additional skill points given by the Charge item
#Const C_MiniItemBonusMultiplier	2		///< Mini item multiplier of regular Charge bonus
#Const C_MiniItemArmorTakenOnPick	100		///< Amont of player armor removed on picking up Mini
#Const C_ObjectsDropSpreadRadius	1.		///< Maximum distance items can be spawned from player upon elimination
#Const C_ToadObjectDropChance		.25		///< Chance for a Toad to drop Charge
#Const C_ToadChanceForArmorDrop		.25		///< Chance that item dropped by Toad will be Armor
#Const C_GateOpeningDuration		5000	///< Required standing time for a Gate to open
#Const C_GateAutoCloseDelay			7500	///< Time after which the Gate closes again

/// Amount of weapons players get for touching the pole
#Const C_PlayerInitialWeapons [
	CSmMode::EWeapon::Laser => 0,
	CSmMode::EWeapon::Nucleus => 0,
	CSmMode::EWeapon::Arrow => 0,
	CSmMode::EWeapon::Rocket => 4
]

/// Players skills settings
#Const C_SkillsPointsStart	["AmmoGain" => 0, "StaminaGain" => 0, "StaminaMax" => 75]
#Const C_SkillsPointsOnGoal	["AmmoGain" => 50, "StaminaGain" => 20]
#Const C_SkillsPointsLimit	["AmmoGain" => 500, "StaminaGain" => 100, "StaminaMax" => 300]

/// Position of the scores table depending on the statistics visibility
#Const C_ScoresTablePosition [False => <0., 40., 20.>, True => <0., 47., 20.>]

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare Ident[Text] G_ObjectId;
declare Ident[] G_SpawnsList;
declare Ident G_LatestSpawnId;
declare Vec3 G_CenterGoalPosition;

declare Boolean G_IsOffZoneActivated;
declare Text[] G_SpawnedPlayers;

// ---------------------------------- //
// Scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("Survival", "Sv", 2.25, 75.);
ST2::SetColWidth("LibST_SMPoints", 5.);
ST2::DestroyCol("LibST_SMRoundPoints");
***

// ---------------------------------- //
// Init server
// ---------------------------------- //
***InitServer***
***
// ---------------------------------- //
// Disable unused Galaxy base script features
GT_UseAutoEndSequence = False;
GT_UseAutospawnObjects = False;
GT_UseComboWeapons = False;
GT_AutoManageOnRespawn = False;
GT_AutoManageOnObjectTouch = False;
GT_AllowMatchmakingMode = False;

GT_LogScriptsVersions = [
	ScriptName => Version,
	Map::GetScriptName() => Map::GetScriptVersion()
];

// ---------------------------------- //
// Load objects
G_ObjectId["Weapon"]	= ItemList_Add("HungerGames\\Weapon.Item.Gbx");
G_ObjectId["Charge"]	= ItemList_Add("HungerGames\\Charge.Item.Gbx");
G_ObjectId["Mini"]		= ItemList_Add("HungerGames\\Mini.Item.Gbx");
G_ObjectId["Replie"]	= ItemList_Add("HungerGames\\Replie.Item.Gbx");
G_ObjectId["Armor"]		= ItemList_Add("SMCommon\\Pickups\\Armor.Item.Gbx");
G_ObjectId["Fuel"]		= ItemList_Add("SMCommon\\Collectibles\\Fuel.Item.gbx");

// ---------------------------------- //
// Create custom interfaces
MB_NeutralEmblemUrl = C_ImgBase^"EmblemHungerGames.dds";
Layers::Create("HungerGames:Interface", CreateManialinkInterface());
Layers::Attach("HungerGames:Interface");
Layers::Create("HungerGames:Statistics", CreateManialinkStatistics());
Layers::SetType("HungerGames:Statistics", CUILayer::EUILayerType::ScoresTable);

// Variables
declare PrevTimeLimit = S_OffZoneActivationTime;
declare PrevPlayersNbAlive = PlayersNbAlive;
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***StartMap***
***
ST2::SetFooterText(TL::Compose("%1-", _("Remaining players: ")));
UIResetPlayersTouchingGoal();
UISetStartTime(-1);

// ---------------------------------- //
// Init OffZone
declare OffZoneRadiusMax = 0.;
OffZoneRadiusSpeed = 0.;
OffZoneRadius = 0.;

// ---------------------------------- //
// Get the central goal landmark id
declare CenterGoalLandmarkId = NullId;
declare CenterGoal <=> Map::GetLandmarkSector("Goal", 0);
if (CenterGoal != Null) UIManager.UIAll.SpectatorAutoTarget = CenterGoal.Id;

// ---------------------------------- //
// Skip map if not valid
if (MapLandmarks_PlayerSpawn.count <= 0 || CenterGoal == Null) {
	Translations::SendChat("This map is not valid, moving to the next one.");
	MB_StopMap = True;
	MB_Sleep(5000);
}
***

// ---------------------------------- //
// Initialize the map objects
// ---------------------------------- //
***InitializeObjects***
***
// ---------------------------------- //
// Reset objects landmarks
foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	declare Boolean ObjectSpawned for MapLandmark;
	declare Integer ObjectNextSpawn for MapLandmark;
	declare Text ObjectType for MapLandmark;
	ObjectSpawned = False;
	ObjectNextSpawn = -1;
	ObjectType = "";
}

// ---------------------------------- //
// Check how many objects are on map
declare NbObjectsSpawnLandmarks = Integer[Text];
declare TotalNbObjectsSpawns = 0;

foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	if (!C_ModeSupportedObjects.exists(MapLandmark.Tag)) continue;
	if (!NbObjectsSpawnLandmarks.existskey(MapLandmark.Tag)) NbObjectsSpawnLandmarks[MapLandmark.Tag] = 0;
	NbObjectsSpawnLandmarks[MapLandmark.Tag] += 1;
	TotalNbObjectsSpawns += 1;
}

// ---------------------------------- //
// Get the target objects amount ratio
declare ObjectsSpawnRatio = ML::Clamp(S_ObjectsSpawnRatio, 0., 1.);
if (S_ObjectsSpawnRatio < 0) {
	declare TargetObjectsAmount = C_AutoRatioItemsPerPlayer * Players.count;
	ObjectsSpawnRatio = ML::Min(ML::ToReal(TargetObjectsAmount) / TotalNbObjectsSpawns, 1.);
}

// ---------------------------------- //
// Get target amount of every object to spawn
declare AvailableObjectsTags = C_ModeSupportedObjects;
declare CurrentObjectTag = AvailableObjectsTags[0];
declare NbObjectsToSpawn = Integer[Text];
declare TotalNbObjectsToSpawn = 0;

while (TotalNbObjectsToSpawn < TotalNbObjectsSpawns * ObjectsSpawnRatio) {
	if (TotalNbObjectsSpawns <= 0) break;
	
	// Initialize tag in array if doesn't exist
	if (!NbObjectsToSpawn.existskey(CurrentObjectTag)) NbObjectsToSpawn[CurrentObjectTag] = 0;
	
	// Go to the next item type if there is enough of current one
	if (NbObjectsToSpawn[CurrentObjectTag] >= NbObjectsSpawnLandmarks[CurrentObjectTag] * ObjectsSpawnRatio) {
		declare Removed = AvailableObjectsTags.remove(CurrentObjectTag);
		if (AvailableObjectsTags.count <= 0) break;
		
		CurrentObjectTag = AvailableObjectsTags[0];
		continue;
	}
	
	// Increase the amount of object
	NbObjectsToSpawn[CurrentObjectTag] += 1;
	TotalNbObjectsToSpawn += 1;
}

// ---------------------------------- //
// Create list of available object landmarks per item type
declare Ident[] AvailableLandmarksIds;
declare CSmMapLandmark[][Text] AvailableLandmarksOfType;

foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
	if (!AvailableLandmarksOfType.existskey(MapLandmark.Tag)) AvailableLandmarksOfType[MapLandmark.Tag] = CSmMapLandmark[];
	AvailableLandmarksOfType[MapLandmark.Tag].add(MapLandmark);
	if (MapLandmark.Tag != "Armor") AvailableLandmarksIds.add(MapLandmark.Id);
}

// ---------------------------------- //
// Choose random landmarks spawning Armor and other items, if not randomized
foreach (Type => ObjectAmount in NbObjectsToSpawn) {
	if (!AvailableLandmarksOfType.existskey(Type)) continue;
	if (S_RandomizeObjectsSpawns && Type != "Armor") continue;
	declare CurObjectSelectedLandmarks = 0;
	
	while (CurObjectSelectedLandmarks < ObjectAmount) {
		if (AvailableLandmarksOfType[Type].count <= 0) break;
		
		declare MapLandmark <=> AvailableLandmarksOfType[Type][ML::Rand(0, AvailableLandmarksOfType[Type].count - 1)];
		declare Removed = AvailableLandmarksOfType[Type].remove(MapLandmark);
		CurObjectSelectedLandmarks += 1;
		
		if (MapLandmark != Null) {
			declare Text ObjectType for MapLandmark;
			ObjectType = Type;
		}
	}
}

// ---------------------------------- //
// Choose randomized positions for items other than Armor, if enabled
if (S_RandomizeObjectsSpawns) foreach (Type => ObjectAmount in NbObjectsToSpawn) {
	if (Type == "Armor") continue;
	declare CurObjectSelectedLandmarks = 0;
	
	while (CurObjectSelectedLandmarks < ObjectAmount) {
		if (AvailableLandmarksIds.count <= 0) break;
		
		declare MapLandmarkId = AvailableLandmarksIds[ML::Rand(0, AvailableLandmarksIds.count - 1)];
		declare Removed = AvailableLandmarksIds.remove(MapLandmarkId);
		CurObjectSelectedLandmarks += 1;
		
		if (MapLandmarks.existskey(MapLandmarkId)) {
			declare MapLandmark <=> MapLandmarks[MapLandmarkId];
			declare Text ObjectType for MapLandmark;
			ObjectType = Type;
		}
	}
}
***

// ---------------------------------- //
// Round start
// ---------------------------------- //
***StartRound***
***
UIManager.UIAll.UISequence = CUIConfig::EUISequence::None;
GalaxyTitles::SetFuelGivingBoost(False);
Interfancy::SetModuleVisibility("Countdown", False);
UISetNbPlayersAlive(0);
MiniMap::Hide();

G_IsOffZoneActivated = False;
G_SpawnedPlayers.clear();

// ---------------------------------- //
// Initialize the central Goal
if (CenterGoal != Null) {
	CenterGoalLandmarkId = CenterGoal.Id;
	CenterGoal.Gauge.ValueReal = 1.;
	CenterGoal.Gauge.Captured = True;
	G_CenterGoalPosition = CenterGoal.Position;
}

// ---------------------------------- //
// Get landmarks distances to the central Goal
foreach (MapLandmark in MapLandmarks) {
	if (MapLandmark.Id == CenterGoalLandmarkId) continue;
	declare Real CenterGoalDistance for MapLandmark;
	CenterGoalDistance = GT_Distance2D(MapLandmark.Position, G_CenterGoalPosition);
}

// ---------------------------------- //
// Configure Gate landmarks
foreach (MapLandmark in MapLandmarks_Gate) {
	MapLandmark.Gate.AutoOpenSpeed = 1;
	MapLandmark.Gate.AutoCloseDelay = C_GateAutoCloseDelay;
	MapLandmark.Gate.Clan = 1;
	MapLandmark.Gauge.Max = C_GateOpeningDuration;
}

// ---------------------------------- //
// Wait for enough players to start the game
UIManager.UIAll.BigMessage = _("Waiting for players...");
while (!ServerShutdownRequested && !MatchEndRequested && (Players.count < C_RequiredPlayersNb || CupAdmin::IsCupPaused())) MB_Yield();
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Initialize objects
---InitializeObjects---

// ---------------------------------- //
// Begin match
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
StartTime = Now + C_StartCountdownDuration + 1000;
UISetStartTime(StartTime);

// Set the Tornado activation countdown
if (S_OffZoneActivationTime <= 0) UIManager.UIAll.CountdownEndTime = -1;
else UIManager.UIAll.CountdownEndTime = StartTime + S_OffZoneActivationTime * 1000;

// ---------------------------------- //
// Spawn players for the game
foreach (Player in Players) HG_SpawnPlayer(Player);
PrevPlayersNbAlive = PlayersNbAlive;
UISetNbPlayersAlive(PlayersNbAlive);

// Setup interface
Layers::Attach("HungerGames:Statistics");
ST2::SetFooterText(TL::Compose("%1"^PlayersNbAlive, _("Remaining players: ")));
ST2::SetPos(C_ScoresTablePosition[True]);
ST2::Build("SM");
***

// ---------------------------------- //
// On armor empty
// ---------------------------------- //
***OnArmorEmpty***
***
// ---------------------------------- //
// Notify everyone about player elimination
if (!Event.Victim.IsBot && PlayersNbAlive > 2) {
	Message::SendStatusMessage(TL::Compose(_("$<%1$> is eliminated!"), Event.Victim.Name), 4000, 1);
	DropPlayerObjects(Event.Victim, S_ObjectsDroppingRatio);
}

// ---------------------------------- //
// Chance for Toads to drop an item
if (Event.Victim.IsBot && Event.Shooter != Null && C_ToadObjectDropChance > 0 && ML::Rand(0., 1.) <= C_ToadObjectDropChance) {
	declare NewObjectTag = "Charge";
	
	// Small chance for item to be Armor
	if (Event.Shooter.Armor < Event.Shooter.ArmorMax && ML::Rand(0., 1.) <= C_ToadChanceForArmorDrop) NewObjectTag = "Armor";
	
	declare Object = SpawnObject(Event.Victim.Position, NewObjectTag);
}
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);

// Ignore all events caused by bots and players who haven't touched the goal
declare Boolean PlayerHasWeapon for Event.Player;
if (Event.Player.IsBot || !PlayerHasWeapon) continue;

// Cache Tag and AnchorId, as it gets destroyed with object
declare Ident AnchorId for Event.Object;
declare Text Tag for Event.Object;
declare ObjectAnchorId = AnchorId;
declare ObjectTag = Tag;

// Pick up the object
declare PickedUpObject = GalaxyTitles::PickUpObject(Event, True);
if (!PickedUpObject) PickedUpObject = PickUpObject(Event);

// ---------------------------------- //
// Start item respawn timer
if (PickedUpObject && MapLandmarks_ObjectAnchor.existskey(ObjectAnchorId)) {
	declare MapLandmark <=> MapLandmarks_ObjectAnchor[ObjectAnchorId];
	declare Boolean ObjectSpawned for MapLandmark;
	declare Integer ObjectNextSpawn for MapLandmark;
	
	declare FasterRespawnObjects = ["Armor", "Fuel", "Replie"];
	declare RespawnDuration = S_ObjectsRespawnTime;
	if (FasterRespawnObjects.exists(ObjectTag)) RespawnDuration = S_ArmorRespawnTime;
	
	ObjectSpawned = RespawnDuration <= 0;
	ObjectNextSpawn = Now + RespawnDuration * 1000;
}
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***PlayLoop***
***
SpawnObjects();

// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// Player touching goal
	if (Event.Type == CSmModeEvent::EType::OnPlayerTriggersSector) {
		declare LandmarkId = NullId;
		foreach (MapLandmark in MapLandmarks_Sector) if (MapLandmark.Sector == Event.Sector) LandmarkId = MapLandmark.Id;
		if (LandmarkId != CenterGoalLandmarkId) continue;
		
		declare Boolean PlayerHasWeapon for Event.Player;
		if (PlayerHasWeapon) continue;
		PlayerHasWeapon = True;
		
		// Set the player skills
		foreach (SkillType => SkillPoints in C_SkillsPointsOnGoal)
			SetPlayerSkill(Event.Player, SkillType, SkillPoints);
		
		// Set player weapons
		foreach (Weapon => Amount in C_PlayerInitialWeapons) Inventory::SetWeaponSlots(Event.Player, Weapon, Amount);
		UIAddPlayerTouchingGoal(Event.Player.User.Login);
	}
	// ---------------------------------- //
	// On player request respawn
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRequestRespawn) {
		Translations::SendChat(Event.Player, "Respawn is not allowed in Hunger Games.");
		Discard(Event);
	}
}

// ---------------------------------- //
// Disable cinematic stripes and show minimap
if (StartTime - Now <= 1500 && UIManager.UIAll.UISequence != CUIConfig::EUISequence::Playing) {
	Interfancy::SetModuleVisibility("Countdown", Now < UIManager.UIAll.CountdownEndTime);
	UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
	UIManager.UIAll.SpectatorAutoTarget = NullId;
	MiniMap::Show();
}

// ---------------------------------- //
// Tornado is not active yet
if (!G_IsOffZoneActivated) {
	// ---------------------------------- //
	// Update current Tornado activation time limit
	if (PrevTimeLimit != S_OffZoneActivationTime) {
		PrevTimeLimit = S_OffZoneActivationTime;
		
		if (S_OffZoneActivationTime <= 0) UIManager.UIAll.CountdownEndTime = -1;
		else UIManager.UIAll.CountdownEndTime = StartTime + (S_OffZoneActivationTime * 1000);
		Interfancy::SetModuleVisibility("Countdown", Now < UIManager.UIAll.CountdownEndTime);
	}
	
	// ---------------------------------- //
	// Start the Tornado
	if (Now > StartTime && S_OffZoneActivationTime > 0 && (PlayersNbAlive <= 2 || Now >= UIManager.UIAll.CountdownEndTime)) {
		G_IsOffZoneActivated = True;
		UIManager.UIAll.CountdownEndTime = -1;
		
		// ---------------------------------- //
		// Compute the initial OffZone radius
		declare MapCorners = [<0., 0., 0.>, <384., 0., 0.>, <0., 0., 384.>, <384., 0., 384.>];
		foreach (CornerPosition in MapCorners) {
			declare Distance = GT_Distance2D(G_CenterGoalPosition, CornerPosition);
			if (Distance > OffZoneRadiusMax) OffZoneRadiusMax = Distance;
		}
		
		// ---------------------------------- //
		// Start the OffZone
		declare OffZoneShrinkDuration = ML::Max(S_OffZoneShrinkDuration, C_OffZoneMinShrinkDuration);
		OffZoneCenterLandmarkId = CenterGoalLandmarkId;
		OffZoneRadiusSpeed = (OffZoneRadiusMax - C_OffZoneMinimumRadius) / OffZoneShrinkDuration;
		OffZoneRadius = OffZoneRadiusMax;
		
		// ---------------------------------- //
		// Start decreasing the pole gauge
		CenterGoal.Gauge.Max = OffZoneShrinkDuration * 1000;
		CenterGoal.Gauge.Value = CenterGoal.Gauge.Max;
		CenterGoal.Gauge.Speed = -1;
		
		// Send notice
		Message::SendStatusMessage(_("Tornado activated."), 4000, 0, CUIConfig::EUISound::Notice, 0);
		Interfancy::SetModuleVisibility("Countdown", False);
	}
}
// ---------------------------------- //
// Tornado is active
else if (OffZoneRadius > 0) {
	// ---------------------------------- //
	// Stop the Tornado
	if (OffZoneRadius <= C_OffZoneMinimumRadius) {
		OffZoneRadius = C_OffZoneMinimumRadius;
		OffZoneRadiusSpeed = 0.;
		CenterGoal.Gauge.ValueReal = 0.;
	}
	
	// ---------------------------------- //
	// Destroy objects behind Tornado
	declare Ident[] ObjectsToDestroy;
	foreach (Object in Objects) {
		declare Real CenterGoalDistance for Object;
		if (CenterGoalDistance >= OffZoneRadius && !ObjectsToDestroy.exists(Object.Id)) ObjectsToDestroy.add(Object.Id);
	}
	while (ObjectsToDestroy.count > 0) {
		declare Boolean Removed;
		Removed = DestroyObject(Objects[ObjectsToDestroy[0]]);
		Removed = ObjectsToDestroy.removekey(0);
	}

	// ---------------------------------- //
	// Manage landmarks
	foreach (MapLandmark in MapLandmarks) {
		if (MapLandmark.Id == CenterGoalLandmarkId) continue;
		declare Real CenterGoalDistance for MapLandmark;
		if (CenterGoalDistance <= 0) continue;

		// ---------------------------------- //
		// Turn off Bases behind the Tornado
		if (MapLandmark.Base != Null && MapLandmark.Base.IsActive && CenterGoalDistance >= OffZoneRadius)
			MapLandmark.Base.IsActive = False;
		
		// ---------------------------------- //
		// Make the Gates open as fast as close the Tornado is
		if (MapLandmark.Gate != Null && MapLandmark.Gate.Automatic) {
			// ---------------------------------- //
			// Open the Gate when behind the Tornado
			if (CenterGoalDistance >= OffZoneRadius) {
				MapLandmark.Gate.Automatic = False;
				MapLandmark.Gate.ManualClosed = False;
				MapLandmark.Gauge.ValueReal = 0.;
			}
			// ---------------------------------- //
			// Compute the Gate opening duration
			else {
				declare TornadoDistance = OffZoneRadius - CenterGoalDistance;
				declare TornadoDistanceMax = OffZoneRadiusMax - CenterGoalDistance;
				MapLandmark.Gauge.Max = ML::FloorInteger(C_GateOpeningDuration * TornadoDistance / TornadoDistanceMax);
			}
		}
	}
}

// ---------------------------------- //
// Manage players functions
foreach (Player in Players) {
	// ---------------------------------- //
	// A new player joins the game after start
	if (!G_SpawnedPlayers.exists(Player.User.Login)) {
		if (!G_IsOffZoneActivated && S_NewcomersJoinTime > 0 && Now - StartTime <= S_NewcomersJoinTime * 1000) {
			HG_SpawnPlayer(Player);
			Killfeed::SendNotice(["$<%1$> is now playing in Games", Player.User.Name]);
		}
		else {
			G_SpawnedPlayers.add(Player.Login);
			Translations::SendChat(Player, "You came too late to join this match. Please wait for the next map. Good luck!");
		}
	}

	// ---------------------------------- //
	// Unspawn players trying to escape arena
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
		declare IsOutsideArena = False;
		for (I, 0, 2) if (I != 1 && (Player.Position[I] < 0 || Player.Position[I] > 384)) IsOutsideArena = True;
		if (Player.Position.Y < -50) IsOutsideArena = True;

		// ---------------------------------- //
		// Eliminate player
		if (IsOutsideArena) {
			UnspawnPlayer(Player);

			// Notify everyone about elimination and drop player objects
			if (PlayersNbAlive >= 2) {
				Translations::SendStatusMessage(["$<%1$> tried to escape arena", Player.User.Name], 4000, 1);
				DropPlayerObjects(Player, S_ObjectsDroppingRatio);
			}
		}
	}
}

// ---------------------------------- //
// Update amount of players alive
if (PrevPlayersNbAlive != PlayersNbAlive) {
	ST2::SetFooterText(TL::Compose("%1"^PlayersNbAlive, _("Remaining players: ")));
	UISetNbPlayersAlive(PlayersNbAlive);
	
	// ---------------------------------- //
	// Give survival points to all players alive
	if (PrevPlayersNbAlive < PlayersNbAlive) foreach (Player in Players) {
		if (Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned) continue;
		TopScores::AddPoints(Player.Score, "Survival", 1);
		Score::AddPoints(Player, C_PlayerPointsForSurvival);
	}

	// ---------------------------------- //
	// Play the victory sound
	if (PlayersNbAlive == 1) UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::Default,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::VictoryPoint, 0
	);

	PrevPlayersNbAlive = PlayersNbAlive;
}

// ---------------------------------- //
// Turn round points into actual total points
foreach (Score in Scores) {
	if (Score.RoundPoints == 0) continue;
	Score.Points += Score.RoundPoints;
	Score.RoundPoints = 0;
}

// Victory conditions
if (PlayersNbAlive <= 1) MB_StopMap = True;
***

// ---------------------------------- //
// Map end
// ---------------------------------- //
***EndMap***
***
Interfancy::SetModuleVisibility("Countdown", False);
UISetNbPlayersAlive(0);
UISetStartTime(-1);

OffZoneRadiusSpeed = 0.;
OffZoneRadius = 0.;
CenterGoal.Gauge.Speed = 0;

// ---------------------------------- //
// Set the map winner
declare WinnerId = NullId;
foreach (Player in Players) if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::Spawned) {
	if (Scores.existskey(1)) Player.Score.Points = ML::Max(Scores[0].Points + C_WinnerMinPointsDiff, Player.Score.Points);
	WinnerId = Player.Id;
	break;
}

MB_Sleep(3000);

// ---------------------------------- //
// Revert the interface
Layers::Detach("HungerGames:Statistics");
ST2::SetPos(C_ScoresTablePosition[False]);
ST2::Build("SM");

declare Text WinnerName;
if (Scores.existskey(0)) WinnerName = Scores[0].User.Name;

// ---------------------------------- //
// Display the round winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;
UIManager.UIAll.BigMessageSound = CUIConfig::EUISound::EndRound;
UIManager.UIAll.BigMessageSoundVariant = 0;

if (WinnerName == "") UIManager.UIAll.BigMessage = _("|Match|Draw");
else UIManager.UIAll.BigMessage = TL::Compose(_("$<%1$> wins the match!"), WinnerName);

MB_Sleep(6000);

// ---------------------------------- //
// Podium
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Podium;
while(!UIManager.UIAll.UISequenceIsCompleted) MB_Yield();

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***EndServer***
***
Layers::Detach("HungerGames:Interface");
Layers::Destroy("HungerGames:Interface");
Layers::Destroy("HungerGames:Statistics");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Update skills of a player
 *
 *	@param	_Player		The player to update
 */
Void UpdatePlayerSkills(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare Integer[Text] PlayerSkillPoints for _Player;
	
	// ---------------------------------- //
	// Limit skill points
	foreach (SkillType => SkillPoints in C_SkillsPointsLimit) {
		if (!PlayerSkillPoints.existskey(SkillType)) continue;
		PlayerSkillPoints[SkillType] = ML::Min(PlayerSkillPoints[SkillType], SkillPoints);
	}
	
	// ---------------------------------- //
	// Apply skill points to the player parameters
	foreach (SkillType => SkillPoints in PlayerSkillPoints) switch (SkillType) {
		case "AmmoGain"		: _Player.AmmoGain		= ML::Clamp(SkillPoints / 100., 0., 10.);
		case "StaminaGain"	: _Player.StaminaGain	= ML::Clamp(SkillPoints / 100., 0., 1.);
		case "StaminaMax"	: _Player.StaminaMax	= ML::Clamp(SkillPoints / 100., .1, 3.);
	}
}

// ---------------------------------- //
/** Set specific skill points of a player
 *
 *	@param	_Player			The player to set skill points
 *	@param	_SkillType		Type of the skill to set
 *	@param	_SkillPoints	Amount of the skill points to set
 */
Void SetPlayerSkill(CSmPlayer _Player, Text _SkillType, Integer _SkillPoints) {
	if (_Player == Null || _SkillType == "") return;
	
	declare Integer[Text] PlayerSkillPoints for _Player;
	PlayerSkillPoints[_SkillType] = ML::Max(0, _SkillPoints);
	
	UpdatePlayerSkills(_Player);
}

// ---------------------------------- //
/** Add specific skill points for a player
 *
 *	@param	_Player			The player to add skill points
 *	@param	_SkillType		Type of the skill to add
 *	@param	_SkillPoints	Amount of the skill points to add
 */
Void AddPlayerSkill(CSmPlayer _Player, Text _SkillType, Integer _SkillPoints) {
	if (_Player == Null || _SkillType == "") return;
	
	declare Integer[Text] PlayerSkillPoints for _Player;
	if (!PlayerSkillPoints.existskey(_SkillType)) PlayerSkillPoints[_SkillType] = 0;
	PlayerSkillPoints[_SkillType] += ML::Max(0, _SkillPoints);
	
	UpdatePlayerSkills(_Player);
}

// ---------------------------------- //
/** Initialize and spawn a player
 *
 *	@param	_Player		A Player to spawn
 */
Void HG_SpawnPlayer(CSmPlayer _Player) {
	if (_Player == Null || _Player.User == Null || G_SpawnedPlayers.exists(_Player.User.Login)) return;
	
	// ---------------------------------- //
	// Initialize through mode base and enable all weapon slots
	GT_InitPlayer(_Player);
	Inventory::SetAvailableWeapons(_Player, [
		CSmMode::EWeapon::Laser, CSmMode::EWeapon::Nucleus, CSmMode::EWeapon::Arrow, CSmMode::EWeapon::Rocket
	]);
	Inventory::SetFirstWeapon(_Player);
	
	// ---------------------------------- //
	// Reset variables
	declare Boolean PlayerHasWeapon for _Player;
	declare Text[] ObjectsToDrop for _Player;
	
	PlayerHasWeapon = False;
	ObjectsToDrop.clear();
	
	// Initialize player skills
	foreach (SkillType => SkillPoints in C_SkillsPointsStart)
		SetPlayerSkill(_Player, SkillType, SkillPoints);
	
	// ---------------------------------- //
	// Melee spawn selection method
	if (G_SpawnsList.count == 0) foreach (MapLandmark in MapLandmarks_PlayerSpawn) G_SpawnsList.add(MapLandmark.Id);
	declare SpawnId = NullId;
	while (True) {
		SpawnId = G_SpawnsList[ML::Rand(0, G_SpawnsList.count - 1)];
		if (SpawnId != G_LatestSpawnId) break;
		if (G_SpawnsList.count == 1) break;
	}
	G_LatestSpawnId = SpawnId;
	declare Removed = G_SpawnsList.remove(SpawnId);
	
	// ---------------------------------- //
	// Spawn the player
	SM::SpawnPlayer(_Player, 0, MapLandmarks_PlayerSpawn[SpawnId].PlayerSpawn);
	G_SpawnedPlayers.add(_Player.Login);
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *	@param	_AnchorId	Id of the map landmark object is spawned on
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag, Ident _AnchorId) {
	if (_Position == <0., 0., 0.> || !C_ModeSupportedObjects.exists(_ObjectTag)) return Null;

	// Check if the given id belongs to a real object anchor landmark
	declare AnchorId = NullId;
	if (MapLandmarks_ObjectAnchor.existskey(_AnchorId)) AnchorId = _AnchorId;
	
	// Object may belong to the GalaxyTitles library
	declare Object = GalaxyTitles::SpawnObject(_Position, _ObjectTag);
	
	// ---------------------------------- //
	// Create the object
	if (Object == Null) {
		switch (_ObjectTag) {
			case "Weapon"	: Object = ObjectCreate(G_ObjectId["Weapon"]);
			case "Charge"	: Object = ObjectCreate(G_ObjectId["Charge"]);
			case "Mini"		: Object = ObjectCreate(G_ObjectId["Mini"]);
		}
		if (Object == Null) return Null;
		
		// Spawn object
		Object.SetPosition(_Position);
	}

	// ---------------------------------- //
	// Set object properties
	declare Ident AnchorId as ObjectAnchorId for Object;
	declare Text Tag for Object;
	ObjectAnchorId = AnchorId;
	Tag = _ObjectTag;
	
	// ---------------------------------- //
	// Save central Goal distance in the object
	declare Real CenterGoalDistance for Object;
	CenterGoalDistance = GT_Distance2D(Object.Position, G_CenterGoalPosition);
	
	return Object;
}

// ---------------------------------- //
/** Spawn an object
 *
 *	@param	_Position	The position the object will be created at
 *	@param	_ObjectTag	Type of the object to create
 *
 *	@return		The created object
 */
CSmObject SpawnObject(Vec3 _Position, Text _ObjectTag) { return SpawnObject(_Position, _ObjectTag, NullId); }

// ---------------------------------- //
/// Spawn objects on landmarks
Void SpawnObjects() {
	foreach (MapLandmark in MapLandmarks_ObjectAnchor) {
		declare ObjectSpawned for MapLandmark = False;
		declare ObjectNextSpawn for MapLandmark = Now;
		declare ObjectType for MapLandmark = "";
		
		// ---------------------------------- //
		// Continue if landmark has object or object can't be spawned
		if (ObjectType == "" || ObjectSpawned || Now < ObjectNextSpawn) continue;
		
		// ---------------------------------- //
		// Create object
		declare Object = SpawnObject(MapLandmark.Position, ObjectType, MapLandmark.Id);
		ObjectSpawned = Object != Null;
	}
}

// ---------------------------------- //
/** Destroy an object
 *
 *	@param	_Object		The object to destroy
 */
Boolean DestroyObject(CSmObject _Object) {
	if (_Object == Null) return False;
	if (GalaxyTitles::DestroyObject(_Object)) return True;
	
	// Destroy object (unspawning the object gives a quiet sound)
	_Object.SetUnspawned();
	ObjectDestroy(_Object);
	return True;
}

// ---------------------------------- //
/** Pick up object
 *
 *	@param	_Event	The event to proceed
 *
 */
Boolean PickUpObject(CSmModeEvent _Event) {
	if (
		_Event == Null || _Event.Type != CSmModeEvent::EType::OnPlayerTouchesObject ||
		_Event.Object == Null || _Event.Player == Null || _Event.Player.IsBot ||
		_Event.Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned
	) return False;
	
	declare Text Tag for _Event.Object;
	declare Boolean DroppedByPlayer for _Event.Object;
	
	// Manage only Weapons, Charges and Minis
	declare SupportedTags = ["Weapon", "Charge", "Mini"];
	if (!SupportedTags.exists(Tag)) return False;
	
	// ---------------------------------- //
	// Pick conditions
	declare CSmMode::EWeapon[] PossibleWeapons;
	declare CanPickUpObject = True;
	
	switch (Tag) {
		// ---------------------------------- //
		// Weapon conditions
		case "Weapon" : {
			// Add weapons if player haven't maxed them out yet
			foreach (Weapon => A in C_PlayerInitialWeapons) {
				declare WeaponMaxSlots = S_MaximumNbWeapons;
				if (Weapon == CSmMode::EWeapon::Rocket) WeaponMaxSlots = C_PlayerMaxNbRocketSlots;
				if (WeaponMaxSlots <= 0 || Inventory::GetWeaponSlots(_Event.Player, Weapon) < WeaponMaxSlots)
					PossibleWeapons.add(Weapon);
			}
			
			CanPickUpObject = PossibleWeapons.count > 0;
		}
		// ---------------------------------- //
		// Mini conditions
		case "Mini" : CanPickUpObject = DroppedByPlayer || _Event.Player.Armor - C_MiniItemArmorTakenOnPick > 0;
	}
	
	// Continue, if the object can't be picked up
	if (!CanPickUpObject) return False;
	
	// ---------------------------------- //
	// Apply effect
	switch (Tag) {
		// ---------------------------------- //
		// Weapon: gives 1 weapon and reloads 1 armor
		case "Weapon" : {
			declare NewWeapon = PossibleWeapons[ML::Rand(0, PossibleWeapons.count - 1)];
			Inventory::AddWeaponSlots(_Event.Player, NewWeapon, 1);
			
			// Notify player about the new weapon received
			declare WeaponName = TL::Split("::", ""^NewWeapon);
			Interfancy::SendCrosshairNote(_Event.Player, ["+1 %1", WeaponName[WeaponName.count - 1]], 2000);
			
			// Heal the player (if object was naturally generated)
			if (!DroppedByPlayer) AddPlayerArmor(_Event.Player, C_WeaponItemArmorBonus, Null, 0);
		}
		// ---------------------------------- //
		// Charge: increase reload, stamina gain and max
		case "Charge" : {
			declare SkillsToIncrease = ["AmmoGain", "StaminaGain", "StaminaMax"];
			foreach (SkillType in SkillsToIncrease)
				AddPlayerSkill(_Event.Player, SkillType, C_ChargeItemSkillPoints);
			
			// Notify player about new abilities
			Interfancy::SendCrosshairNote(
				_Event.Player,
				["+%1% %2", TL::ToText(C_ChargeItemSkillPoints), "Skills"],
				2000
			);
		}
		// ---------------------------------- //
		// MiniCharge: double bonus as Charge, removes 1 armor
		case "Mini" : {
			declare SkillsToIncrease = ["AmmoGain", "StaminaGain", "StaminaMax"];
			foreach (SkillType in SkillsToIncrease)
				AddPlayerSkill(_Event.Player, SkillType, C_ChargeItemSkillPoints * C_MiniItemBonusMultiplier);
			
			// Remove player armor (if object was naturally generated)
			if (!DroppedByPlayer) RemovePlayerArmor(_Event.Player, C_MiniItemArmorTakenOnPick, Null, 0);
			
			// Notify player about new abilities
			Interfancy::SendCrosshairNote(
				_Event.Player,
				["+%1% %2", TL::ToText(C_ChargeItemSkillPoints * C_MiniItemBonusMultiplier), "Skills"],
				2000
			);
		}
	}
	
	// ---------------------------------- //
	// Bind object tag to a player for eventual late drop
	declare Text[] ObjectsToDrop for _Event.Player;
	ObjectsToDrop.add(Tag);

	// ---------------------------------- //
	// Give points for picking up the item
	TopScores::AddPoints(_Event.Player.Score, "Items", 1);
	Score::AddPoints(_Event.Player, C_PlayerPointsForObjects);
	
	// Destroy object
	DestroyObject(_Event.Object);
	return True;
}

// ---------------------------------- //
/** Drop objects picked up by a player
 *
 *	@param	_Player		The player whoose objects are dropped
 *	@param	_DropRatio	Percentage ratio of the dropped objects
 */
Void DropPlayerObjects(CSmPlayer _Player, Real _DropRatio) {
	if (_Player == Null || _DropRatio <= 0) return;
	
	// ---------------------------------- //
	// Get all objects of the player
	declare Text[] ObjectsToDrop for _Player;
	declare PlayerReplies = Inventory::GetItemAmount(_Player, "LibGalaxyTitles_Replie");
	if (PlayerReplies > 0) for (I, 1, PlayerReplies) ObjectsToDrop.add("Replie");
	declare TotalObjectsCount = ObjectsToDrop.count;
	
	// Remove random objects when there are too many
	while (ObjectsToDrop.count > TotalObjectsCount * _DropRatio) {
		declare Removed = ObjectsToDrop.removekey(ML::Rand(0, ObjectsToDrop.count - 1));
	}
	
	// ---------------------------------- //
	// Spawn player objects
	foreach (NewObjectTag in ObjectsToDrop) {
		declare ObjectPosition = _Player.Position;
		for (I, 0, 1) ObjectPosition[I*2] += ML::Rand(-C_ObjectsDropSpreadRadius, C_ObjectsDropSpreadRadius);
		
		// Create object
		declare Object = SpawnObject(ObjectPosition, NewObjectTag);
		if (Object == Null) continue;
		
		// Indicate that object was dropped by a player
		declare Boolean DroppedByPlayer for Object;
		DroppedByPlayer = True;
	}
}

// ---------------------------------- //
/** Set start time for the UI
 *
 *	@param	_StartTime	The start time
 */
Void UISetStartTime(Integer _StartTime) {
	declare netwrite Integer Net_HungerGames_StartTime for Teams[0];
	Net_HungerGames_StartTime = _StartTime;
}

// ---------------------------------- //
/** Set alive players amount for the UI
 *
 *	@param	_PlayersNbAlive		Amount of alive players
 */
Void UISetNbPlayersAlive(Integer _PlayersNbAlive) {
	declare netwrite Integer Net_HungerGames_PlayersAlive for Teams[0];
	Net_HungerGames_PlayersAlive = _PlayersNbAlive;
}

// ---------------------------------- //
/** Add player who touched Goal to the UI
 *
 *	@param	_Login	Login of the player
 */
Void UIAddPlayerTouchingGoal(Text _Login) {
	declare netwrite Text[] Net_HungerGames_TouchedGoal for Teams[0];
	Net_HungerGames_TouchedGoal.add(_Login);
}

// ---------------------------------- //
/// Clear list of players who touched goal
Void UIResetPlayersTouchingGoal() {
	declare netwrite Text[] Net_HungerGames_TouchedGoal for Teams[0];
	Net_HungerGames_TouchedGoal.clear();
}

// ---------------------------------- //
/** Create manialink for the interface module
 *
 *	@return		The interface manialink
 */
Text CreateManialinkInterface() {
	return """
<manialink version="2" name="HungerGames:Interface">
<stylesheet>
	<style class="font" halign="center" valign="center2" textsize="1" textemboss="1" textcolor="FFF" textfont="Eurostile_Bold"/>
</stylesheet>
<frame id="Frame_Countdown">
	<quad sizen="40 40" halign="center" valign="center" id="Quad_DigitPri"/>
	<quad sizen="40 40" halign="center" valign="center" id="Quad_DigitSec" posn="0 0 -1"/>
</frame>
<frame id="Frame_TouchGoal" posn="0 76">
	<label posn="0 2" class="font" textsize="4" textprefix="$T" id="Label_TouchGoalTitle" opacity="0"/>
	<label posn="0 -2" class="font" textprefix="$T" id="Label_TouchGoalDesc" opacity="0"/>
</frame>
<script><!--
/**
 *	HungerGames: Interface
 */

#Include "TextLib" as TL
#Include "MathLib" as ML

#Const C_MaxCountdownTicks {{{ML::Max(C_StartCountdownDuration / 1000, 0)}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Quad_DigitPri <=> (Page.GetFirstChild("Quad_DigitPri") as CMlQuad);
declare Quad_DigitSec <=> (Page.GetFirstChild("Quad_DigitSec") as CMlQuad);
declare Label_TouchGoalTitle <=> (Page.GetFirstChild("Label_TouchGoalTitle") as CMlLabel);
declare Label_TouchGoalDesc <=> (Page.GetFirstChild("Label_TouchGoalDesc") as CMlLabel);

Label_TouchGoalTitle.SetText(Translate("Touch the Goal!"));
Label_TouchGoalDesc.SetText(Translate("You must touch the Goal to be able to pick up items!"));

// ---------------------------------- //
// Netcode
declare netread Integer Net_HungerGames_StartTime for Teams[0];
declare netread Integer Net_HungerGames_PlayersAlive for Teams[0];
declare netread Text[] Net_HungerGames_TouchedGoal for Teams[0];

// ---------------------------------- //
// Variables
declare CountdownSound = Audio.CreateSound("{{{C_ImgBase}}}Sounds/CountdownHungerGames.ogg");
declare CountdownTick = -1;
declare CenterGoalPosition = Vec3;
declare TouchGoalAlertVisible = False;

// Update
declare PrevCountdownTick = CountdownTick;
declare PrevNbPlayersAlive = -1;
declare PrevTouchGoalAlertVisible = False;

foreach (MapLandmark in MapLandmarks) {
	if (MapLandmark.Gauge != Null && MapLandmark.Tag == "Goal") CenterGoalPosition = MapLandmark.Position;
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Set "Touch the Goal" message visibility
TouchGoalAlertVisible = GUIPlayer != Null && GameTime >= GUIPlayer.StartTime && GUIPlayer.Armor > 0 && !Net_HungerGames_TouchedGoal.exists(GUIPlayer.Login);

// ---------------------------------- //
// Update alert visibility
if (PrevTouchGoalAlertVisible != TouchGoalAlertVisible) {
	PrevTouchGoalAlertVisible = TouchGoalAlertVisible;
	
	LibManialink_AnimStop(Label_TouchGoalTitle);
	LibManialink_AnimStop(Label_TouchGoalDesc);
	
	// ---------------------------------- //
	// Show alert
	if (TouchGoalAlertVisible) {
		Label_TouchGoalTitle.RelativePosition.Y = 4.;
		Label_TouchGoalDesc.RelativePosition.Y = 0.;
		Label_TouchGoalTitle.Opacity = 0.;
		Label_TouchGoalDesc.Opacity = 0.;
		LibManialink_Anim(Label_TouchGoalTitle, "<label posn='0 2' opacity=1 />", 125, "EaseLinear");
		LibManialink_Anim(Label_TouchGoalDesc, "<label posn='0 -2' opacity=1 />", 125, "EaseLinear");
	}
	// ---------------------------------- //
	// Hide alert
	else {
		Label_TouchGoalTitle.RelativePosition.Y = 2.;
		Label_TouchGoalDesc.RelativePosition.Y = -2.;
		Label_TouchGoalTitle.Opacity = 1.;
		Label_TouchGoalDesc.Opacity = 1.;
		LibManialink_Anim(Label_TouchGoalTitle, "<label posn='0 0' opacity=0 />", 125, "EaseLinear");
		LibManialink_Anim(Label_TouchGoalDesc, "<label posn='0 -4' opacity=0 />", 125, "EaseLinear");
	}
}

// ---------------------------------- //
// Warning about touching the Goal
if (TouchGoalAlertVisible && CenterGoalPosition != <0., 0., 0.>) {
	declare Distance = ML::Distance(CenterGoalPosition, GUIPlayer.Position);
	if (Distance > 50) {
		declare Color = <1., 0., 0.>;
		if (Now % 250 >= 125) Color = <.5, 0., 0.>;
		Label_TouchGoalTitle.TextColor = Color;
		Label_TouchGoalDesc.TextColor = Color;
	} else {
		Label_TouchGoalTitle.TextColor = <1., 1., 1.>;
		Label_TouchGoalDesc.TextColor = <1., 1., 1.>;
	}
}

// ---------------------------------- //
// Get current countdown tick
CountdownTick = (Net_HungerGames_StartTime - GameTime + 1000) / 1000;

// ---------------------------------- //
// Cannon sound upon elimination
if (PrevNbPlayersAlive != Net_HungerGames_PlayersAlive) {
	if (PrevNbPlayersAlive > Net_HungerGames_PlayersAlive && Net_HungerGames_PlayersAlive >= 2 && GameTime > Net_HungerGames_StartTime) {
		Audio.PlaySoundEvent("{{{C_ImgBase}}}Sounds/PlayerEliminated.ogg", 10.);
	}
	PrevNbPlayersAlive = Net_HungerGames_PlayersAlive;
}

// ---------------------------------- //
// Tick update
if (PrevCountdownTick != CountdownTick) {
	PrevCountdownTick = CountdownTick;
	
	// ---------------------------------- //
	// Animate the countdown number on tick change
	if (CountdownTick >= 0 && CountdownTick <= C_MaxCountdownTicks) {
		Quad_DigitPri.ImageUrl = "{{{C_ImgBase}}}Countdown/main_"^CountdownTick^".png";
		Quad_DigitSec.ImageUrl = "{{{C_ImgBase}}}Countdown/sec_"^CountdownTick^".png";
		
		LibManialink_AnimStop(Quad_DigitPri);
		LibManialink_AnimStop(Quad_DigitSec);
		
		Quad_DigitPri.RelativeScale = 2.;
		Quad_DigitSec.RelativeScale = 1.;
		
		Quad_DigitPri.Opacity = 1.;
		Quad_DigitSec.Opacity = 1.;
		
		LibManialink_Anim(Quad_DigitPri, "<quad scale=1 />", 1000, "EaseOutCirc");
		LibManialink_Anim(Quad_DigitSec, "<quad scale=1.5 />", 1000, "EaseLinear");
		
		LibManialink_AnimChain(Quad_DigitPri, "<quad opacity=0 />", 250, "EaseLinear");
		LibManialink_AnimChain(Quad_DigitSec, "<quad opacity=0 />", 250, "EaseLinear");
		
		if (!CountdownSound.IsPlaying && CountdownTick > 0) {
			CountdownSound.Play();
			CountdownSound.PlayCursor = ML::ToReal(10 - CountdownTick);
		}
	}
	
	// ---------------------------------- //
	// Match start sound
	if (CountdownTick == 0) PlayUiSound(CMlScriptIngame::EUISound::StartMatch, 1, 1.);
	
	// ---------------------------------- //
	// Stop countdown sound
	if (CountdownSound.IsPlaying && CountdownTick <= -1) CountdownSound.Stop();
}
***

{{{Manialink::Animations(["EaseOutCirc"])}}}
{{{Translations::InjectInManialink(["Touch the Goal!", "You must touch the Goal to be able to pick up items!"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		LibManialink_AnimLoop();
		---Yield---
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
/** Create manialink for the statistics module
 *
 *	@return		The statistics manialink
 */
Text CreateManialinkStatistics() {
	declare WB = "file://Media/Manialinks/ShootMania/Window/";
	return """
<manialink version="2" name="HungerGames:Statistics">
<stylesheet>
	<style class="font" valign="center2" textemboss="1" textcolor="FFF" textsize="1" textfont="Eurostile_Bold"/>
</stylesheet>

<framemodel id="FrameModel_StatGauge">
	<label posn="0 3" class="font" halign="center" textsize="3" id="Label_StatValueCur" text="0%"/>
	<label posn="-25 2.25" class="font" halign="left" textcolor="888" id="Label_StatValueMin" text="0%"/>
	<label posn="25 2.25" class="font" halign="right" textcolor="888" id="Label_StatValueMax" text="0%"/>
	<gauge sizen="54 8" halign="center" valign="center" drawbg="0" id="Gauge_StatProgress"/>
	<label posn="0 -3" class="font" halign="center" textprefix="$t" id="Label_StatDescription" text="---"/>
</framemodel>

<frame posn="-84 -44 10" clip="1" clipposn="84 -10" clipsizen="170 22">
	<quad posn="0 36" sizen="10 50" image="{{{WB}}}BottomLeft.png" colorize="000"/>
	<quad posn="10 36" sizen="148 50" image="{{{WB}}}Bottom.png" colorize="000"/>
	<quad posn="158 36" sizen="10 50" image="{{{WB}}}BottomRight.png" colorize="000"/>
	
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#0" posn="31 -6 1"/>
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#1" posn="84 -6 1"/>
	<frameinstance modelid="FrameModel_StatGauge" id="Frame_StatGauge#2" posn="137 -6 1"/>
</frame>

<script><!--
/**
 *	HungerGames: Statistics
 */

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_StatsNames 	["Ammo reload", "Stamina reload", "Stamina max"]
#Const C_StatsMaximum	[5., 1., 3.]

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Laod interface elements
declare CMlFrame[] Frame_StatGauges;
for (I, 0, 2) Frame_StatGauges.add((Page.GetFirstChild("Frame_StatGauge#"^I) as CMlFrame));

// ---------------------------------- //
// Variables
declare InterfaceColor = LocalUser.Color;
declare StatsValues = [0., 0., 0.];

/// Update
declare PrevGUIPlayerId = NullId;
declare PrevInterfaceColor = Vec3;
declare PrevStatsValues = [0., 0., 0.];

// ---------------------------------- //
// Setup statistics
foreach (I => Frame in Frame_StatGauges) {
	declare Label_StatDescription <=> (Frame.GetFirstChild("Label_StatDescription") as CMlLabel);
	declare Label_StatValueMin <=> (Frame.GetFirstChild("Label_StatValueMin") as CMlLabel);
	declare Label_StatValueMax <=> (Frame.GetFirstChild("Label_StatValueMax") as CMlLabel);
	
	Label_StatDescription.SetText(Translate(C_StatsNames[I]));
	Label_StatValueMin.SetText("0%");
	Label_StatValueMax.SetText(ML::FloorInteger(C_StatsMaximum[I] * 100)^"%");
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update interface on player change
if (GUIPlayer != Null && GUIPlayer.SpawnStatus != CSmPlayer::ESpawnStatus::NotSpawned) {
	if (PrevGUIPlayerId != GUIPlayer.Id) {
		PrevGUIPlayerId = GUIPlayer.Id;
		InterfaceColor = GUIPlayer.User.Color;
	}
} else if (PrevGUIPlayerId != NullId) {
	PrevGUIPlayerId = NullId;
	InterfaceColor = LocalUser.Color;
	StatsValues = [0., 0., 0.];
}

// ---------------------------------- //
// Update the color of the interface
if (PrevInterfaceColor != InterfaceColor) {
	PrevInterfaceColor = InterfaceColor;
	
	foreach (Frame in Frame_StatGauges) {
		declare Label_StatDescription <=> (Frame.GetFirstChild("Label_StatDescription") as CMlLabel);
		declare Gauge_StatProgress <=> (Frame.GetFirstChild("Gauge_StatProgress") as CMlGauge);
		
		Label_StatDescription.TextColor = Brightness(InterfaceColor, 4.);
		Gauge_StatProgress.Color = InterfaceColor;
	}
}

// ---------------------------------- //
// Update current player statistics
if (PrevGUIPlayerId != NullId && GUIPlayer != Null) {
	StatsValues[0] = GUIPlayer.AmmoGain;
	StatsValues[1] = GUIPlayer.StaminaGain;
	StatsValues[2] = GUIPlayer.StaminaMax;
}

// ---------------------------------- //
// Update statistics frames
foreach (I => Frame in Frame_StatGauges) {
	if (!StatsValues.existskey(I) || !PrevStatsValues.existskey(I) || StatsValues[I] == PrevStatsValues[I]) continue;
	PrevStatsValues[I] = StatsValues[I];
	
	// ---------------------------------- //
	// Get frame elements
	declare Label_StatValueCur <=> (Frame.GetFirstChild("Label_StatValueCur") as CMlLabel);
	declare Gauge_StatProgress <=> (Frame.GetFirstChild("Gauge_StatProgress") as CMlGauge);
	
	// ---------------------------------- //
	// Set gauges ratio
	Label_StatValueCur.SetText(ML::NearestInteger(StatsValues[I] * 100)^"%");
	SetGaugeRatio(Gauge_StatProgress, StatsValues[I] / C_StatsMaximum[I]);
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Change color brightness
 *
 *	@param	_Color			Input color
 *	@param	_Brightness		Target brightness
 *
 *	@return		New color
 */
Vec3 Brightness(Vec3 _Color, Real _Brightness) {
	if (_Brightness == 1) return _Color;
	if (_Brightness <= 0) return Vec3;
	
	declare Vec3 OutputColor;
	if (_Brightness < 1) for (I, 0, 2) OutputColor[I] = _Color[I] * _Brightness;
	else if (_Brightness > 1) for (I, 0, 2) OutputColor[I] = 1 - (1 / _Brightness) + _Color[I] * (1 / _Brightness);
	return OutputColor;
}

// ---------------------------------- //
/** Set gauge ratio with value cut fix
 *
 *	@param	_Gauge		The gauge to set ratio
 *	@param	_Ratio		Ratio to set
 */
Void SetGaugeRatio(CMlGauge _Gauge, Real _Ratio) {
	if (_Gauge == Null) return;
	if (_Ratio <= 0.) { _Gauge.Ratio = 0.; return; }
	if (_Ratio >= 1.) { _Gauge.Ratio = 1.; return; }
	declare GaugeCutOff = 4 / _Gauge.Size.X;
	_Gauge.Ratio = _Ratio * (1 - GaugeCutOff) + GaugeCutOff;
}

{{{Translations::InjectInManialink(["Ammo gain", "Stamina gain", "Stamina max"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	---Main---
	while (True) {
		yield;
		---Yield---
	}
}
--></script>
</manialink>""";
}