// -------------------------------------- //
//  SPEEDBALL V2 by domino54              //
//  script version: 2017-09-07            //
//  original author: steeffeen            //
// -------------------------------------- //

#Extends "Modes/ShootMania/ModeGalaxyTitles.Script.txt"

#Const CompatibleMapTypes "SpeedBallV2Arena, SpeedBallArena, SpeedBallTitleArena"
#Const Version		"2017-09-07"
#Const ScriptName	"Modes/ShootMania/SpeedBallV2.Script.txt"

#Include "Libs/Nadeo/Color.Script.txt" as Color
#Include "Libs/Nadeo/ShootMania/Map.Script.txt" as Map

// ---------------------------------- //
// Settings
// ---------------------------------- //
#Setting S_TimeLimitNormal		180		as _("Normal phase time limit")
#Setting S_TimeLimitReduction	120		as _("Reduction phase time limit")
#Setting S_TimeLimitInstant		60		as _("Instant capture time limit")
#Setting S_RoundsToWin			2		as _("Rounds to win")
#Setting S_RoundGapToWin		1		as _("Round gap to win")
#Setting S_RoundsLimit			3		as _("Rounds limit")
#Setting S_WarmUpDuration		0		as _("Warm up duration (sec.)")
#Setting S_BallAlwaysVisible	True	as _("Always show the ball marker")
#Setting S_UseAutoBalance		False	as _("Balance teams on round start")
#Setting S_UseThrowableBall		False	as _("Use throwable Ball")
#Setting S_BallTimeSelectWinner	False	as _("If round ends by time limit, team with longer ball time wins")
#Setting S_NbPlayersPerTeamMin	1		as _("Minumum number of players in each team")
#Setting S_NbPlayersPerTeamMax	3		as _("Maximum number of players per team (0: no max)")
#Setting S_BallDropPhysicsMode	0		as "<hidden>"
#Setting S_EnableCharSelection	False	///< Disable characters by default.
#Setting S_EnableFriendlyFire	True	///< Enable friendly fire by default.
#Setting S_PlayerArmorPoints	2		///< Reduce players armor to 2 points.

// ---------------------------------- //
// Commands
// ---------------------------------- //
#Command Command_CurrentMapPointsClan1	(Integer)	as _("Current map points for clan 1")
#Command Command_CurrentMapPointsClan2	(Integer)	as _("Current map points for clan 2")
#Command Command_ForceWarmUp			(Boolean)	as _("Set pause")

// ---------------------------------- //
// Constants
// ---------------------------------- //
#Const C_GoalPostLoadingTime	2000	///< For how long players have to stand on goal to capture it.
#Const C_PlayerBallThrowSpeed	45.		///< Throwing speed of the Ball.
#Const C_BallArmorReplenishGain	200		///< Health regeneration for Ball carrier.
#Const C_BallRespawnMaxSpeed	.125	///< Ball starts respawning if object moves below this speed.
#Const C_BallRespawnSetDelay	125		///< Time before Ball starts respawning after last move.
#Const C_BallRespawnDuration	5000	///< Duration of the Ball respawn.
#Const C_BallMaxLifeDuration	10000	///< Max Ball life duration when not respawning.
#Const C_BallTimePerPoint		0		///< Time between each point given for holding the ball.
#Const C_BallDropPosOffset		<0., .5, 0.>	///< Ball drop position offset (avoid falling under map).

// Gameplay phases enum
#Const C_GameplayPhase_Normal		0	///< Normal part of the match.
#Const C_GameplayPhase_Reduction	1	///< Goal capture time reduction.
#Const C_GameplayPhase_Instant		2	///< Instant capture phase.

#Const Description _("TYPE: Team versus Team\nOBJECTIVE: Deliver the Ball from central Checkpoint to your opponents' Goal to win the round.")

// ---------------------------------- //
// Global variables
// ---------------------------------- //
declare CSmMapLandmark[Integer] G_ClanSpawnLandmarks;	///< Spawns in which players are spawned.
declare CSmMapLandmark[Integer] G_ClanGoalLandmarks;	///< Goals used to open jails by teammates.
declare CSmMapLandmark G_CentralCheckpointLandmark;		///< Checkpoint in the center of the map, where Ball is spawned.
declare Vec3 G_CheckpointBallPos;	///< Position of the static Ball.

declare Integer G_CurGameplayPhase;	///< Current game phase [0 = normal, 1 = reduction, 2 = instant].
declare Integer G_PhaseStartTime;	///< Start time of the current phase.
declare Boolean G_BallIsCheckpoint;	///< True, if the Ball is on a checkpoint.
declare Integer G_BallRespawnTime;	///< Time when the Ball will respawn.
declare Integer G_BallDroppedTime;	///< Time when the Ball was dropped.
declare Ident G_CurBallCarrierId;	///< Id of the player currently holding the Ball.
declare Boolean G_BallHasBeenBounced;	///< If False, ball can bounce at least once.

declare Ident[Text] G_ObjectsIds;	///< Ids of the objects used by the game mode.
declare CSmObject G_MobileBall;		///< Ball carried by player and dropped in the world.
declare CSmObject G_StaticBall;		///< Static Ball over checkpoint.

// ---------------------------------- //
// Extend
// ---------------------------------- //
***Match_LogVersions***
***
Log::RegisterScript(ScriptName, Version);
Log::RegisterScript(Color::GetScriptName(), Color::GetScriptVersion());
Log::RegisterScript(Map::GetScriptName(), Map::GetScriptVersion());
***

// ---------------------------------- //
// Set up matchmaking
// ---------------------------------- //
***MM_SetupMatchmaking***
***
MM_SetFormat([S_NbPlayersPerTeamMax, S_NbPlayersPerTeamMax]);
if (S_NbPlayersPerTeamMax > S_NbPlayersPerTeamMin) {
	MM_SetProgressiveFormats([1, 1], S_NbPlayersPerTeamMin, S_NbPlayersPerTeamMax-1);
}
***

// ---------------------------------- //
// Galaxy title settings
// ---------------------------------- //
***GalaxyTitles_Settings***
***
G_NearMissMaxDistRocket = .5;
***

// ---------------------------------- //
// Set the scores table
// ---------------------------------- //
***ScoresTable***
***
TopScores::AddCategory("BallTime", "Ball Interaction", "", 2., "", 2.25, 60.);
TopScores::AddCategory("BallDamage", "Carrier damage", "", 3.);
TopScores::AddCategory("CaptureAttempt", "Capture percentage", "", 4.);
TopScores::AddCategory("BallPasses", "Most passes", "", 5.);
TopScores::AddCategory("FriendlyFire", "Friendly-fire", "", 6.);
TopScores::SetFormat(4, 2);
***

// ---------------------------------- //
// Update the mode rules
// ---------------------------------- //
***Match_Rules***
***
ModeInfo::SetName("SpeedBall v2");
ModeInfo::SetType(ModeInfo::C_Type_Teams);
ModeInfo::SetRules("1. Two teams are trying to capture the Ball in their opponents' Goal.\n2. Ball is can be obtained from central Checkpoint or by eliminating player currently carrying it.\n3. Dropped Ball will return to the Checkpoint after 5 seconds of inactivity.\n4. You can pass the Ball to other players by shooting them with your weapon.\n5. Time needed to capture the Goal decreases over time, finally making the capture instant.");
ModeInfo::SetStatusMessage(Description);
***

// ---------------------------------- //
// Server start
// ---------------------------------- //
***Match_InitServer***
***
UseClans = True;
Killfeed::Unload();
MiniMap::Unload();
TopScores::Load(); // TEMP

// Create custom interface
Layers::Create("SpeedBall:Interface", CreateManialinkInterface());
Layers::Create("SpeedBall:Markers", CreateManialinkMarkers());
Layers::SetType("SpeedBall:Markers", CUILayer::EUILayerType::Markers);
MiniMap::SetOpponentsVisibility(False);

// ---------------------------------- //
// Load objects
G_ObjectsIds["Ball"] = ItemList_Add("SpeedBall\\Ball.Item.Gbx");
G_ObjectsIds["BallStatic"] = ItemList_Add("PickUpSpeedBall\\Ball.Item.Gbx");

// ---------------------------------- //
// Variables
declare UpdateTimeLimit = False;
declare RoundWinningClan = 0;
declare PrevBallIsCheckpoint = G_BallIsCheckpoint;
declare PrevMobileBallPosition = Vec3;
declare LastBallMovementTime = -1;
declare PrevTimeLimitNormal = S_TimeLimitNormal;
declare PrevTimeLimitReduction = S_TimeLimitReduction;
declare PrevTimeLimitInstant = S_TimeLimitInstant;
***

// ---------------------------------- //
// Map begin
// ---------------------------------- //
***Match_InitMap***
***
// ---------------------------------- //
// Check if the map is valid
declare MapValidated = True;
for (Order, 1, 2) {
	if (Map::GetLandmarkPlayerSpawn("Spawn", Order) == Null) MapValidated = False;
	if (Map::GetLandmarkGauge("Goal", Order) == Null) MapValidated = False;
}
if (Map::GetLandmarkGauge("Checkpoint", 0) == Null && Map::GetLandmarkGauge("Goal", 3) == Null) MapValidated = False;

// Skip map if not valid
if (!MapValidated) GT_SkipInvalidMap();
***

// ---------------------------------- //
// Map start
// ---------------------------------- //
***Match_StartMap***
***
if (!MM_IsMatchServer() && S_WarmUpDuration > 0 && S_NbPlayersPerTeamMax > 0) {
	GT_InitWarmUp(S_NbPlayersPerTeamMax);
	GT_DoWarmUp(S_WarmUpDuration, S_NbPlayersPerTeamMax);
}
***

// ---------------------------------- //
// Round start
// ---------------------------------- //
***Match_InitRound***
***
ResetBall();
ResetGaugeMaxValue();
RoundWinningClan = 0;
PrevBallIsCheckpoint = G_BallIsCheckpoint;
declare ClansBallTime = [0, 0, 0];

// ---------------------------------- //
// Bind landmarks to teams
declare BlueTeamSideOrder = MB_GetRoundCount() % 2 + 1;

// Get spawns
G_ClanSpawnLandmarks = [
	1 => Map::GetLandmarkPlayerSpawn("Spawn", BlueTeamSideOrder),
	2 => Map::GetLandmarkPlayerSpawn("Spawn", 3 - BlueTeamSideOrder)
];

// Get checkpoint
G_CentralCheckpointLandmark <=> Map::GetLandmarkGauge("Checkpoint", 0);
if (G_CentralCheckpointLandmark == Null)
	G_CentralCheckpointLandmark <=> Map::GetLandmarkGauge("Goal", 3);

G_CheckpointBallPos = G_CentralCheckpointLandmark.Position + <0., .25, 0.>;

// Get poles
G_ClanGoalLandmarks = [
	1 => Map::GetLandmarkGauge("Goal", BlueTeamSideOrder),
	2 => Map::GetLandmarkGauge("Goal", 3 - BlueTeamSideOrder)
];

// ---------------------------------- //
// Update landmarks colors
foreach (Clan => MapLandmark in G_ClanSpawnLandmarks) {
	if (MapLandmark.Base == Null) continue;
	MapLandmark.Base.Clan = Clan;
	MapLandmark.Base.IsActive = True;
}

// Fill the checkpoint gauge
if (G_CentralCheckpointLandmark.Gauge != Null)
	G_CentralCheckpointLandmark.Gauge.ValueReal = 1.;

// ---------------------------------- //
// Update landmarks colors
foreach (Clan => MapLandmark in G_ClanGoalLandmarks) {
	if (MapLandmark.Base == Null) continue;
	MapLandmark.Base.Clan = Clan;
	MapLandmark.Gauge.Clan = 3 - Clan;
	MapLandmark.Gauge.Max = C_GoalPostLoadingTime;
	MapLandmark.Gauge.ValueReal = 0.;
	MapLandmark.Gauge.Captured = False;
	MapLandmark.Base.IsActive = False;
}

// ---------------------------------- //
// Create objects
G_MobileBall <=> ObjectCreate(G_ObjectsIds["Ball"]);
G_MobileBall.SetUnspawned();
G_MobileBall.Throwable = True;
G_StaticBall <=> ObjectCreate(G_ObjectsIds["BallStatic"]);
G_StaticBall.SetPosition(G_CheckpointBallPos);

// Balance teams
if (S_UseAutoBalance) GT_AutoBalance();

// Wait for enough players to start the game
GT_WaitForPlayers(S_NbPlayersPerTeamMin);

// Matchmaking: allow substitutes
if (MM_IsMatchServer()) MM_AllowSubstitutes(True);

// Character selection screen
GT_ShowCharSelection();

// ---------------------------------- //
// Ball bounce mechanics
G_BallHasBeenBounced = False;
declare BallCarrierLastPosition = Vec3;
declare BallCarrierIsTouchingGround = False;

// ---------------------------------- //
// Reset players Ball time
foreach (Score in Scores) {
	declare Integer PlayerBallTime for Score;
	declare Integer PrevPlayerBallTime for Score;
	PlayerBallTime = 0;
	PrevPlayerBallTime = 0;
}

// ---------------------------------- //
// New map sound
UIManager.UIAll.UISequence = CUIConfig::EUISequence::Playing;
UIManager.UIAll.OverlayHideNotices = False;
UIManager.UIAll.SendNotice(
	"", CUIConfig::ENoticeLevel::MatchInfo,
	Null, CUIConfig::EAvatarVariant::Default,
	CUIConfig::EUISound::StartRound, 0
);

StartTime = Now + S_RespawnTime;
SetGameplayPhase(C_GameplayPhase_Normal);
SB_SetTimeLimit(S_TimeLimitNormal, S_TimeLimitReduction, S_TimeLimitInstant);
UpdateTimeLimit = False;
***

// ---------------------------------- //
// Start play loop
// ---------------------------------- //
***Match_StartPlayLoop***
***
Layers::Attach("SpeedBall:Interface");
Layers::Attach("SpeedBall:Markers");

MiniMap::SetMarker("SpeedBall", "Ball.png", <1., 1., 1.>, G_CheckpointBallPos);
SetBallMarker(G_CheckpointBallPos + <0., -.5, 0.>);

foreach (Clan => MapLandmark in G_ClanGoalLandmarks) {
	declare Pos = MapLandmark.Position + <0., 28., 0.>;
	MiniMap::SetMarker("Goal#"^Clan, "Goal.png", Teams[Clan-1].ColorPrimary, Pos);
	Markers::AddMarker("Goal#"^Clan, """<marker
		pos="{{{Pos.X^" "^Pos.Y^" "^Pos.Z}}}" manialinkframeid="Frame_MarkerGoal#{{{Clan}}}"
		minimapvisibility="Never" visibility="WhenInFrustum" box="1 1 1"
	/>""");
}
***

// ---------------------------------- //
// On armor empty
// ---------------------------------- //
***OnArmorEmpty***
***
DropBall(Event.Victim);
***

// ---------------------------------- //
// On hit event conditions
// ---------------------------------- //
***OnHitConditions***
***
if (Event.Shooter != Null && Event.Shooter.Id == G_CurBallCarrierId) {
	Discard(Event);
	if (Event.Victim != Null && Event.Victim != Event.Shooter && !Event.Victim.IsBot) {
		PickUpBall(Event.Victim, True);
		Inventory::SetItemAmount(Event.Shooter, "Ball", 0);

		// Points for pass
		if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
			Scores::AddPlayerRoundPoints(Event.Shooter.Score, 2);
			TopScores::AddPoints(Event.Shooter.Score, "BallTime", 2);
			TopScores::AddPoints(Event.Shooter.Score, "BallPasses", 1);
			Statistics::TrackEvent(Event.Shooter, "SpeedBallPasses", 1);
		}
	}
 	continue;
}
***

// ---------------------------------- //
// On hit event
// ---------------------------------- //
***OnHit***
***
if (Event.Victim != Null && Event.Victim.Id == G_CurBallCarrierId) {
	Points *= 2;
	TopScores::AddPoints(Event.Shooter.Score, "BallDamage", Points);
}
if (Event.Shooter.CurrentClan == Event.Victim.CurrentClan) {
	TopScores::AddPoints(Event.Shooter.Score, "FriendlyFire", Points);
}
***

// ---------------------------------- //
// On player request respawn
// ---------------------------------- //
***OnPlayerRequestRespawn***
***
DropBall(Event.Player);
***

// ---------------------------------- //
// On player touches object
// ---------------------------------- //
***OnPlayerTouchesObject***
***
Discard(Event);
if (Event.Object == G_StaticBall) continue;
if (Event.Object == G_MobileBall) PickUpBall(Event.Player);
***

// ---------------------------------- //
// Play loop
// ---------------------------------- //
***Match_PlayLoop***
***
// ---------------------------------- //
// Manage events
foreach (Event in PendingEvents) {
	// ---------------------------------- //
	// On player throws object
	if (Event.Type == CSmModeEvent::EType::OnPlayerThrowsObject) {
		if (Event.Player.Id != G_CurBallCarrierId && Event.Object != G_MobileBall) continue;
		Inventory::SetItemAmount(Event.Player, "Ball", 0);
		SetBallIsOnCheckpoint(False);
		SetBallRespawnTime(-1);
		SetBallCarrier(Null);
		G_BallDroppedTime = Now;
	}
	// ---------------------------------- //
	// On player removed
	else if (Event.Type == CSmModeEvent::EType::OnPlayerRemoved) {
		if (G_BallIsCheckpoint || G_BallDroppedTime > 0) continue;
		if (Players.existskey(G_CurBallCarrierId)) continue;
		G_MobileBall.SetPosition(Event.PlayerLastPosition + C_BallDropPosOffset);

		SetBallIsOnCheckpoint(False);
		SetBallRespawnTime(-1);
		SetBallCarrier(Null);
		G_BallDroppedTime = Now;

		Translations::SendBigMessage(
			["$<%1$> dropped the Ball!", Event.User.Name], 2000, 1,
			CUIConfig::EUISound::PhaseChange, 0
		);
	}
	// ---------------------------------- //
	// On command
	else if (Event.Type == CSmModeEvent::EType::OnCommand) {
		switch (Event.CommandName) {
			// ---------------------------------- //
			// Force clan 1 points
			case "Command_CurrentMapPointsClan1": {
				if (Event.CommandValueInteger < 0) ClanScores[1] = 0;
				else ClanScores[1] = Event.CommandValueInteger;
				MM_SetScores([ClanScores[1], ClanScores[2]]);
			}
			// ---------------------------------- //
			// Force clan 2 points
			case "Command_CurrentMapPointsClan2": {
				if (Event.CommandValueInteger < 0) ClanScores[2] = 0;
				else ClanScores[2] = Event.CommandValueInteger;
				MM_SetScores([ClanScores[1], ClanScores[2]]);
			}
			// ---------------------------------- //
			// Force warm-up
			case "Command_ForceWarmUp": {
				if (!Event.CommandValueBoolean) continue;

				UIManager.UIAll.CountdownEndTime = -1;
				GT_DisableTimeLimit();

				GT_InitWarmUp(S_NbPlayersPerTeamMax);
				GT_DoWarmUp(S_WarmUpDuration, S_NbPlayersPerTeamMax);

				StartTime = Now;
				SetGameplayPhase(G_CurGameplayPhase);
				UpdateTimeLimit = True;
				ResetBall();
			}
		}
	}
}

// ---------------------------------- //
// On gameplay phase change
if (UIManager.UIAll.CountdownEndTime > 0 && Now >= UIManager.UIAll.CountdownEndTime) {
	UpdateTimeLimit = True;
	
	if (G_CurGameplayPhase == C_GameplayPhase_Normal) {
		declare NextPhase = C_GameplayPhase_Reduction;
		if (S_TimeLimitReduction <= 0) NextPhase = C_GameplayPhase_Instant;
		SetGameplayPhase(NextPhase);
	}
	else SetGameplayPhase(C_GameplayPhase_Instant);

	// Revert gauge max
	foreach (MapLandmark in G_ClanGoalLandmarks) MapLandmark.Gauge.Max = C_GoalPostLoadingTime;
	
	// ---------------------------------- //
	// New phase notification
	declare SoundVariant = 0;
	if (G_CurGameplayPhase == C_GameplayPhase_Instant) SoundVariant = 1;
	UIManager.UIAll.SendNotice(
		"", CUIConfig::ENoticeLevel::Default,
		Null, CUIConfig::EAvatarVariant::Default,
		CUIConfig::EUISound::PhaseChange, SoundVariant
	);
}

// ---------------------------------- //
// Update the time limit
if (PrevTimeLimitNormal != S_TimeLimitNormal) {
	PrevTimeLimitNormal = S_TimeLimitNormal;
	UpdateTimeLimit = True;
}
if (PrevTimeLimitReduction != S_TimeLimitReduction) {
	PrevTimeLimitReduction = S_TimeLimitReduction;
	UpdateTimeLimit = True;
}
if (PrevTimeLimitInstant != S_TimeLimitInstant) {
	PrevTimeLimitInstant = S_TimeLimitInstant;
	UpdateTimeLimit = True;
}
if (UpdateTimeLimit) {
	SB_SetTimeLimit(S_TimeLimitNormal, S_TimeLimitReduction, S_TimeLimitInstant);
	UpdateTimeLimit = False;
}

// ---------------------------------- //
// Start respawn countdown after Ball stops its movement
if (G_MobileBall.Status == CSmObject::EStatus::InWorld) {
	declare Pos = G_MobileBall.Position;
	declare G_MobileBall_Speed = ML::Distance(PrevMobileBallPosition, Pos) * C_ScriptTicksPerSecond;

	// ---------------------------------- //
	// Bounce the ball in danger situations
	if (S_BallDropPhysicsMode == 2 && !G_BallHasBeenBounced) {
		// Under water
		if (G_MobileBall.Position.Y < 0) {
			G_MobileBall.SetPositionAndVel(G_MobileBall.Position, G_MobileBall.Vel * -1.);
			G_BallHasBeenBounced = True;
		}

		// Over a cliff
		if (G_MobileBall.Position.Y < BallCarrierLastPosition.Y && BallCarrierIsTouchingGround) {
			G_MobileBall.SetPositionAndVel(G_MobileBall.Position, G_MobileBall.Vel * -1.);
			G_BallHasBeenBounced = True;
		}
	}

	// ---------------------------------- //
	// Update markers position
	if (PrevMobileBallPosition != Pos) {
		MiniMap::SetMarker("SpeedBall", "Ball.png", <1., 1., 1.>, Pos);
		SetBallMarker(Pos);
		PrevMobileBallPosition = Pos;
	}

	// ---------------------------------- //
	// Trigger ball respawn counter
	if (G_BallRespawnTime <= 0) {
		if (G_MobileBall_Speed > C_BallRespawnMaxSpeed) {
			SetBallRespawnTime(-1);
			LastBallMovementTime = Now;
		}
		if (Now > LastBallMovementTime + C_BallRespawnSetDelay) {
			SetBallRespawnTime(Now + C_BallRespawnDuration);
			LastBallMovementTime = -1;
		}
	}

	// Unspawn ball under map
	if (G_MobileBall.Position.Y < -50.) ResetBall();
}

// Drop Ball if carrier goes into spectator mode
if (G_CurBallCarrierId != NullId && !Players.existskey(G_CurBallCarrierId) && AllPlayers.existskey(G_CurBallCarrierId))
	DropBall(AllPlayers[G_CurBallCarrierId]);

// Reset Ball if it's too long on the ground
if (G_BallRespawnTime > 0 && Now >= G_BallRespawnTime) ResetBall();

// Reset ball if it lays not respawning for too long
if (G_BallDroppedTime > 0 && G_BallRespawnTime <= 0 && Now >= G_BallDroppedTime + C_BallMaxLifeDuration) ResetBall();

// ---------------------------------- //
// Update central Ball visibility
if (PrevBallIsCheckpoint != G_BallIsCheckpoint) {
	PrevBallIsCheckpoint = G_BallIsCheckpoint;

	// ---------------------------------- //
	// Ball returns to the Checkpoint
	if (G_BallIsCheckpoint) {
		G_StaticBall.SetPosition(G_CheckpointBallPos);
		G_MobileBall.SetUnspawned();
		MiniMap::Flash();

		Translations::SendBigMessage(
			"The Ball has been reset!", 2000, 1,
			CUIConfig::EUISound::PhaseChange, 1
		);

		MiniMap::SetMarker("SpeedBall", "Ball.png", <1., 1., 1.>, G_CheckpointBallPos);
		SetBallMarker(G_CheckpointBallPos + <0., -.5, 0.>);
	}
	// ---------------------------------- //
	// Ball is somewhere else
	else G_StaticBall.SetUnspawned();
}

// ---------------------------------- //
// Capture goals
foreach (Clan => MapLandmark in G_ClanGoalLandmarks) {
	if (G_CurGameplayPhase == C_GameplayPhase_Instant) break;
	declare IsBeingCaptured = MapLandmark.Sector.PlayersIds.exists(G_CurBallCarrierId) && Players[G_CurBallCarrierId].CurrentClan != Clan;

	// ---------------------------------- //
	// Reset Goal if loading is stopped
	if (!IsBeingCaptured) {
		if (MapLandmark.Gauge.ValueReal != 0) {
			MapLandmark.Gauge.ValueReal = 0.;
			MapLandmark.Gauge.Speed = 0;
			MapLandmark.Base.IsActive = False;
		}
	}
	// ---------------------------------- //
	// Start capturing
	else if (MapLandmark.Gauge.Speed <= 0) {
		MapLandmark.Gauge.Speed = 1;
		MapLandmark.Base.IsActive = True;
	}
	
	if (!IsBeingCaptured) continue;

	// ---------------------------------- //
	// Manage goal loading time
	MapLandmark.Gauge.Max = C_GoalPostLoadingTime;
	MapLandmark.Gauge.Captured = MapLandmark.Gauge.ValueReal >= 1;

	if (G_CurGameplayPhase == C_GameplayPhase_Reduction) {
		declare RemainingTimeRatio = (UIManager.UIAll.CountdownEndTime - Now) / (S_TimeLimitReduction * 1000.);
		MapLandmark.Gauge.Max = ML::Max(ML::FloorInteger(RemainingTimeRatio * C_GoalPostLoadingTime), 1);
	}

	// Update max gauge value
	if (MapLandmark.Gauge.ValueReal > GetGaugeMaxValue(MapLandmark.Gauge.Clan))
		SetGaugeMaxValue(MapLandmark.Gauge.Clan, MapLandmark.Gauge.ValueReal);

	// ---------------------------------- //
	// Stop the round when Goal is captured
	if (MapLandmark.Gauge.ValueReal >= 1) {
		declare Player = Players[G_CurBallCarrierId];
		RoundWinningClan = Player.CurrentClan;
		MapLandmark.Base.Clan = RoundWinningClan;
		ClanScores[RoundWinningClan] += 1;
		MiniMap::Flash();

		Scores::AddPlayerRoundPoints(Player.Score, 5);
		TopScores::AddPoints(Player.Score, "BallTime", 5);
		TopScores::AddPoints(Player.Score, "CaptureAttempt", 100);
		Statistics::TrackEvent(Player, "SpeedBallScores", 1);

		Translations::SendBigMessage(
			["$<%1$> scores for $<%2$>!", Player.User.Name, Teams[RoundWinningClan-1].ColorizedName],
			3000, 1, CUIConfig::EUISound::VictoryPoint, 1
		);
		MB_StopRound();
	}
}

// ---------------------------------- //
// Manage player functions
foreach (Player in Players) {
	declare Real LastCaptureAttempt for Player;

	// ---------------------------------- //
	// Spawn players
	if (Player.SpawnStatus == CSmPlayer::ESpawnStatus::NotSpawned && !Player.RequestsSpectate && GT_IsValidPlayer(Player)) {
		GT_InitPlayer(Player);

		// Reset player
		Player.UseAlternateWeaponVisual = False;
		Player.ThrowSpeed = C_PlayerBallThrowSpeed;
		LastCaptureAttempt = 0.;

		// Add Ball to the inventory
		Inventory::CreateItemSlot(Player, "Ball", CSmModeEvent::EActionInput::None, 0, "Ball.png");
		
		// Spawn player
		declare PlayerSpawn <=> G_ClanSpawnLandmarks[Player.CurrentClan].PlayerSpawn;
		SM::Spawn(Player, Player.CurrentClan, PlayerSpawn, Now + S_RespawnTime);
	}

	// ---------------------------------- //
	// Manage captured landmark
	if (Player.Id == G_CurBallCarrierId && Player.CapturedLandmark == G_ClanGoalLandmarks[3-Player.CurrentClan]) {
		declare MapLandmark <=> Player.CapturedLandmark;
		LastCaptureAttempt = MapLandmark.Gauge.ValueReal;

		// ---------------------------------- //
		// Instant capture phase
		if (G_CurGameplayPhase == C_GameplayPhase_Instant) {
			MapLandmark.Base.Clan = RoundWinningClan;
			MapLandmark.Gauge.ValueReal = 1.;
			MapLandmark.Gauge.Captured = True;

			RoundWinningClan = Player.CurrentClan;
			ClanScores[RoundWinningClan] += 1;
			SetGaugeMaxValue(MapLandmark.Gauge.Clan, MapLandmark.Gauge.ValueReal);

			Scores::AddPlayerRoundPoints(Player.Score, 5);
			TopScores::AddPoints(Player.Score, "BallTime", 5);
			TopScores::AddPoints(Player.Score, "CaptureAttempt", 100);
			Statistics::TrackEvent(Player, "SpeedBallScores", 1);

			Translations::SendBigMessage(
				["$<%1$> scores for $<%2$>!", Player.User.Name, Teams[RoundWinningClan-1].ColorizedName],
				3000, 1, CUIConfig::EUISound::VictoryPoint, 1
			);
			MB_StopRound();
		}
	}
	// ---------------------------------- //
	// Capture attempt points
	else if (LastCaptureAttempt != 0) {
		TopScores::AddPoints(Player.Score, "CaptureAttempt", ML::NearestInteger(LastCaptureAttempt * 100));
		LastCaptureAttempt = 0.;
	}

	// Pick up Ball from checkpoint
	if (G_BallIsCheckpoint && Player.CapturedLandmark == G_CentralCheckpointLandmark) PickUpBall(Player);

	// ---------------------------------- //
	// Count ball time of the player
	if (Player.Id == G_CurBallCarrierId) {
		declare TimeUnit = 1000 / C_ScriptTicksPerSecond;
		ClansBallTime[Player.CurrentClan] += TimeUnit;

		declare Integer PlayerBallTime for Player.Score;
		declare Integer PrevPlayerBallTime for Player.Score;
		PlayerBallTime += TimeUnit;

		if (C_BallTimePerPoint > 0 && PlayerBallTime - PrevPlayerBallTime >= C_BallTimePerPoint) {
			PrevPlayerBallTime = PlayerBallTime;
			Scores::AddPlayerRoundPoints(Player.Score, 1);
			TopScores::AddPoints(Player.Score, "BallTime", 1);
		}

		// ---------------------------------- //
		// Ball re-bounce mechanics
		BallCarrierLastPosition = Player.Position;
		if (Player.IsTouchingGround) BallCarrierIsTouchingGround = True;
		else if (ML::Abs(Player.Position.Y - BallCarrierLastPosition.Y) > .25)
			BallCarrierIsTouchingGround = False;
	}
}

// Victory conditions
if (GT_TimeReachedLimit()) MB_StopRound();
***

// ---------------------------------- //
// End play loop
// ---------------------------------- //
***Match_EndPlayLoop***
***
UIManager.UIAll.CountdownEndTime = -1;
Layers::Detach("SpeedBall:Markers");

MiniMap::DestroyMarker("SpeedBall");
Markers::RemoveMarker("SpeedBall");
for (I, 1, 2) {
	MiniMap::DestroyMarker("Goal#"^I);
	Markers::RemoveMarker("Goal#"^I);
}
***

// ---------------------------------- //
// Round end
// ---------------------------------- //
***Match_EndRound***
***
SM::UnspawnAllPlayers();
ResetBall();
ObjectDestroy(G_MobileBall);
ObjectDestroy(G_StaticBall);

// ---------------------------------- //
// Prevent poles from self-capturing
foreach (MapLandmark in G_ClanGoalLandmarks) {
	if (MapLandmark == Null || MapLandmark.Gauge == Null) continue;
	MapLandmark.Gauge.Speed = 0;
}

MB_Sleep(3000);

// Detach the interface
Layers::Detach("SpeedBall:Interface");
Message::CleanBigMessages();
StartTime = -1;

// ---------------------------------- //
// Select round winner if none
if (RoundWinningClan <= 0) {
	// ---------------------------------- //
	// From ball time
	if (S_BallTimeSelectWinner) {
		if (ClansBallTime[1] != ClansBallTime[2]) {
			declare TimeAdvantage = 0;
			foreach (Clan => TotalBallTime in ClansBallTime) {
				if (Clan == 0 || TotalBallTime < ClansBallTime[3-Clan]) continue;
				TimeAdvantage = TotalBallTime - ClansBallTime[3-Clan];
				RoundWinningClan = Clan;
				break;
			}

			ClanScores[RoundWinningClan] += 1;

			declare TimeAdvantageText = TimeAdvantage^"ms";
			if (TimeAdvantage >= 1000) TimeAdvantageText = TL::FormatReal(TimeAdvantage / 1000., 2, False, False)^"s";
			Translations::SendStatusMessage(["$<%1$> held the ball for %2 longer.", Teams[RoundWinningClan-1].ColorizedName, TimeAdvantageText], 6000, 1);
		}
		// ---------------------------------- //
		// Those losers still managed to end in a draw
		else if (ClansBallTime[1] > 0 && ClansBallTime[2] > 0) {
			Translations::SendStatusMessage(["Both teams held the ball equally long. Don't ask me how."], 6000, 1);
		} else {
			Translations::SendStatusMessage(["No one bothered to even pick up the ball. Seriously?"], 6000, 1);
		}
	}
	// ---------------------------------- //
	// From highest capture attempt
	else {
		declare ClansMaxValues = [1 => GetGaugeMaxValue(1), 2 => GetGaugeMaxValue(2)];
		declare CaptureAdvantage = 0.;

		foreach (Clan => MaxValue in ClansMaxValues) {
			if (MaxValue <= ClansMaxValues[3-Clan]) continue;
			CaptureAdvantage = MaxValue - ClansMaxValues[3-Clan];
			RoundWinningClan = Clan;
			break;
		}

		if (RoundWinningClan > 0) {
			ClanScores[RoundWinningClan] += 1;
			declare CaptureAdvantageText = TL::FormatReal(CaptureAdvantage * 100., 2, False, False)^"%";
			Translations::SendStatusMessage(["$<%1$> performed %2 more successful capture attempt.", Teams[RoundWinningClan-1].ColorizedName, CaptureAdvantageText], 6000, 1);
		}
	}
}

// ---------------------------------- //
// Announce the winner
UIManager.UIAll.UISequence = CUIConfig::EUISequence::EndRound;
UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::ForcedVisible;

declare Msg = _("|Match|Draw");
if (RoundWinningClan != 0) Msg = TL::Compose(_("$<%1$> wins the round!"), Teams[RoundWinningClan-1].ColorizedName);
Message::SendBigMessage(Msg, 6000, 0, CUIConfig::EUISound::EndRound, 0);

MB_Sleep(6000);

UIManager.UIAll.ScoreTableVisibility = CUIConfig::EVisibility::Normal;
UIManager.UIAll.BigMessage = "";

// ---------------------------------- //
// Map end conditions
declare MatchWiningClan = GT_GetMatchWinner(S_RoundsToWin, S_RoundGapToWin, S_RoundsLimit);
if (MatchWiningClan > 0) MB_StopMatch();
***

// ---------------------------------- //
// Server end
// ---------------------------------- //
***Match_EndServer***
***
Layers::Destroy("SpeedBall:Interface");
Layers::Destroy("SpeedBall:Markers");
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Set the current gameplay phase.
 *
 *	@param	_GameplayPhase	Current gameplay phase.
 */
Void SetGameplayPhase(Integer _GameplayPhase) {
	declare GameplayPhase = ML::Clamp(_GameplayPhase, 0, 2);

	declare netwrite Integer Net_SpeedBall_GameplayPhase for Teams[0];
	Net_SpeedBall_GameplayPhase = GameplayPhase;
	G_CurGameplayPhase = GameplayPhase;
	G_PhaseStartTime = ML::Max(StartTime, Now);
}

// ---------------------------------- //
/** Set up the time limit for the current phase.
 *
 *	@param	_Normal		Time limit for the normal phase.
 *	@param	_Reduction	Time limit for the reduction phase.
 *	@param	_Instant	Time limit for the instant capture.
 */
Void SB_SetTimeLimit(Integer _Normal, Integer _Reduction, Integer _Instant) {
	declare PhaseEndTime = -1;
	declare IsPhaseInfinite = False;
	declare IsLastPhase = False;

	switch (G_CurGameplayPhase) {
		// ---------------------------------- //
		// Normal phase
		case C_GameplayPhase_Normal : {
			PhaseEndTime = G_PhaseStartTime + _Normal * 1000;
			IsPhaseInfinite = _Normal <= 0;
			IsLastPhase = _Reduction <= 0 && _Instant <= 0;
		}
		// ---------------------------------- //
		// Reduction phase
		case C_GameplayPhase_Reduction : {
			PhaseEndTime = G_PhaseStartTime + _Reduction * 1000;
			IsPhaseInfinite = _Reduction <= 0;
			IsLastPhase = _Instant <= 0;
		}
		// ---------------------------------- //
		// Instant capture
		case C_GameplayPhase_Instant : {
			PhaseEndTime = G_PhaseStartTime + _Instant * 1000;
			IsPhaseInfinite = _Instant <= 0;
			IsLastPhase = True;
		}
	}

	// Phase is infinite
	if (IsPhaseInfinite) {
		UIManager.UIAll.CountdownEndTime = -1;
		GT_SetTimeLimit(-1, False, False);
	}
	// There are no phases after this one
	else if (IsLastPhase) {
		UIManager.UIAll.CountdownEndTime = -1;
		GT_SetTimeLimit(PhaseEndTime, False, False);
	}
	// Set up short timer
	else {
		UIManager.UIAll.CountdownEndTime = PhaseEndTime;
		GT_SetTimeLimit(-1, False, False);
	}
}

// ---------------------------------- //
/** Set the position of the ball marker.
 *
 *	@param	_Position	Position of the marker.
 */
Void SetBallMarker(Vec3 _Position) {
	declare MarkerVisibility = "WhenInFrustum";
	if (S_BallAlwaysVisible) MarkerVisibility = "Always";

	Markers::AddMarker("SpeedBall", """<marker
		manialinkframeid="Frame_BallMarker" box="0 1.25 0"
		pos="{{{_Position.X^" "^_Position.Y^" "^_Position.Z}}}"
		minimapvisibility="Never" visibility="{{{MarkerVisibility}}}"
	/>""");
}

// ---------------------------------- //
/** Set the player to attach the ball marker.
 *
 *	@param	_Player		Player to attach the marker.
 */
Void SetBallMarker(CSmPlayer _Player) {
	if (_Player == Null) return;
	declare MarkerVisibility = "WhenInFrustum";
	if (S_BallAlwaysVisible) MarkerVisibility = "Always";

	Markers::AddMarker("SpeedBall", """<marker
		manialinkframeid="Frame_BallMarker" playerlogin="{{{_Player.User.Login}}}"
		minimapvisibility="Never" visibility="{{{MarkerVisibility}}}"
	/>""");
}

// ---------------------------------- //
/** Set the Ball respawn time.
 *
 *	@param	_RespawnTime	Ball respawn time.
 */
Void SetBallRespawnTime(Integer _RespawnTime) {
	declare netwrite Integer Net_SpeedBall_BallRespawnTime for Teams[0];
	Net_SpeedBall_BallRespawnTime = _RespawnTime;
	G_BallRespawnTime = _RespawnTime;
}

// ---------------------------------- //
/** Set the current Ball carrier.
 *
 *	@param	_Player		Current Ball carrier.
 */
Void SetBallCarrier(CSmPlayer _Player) {
	declare netwrite Text Net_SpeedBall_BallCarrierLogin for Teams[0];

	if (_Player == Null) {
		G_CurBallCarrierId = NullId;
		Net_SpeedBall_BallCarrierLogin = "";
	} else {
		G_CurBallCarrierId = _Player.Id;
		Net_SpeedBall_BallCarrierLogin = _Player.User.Login;
	}

	if (G_CentralCheckpointLandmark != Null && G_CentralCheckpointLandmark.Base != Null) {
		G_CentralCheckpointLandmark.Base.Clan = 0;
		if (_Player != Null) G_CentralCheckpointLandmark.Base.Clan = _Player.CurrentClan;
	}

	// Force auto spectator
	UIManager.UIAll.SpectatorAutoTarget = G_CurBallCarrierId;

	foreach (Player in Players) {
		// White Rocket particles for current Ball carrier
		Player.UseAlternateWeaponVisual = Player == _Player;

		// Health regeneration for ball carrier
		if (Player == _Player) Player.ArmorReplenishGain = C_BallArmorReplenishGain;
		else Player.ArmorReplenishGain = 0;
	}
}

// ---------------------------------- //
/** Set if the Ball is on Checkpoint.
 *
 *	@param	_IsOnCheckpoint		True if Ball is on the Checkpoint.
 */
Void SetBallIsOnCheckpoint(Boolean _IsOnCheckpoint) {
	declare netwrite Boolean Net_SpeedBall_IsOnCheckpoint for Teams[0];
	Net_SpeedBall_IsOnCheckpoint = _IsOnCheckpoint;
	G_BallIsCheckpoint = _IsOnCheckpoint;
}

// ---------------------------------- //
/** Pick up the Ball.
 *
 *	@param	_Player		The player to picked up the Ball.
 *	@param	_IsPass		If it's a pass or not.
 */
Void PickUpBall(CSmPlayer _Player, Boolean _IsPass) {
	if (_Player == Null || _Player.SpawnStatus != CSmPlayer::ESpawnStatus::Spawned || _Player.IsBot) return;

	SetBallIsOnCheckpoint(False);
	SetBallRespawnTime(-1);
	SetBallCarrier(_Player);
	G_BallDroppedTime = -1;
	G_BallHasBeenBounced = False;

	// Set the Ball state
	if (S_UseThrowableBall) G_MobileBall.SetPlayer(_Player);
	else G_MobileBall.SetUnspawned();

	// Add points
	Scores::AddPlayerRoundPoints(_Player.Score, 2);
	TopScores::AddPoints(_Player.Score, "BallTime", 2);
	Inventory::SetItemAmount(_Player, "Ball", 1);
	Statistics::TrackEvent(_Player, "SpeedBallPickUp", 1);

	// Sound
	declare Sound = CUIConfig::EUISound::PhaseChange;
	if (_IsPass) Sound = CUIConfig::EUISound::Warning;

	// Team color
	declare TeamColor = "FFF";
	if (_Player.CurrentClan > 0) TeamColor = TL::ColorToText(Teams[_Player.CurrentClan - 1].ColorPrimary);

	Translations::SendBigMessage(["$<%1$> has the $<$%2Ball$>!", _Player.User.Name, TeamColor], 2000, 1, Sound, 0);
	Interfancy::SendCrosshairNote(_Player, ["Shoot to pass the Ball"], 2000);

	MiniMap::SetMarker("SpeedBall", "Ball.png", Color::HsvToRgb(<_Player.GetLinearHue, 1., 1.>), _Player.User.Login);
	SetBallMarker(_Player);
}

Void PickUpBall(CSmPlayer _Player) {
	PickUpBall(_Player, False);
}

// ---------------------------------- //
/** Drop the Ball.
 *
 *	@param	_Player		The player who drops the Ball.
 */
Void DropBall(CSmPlayer _Player) {
	if (_Player == Null || _Player.Id != G_CurBallCarrierId) return;

	SetBallIsOnCheckpoint(False);
	SetBallRespawnTime(-1);
	SetBallCarrier(Null);
	G_BallDroppedTime = Now;

	declare BallVelocity = _Player.Velocity;
	if (S_BallDropPhysicsMode == 0) BallVelocity = <0., 0., 0.>;
	G_MobileBall.SetPositionAndVel(_Player.Position + C_BallDropPosOffset, BallVelocity);

	MiniMap::DestroyMarker("SpeedBall");
	
	Translations::SendBigMessage(
		["$<%1$> dropped the Ball!", _Player.User.Name], 2000, 1,
		CUIConfig::EUISound::PhaseChange, 0
	);
}

// ---------------------------------- //
/// Reset the Ball.
Void ResetBall() {
	SetBallIsOnCheckpoint(True);
	SetBallRespawnTime(-1);
	SetBallCarrier(Null);
	G_BallDroppedTime = -1;
}

// ---------------------------------- //
/** Update max gauge ratio.
 *
 *	@param	_Clan	The clan to update.
 *	@param	_Ratio	The ratio to update.
 */
Void SetGaugeMaxValue(Integer _Clan, Real _Ratio) {
	declare netwrite Integer Net_SpeedBall_LastMaxValueUpdate for Teams[0];
	declare netwrite Real[Integer] Net_SpeedBall_GaugeMaxValues for Teams[0];
	if (Net_SpeedBall_GaugeMaxValues.existskey(_Clan) && Net_SpeedBall_GaugeMaxValues[_Clan] >= _Ratio) return;
	Net_SpeedBall_LastMaxValueUpdate = Now;
	Net_SpeedBall_GaugeMaxValues[_Clan] = _Ratio;
}

// ---------------------------------- //
/** Update max gauge ratio.
 *
 *	@param	_Clan	The clan to update.
 *
 *	@return		The clan's max gauge ratio.
 */
Real GetGaugeMaxValue(Integer _Clan) {
	declare netwrite Real[Integer] Net_SpeedBall_GaugeMaxValues for Teams[0];
	if (!Net_SpeedBall_GaugeMaxValues.existskey(_Clan)) return 0.;
	return Net_SpeedBall_GaugeMaxValues[_Clan];
}

// ---------------------------------- //
/// Reset gauges max values.
Void ResetGaugeMaxValue() {
	declare netwrite Integer Net_SpeedBall_LastMaxValueUpdate for Teams[0];
	declare netwrite Real[Integer] Net_SpeedBall_GaugeMaxValues for Teams[0];
	Net_SpeedBall_LastMaxValueUpdate = Now;
	Net_SpeedBall_GaugeMaxValues = [1 => 0., 2 => 0.];
}

// ---------------------------------- //
/** Create manialink for the interface module.
 *
 *	@return		The interface manialink.
 */
Text CreateManialinkInterface() {
	return """
<manialink version="3" name="SpeedBall:Interface">
<stylesheet>
	<style id="Label_CountdownInfo" textsize="1" textfont="Eurostile_Bold" textcolor="FFF" />
	<style class="EscapeMessage" halign="center" valign="center2" textemboss="1" textfont="Eurostile_Bold" textcolor="FFF" />
	<style class="BallCarrier" halign="center" valign="center" size="20 20" image="{{{C_ImgBase}}}BallCarrier.png" opacity=".875" />
	<style class="desc" halign="center" valign="center2" textsize="1" textcolor="FFF" textemboss="1" textfont="Eurostile_Bold" />
	<style class="CircGauge" size="16 16" halign="center" valign="center" colorize="FFF" />
</stylesheet>

<frame id="Frame_CountdownInfo" pos="0 81.25">
	<label halign="center" valign="center2" textprefix="$t$s" id="Label_CountdownInfo" />
</frame>

<frame id="Frame_BallCarrier">
	<quad class="BallCarrier" id="Quad_BallCarrierL" opacity="0" pos="-30" />
	<quad class="BallCarrier" id="Quad_BallCarrierR" opacity="0" pos="30" rot="180" />
</frame>

<frame id="Frame_GaugeMessage" pos="0 -54">
	<frame id="Frame_GaugeMessageAnim">
		<label class="EscapeMessage" id="Label_CurLandmarkMessage" />
		<quad pos="0 8" size="12 12" halign="center" valign="center" autoscale="0" id="Quad_CurLandmarkIcon" />
		<gauge pos="0 -3" size="52 8" halign="center" valign="center" drawbg="0" id="Gauge_CurLandmarkValue" hidden="1" />
	</frame>
</frame>

<frame id="Frame_BallOccupation" pos="0 72">
	<label pos="0 2.75" size="50" class="desc" textsize="2" textcolor="FFF" id="Label_BallCarrierName" />
	<quad size="54 3.5" scale=".75" halign="center" valign="center" image="{{{C_ImgBase}}}ColorSeparator.png" id="Quad_BallCarrierColor" />
	<label pos="0 -2.5" class="desc" id="Label_BallCarrierDesc" />
</frame>

<framemodel id="FrameModel_PoleGauge">
	<label pos="0 -2.75" class="EscapeMessage" textsize="2" text="0%" id="Label_Ratio" />
	<quad pos="0 1.25" size="6 6" halign="center" valign="center" style="Emblems" substyle="#0" id="Quad_Emblem" />
	<frame size="8 16" halign="left" valign="center">
		<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeL" hidden="1" />
	</frame>
	<frame size="8 16" halign="right" valign="center">
		<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeProg.png" id="Quad_GaugeR" hidden="1" rot="180" />
	</frame>
	<quad class="CircGauge" image="{{{C_ImgBase}}}CircGaugeBg.png" id="Quad_GaugeBg" />
	<quad
		size="14 14" halign="center" valign="center"
		image="file://Media/Manialinks/Common/disc.dds" colorize="FFF" opacity="0" id="Quad_CaptureAlert"
	 />
</framemodel>

<frameinstance modelid="FrameModel_PoleGauge" id="Frame_PoleGauge#1" scale=".875" pos="-40 82" />
<frameinstance modelid="FrameModel_PoleGauge" id="Frame_PoleGauge#2" scale=".875" pos="40 82" />

<!--
	Playerlist attributes:
	- substyle: Small, Medium, Big
	- lines
	- columns
	- team: 0, 1, 2
	- status: Playing, Spectating
	- logins
-->

<frame pos="-160 72" id="Frame_PlayersList_1">
	<playerlist pos="0 -3" scale=".67" halign="left" lines="3" columns="1" substyle="Medium" team="1" status="Playing" />
	<frame>
		<quad pos=".5 1.5" size="7 7" halign="left" valign="center" style="Emblems" substyle="#1" /> 
		<label pos="8 .4" size="28 3.5" halign="left" valign="center" textsize="2" textemboss="1" text="Blue" id="Label_Team1Name" />
		<quad pos=".25" size="39.45 3.5" halign="left" valign="center" bgcolor="FFF8" />
	</frame>
</frame>

<frame pos="160 72" id="Frame_PlayersList_2">
	<playerlist pos="0 -3" scale=".67" halign="right" lines="3" columns="1" substyle="Medium" team="2" status="Playing" />
	<frame>
		<quad pos="-.5 1.5" size="7 7" halign="right" valign="center" style="Emblems" substyle="#2" /> 
		<label pos="-8 .4" size="28 3.5" halign="right" valign="center" textsize="2" textemboss="1" text="Red" id="Label_Team1Name" />
		<quad pos="-.25" size="39.45 3.5" halign="right" valign="center" bgcolor="FFF8" />
	</frame>
</frame>

<script><!--

#Include "MathLib" as ML
#Include "TextLib" as TL

#Const C_GoalIconsPath "file://Media/Manialinks/ShootMania/Common/"

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Label_CountdownInfo	<=> (Page.GetFirstChild("Label_CountdownInfo") as CMlLabel);
declare Quad_BallCarrierL	<=> (Page.GetFirstChild("Quad_BallCarrierL") as CMlQuad);
declare Quad_BallCarrierR	<=> (Page.GetFirstChild("Quad_BallCarrierR") as CMlQuad);
declare Frame_BallOccupation	<=> (Page.GetFirstChild("Frame_BallOccupation") as CMlFrame);
declare Quad_BallCarrierColor	<=> (Page.GetFirstChild("Quad_BallCarrierColor") as CMlQuad);
declare Label_BallCarrierDesc	<=> (Page.GetFirstChild("Label_BallCarrierDesc") as CMlLabel);
declare Label_BallCarrierName	<=> (Page.GetFirstChild("Label_BallCarrierName") as CMlLabel);
declare Frame_GaugeMessageAnim		<=> (Page.GetFirstChild("Frame_GaugeMessageAnim") as CMlFrame);
declare Label_CurLandmarkMessage	<=> (Page.GetFirstChild("Label_CurLandmarkMessage") as CMlLabel);
declare Quad_CurLandmarkIcon		<=> (Page.GetFirstChild("Quad_CurLandmarkIcon") as CMlQuad);
declare Gauge_CurLandmarkValue		<=> (Page.GetFirstChild("Gauge_CurLandmarkValue") as CMlGauge);

declare Frame_PolesGauges = [
	1 => (Page.GetFirstChild("Frame_PoleGauge#1") as CMlFrame),
	2 => (Page.GetFirstChild("Frame_PoleGauge#2") as CMlFrame)
];

Label_BallCarrierDesc.Value = TL::ToUpperCase(Translate("Ball"));

// ---------------------------------- //
// Persistent settings
declare persistent Boolean Persistent_SpeedBall_CarrierInfoCorner for LocalUser;

// ---------------------------------- //
// Net variables
declare netread Text Net_SpeedBall_BallCarrierLogin for Teams[0];
declare netread Integer Net_SpeedBall_BallRespawnTime for Teams[0];
declare netread Boolean Net_SpeedBall_IsOnCheckpoint for Teams[0];
declare netread Integer Net_SpeedBall_GameplayPhase for Teams[0];
declare netread Integer Net_SpeedBall_LastMaxValueUpdate for Teams[0];
declare netread Real[Integer] Net_SpeedBall_GaugeMaxValues for Teams[0];

// ---------------------------------- //
// Variables
declare BallCarrierVisible = False;
declare UpdateCarrierMessage = True;
declare GaugeMessageVisible = False;
declare GaugeMessageEndTime = -1;
declare ClansMaxCaptureRatios = [0., 0., 0.];
declare UpdateCaptureGauges = True;

declare PrevGameplayPhase = -1;
declare PrevBallCarrierVisible = False;
declare PrevCarrierLogin = "!";
declare PrevInterfaceColor = -1.;
declare PrevGaugeMessageVisible = False;
declare PrevGaugeMessageClan = -1;
declare PrevGaugeMessageCaptured = True;
declare PrevIsOnCheckpoint = False;
declare PrevMaxCapUpdate = -1;
declare PrevPosSetting = False;

foreach (Team in Teams) {
	declare Vec3 PrevTeamColor for Team;
	PrevTeamColor = Vec3;
}
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update gameplay phase text
if (PrevGameplayPhase != Net_SpeedBall_GameplayPhase) {
	PrevGameplayPhase = Net_SpeedBall_GameplayPhase;

	switch (Net_SpeedBall_GameplayPhase) {
		case {{{C_GameplayPhase_Normal}}} : {
			Label_CountdownInfo.Value = Translate("Normal phase");
			Label_CountdownInfo.TextColor = <1., 1., 1.>;
		}
		case {{{C_GameplayPhase_Reduction}}} : {
			Label_CountdownInfo.Value = Translate("Reduction phase");
			Label_CountdownInfo.TextColor = <1., .75, 0.>;
		}
		case {{{C_GameplayPhase_Instant}}} : {
			Label_CountdownInfo.Value = Translate("Instant capture");
			Label_CountdownInfo.TextColor = <1., 0., 0.>;
		}
	}
}

// Set Ball carrier marks visibility
BallCarrierVisible = GUIPlayer != Null && GUIPlayer.Position != <0., 0., 0.> && GUIPlayer.User.Login == Net_SpeedBall_BallCarrierLogin;

// ---------------------------------- //
// Info position setting
if (PrevPosSetting != Persistent_SpeedBall_CarrierInfoCorner) {
	PrevPosSetting = Persistent_SpeedBall_CarrierInfoCorner;

	if (PrevPosSetting) Frame_BallOccupation.RelativePosition_V3 = <130., -60.>;
	else Frame_BallOccupation.RelativePosition_V3 = <0., 72.>;
}

// ---------------------------------- //
// Update Ball carrier marks visibility
if (PrevBallCarrierVisible != BallCarrierVisible) {
	PrevBallCarrierVisible = BallCarrierVisible;
	
	declare Opacity = 0.;
	if (BallCarrierVisible) Opacity = 1.;
	
	AnimMgr.Add(Quad_BallCarrierL, "<quad opacity='"^Opacity^"' />", 200, CAnimManager::EAnimManagerEasing::SineInOut);
	AnimMgr.Add(Quad_BallCarrierR, "<quad opacity='"^Opacity^"' />", 200, CAnimManager::EAnimManagerEasing::SineInOut);
}

// ---------------------------------- //
// Update color
if (BallCarrierVisible) {
	if (PrevInterfaceColor != GUIPlayer.GetLinearHue) {
		PrevInterfaceColor = GUIPlayer.GetLinearHue;

		declare Color = HsvToRgb(<PrevInterfaceColor, 1., 1.>);
		Quad_BallCarrierL.Colorize = Color;
		Quad_BallCarrierR.Colorize = Color;
	}
}

// ---------------------------------- //
// Update Ball message on carrier change
if (PrevCarrierLogin != Net_SpeedBall_BallCarrierLogin) {
	PrevCarrierLogin = Net_SpeedBall_BallCarrierLogin;

	UpdateCarrierMessage = True;
	declare InterfaceColor = <1., 1., 1.>;

	foreach (Player in Players) {
		if (Player.User.Login != Net_SpeedBall_BallCarrierLogin) continue;
		InterfaceColor = HsvToRgb(<Player.GetLinearHue, 1., 1.>);
		break;
	}

	Quad_BallCarrierColor.Colorize = InterfaceColor;
	Label_BallCarrierDesc.TextColor = Brightness(InterfaceColor, 3.);
}

// ---------------------------------- //
// Format the gauge message
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Goal" || MapLandmark.Gauge.Clan <= 0 || MapLandmark.Gauge.Speed <= 0) continue;
	if (!MapLandmark.Gauge.Captured && MapLandmark.Gauge.ValueReal > 0) GaugeMessageEndTime = Now + 1000;

	// ---------------------------------- //
	// Update gauge color
	if (PrevGaugeMessageClan != MapLandmark.Gauge.Clan) {
		PrevGaugeMessageClan = MapLandmark.Gauge.Clan;
		Gauge_CurLandmarkValue.Color = Teams[PrevGaugeMessageClan-1].ColorPrimary;
	}

	// ---------------------------------- //
	// Update gauge message
	if (MapLandmark.Gauge.ValueReal >= 1) Label_CurLandmarkMessage.Value = _("Goal captured!");
	else Label_CurLandmarkMessage.Value = TL::Compose("%1 ("^ML::FloorInteger(MapLandmark.Gauge.ValueReal * 100)^"%%)", _("Capturing"));
	SetGaugeRatio(Gauge_CurLandmarkValue, MapLandmark.Gauge.ValueReal);

	// ---------------------------------- //
	// Update gauge icon
	if (PrevGaugeMessageCaptured != (MapLandmark.Gauge.ValueReal >= 1)) {
		PrevGaugeMessageCaptured = (MapLandmark.Gauge.ValueReal >= 1);

		declare Icon = "c_goal_capture.dds";
		if (PrevGaugeMessageCaptured) Icon = "c_goal_captured.dds";
		Quad_CurLandmarkIcon.ImageUrl = C_GoalIconsPath^Icon;
	}
}

// ---------------------------------- //
// Change gauge message visibility
GaugeMessageVisible = Now <= GaugeMessageEndTime;
if (PrevGaugeMessageVisible != GaugeMessageVisible) {
	PrevGaugeMessageVisible = GaugeMessageVisible;
	
	Gauge_CurLandmarkValue.Visible = GaugeMessageVisible;
	
	declare PositionY = -2.;
	Frame_GaugeMessageAnim.RelativePosition_V3.Y = 0.;
	declare Opacity = 0.;
	Label_CurLandmarkMessage.Opacity = 1.;
	
	if (GaugeMessageVisible) {
		Frame_GaugeMessageAnim.RelativePosition_V3.Y = -PositionY;
		PositionY = 0.;
		Label_CurLandmarkMessage.Opacity = 0.;
		Opacity = 1.;
	}
	
	AnimMgr.Add(Frame_GaugeMessageAnim, "<frame pos='0 "^PositionY^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Label_CurLandmarkMessage, "<label opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
	AnimMgr.Add(Quad_CurLandmarkIcon, "<quad opacity='"^Opacity^"' />", 125, CAnimManager::EAnimManagerEasing::Linear);
}

// ---------------------------------- //
// Checkpoint change
if (PrevIsOnCheckpoint != Net_SpeedBall_IsOnCheckpoint) {
	PrevIsOnCheckpoint = Net_SpeedBall_IsOnCheckpoint;
	UpdateCarrierMessage = True;
}

// Respawn timer forces update
if (Net_SpeedBall_BallRespawnTime > 0) UpdateCarrierMessage = True;

// ---------------------------------- //
// Update Ball carrier message
if (UpdateCarrierMessage) {
	UpdateCarrierMessage = False;

	// ---------------------------------- //
	// Carried by a player
	if (Net_SpeedBall_BallCarrierLogin != "") {
		declare CarrierName = Net_SpeedBall_BallCarrierLogin;
		foreach (Player in Players) {
			if (Player.User.Login != Net_SpeedBall_BallCarrierLogin) continue;
			CarrierName = Player.User.Name;
			break;
		}
		Label_BallCarrierName.Value = CarrierName;
	}
	// ---------------------------------- //
	// On checkpoint
	else if (PrevIsOnCheckpoint) {
		Label_BallCarrierName.Value = TL::ToUpperCase(_("Checkpoint"));
	}
	// ---------------------------------- //
	// Respawning
	else if (Net_SpeedBall_BallRespawnTime > 0) {
		declare Time = ML::Max(Net_SpeedBall_BallRespawnTime - GameTime, 0) / 1000.;
		Label_BallCarrierName.Value = TL::ToUpperCase(Translate("Respawning"))^" - "^TL::FormatReal(Time, 1, False, False);
	}
	// ---------------------------------- //
	// Dropped
	else {
		Label_BallCarrierName.Value = TL::ToUpperCase(Translate("Dropped"));
	}
}

// ---------------------------------- //
// Pole gauge color change
foreach (I => Team in Teams) {
	declare Vec3 PrevTeamColor for Team;
	if (PrevTeamColor == Team.ColorPrimary) continue;
	PrevTeamColor = Team.ColorPrimary;

	declare Frame <=> Frame_PolesGauges[I+1];
	declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
	declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
	declare Quad_GaugeBg <=> (Frame.GetFirstChild("Quad_GaugeBg") as CMlQuad);
	declare Quad_Emblem <=> (Frame.GetFirstChild("Quad_Emblem") as CMlQuad);

	Quad_GaugeL.Colorize = PrevTeamColor;
	Quad_GaugeR.Colorize = PrevTeamColor;
	Quad_GaugeBg.Colorize = PrevTeamColor;
	Quad_Emblem.Substyle = "#"^I+1;
}

// ---------------------------------- //
// Update max value
foreach (MapLandmark in MapLandmarks_Gauge) {
	if (MapLandmark.Tag != "Goal" && (MapLandmark.Order != 1 || MapLandmark.Order != 2)) continue;

	declare Real PrevLandmarkValue for MapLandmark;
	if (PrevLandmarkValue == MapLandmark.Gauge.ValueReal) continue;
	PrevLandmarkValue = MapLandmark.Gauge.ValueReal;

	declare Clan = MapLandmark.Gauge.Clan;
	if (ClansMaxCaptureRatios[Clan] >= PrevLandmarkValue) continue;
	ClansMaxCaptureRatios[Clan] = PrevLandmarkValue;
	UpdateCaptureGauges = True;
}

// ---------------------------------- //
// Update max value on server request
if (PrevMaxCapUpdate != Net_SpeedBall_LastMaxValueUpdate && GameTime > Net_SpeedBall_LastMaxValueUpdate + 500) {
	PrevMaxCapUpdate = Net_SpeedBall_LastMaxValueUpdate;
	foreach (Clan => MaxValue in Net_SpeedBall_GaugeMaxValues) ClansMaxCaptureRatios[Clan] = MaxValue;
	UpdateCaptureGauges = True;
}

// ---------------------------------- //
// Update capture gauges
if (UpdateCaptureGauges) {
	UpdateCaptureGauges = False;

	foreach (Clan => Frame in Frame_PolesGauges) {
		declare GaugeRatio = 0.;
		if (ClansMaxCaptureRatios.existskey(Clan)) GaugeRatio = ML::Clamp(ClansMaxCaptureRatios[Clan], 0., 1.);

		declare Quad_GaugeL <=> (Frame.GetFirstChild("Quad_GaugeL") as CMlQuad);
		declare Quad_GaugeR <=> (Frame.GetFirstChild("Quad_GaugeR") as CMlQuad);
		declare Quad_Emblem <=> (Frame.GetFirstChild("Quad_Emblem") as CMlQuad);
		declare Label_Ratio <=> (Frame.GetFirstChild("Label_Ratio") as CMlLabel);
		
		// ---------------------------------- //
		// Set ratio
		Quad_GaugeL.RelativeRotation = ML::Clamp(GaugeRatio * 360., 0., 180.);
		Quad_GaugeR.RelativeRotation = 180 + ML::Clamp((GaugeRatio - .5) * 360., 0., 180.);
		Quad_GaugeL.Visible = Quad_GaugeL.RelativeRotation > 1.5;
		Quad_GaugeR.Visible = Quad_GaugeR.RelativeRotation > 180;
		
		// ---------------------------------- //
		// Set gauge image
		declare Image = "CircGaugeProg.png";
		if (GaugeRatio >= 1.) Image = "CircGaugeFull.png";
		Quad_GaugeL.ImageUrl = "{{{C_ImgBase}}}"^Image;
		Quad_GaugeR.ImageUrl = Quad_GaugeL.ImageUrl;
		Label_Ratio.Value = ML::FloorInteger(GaugeRatio * 100)^"%";
	}
}
***

{{{ManialinkTools::Functions(["SetGaugeRatio", "HsvToRgb", "Brightness"])}}}
{{{Translations::InjectInManialink(["Normal phase", "Reduction phase", "Instant capture", "Ball", "Dropped", "Respawning"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		yield;
	}
}
--></script>
</manialink>
	""";
}
// ---------------------------------- //
/** Create manialink for the markers module.
 *
 *	@return		The markers manialink.
 */
Text CreateManialinkMarkers() {
	declare R = 9/16.;
	return """
<manialink version="3" name="SpeedBall:Markers">
<framemodel id="FrameModel_GoalMarker">
	<label halign="center" valign="center2" textsize="1" textemboss="1" textfont="Eurostile_Bold" id="Label_MarkerText" />
	<quad pos="0 2.5" size="{{{8*R}}} 8" halign="center" autoscale="0" image="file://Media/Manialinks/ShootMania/Common/target.dds" id="Quad_MarkerIcon" />
</framemodel>

<frameinstance modelid="FrameModel_GoalMarker" scale=".875" id="Frame_MarkerGoal#1" hidden="1" />
<frameinstance modelid="FrameModel_GoalMarker" scale=".875" id="Frame_MarkerGoal#2" hidden="1" />

<frame id="Frame_BallMarker">
	<label
		pos="0 5" halign="center" valign="center2" textemboss="1" textcolor="FFF"
		textfont="Eurostile_Bold" id="Label_BallMarkerText"
	/>
	<quad
		size="{{{7*R}}} 7" halign="center" valign="center" colorize="FFF"
		image="{{{C_ImgBase}}}Minimap/Ball.png" id="Quad_BallMarkerIcon"
	/>
</frame>

<script><!--
#Include "MathLib" as ML
#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
***Main***
***
// ---------------------------------- //
// Load interface elements
declare Label_BallMarkerText <=> (Page.GetFirstChild("Label_BallMarkerText") as CMlLabel);
declare Quad_BallMarkerIcon <=> (Page.GetFirstChild("Quad_BallMarkerIcon") as CMlQuad);

declare Frame_MarkersGoal = [
	1 => (Page.GetFirstChild("Frame_MarkerGoal#1") as CMlFrame),
	2 => (Page.GetFirstChild("Frame_MarkerGoal#2") as CMlFrame)
];

// ---------------------------------- //
// Net variables
declare netread Integer Net_SpeedBall_BallRespawnTime for Teams[0];
declare netread Text Net_SpeedBall_BallCarrierLogin for Teams[0];
declare netread Boolean Net_SpeedBall_IsOnCheckpoint for Teams[0];

// ---------------------------------- //
// Variables
declare UpdateMarkers = True;
declare PrevGUIPlayerLogin = "";
declare PrevBallCarrierLogin = "";
***

// ---------------------------------- //
// Yield
// ---------------------------------- //
***Yield***
***
// ---------------------------------- //
// Update markers on player change
if (GUIPlayer != Null) {
	if (PrevGUIPlayerLogin != GUIPlayer.User.Login) {
		PrevGUIPlayerLogin = GUIPlayer.User.Login;
		UpdateMarkers = True;
	}
} else if (PrevGUIPlayerLogin != "") {
	PrevGUIPlayerLogin = "";
	UpdateMarkers = True;
}

// ---------------------------------- //
// Update markers
if (UpdateMarkers) {
	UpdateMarkers = False;
	
	// ---------------------------------- //
	// Format goals markers
	foreach (Clan => Frame in Frame_MarkersGoal) {
		// ---------------------------------- //
		// Load marker elements
		declare Label_MarkerText <=> (Frame.GetFirstChild("Label_MarkerText") as CMlLabel);
		declare Quad_MarkerIcon <=> (Frame.GetFirstChild("Quad_MarkerIcon") as CMlQuad);
		
		Quad_MarkerIcon.Colorize = Teams[Clan-1].ColorPrimary;
		Label_MarkerText.TextColor = Brightness(Quad_MarkerIcon.Colorize, 2.);
		
		// ---------------------------------- //
		// Set marker text
		declare MarkerText = Teams[Clan-1].Name;
		if (GUIPlayer != Null) {
			if (GUIPlayer.CurrentClan != Clan) MarkerText = _("Capture");
			else MarkerText = _("|Imperative|Defend");
		}
		Label_MarkerText.Value = TL::Compose("$n$t%1", MarkerText);
	}
}

// ---------------------------------- //
// Format Ball respawn timer
Label_BallMarkerText.Visible = Net_SpeedBall_BallRespawnTime > 0;
if (Label_BallMarkerText.Visible) {
	declare Time = ML::Max(Net_SpeedBall_BallRespawnTime - GameTime, 0) / 1000.;
	Label_BallMarkerText.Value = "$n"^TL::FormatReal(Time, 1, False, False);
}

// ---------------------------------- //
// Update Ball marker color
if (PrevBallCarrierLogin != Net_SpeedBall_BallCarrierLogin) {
	PrevBallCarrierLogin = Net_SpeedBall_BallCarrierLogin;

	declare Color = <1., 1., 1.>;
	foreach (Player in Players) {
		if (Player.User.Login != PrevBallCarrierLogin) continue;
		Color = HsvToRgb(<Player.GetLinearHue, 1., 1.>);
		break;
	}
	Quad_BallMarkerIcon.Colorize = Color;
}
***

{{{ManialinkTools::Functions(["HsvToRgb", "Brightness"])}}}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	+++Main+++
	while (True) {
		+++Yield+++
		yield;
	}
}
--></script>
</manialink>
	""";
}