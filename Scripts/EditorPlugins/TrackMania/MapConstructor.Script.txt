// -------------------------------------- //
//  MAP CONSTRUCTOR by domino54           //
//  script version: 2015-07-08            //
// -------------------------------------- //

/**
 *	This plugin GENERATES RANDOM MAP MADAFAKAS!!!
 */

#RequireContext CEditorPlugin

#Include "MathLib" as ML

#Const	Version		"2015-07-09"
#Const	ScriptName	"MapConstructor.Script.txt"

// ---------------------------------- //
// Constants
// ---------------------------------- //

// ---------------------------------- //
// Generator
// ---------------------------------- //
#Const C_CheckpointFrequency 	6		///< Default checkpoint apperance frequency
#Const C_CurveMaxFrequency 		1		///< Default curve apperance frequency
#Const C_PropsMaxFrequency 		2		///< Default props apperance frequency
#Const C_DecoChanceSide			.75		///< Default chance of spawning side decoration
#Const C_DecoChancePillar		.75		///< Default chance of spawning pillar decoration
#Const C_DecoExtraAmount		100		///< Default amount of extra decoration blocks

/// Sizes of the environments
#Const C_Dimensions [
	"Canyon" =>
		["Sunrise" => 32, "Day" => 32, "Sunset" => 32, "Night" => 32],
	"Stadium" =>
		["Sunrise" => 32, "Day" => 32, "Sunset" => 32, "Night" => 32,
		"64x64Sunrise" => 64, "64x64Day" => 64, "64x64Sunset" => 64, "64x64Night" => 64],
	"Valley" => 
		["Sunrise48" => 48, "Day48" => 48, "Sunset48" => 48, "Night48" => 48]
]

// ---------------------------------- //
// Blocks
// ---------------------------------- //

// ---------------------------------- //
// Spawn blocks
#Const C_BlockModels_Spawn [
	// ---------------------------------- //
	// Canyon
	"RoadMainStart",
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMainStartLine",
	// ---------------------------------- //
	// Valley
	"Road2WayStart"
]

// ---------------------------------- //
// Checkpoint blocks
#Const C_BlockModels_Checkpoint [
	// ---------------------------------- //
	// Canyon
	"RoadMainCheckpoint"	=> [<-1, 0, 0>, <0, 0, 0>],
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMainCheckpoint"		=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumRoadMainCheckpointUp"	=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumRoadMainCheckpointDown"	=> [<-1, -1, 0>, <0, 0, 0>],
	// ---------------------------------- //
	// Valley
	"Road2WayCheckpoint"	=> [<-1, 0, 0>, <0, 0, 0>]
]

// ---------------------------------- //
// Finish blocks
#Const C_BlockModels_Finish [
	// ---------------------------------- //
	// Canyon
	"RoadMainFinish",
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMainFinishLine",
	// ---------------------------------- //
	// Valley
	"Road2WayFinish"
]

// ---------------------------------- //
/** Road curve blocks
 *
 *	"CurveBlockName" => [<StartClipPosition>, <EndClipPosition>]
 */
#Const C_BlockModels_Curve [
	// ---------------------------------- //
	// Canton
	"RoadMainGTDiag2X2A"			=> [<-2, 0, 0>, <0, 0, 1>],
	"RoadMainGTDiag2X2MirrorA"		=> [<-2, 0, -1>, <0, 0, 0>],
	"RoadMainGTDiag2X2Down"			=> [<-2, 0, 0>, <0, 0, 1>],
	"RoadMainGTDiag2X2DownMirror"	=> [<-2, 0, -1>, <0, 0, 0>],
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMainGTDiag2x2"			=> [<-2, 0, 0>, <0, 0, 1>],
	"StadiumRoadMainGTDiag2x2Mirror"	=> [<-2, 0, -1>, <0, 0, 0>],
	"StadiumRoadMainGTDiag3x2"			=> [<-3, 0, 0>, <0, 0, 1>],
	"StadiumRoadMainGTDiag3x2Mirror"	=> [<-3, 0, -1>, <0, 0, 0>],
	// ---------------------------------- //
	// Valley
	"Road2WayDiag2"			=> [<-2, 0, -1>, <0, 0, 0>],
	"Road2WayDiag2Mirror"	=> [<-2, 0, 0>, <0, 0, 1>]
]

// ---------------------------------- //
/** Road props blocks
 *
 *	"PropBlockName" => [<StartClipPosition>, <EndClipPosition>]
 */
#Const C_BlockModels_Prop [
	// ---------------------------------- //
	// Canyon
	"RoadMainStraightDown"			=> [<-1, 0, 0>, <0, 0, 0>],
	"RoadMainStraightUp"			=> [<-1, 0, 0>, <0, 0, 0>],
	"RoadMainTreePineBigStraight"	=> [<-1, 0, 0>, <0, 0, 0>],
	// ---------------------------------- //
	// Stadium
	"StadiumHolePillar"				=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumHolePillar2Front"		=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumHolePillar2Line"		=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumHolePillar3"			=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumHole"					=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumRoadStretch"			=> [<-1, 0, 0>, <0, 0, 0>],
	"StadiumRoadMainSlopeBase"		=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumRoadMainSlopeStraight"	=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumRoadMainSlopeBase1x2"	=> [<-2, 0, 0>, <0, 1, 0>],
	"StadiumHolePillarSlope"		=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumHoleSlope"				=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumRoadStretchSlope"		=> [<-1, 0, 0>, <0, 1, 0>],
	"StadiumBump1Slope"				=> [<-1, -1, 0>, <0, 0, 0>],
	"StadiumTrenchXRoadMain"		=> [<-1, -1, 0>, <0, 1, 0>],
	// ---------------------------------- //
	// Valley
	"Road2WayWithoutPole"	=> [<-1, 0, 0>, <0, 0, 0>],
	"Road2WayWithBirds"		=> [<-1, 0, 0>, <0, 0, 0>]
]

// ---------------------------------- //
// Global decoration blocks
#Const C_BlockModels_Deco [
	// ---------------------------------- //
	// Canyon
	"DecoTreesBig1X1",
	"DecoTreesMedium1X1",
	"DecoRocksMedium1X1",
	"DecoCactusMedium1X1",
	"DecoBushesMedium1X1",
	"DecoTreePineBig1X1",
	"DecoReffineryX2",
	"DecoTechnicsAntenna",
	"RoadMainSupport",
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMain",
	"StadiumPlatformGridStraight",
	"StadiumPlatformSlope2Straight",
	"StadiumCircuitPillar5",
	"StadiumRoadDirt",
	"StadiumRoadDirtHigh",
	"StadiumSculptBridgePillar",
	"StadiumSculptBridgePillarMirror",
	"StadiumSculptBridgeSlopeStart",
	"StadiumSculptBridgeSlopeStartMirror",
	"StadiumTubeRoadDown",
	"StadiumFabricStraight1x1",
	"StadiumFabricCornerOut",
	"StadiumInflatableCastle",
	"StadiumInflatableCastleDoor",
	"StadiumInflatableCastleBig",
	"StadiumInflatableCactus",
	"StadiumInflatableSnowTree",
	"StadiumInflatablePalmTree",
	"StadiumControlRoadGlass",
	"StadiumControlRoadPub",
	"StadiumControlRoadCamera",
	"StadiumControlLightBase",
	"StadiumTubeRoadLightSystem",
	"StadiumTubeRoadSoundSystem",
	"StadiumSculptA",
	"StadiumSculptB",
	"StadiumSculptC",
	// ---------------------------------- //
	// Valley
	"RoadDirt",
	"DecoAeolian",
	"DecoTrees",
	"DecoTreesMed",
	"DecoTreesSmall",
	"DecoMayorHouse",
	"DecoHomeSmall",
	"DecoHomeBig",
	"DecoChurch",
	"DecoHomeBigB",
	"DecoOldBusStop"
]

// ---------------------------------- //
// Global tube block
#Const C_BlockModels_Tube [
	// ---------------------------------- //
	// Canyon
	"RoadMainSupport",
	// ---------------------------------- //
	// Stadium
	"StadiumTube"
]

// ---------------------------------- //
/** Sideaway decoration trigger blocks
 *
 *	"RoadBlockName" => [<DecoBlocksPositions>]
 */
#Const C_DecoTriggers_Side [
	// ---------------------------------- //
	// Canyon
	"RoadMainStart"					=> [<0, 0, 1>, <0, 0, -1>],
	"RoadMainCheckpoint"			=> [<0, 0, 1>, <0, 0, -1>],
	"RoadMainFinish"				=> [<0, 0, 1>, <0, 0, -1>],
	"RoadMainGTDiag2X2A"			=> [<1, 0, 1>, <0, 0, -2>, <0, 0, 1>, <1, 0, -2>],
	"RoadMainGTDiag2X2MirrorA"		=> [<0, 0, 2>, <1, 0, -1>, <0, 0, -1>, <1, 0, -2>],
	"RoadMainGTDiag2X2Down"			=> [<1, 0, 1>, <0, 0, -2>, <0, 0, 1>, <0, 0, 1>],
	"RoadMainGTDiag2X2DownMirror"	=> [<0, 0, 2>, <1, 0, -1>, <0, 0, -1>, <1, 0, -2>],
	"RoadMainStraightDown"			=> [<0, 0, 1>, <0, 0, -1>],
	"RoadMainStraightUp"			=> [<0, 0, 1>, <0, 0, -1>],
	"RoadMainTreePineBigStraight"	=> [<0, 0, 1>, <0, 0, -1>],
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMainStartLine"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainCheckpoint"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainCheckpointUp"		=> [<0, 1, 1>, <0, 1, -1>],
	"StadiumRoadMainCheckpointDown"		=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainFinishLine"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainGTDiag2x2"			=> [<0, 0, 1>, <0, 0, -2>, <1, 0, 1>, <1, 0, -2>],
	"StadiumRoadMainGTDiag2x2Mirror"	=> [<0, 0, 2>, <0, 0, -1>, <1, 0, 2>, <1, 0, -1>],
	"StadiumRoadMainGTDiag3x2"			=> [<0, 0, 1>, <0, 0, -2>, <1, 0, 1>, <1, 0, -2>, <3, 0, 1>, <3, 0, -2>],
	"StadiumRoadMainGTDiag3x2Mirror"	=> [<0, 0, 2>, <0, 0, -1>, <1, 0, 2>, <1, 0, -1>, <3, 0, 2>, <3, 0, -1>],
	"StadiumHolePillar"					=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumHolePillar2Front"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumHolePillar2Line"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumHolePillar3"				=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumHole"						=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadStretch"				=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainSlopeBase"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainSlopeStraight"		=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadMainSlopeBase1x2"		=> [<0, -1, 1>, <0, -1, -1>, <1, 0, 1>, <1, 0, -1>],
	"StadiumHolePillarSlope"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumHoleHoleSlope"				=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumRoadStretchSlope"			=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumBump1Slope"					=> [<0, 0, 1>, <0, 0, -1>],
	"StadiumTrenchXRoadMain"			=> [<0, 0, 1>, <0, 0, -1>],
	// ---------------------------------- //
	// Valley
	"Road2WayStart"			=> [<0, 0, 1>, <0, 0, -1>],
	"Road2WayCheckpoint"	=> [<0, 0, 1>, <0, 0, -1>],
	"Road2WayFinish"		=> [<-1, 0, 2>, <-1, 0, -2>, <0, 0, 2>, <0, 0, -2>],
	"Road2WayDiag2Mirror"	=> [<-1, 0, 2>, <-1, 0, -2>, <0, 0, 2>, <0, 0, -2>],
	"Road2WayWithoutPole"	=> [<0, 0, 1>, <0, 0, -1>],
	"Road2WayWithBirds"		=> [<0, 0, 1>, <0, 0, -1>]
]

// ---------------------------------- //
/** Pillar decoration trigger blocks
 *
 *	"RoadBlockName" => ["DecorationBlocksNames"]
 */
#Const C_DecoTriggers_Pillar [
	// ---------------------------------- //
	// Stadium
	"StadiumHolePillar" => [
		"StadiumTubeRoadLightSystem",
		"StadiumTubeRoadSoundSystem"
	],
	"StadiumHolePillar2Front" => [
		"StadiumControlRoadGlass",
		"StadiumControlLightBase",
		"StadiumControlRoadCamera"
	],
	"StadiumHolePillar2Line" => [
		"StadiumControlRoadGlass",
		"StadiumControlLightBase",
		"StadiumControlRoadCamera"
	],
	"StadiumHolePillar3" => [
		"StadiumControlRoadGlass",
		"StadiumControlLightBase",
		"StadiumControlRoadCamera"
	]
]

// ---------------------------------- //
/** Blocks that generate tubes under them
 *
 *	"BlockName" => [<TubeOffset>]
 */
#Const C_TubeTriggers [
	"StadiumRoadMainCheckpoint"			=> [<0, -1, 0>],
	"StadiumRoadMainCheckpointUp"		=> [<0, -2, 0>],
	"StadiumRoadMainCheckpointDown"		=> [<0, -1, 0>],
	"StadiumRoadMainFinishLine"			=> [<0, -1, 0>],
	"StadiumRoadMainGTDiag2x2"			=> [<1, -1, -1>, <0, -1, 0>],
	"StadiumRoadMainGTDiag2x2Mirror"	=> [<1, -1, 1>, <0, -1, 0>],
	"StadiumRoadMainGTDiag3x2"			=> [<2, -1, -1>, <0, -1, 0>],
	"StadiumRoadMainGTDiag3x2Mirror"	=> [<2, -1, 1>, <0, -1, 0>],
	"StadiumHolePillar"					=> [<0, -1, 0>],
	"StadiumHolePillar2Front"			=> [<0, -1, 0>],
	"StadiumHolePillar2Line"			=> [<0, -1, 0>],
	"StadiumHolePillar3"				=> [<0, -1, 0>],
	"StadiumRoadStretch"				=> [<0, -1, 0>],
	"StadiumHolePillarSlope"			=> [<0, -2, 0>]
]

// ---------------------------------- //
// Decoration blocks in air
#Const C_DecoBlocks_Air [
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMain",
	"StadiumPlatformGridStraight",
	"StadiumPlatformSlope2Straight",
	"StadiumCircuitPillar5",
	"StadiumSculptBridgePillar",
	"StadiumSculptBridgePillarMirror",
	"StadiumTubeRoadDown",
	"StadiumControlRoadGlass",
	"StadiumControlRoadPub",
	"StadiumControlRoadCamera",
	"StadiumControlLightBase",
	"StadiumTubeRoadLightSystem",
	"StadiumTubeRoadSoundSystem"
]

// ---------------------------------- //
// Extra decoration blocks
#Const C_DecoBlocks_Extra [
	// ---------------------------------- //
	// Canyon
	"DecoTreesBig1X1",
	"DecoTreesMedium1X1",
	"DecoRocksMedium1X1",
	"DecoCactusMedium1X1",
	"DecoBushesMedium1X1",
	"DecoTreePineBig1X1",
	// ---------------------------------- //
	// Stadium
	"StadiumRoadMain",
	"StadiumCircuitPillar5",
	"StadiumRoadDirt",
	"StadiumRoadDirtHigh",
	"StadiumSculptBridgeSlopeStart",
	"StadiumSculptBridgeSlopeStartMirror",
	"StadiumTubePillarCap",
	"StadiumTubeRoadDown",
	"StadiumInflatableCastle",
	"StadiumInflatableCastleBig",
	"StadiumInflatableCactus",
	"StadiumInflatableSnowTree",
	"StadiumInflatablePalmTree",
	// ---------------------------------- //
	// Valley
	"RoadDirt",
	"DecoTrees",
	"DecoTreesMed",
	"DecoTreesSmall"
]

// ---------------------------------- //
// These blocks require special rotation
#Const C_BlockSpecialRotation [
	// ---------------------------------- //
	// Stadium
	"StadiumRoadStretch"		=> ::CardinalDirections::West,
	"StadiumBump1Slope"			=> ::CardinalDirections::West,
	"StadiumTrenchXRoadMain"	=> ::CardinalDirections::North
]

// ---------------------------------- //
// Place tube under block
// ---------------------------------- //
***PlaceTube***
***
if (PrevBlockPosition.Y > CollectionGroundY && BlockModelTube != Null && C_TubeTriggers.existskey(CurBlock.Name)) {
	foreach (Offset in C_TubeTriggers[CurBlock.Name]) {
		PlaceBlock(BlockModelTube, PrevBlockPosition + Offset, RandomDirection());
	}
}
***

// ---------------------------------- //
// Functions
// ---------------------------------- //

// ---------------------------------- //
/** Get layer Map Constructor button
 *
 *	@return		Manialink page with Map Constructor interface
 */
Text GetLayerMapConstructor() {
	return """
<manialink version="2" name="Plugin:AutoGhostBlocks">
<stylesheet>
	<style class="lblName" posn="-32.5" valign="center2" textsize="2" scale=".9" textcolor="000"/>
	<style class="entryValue" posn="27.5" sizen="10 4" halign="right" valign="center2" textsize="2" textemboss="1" textcolor="FFF"/>
	<style class="btnReset" posn="32.5" sizen="5 5" halign="right" valign="center" style="Icons128x32_1" substyle="RT_Laps"/>
	<style class="txtWarning" sizen="70 10" scale=".9" halign="center" textsize="2" textcolor="000" autonewline="1"/>
</stylesheet>

<quad
	posn="-154 72" sizen="12 12" halign="center" valign="center" ScriptEvents="1"
	style="UIConstructionBullet_Buttons" substyle="NewRandomBullet" id="Quad_BtnOpenMenu"
/>

<label
	posn="90 -88" halign="center" valign="bottom" style="TrackerText"
	text="{{{"Open Map Constructor menu"}}}" translate="1" id="Label_MouseHoverTooltip" hidden="1"
/>

<frame id="Frame_GeneratorWindow" posn="0 0 14" hidden="1">
	<frame posn="-124 78 1">
		<quad posn="0 0" halign="center" sizen="74 15" style="Bgs1InRace" substyle="BgTitle3_4"/>
		<label posn="0 -7.5 1" halign="center" valign="center2" style="TextTitle3" text="Map Constructor"/>
		
		<!-- Warning message and generate buttons -->
		<frame posn="0 -14">
			<quad halign="center" sizen="70 26" style="Bgs1" substyle="BgTitlePage"/>
			<label posn="0 -3" class="txtWarning" text="WARNING: Generating a new map will remove all your current edition progress."/>
			<label posn="-15 -12" halign="center" style="CardButtonSmallS" text="Generate and play" ScriptEvents="1" id="Label_BtnGeneratePlay"/>
			<label posn="-15 -18" halign="center" style="CardButtonSmallS" text="Generate only" ScriptEvents="1" id="Label_BtnGenerateOnly"/>
			<label posn="15 -12" halign="center" style="CardButtonSmallS" text="Advanced mode" ScriptEvents="1" id="Label_BtnAdvanced"/>
			<label posn="15 -18" halign="center" style="CardButtonSmallS" text="Close" ScriptEvents="1" id="Label_BtnCancel"/>
		</frame>
		
		<!-- Properties window -->
		<frame id="Frame_Advanced" posn="0 -41">
			<quad halign="center" sizen="70 40" style="Bgs1" substyle="BgTitlePage"/>
			<label posn="0 -4 1" halign="center" valign="center2" style="TextTitle3" textcolor="000" text="Advanced mode"/>
			
			<frame posn=".5 -9 1">
				<label class="lblName" text="Blocks between checkpoints"/>
				<entry class="entryValue" id="Entry_FrequencyCheckpoint" default="{{{C_CheckpointFrequency}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetCheckpoint"/>
			</frame>
			<frame posn=".5 -14 1">
				<label class="lblName" text="Blocks frequency: curves"/>
				<entry class="entryValue" id="Entry_FrequencyCurve" default="{{{C_CurveMaxFrequency}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetCurve"/>
			</frame>
			<frame posn=".5 -19 1">
				<label class="lblName" text="Blocks frequency: road props"/>
				<entry class="entryValue" id="Entry_FrequencyProps" default="{{{C_PropsMaxFrequency}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetProps"/>
			</frame>
			<frame posn=".5 -25 1">
				<label class="lblName" text="Deco intensity: on sides"/>
				<entry class="entryValue" id="Entry_IntensitySide" default="{{{C_DecoChanceSide}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetDecoS"/>
			</frame>
			<frame posn=".5 -30 1">
				<label class="lblName" text="Deco intensity: on block pillars"/>
				<entry class="entryValue" id="Entry_IntensityPillar" default="{{{C_DecoChancePillar}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetDecoP"/>
			</frame>
			<frame posn=".5 -36 1">
				<label class="lblName" text="Extra random scenery blocks"/>
				<entry class="entryValue" id="Entry_NbExtraDecoration" default="{{{C_DecoExtraAmount}}}"/>
				<quad class="btnReset" ScriptEvents="1" id="Quad_BtnResetDeco"/>
			</frame>
		</frame>
	</frame>
</frame>

<script><!--
/**
 *	Map Constructor by domino54
 */

#Include "TextLib" as TL

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	// ---------------------------------- //
	// Load interface elements
	declare Frame_GeneratorWindow	<=> (Page.GetFirstChild("Frame_GeneratorWindow")	as CMlFrame);
	declare Frame_Advanced			<=> (Page.GetFirstChild("Frame_Advanced")			as CMlFrame);
	declare Quad_BtnOpenMenu		<=> (Page.GetFirstChild("Quad_BtnOpenMenu")			as CMlQuad);
	declare Label_MouseHoverTooltip	<=> (Page.GetFirstChild("Label_MouseHoverTooltip")	as CMlLabel);
	
	declare Entry_FrequencyCheckpoint	<=> (Page.GetFirstChild("Entry_FrequencyCheckpoint")	as CMlEntry);
	declare Entry_FrequencyCurve		<=> (Page.GetFirstChild("Entry_FrequencyCurve")			as CMlEntry);
	declare Entry_FrequencyProps		<=> (Page.GetFirstChild("Entry_FrequencyProps")			as CMlEntry);
	declare Entry_IntensitySide			<=> (Page.GetFirstChild("Entry_IntensitySide")			as CMlEntry);
	declare Entry_IntensityPillar		<=> (Page.GetFirstChild("Entry_IntensityPillar")		as CMlEntry);
	declare Entry_NbExtraDecoration		<=> (Page.GetFirstChild("Entry_NbExtraDecoration")		as CMlEntry);
	
	// ---------------------------------- //
	// Variables
	declare IsMapGenerated for Page = True;
	declare PlayMapAfterGen for Page = False;
	declare IsAdvancedMode for Page = False;
	declare Generator_CheckpointFrequency	for Page = {{{C_CheckpointFrequency}}};
	declare Generator_CurveFrequency		for Page = {{{C_CurveMaxFrequency}}};
	declare Generator_PropsFrequency		for Page = {{{C_PropsMaxFrequency}}};
	declare Generator_DecoIntensSide		for Page = {{{C_DecoChanceSide}}};
	declare Generator_DecoIntensPillar		for Page = {{{C_DecoChancePillar}}};
	declare Generator_ExtraDecoAmount		for Page = {{{C_DecoExtraAmount}}};
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		
		// ---------------------------------- //
		// Events management
		foreach (Event in PendingEvents) {
			// ---------------------------------- //
			// Mouse click
			if (Event.Type == CMlEvent::Type::MouseClick) {
				if (Event.ControlId == "Quad_BtnOpenMenu") {
					Frame_GeneratorWindow.Show();
					Audio.PlaySoundEvent(CAudioManager::ELibSound::ShowDialog, 0, 0.);
					Label_MouseHoverTooltip.Hide();
				}
				// ---------------------------------- //
				// In window
				else if (Event.ControlId == "Label_BtnGeneratePlay") {
					Frame_GeneratorWindow.Hide();
					Audio.PlaySoundEvent(CAudioManager::ELibSound::HideDialog, 0, 0.);
					IsMapGenerated = False;
					PlayMapAfterGen = True;
				}
				else if (Event.ControlId == "Label_BtnGenerateOnly") {
					Frame_GeneratorWindow.Hide();
					Audio.PlaySoundEvent(CAudioManager::ELibSound::HideDialog, 0, 0.);
					IsMapGenerated = False;
					PlayMapAfterGen = False;
				}
				else if (Event.ControlId == "Label_BtnAdvanced") {
					IsAdvancedMode = !IsAdvancedMode;
				}
				else if (Event.ControlId == "Label_BtnCancel") {
					Frame_GeneratorWindow.Hide();
					Audio.PlaySoundEvent(CAudioManager::ELibSound::HideDialog, 0, 0.);
				}
				// ---------------------------------- //
				// Advanced mode
				else if (Event.ControlId == "Quad_BtnResetCheckpoint") {
					Entry_FrequencyCheckpoint.Value = "{{{C_CheckpointFrequency}}}";
				}
				else if (Event.ControlId == "Quad_BtnResetCurve") {
					Entry_FrequencyCurve.Value = "{{{C_CurveMaxFrequency}}}";
				}
				else if (Event.ControlId == "Quad_BtnResetProps") {
					Entry_FrequencyProps.Value = "{{{C_PropsMaxFrequency}}}";
				}
				else if (Event.ControlId == "Quad_BtnResetDecoS") {
					Entry_IntensitySide.Value = "{{{C_DecoChanceSide}}}";
				}
				else if (Event.ControlId == "Quad_BtnResetDecoP") {
					Entry_IntensityPillar.Value = "{{{C_DecoChancePillar}}}";
				}
				else if (Event.ControlId == "Quad_BtnResetDeco") {
					Entry_NbExtraDecoration.Value = "{{{C_DecoExtraAmount}}}";
				}
			}
			// ---------------------------------- //
			// Mouse over
			else if (Event.Type == CMlEvent::Type::MouseOver) {
				if (Event.ControlId == "Quad_BtnOpenMenu") Label_MouseHoverTooltip.Show();
			}
			// ---------------------------------- //
			// Mouse out
			else if (Event.Type == CMlEvent::Type::MouseOut) {
				if (Event.ControlId == "Quad_BtnOpenMenu") Label_MouseHoverTooltip.Hide();
			}
		}
		
		// ---------------------------------- //
		// Read values
		if (TL::ToInteger(Entry_FrequencyCheckpoint.Value) < 1) Entry_FrequencyCheckpoint.Value = "1";
		if (TL::ToInteger(Entry_FrequencyCheckpoint.Value) > 100) Entry_FrequencyCheckpoint.Value = "100";
		
		if (TL::ToInteger(Entry_FrequencyCurve.Value) < 0) Entry_FrequencyCurve.Value = "0";
		if (TL::ToInteger(Entry_FrequencyCurve.Value) > 100) Entry_FrequencyCurve.Value = "100";
		
		if (TL::ToInteger(Entry_FrequencyProps.Value) < 0) Entry_FrequencyProps.Value = "0";
		if (TL::ToInteger(Entry_FrequencyProps.Value) > 100) Entry_FrequencyProps.Value = "100";
		
		if (TL::ToReal(Entry_IntensitySide.Value) <= 0) Entry_IntensitySide.Value = "0.0";
		if (TL::ToReal(Entry_IntensitySide.Value) >= 1) Entry_IntensitySide.Value = "1.0";
		
		if (TL::ToReal(Entry_IntensityPillar.Value) <= 0) Entry_IntensityPillar.Value = "0.0";
		if (TL::ToReal(Entry_IntensityPillar.Value) >= 1) Entry_IntensityPillar.Value = "1.0";
		
		if (TL::ToInteger(Entry_NbExtraDecoration.Value) < 0) Entry_NbExtraDecoration.Value = "0";
		if (TL::ToInteger(Entry_NbExtraDecoration.Value) > 1000) Entry_NbExtraDecoration.Value = "1000";
		
		// ---------------------------------- //
		// Apply settings
		Generator_CheckpointFrequency	= TL::ToInteger(Entry_FrequencyCheckpoint.Value);
		Generator_CurveFrequency		= TL::ToInteger(Entry_FrequencyCurve.Value);
		Generator_PropsFrequency		= TL::ToInteger(Entry_FrequencyProps.Value);
		Generator_DecoIntensSide		= TL::ToReal(Entry_IntensitySide.Value);
		Generator_DecoIntensPillar		= TL::ToReal(Entry_IntensityPillar.Value);
		Generator_ExtraDecoAmount		= TL::ToInteger(Entry_NbExtraDecoration.Value);
		
		// ---------------------------------- //
		// Others
		Quad_BtnOpenMenu.Visible = (!Frame_GeneratorWindow.Visible && IsMapGenerated);
		Frame_Advanced.Visible = IsAdvancedMode;
	}
}
--></script>
</manialink>""";
}

// ---------------------------------- //
// Get random cardinal direction
::CardinalDirections RandomDirection() {
	declare Directions = [
		::CardinalDirections::North,
		::CardinalDirections::East,
		::CardinalDirections::South,
		::CardinalDirections::West
	];
	return Directions[ML::Rand(0, Directions.count - 1)];
}

// ---------------------------------- //
// Main
// ---------------------------------- //
main() {
	ManialinkText = GetLayerMapConstructor();
	
	// ---------------------------------- //
	// Generation steps
	declare IsMapGenerated for ManialinkPage	= True;		///< Map has been generated
	declare PlayMapAfterGen for ManialinkPage	= False;	///< Play map after generating
	declare MapInitialized						= False;	///< Map initialized (remove all and place spawn)
	declare AreRoadsFinished					= False;	///< Roads have been placed
	declare AreDetailsFinished					= False;	///< All details have been placed
	
	declare Generator_CheckpointFrequency	for ManialinkPage = C_CheckpointFrequency;
	declare Generator_CurveFrequency		for ManialinkPage = C_CurveMaxFrequency;
	declare Generator_PropsFrequency		for ManialinkPage = C_PropsMaxFrequency;
	declare Generator_DecoIntensSide		for ManialinkPage = C_DecoChanceSide;
	declare Generator_DecoIntensPillar		for ManialinkPage = C_DecoChancePillar;
	declare Generator_ExtraDecoAmount		for ManialinkPage = C_DecoExtraAmount;
	
	// ---------------------------------- //
	// Decoration positions
	declare Text[][Int3] DetailsPosn_Side;		///< Positions of normal decoration blocks
	declare Text[][Int3] DetailsPosn_Pillar;	///< Positions of pillar blocks decorations
	
	// ---------------------------------- //
	// Variables
	declare Int3 PrevBlockPosition;		///< Coords of previous used block
	declare Integer NbBlocksToNextCp;	///< Nb blocks until next checkpoint
	
	declare NbTries_Curve = Integer[];
	declare NbTries_Props = Integer[];
	declare NbTries_CP = Integer[];
	
	declare NbPlaced_Curve = 0;
	declare NbPlaced_Props = 0;
	declare NbPlaced_CP = 0;
	
	declare MapDimensions = C_Dimensions[Map.CollectionName][Map.DecorationName];
	
	// ---------------------------------- //
	// Available waypoint blocks
	declare CBlockModel BlockModelSpawn;		///< Current environment start block
	declare CBlockModel BlockModelFinish;		///< Current environment finish block
	declare CBlockModel BlockModelTube;			///< Current environment tube block
	
	// ---------------------------------- //
	// Available building blocks
	declare CBlockModel[] AvailableBlocks_Curves;	///< Current environment curve blocks
	declare CBlockModel[] AvailableBlocks_Props;	///< Current environment props blocks
	declare CBlockModel[] AvailableBlocks_Deco;		///< Current environment decorative blocks
	declare CBlockModel[] AvailableBlocks_CP;		///< Current environment checkpoint block
	
	// ---------------------------------- //
	// Load environment block models
	foreach (BlockModel in BlockModels) {
		// Start point
		if (C_BlockModels_Spawn.exists(BlockModel.Name))
			BlockModelSpawn = BlockModel;
		
		// Road curves
		if (C_BlockModels_Curve.existskey(BlockModel.Name))
			AvailableBlocks_Curves.add(BlockModel);
		
		// Road props
		if (C_BlockModels_Prop.existskey(BlockModel.Name))
			AvailableBlocks_Props.add(BlockModel);
			
		// Checkpoint
		if (C_BlockModels_Checkpoint.existskey(BlockModel.Name))
			AvailableBlocks_CP.add(BlockModel);
			
		// Finish line
		if (C_BlockModels_Finish.exists(BlockModel.Name))
			BlockModelFinish = BlockModel;
		
		// Side decoration
		if (C_BlockModels_Deco.exists(BlockModel.Name))
			AvailableBlocks_Deco.add(BlockModel);
		
		// Tube
		if (C_BlockModels_Tube.exists(BlockModel.Name))
			BlockModelTube = BlockModel;
	}
	
	// ---------------------------------- //
	// Yield
	// ---------------------------------- //
	while (True) {
		yield;
		
		// ---------------------------------- //
		// Map generation
		// ---------------------------------- //
		while (!IsMapGenerated) {
			yield;
			
			// ---------------------------------- //
			// Variables
			declare CBlockModel CurBlock;	///< Current block model to place
			declare Int3 BeginClipOffSet;	///< OffSet of current block start
			declare Int3 EndClipOffSet;		///< OffSet of current block end
			
			// ---------------------------------- //
			// Initialize map - place spawn block
			// ---------------------------------- //
			if (!MapInitialized) {
				MapInitialized = True;
				RemoveAll();
				
				DetailsPosn_Side.clear();
				DetailsPosn_Pillar.clear();
				PlaceMode = ::PlaceMode::Block;
				
				AreRoadsFinished = False;
				AreDetailsFinished = False;
				
				NbTries_Curve.clear();
				NbTries_Props.clear();
				NbTries_CP.clear();
				
				NbPlaced_Curve = 0;
				NbPlaced_Props = 0;
				NbPlaced_CP = 0;
				
				// Start block init position
				PrevBlockPosition = <
					MapDimensions - 1,
					CollectionGroundY,
					(MapDimensions - 1) / 2  + ML::Rand(-MapDimensions/3, MapDimensions/3)
				>;
				
				// Checkpoints
				NbBlocksToNextCp = Generator_CheckpointFrequency;
				
				// Place spawn
				PlaceBlock(BlockModelSpawn, PrevBlockPosition, ::CardinalDirections::East);
				
				// Add decoration
				if (C_DecoTriggers_Side.existskey(BlockModelSpawn.Name)) {
					declare AvailableDeco = C_BlockModels_Deco;
					declare DecoPosn = C_DecoTriggers_Side[BlockModelSpawn.Name];
					foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
				}
			}
			
			// ---------------------------------- //
			// Place race road segments
			// ---------------------------------- //
			else if (!AreRoadsFinished) {
				// ---------------------------------- //
				// Place the road curves
				// ---------------------------------- //
				declare PlacedBlock_Curve = False;
				while (
					NbBlocksToNextCp > 0 &&
					Generator_CurveFrequency > 0 &&
					NbPlaced_Curve < Generator_CurveFrequency &&
					NbTries_Curve.count < AvailableBlocks_Curves.count
				) {
					yield;
					
					// ---------------------------------- //
					// Get current curve properties
					CurBlock = AvailableBlocks_Curves[ML::Rand(0, AvailableBlocks_Curves.count - 1)];
					BeginClipOffSet = C_BlockModels_Curve[CurBlock.Name][0];
					EndClipOffSet = C_BlockModels_Curve[CurBlock.Name][1];
					
					// ---------------------------------- //
					// Place the curve
					PlacedBlock_Curve = PlaceBlock(CurBlock, PrevBlockPosition + BeginClipOffSet, ::CardinalDirections::East);
					
					// ---------------------------------- //
					// If curve was'nt placed
					if (!PlacedBlock_Curve) {
						declare CurveIndex = AvailableBlocks_Curves.keyof(CurBlock);
						if (!NbTries_Curve.exists(CurveIndex)) NbTries_Curve.add(CurveIndex);
					} else NbTries_Curve.clear();
					
					// ---------------------------------- //
					// Curve was placed correctly
					if (PlacedBlock_Curve) {
						NbPlaced_Curve += 1;
						NbBlocksToNextCp -= 1;
						PrevBlockPosition += BeginClipOffSet + EndClipOffSet;
						
						if (C_DecoTriggers_Side.existskey(CurBlock.Name)) {
							// Add side decoration
							if (PrevBlockPosition.Y <= CollectionGroundY) {
								declare AvailableDeco = C_BlockModels_Deco;
								declare DecoPosn = C_DecoTriggers_Side[CurBlock.Name];
								foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
							}
							// Place air decoration
							else {
								declare AvailableDeco = C_DecoBlocks_Air;
								declare DecoPosn = C_DecoTriggers_Side[CurBlock.Name];
								foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
							}
						}
						
						// ---------------------------------- //
						// Add tube
						---PlaceTube---
					}
				}
				if (NbPlaced_Curve >= Generator_CurveFrequency) NbPlaced_Curve = 0;
					
				// ---------------------------------- //
				// Place the road props
				// ---------------------------------- //
				declare PlacedBlock_Prop = False;
				while (
					NbBlocksToNextCp > 0 &&
					Generator_PropsFrequency > 0 &&
					NbPlaced_Props < Generator_PropsFrequency &&
					NbTries_Props.count < AvailableBlocks_Props.count
				) {
					yield;
					
					// ---------------------------------- //
					// Get current prop properties
					CurBlock = AvailableBlocks_Props[ML::Rand(0, AvailableBlocks_Props.count - 1)];
					BeginClipOffSet = C_BlockModels_Prop[CurBlock.Name][0];
					EndClipOffSet = C_BlockModels_Prop[CurBlock.Name][1];
					
					// ---------------------------------- //
					// Get block target rotation
					declare ::CardinalDirections TargetDirection;
					TargetDirection = ::CardinalDirections::East;
					if (C_BlockSpecialRotation.existskey(CurBlock.Name)) TargetDirection = C_BlockSpecialRotation[CurBlock.Name];						
					
					// ---------------------------------- //
					// Place the props
					PlacedBlock_Prop = PlaceBlock(CurBlock, PrevBlockPosition + BeginClipOffSet, TargetDirection);
					
					// ---------------------------------- //
					// If prop was'nt placed
					if (!PlacedBlock_Prop) {
						declare PropIndex = AvailableBlocks_Props.keyof(CurBlock);
						if (!NbTries_Props.exists(PropIndex)) NbTries_Props.add(PropIndex);
					} else NbTries_Props.clear();
					
					// ---------------------------------- //
					// Prop was placed correctly
					if (PlacedBlock_Prop) {
						NbPlaced_Props += 1;
						NbBlocksToNextCp -= 1;
						PrevBlockPosition += BeginClipOffSet + EndClipOffSet;
						
						if (C_DecoTriggers_Side.existskey(CurBlock.Name)) {
							// Add side decoration
							if (PrevBlockPosition.Y <= CollectionGroundY) {
								declare AvailableDeco = C_BlockModels_Deco;
								declare DecoPosn = C_DecoTriggers_Side[CurBlock.Name];
								foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
							}
							// Place air decoration
							else {
								declare AvailableDeco = C_DecoBlocks_Air;
								declare DecoPosn = C_DecoTriggers_Side[CurBlock.Name];
								foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos + <0, 1, 0>] = AvailableDeco;
							}
						}
						
						// Add pillar decoration
						if (C_DecoTriggers_Pillar.existskey(CurBlock.Name)) {
							declare AvailableDeco = C_DecoTriggers_Pillar[CurBlock.Name];
							DetailsPosn_Pillar[PrevBlockPosition + <0, 1, 0>] = AvailableDeco;
						}
						
						// ---------------------------------- //
						// Add tube
						---PlaceTube---
					}
				}
				if (NbPlaced_Props >= Generator_PropsFrequency) NbPlaced_Props = 0;
				
				// ---------------------------------- //
				// Place checkpoints
				// ---------------------------------- //
				declare PlacedBlock_Checkpoint = False;
				while (
					(NbBlocksToNextCp <= 0 ||
					((NbTries_Curve.count > 0 || Generator_CurveFrequency <= 0) &&
					(NbTries_Props.count > 0 || Generator_PropsFrequency <= 0))) &&
					
					NbPlaced_CP < 1 &&
					NbTries_CP.count < AvailableBlocks_CP.count
				) {
					yield;
					
					// ---------------------------------- //
					// Get block
					declare CurBlock = AvailableBlocks_CP[ML::Rand(0, AvailableBlocks_CP.count - 1)];
					BeginClipOffSet = C_BlockModels_Checkpoint[CurBlock.Name][0];
					EndClipOffSet = C_BlockModels_Checkpoint[CurBlock.Name][1];
					
					// ---------------------------------- //
					// Place checkpoint
					PlacedBlock_Checkpoint = PlaceBlock(CurBlock, PrevBlockPosition + BeginClipOffSet, ::CardinalDirections::East);
					
					// ---------------------------------- //
					// If checkpoint was'nt placed
					if (!PlacedBlock_Checkpoint) {
						declare CPIndex = AvailableBlocks_CP.keyof(CurBlock);
						if (!NbTries_CP.exists(CPIndex)) NbTries_CP.add(CPIndex);
					} else NbTries_CP.clear();
					
					if (NbTries_CP.count >= AvailableBlocks_CP.count) NbBlocksToNextCp = Generator_CheckpointFrequency;
					
					// ---------------------------------- //
					// Checkpoint was placed correctly
					if (PlacedBlock_Checkpoint) {
						PrevBlockPosition += BeginClipOffSet + EndClipOffSet;
						NbBlocksToNextCp = Generator_CheckpointFrequency;
						
						// Place air decoration
						if (C_DecoTriggers_Side.existskey(CurBlock.Name)) {
							declare AvailableDeco = C_DecoBlocks_Air;
							declare DecoPosn = C_DecoTriggers_Side[CurBlock.Name];
							foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos + <0, 1, 0>] = AvailableDeco;
						}
						
						// ---------------------------------- //
						// Add tube
						---PlaceTube---
					}
				}
				if (NbPlaced_CP >= 1) NbPlaced_CP = 0;
				
				// ---------------------------------- //
				// Place finish
				// ---------------------------------- //
				if (
					(NbTries_Curve.count >= AvailableBlocks_Curves.count || Generator_CurveFrequency <= 0) &&
					(NbTries_Props.count >= AvailableBlocks_Props.count || Generator_PropsFrequency <= 0) &&
					NbTries_CP.count >= AvailableBlocks_CP.count
				) {
					AreRoadsFinished = True;
					
					// Place finish
					PlaceBlock(BlockModelFinish, PrevBlockPosition + <-1, 0, 0>, ::CardinalDirections::East);
					PrevBlockPosition += <-1, 0, 0>;
					
					// ---------------------------------- //
					// Add tube
					---PlaceTube---
					
					if (C_DecoTriggers_Side.existskey(BlockModelFinish.Name)) {
						// Add side decoration
						if (PrevBlockPosition.Y <= CollectionGroundY) {
							declare AvailableDeco = C_BlockModels_Deco;
							declare DecoPosn = C_DecoTriggers_Side[BlockModelFinish.Name];
							foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
						}
						// Place air decoration
						else {
							declare AvailableDeco = C_DecoBlocks_Air;
							declare DecoPosn = C_DecoTriggers_Side[BlockModelFinish.Name];
							foreach (Pos in DecoPosn) DetailsPosn_Side[PrevBlockPosition + Pos] = AvailableDeco;
						}
					}
				}
			}
			
			// ---------------------------------- //
			// Place decoration segments
			// ---------------------------------- //
			else if (!AreDetailsFinished) {
				// ---------------------------------- //
				// Decoration at the side of the road
				// ---------------------------------- //
				declare NbDecoPlaced_Side = 0;
				foreach (Position => BlockNames in DetailsPosn_Side) {
					NbDecoPlaced_Side += 1;
					
					// Get list of blocks that can be placed in this position
					declare PossibleBlocks = CBlockModel[];
					foreach (Block in AvailableBlocks_Deco) {
						if (BlockNames.exists(Block.Name)) PossibleBlocks.add(Block);
					}
					
					// Chance deco will be placed
					declare PlaceChance = ML::Rand(0., 1.);
					
					// Place decoration
					if (PossibleBlocks.count > 0 && PlaceChance <= Generator_DecoIntensSide) {
						CurBlock = PossibleBlocks[ML::Rand(0, PossibleBlocks.count - 1)];
						declare PlacedDeco = PlaceBlock(CurBlock, Position, RandomDirection());
						
						// Add tube
						if (PrevBlockPosition.Y > CollectionGroundY && BlockModelTube != Null && PlacedDeco) {
							PlaceBlock(BlockModelTube, Position + <0, -1, 0>, RandomDirection());
						}
						
						if (PlacedDeco) yield;
					}
				}
				
				// ---------------------------------- //
				// Decoration on road props pillars
				// ---------------------------------- //
				declare NbDecoPlaced_Pillar = 0;
				foreach (Position => BlockNames in DetailsPosn_Pillar) {
					NbDecoPlaced_Pillar += 1;
					
					// Get list of blocks that can be placed in this position
					declare PossibleBlocks = CBlockModel[];
					foreach (Block in AvailableBlocks_Deco) {
						if (BlockNames.exists(Block.Name)) PossibleBlocks.add(Block);
					}
					
					// Chance deco will be placed
					declare PlaceChance = ML::Rand(0., 1.);
					
					// Place decoration
					if (PossibleBlocks.count > 0 && PlaceChance <= Generator_DecoIntensPillar) {
						CurBlock = PossibleBlocks[ML::Rand(0, PossibleBlocks.count - 1)];
						declare PlacedDeco = PlaceBlock(CurBlock, Position, RandomDirection());
						if (PlacedDeco) yield;
					}
				}
				
				// ---------------------------------- //
				// Extra random decoration
				// ---------------------------------- //
				declare NbDecoPlaced_Extra = 0;
				for (I, 1, Generator_ExtraDecoAmount) {
					NbDecoPlaced_Extra += 1;
					
					// Get list of blocks that can be placed in this position
					declare PossibleBlocks = CBlockModel[];
					foreach (Block in AvailableBlocks_Deco) {
						if (C_DecoBlocks_Extra.exists(Block.Name)) PossibleBlocks.add(Block);
					}
					
					// Position
					declare Position = <
						ML::Rand(0, MapDimensions - 1),
						CollectionGroundY,
						ML::Rand(0, MapDimensions - 1)
					>;
					
					// Place decoration
					if (PossibleBlocks.count > 0) {
						CurBlock = PossibleBlocks[ML::Rand(0, PossibleBlocks.count - 1)];
						declare PlacedDeco = PlaceBlock_NoDestruction(CurBlock, Position, RandomDirection());
						if (PlacedDeco) yield;
					}
				}
				
				// ---------------------------------- //
				// All deco segments placed
				if (NbDecoPlaced_Side >= DetailsPosn_Side.count &&
					NbDecoPlaced_Pillar >= DetailsPosn_Pillar.count &&
					NbDecoPlaced_Extra >= Generator_ExtraDecoAmount)
					AreDetailsFinished = True;
			}
			
			// ---------------------------------- //
			// Map is generated
			// ---------------------------------- //
			else {
				IsMapGenerated = True;
				MapInitialized = False;
				if (PlayMapAfterGen) Validate();
			}
		}
	}
}
